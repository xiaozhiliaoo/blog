{"meta":{"version":1,"warehouse":"3.0.2"},"models":{"Asset":[{"_id":"source/images/ArrayBlockingQueue.png","path":"images/ArrayBlockingQueue.png","modified":1,"renderable":0},{"_id":"source/images/CI.png","path":"images/CI.png","modified":1,"renderable":0},{"_id":"source/images/Deque-Impl.png","path":"images/Deque-Impl.png","modified":1,"renderable":0},{"_id":"source/images/Executor-Class-Diagram.png","path":"images/Executor-Class-Diagram.png","modified":1,"renderable":0},{"_id":"source/images/CompletionService.png","path":"images/CompletionService.png","modified":1,"renderable":0},{"_id":"source/images/FutureTaskStack.png","path":"images/FutureTaskStack.png","modified":1,"renderable":0},{"_id":"source/images/GOF-Proxy.png","path":"images/GOF-Proxy.png","modified":1,"renderable":0},{"_id":"source/images/FutureTask.png","path":"images/FutureTask.png","modified":1,"renderable":0},{"_id":"source/images/FutureTaskStatus.png","path":"images/FutureTaskStatus.png","modified":1,"renderable":0},{"_id":"source/images/JCF-Base.png","path":"images/JCF-Base.png","modified":1,"renderable":0},{"_id":"source/images/JUC-Task-Diagram.png","path":"images/JUC-Task-Diagram.png","modified":1,"renderable":0},{"_id":"source/images/Proxy.png","path":"images/Proxy.png","modified":1,"renderable":0},{"_id":"source/images/List-Impl.png","path":"images/List-Impl.png","modified":1,"renderable":0},{"_id":"source/images/Queue-Impl.png","path":"images/Queue-Impl.png","modified":1,"renderable":0},{"_id":"source/images/Map-Impl.png","path":"images/Map-Impl.png","modified":1,"renderable":0},{"_id":"source/images/String-Design.png","path":"images/String-Design.png","modified":1,"renderable":0},{"_id":"source/images/System-Reasearch.png","path":"images/System-Reasearch.png","modified":1,"renderable":0},{"_id":"source/images/ThreadLocal.png","path":"images/ThreadLocal.png","modified":1,"renderable":0},{"_id":"source/images/ThreadLocalMap.png","path":"images/ThreadLocalMap.png","modified":1,"renderable":0},{"_id":"source/images/ThreadPoolExecutor.png","path":"images/ThreadPoolExecutor.png","modified":1,"renderable":0},{"_id":"source/images/ThreadLocalMultiThread.png","path":"images/ThreadLocalMultiThread.png","modified":1,"renderable":0},{"_id":"source/images/shard-legend.png","path":"images/shard-legend.png","modified":1,"renderable":0},{"_id":"source/images/set-impl.jpg","path":"images/set-impl.jpg","modified":1,"renderable":0},{"_id":"source/images/HashMap.png","path":"images/HashMap.png","modified":1,"renderable":0},{"_id":"source/images/JCF-Summary.png","path":"images/JCF-Summary.png","modified":1,"renderable":0},{"_id":"source/images/avatar.png","path":"images/avatar.png","modified":1,"renderable":0},{"_id":"source/images/kafka/Broker-Single2.png","path":"images/kafka/Broker-Single2.png","modified":1,"renderable":0},{"_id":"source/images/kafka/ConsumerList.png","path":"images/kafka/ConsumerList.png","modified":1,"renderable":0},{"_id":"source/images/kafka/Broker-Single.png","path":"images/kafka/Broker-Single.png","modified":1,"renderable":0},{"_id":"source/images/kafka/Consumer.png","path":"images/kafka/Consumer.png","modified":1,"renderable":0},{"_id":"source/images/kafka/Broker.png","path":"images/kafka/Broker.png","modified":1,"renderable":0},{"_id":"source/images/kafka/ConsumerList2.png","path":"images/kafka/ConsumerList2.png","modified":1,"renderable":0},{"_id":"source/images/kafka/Topic2.png","path":"images/kafka/Topic2.png","modified":1,"renderable":0},{"_id":"source/images/kafka/Topic1.png","path":"images/kafka/Topic1.png","modified":1,"renderable":0},{"_id":"source/images/kafka/TopicList.png","path":"images/kafka/TopicList.png","modified":1,"renderable":0},{"_id":"source/images/guava-retry.png","path":"images/guava-retry.png","modified":1,"renderable":0},{"_id":"source/images/kafka/kafka-cluster-info.png","path":"images/kafka/kafka-cluster-info.png","modified":1,"renderable":0},{"_id":"themes/next/source/css/main.styl","path":"css/main.styl","modified":1,"renderable":1},{"_id":"themes/next/source/images/avatar.gif","path":"images/avatar.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/algolia_logo.svg","path":"images/algolia_logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/apple-touch-icon-next.png","path":"images/apple-touch-icon-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","path":"images/cc-by-nc-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nd.svg","path":"images/cc-by-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","path":"images/cc-by-nc-nd.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-nc.svg","path":"images/cc-by-nc.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by-sa.svg","path":"images/cc-by-sa.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-zero.svg","path":"images/cc-zero.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png","path":"images/favicon-16x16-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/cc-by.svg","path":"images/cc-by.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-16x16-next.png.bak","path":"images/favicon-16x16-next.png.bak","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32-next.png","path":"images/favicon-32x32-next.png","modified":1,"renderable":1},{"_id":"themes/next/source/images/loading.gif","path":"images/loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/favicon-32x32next.png.bak","path":"images/favicon-32x32next.png.bak","modified":1,"renderable":1},{"_id":"themes/next/source/images/logo.svg","path":"images/logo.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/placeholder.gif","path":"images/placeholder.gif","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-l.svg","path":"images/quote-l.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/quote-r.svg","path":"images/quote-r.svg","modified":1,"renderable":1},{"_id":"themes/next/source/images/searchicon.png","path":"images/searchicon.png","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/bootstrap.js","path":"js/src/bootstrap.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/affix.js","path":"js/src/affix.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/hook-duoshuo.js","path":"js/src/hook-duoshuo.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/exturl.js","path":"js/src/exturl.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/js.cookie.js","path":"js/src/js.cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/motion.js","path":"js/src/motion.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/post-details.js","path":"js/src/post-details.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scroll-cookie.js","path":"js/src/scroll-cookie.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/scrollspy.js","path":"js/src/scrollspy.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/utils.js","path":"js/src/utils.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/algolia-search.js","path":"js/src/algolia-search.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","path":"lib/algolia-instant-search/instantsearch.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","path":"lib/canvas-nest/canvas-nest.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","path":"lib/canvas-ribbon/canvas-ribbon.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/LICENSE","path":"lib/fastclick/LICENSE","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/README.md","path":"lib/fastclick/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/bower.json","path":"lib/fastclick/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","path":"lib/jquery_lazyload/CONTRIBUTING.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","path":"lib/jquery_lazyload/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","path":"lib/jquery_lazyload/README.md","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","path":"lib/jquery_lazyload/jquery.lazyload.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","path":"lib/jquery_lazyload/jquery.scrollstop.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","path":"lib/needsharebutton/needsharebutton.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","path":"lib/needsharebutton/needsharebutton.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","path":"lib/needsharebutton/font-embedded.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","path":"lib/font-awesome/HELP-US-OUT.txt","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/bower.json","path":"lib/font-awesome/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","path":"lib/three/canvas_lines.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/three-waves.min.js","path":"lib/three/three-waves.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","path":"lib/three/canvas_sphere.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","path":"lib/pace/pace-theme-barber-shop.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","path":"lib/pace/pace-theme-big-counter.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","path":"lib/pace/pace-theme-bounce.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","path":"lib/pace/pace-theme-center-atom.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","path":"lib/pace/pace-theme-center-circle.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","path":"lib/pace/pace-theme-center-radar.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","path":"lib/pace/pace-theme-corner-indicator.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","path":"lib/pace/pace-theme-center-simple.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","path":"lib/pace/pace-theme-fill-left.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","path":"lib/pace/pace-theme-loading-bar.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","path":"lib/pace/pace-theme-mac-osx.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","path":"lib/pace/pace-theme-minimal.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace.min.js","path":"lib/pace/pace.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/bower.json","path":"lib/velocity/bower.json","modified":1,"renderable":1},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","path":"lib/pace/pace-theme-flash.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","path":"lib/velocity/velocity.ui.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","path":"lib/velocity/velocity.ui.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.min.js","path":"lib/velocity/velocity.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/jquery/index.js","path":"lib/jquery/index.js","modified":1,"renderable":1},{"_id":"themes/next/source/js/src/schemes/pisces.js","path":"js/src/schemes/pisces.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.css","path":"lib/Han/dist/han.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.css","path":"lib/Han/dist/han.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.min.js","path":"lib/Han/dist/han.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","path":"lib/fancybox/source/blank.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","path":"lib/fancybox/source/fancybox_sprite.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","path":"lib/fancybox/source/fancybox_sprite@2x.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","path":"lib/fancybox/source/fancybox_overlay.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","path":"lib/fancybox/source/fancybox_loading@2x.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","path":"lib/fancybox/source/jquery.fancybox.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","path":"lib/fancybox/source/jquery.fancybox.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","path":"lib/fancybox/source/jquery.fancybox.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","path":"lib/fancybox/source/fancybox_loading.gif","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","path":"lib/fastclick/lib/fastclick.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","path":"lib/fastclick/lib/fastclick.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","path":"lib/font-awesome/css/font-awesome.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","path":"lib/font-awesome/css/font-awesome.css.map","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","path":"lib/font-awesome/css/font-awesome.min.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","path":"lib/ua-parser-js/dist/ua-parser.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","path":"lib/ua-parser-js/dist/ua-parser.pack.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/han.js","path":"lib/Han/dist/han.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","path":"lib/font-awesome/fonts/fontawesome-webfont.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","path":"lib/font-awesome/fonts/fontawesome-webfont.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/velocity/velocity.js","path":"lib/velocity/velocity.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","path":"lib/Han/dist/font/han-space.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","path":"lib/Han/dist/font/han-space.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","path":"lib/Han/dist/font/han.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","path":"lib/Han/dist/font/han.woff2","modified":1,"renderable":1},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","path":"lib/Han/dist/font/han.woff","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","path":"lib/fancybox/source/helpers/fancybox_buttons.png","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","path":"lib/fancybox/source/helpers/jquery.fancybox-media.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","path":"lib/fancybox/source/helpers/jquery.fancybox-buttons.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","modified":1,"renderable":1},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","path":"lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","path":"lib/font-awesome/fonts/FontAwesome.otf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","path":"lib/font-awesome/fonts/fontawesome-webfont.eot","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","path":"lib/font-awesome/fonts/fontawesome-webfont.ttf","modified":1,"renderable":1},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","path":"lib/algolia-instant-search/instantsearch.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/three/three.min.js","path":"lib/three/three.min.js","modified":1,"renderable":1},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","path":"lib/font-awesome/fonts/fontawesome-webfont.svg","modified":1,"renderable":1}],"Cache":[{"_id":"themes/next/.bowerrc","hash":"334da94ca6f024d60d012cc26ea655681e724ad8","modified":1594023552000},{"_id":"themes/next/.editorconfig","hash":"211d2c92bfdddb3e81ea946f4ca7a539f150f4da","modified":1594023552000},{"_id":"themes/next/.gitattributes","hash":"8454b9313cb1a97b63fb87e2d29daee497ce6249","modified":1594023552000},{"_id":"themes/next/.gitignore","hash":"ee0b13c268cc8695d3883a5da84930af02d4ed08","modified":1594023552000},{"_id":"themes/next/.hound.yml","hash":"289dcf5bfe92dbd680d54d6e0668f41c9c9c0c78","modified":1594023552000},{"_id":"themes/next/.javascript_ignore","hash":"cd250ad74ca22bd2c054476456a73d9687f05f87","modified":1594023552000},{"_id":"themes/next/.jshintrc","hash":"b7d23f2ce8d99fa073f22f9960605f318acd7710","modified":1594023552000},{"_id":"themes/next/.stylintrc","hash":"3b7f9785e9ad0dab764e1c535b40df02f4ff5fd6","modified":1594023552000},{"_id":"themes/next/.travis.yml","hash":"6674fbdfe0d0c03b8a04527ffb8ab66a94253acd","modified":1594023552000},{"_id":"themes/next/LICENSE","hash":"ec44503d7e617144909e54533754f0147845f0c5","modified":1594023552000},{"_id":"themes/next/README.cn.md","hash":"b878b73f3fcdef47849453c94420871903d487b3","modified":1594023552000},{"_id":"themes/next/README.md","hash":"efcdc4b0ca791c3fc64afa28c8721e137f2d11ea","modified":1594023552000},{"_id":"themes/next/bower.json","hash":"486ebd72068848c97def75f36b71cbec9bb359c5","modified":1594023552000},{"_id":"themes/next/_config.yml","hash":"24cd5ef595e2dc8e7ecfd57e470a5b9f359982db","modified":1656436220000},{"_id":"themes/next/gulpfile.coffee","hash":"412defab3d93d404b7c26aaa0279e2e586e97454","modified":1594023552000},{"_id":"themes/next/package.json","hash":"3963ad558a24c78a3fd4ef23cf5f73f421854627","modified":1594023552000},{"_id":"source/_posts/2020-plan.md","hash":"dfef34fec0d786cf3a6d7b972aeaa746b0d12633","modified":1639928936000},{"_id":"source/_posts/Algorithm-Engineering.md","hash":"d57173585a340f96ae12e58c29a1f62e43ddb195","modified":1656437090000},{"_id":"source/_posts/CompletionService-Design-And-Implementation.md","hash":"0cba88ac202b26419f4cbe437a6156e1770d6eb1","modified":1656436958000},{"_id":"source/_posts/AQS-api-explain.md","hash":"dd7fca2e765ed181a557b6dda514f7220209ddef","modified":1656436958000},{"_id":"source/_posts/Dynamic-Proxy.md","hash":"b72913c9cdcdaec52b821bace5cef71f3bc4ae74","modified":1656437000000},{"_id":"source/_posts/FutureTask-Design-And-Implementation.md","hash":"45bc3e119c0843b3c10fafbb07a573ae295dbd27","modified":1656436958000},{"_id":"source/_posts/HashMap-Design-And-Implementation.md","hash":"c48246e2198a774f85b3e2784f0d27ed09774bd3","modified":1656436910000},{"_id":"source/_posts/JCF-AbstractInterfaceImpl.md","hash":"18924e2e1dddc38f01ff581122f1eacdcf1452d5","modified":1656436910000},{"_id":"source/_posts/OOM.md","hash":"3e15ec8dae19c653f6266abe0f0c062bd927980d","modified":1639928494000},{"_id":"source/_posts/JCF-HighLevel.md","hash":"2e9b24d74643c666bd05226ca5ce9498da752943","modified":1656436910000},{"_id":"source/_posts/Think-CRUDBoy-APICaller.md","hash":"e3adf218c06413ebe81eecefdcb568707bb65aec","modified":1609564770000},{"_id":"source/_posts/ThreadLocal-Design-And-Implementation.md","hash":"69188947c52a1eda4af4814668003fdfb4dc9c3a","modified":1656437020000},{"_id":"source/_posts/buy-house-mistake.md","hash":"6c7d3310cca6d29863b96308ed5801e55f96655f","modified":1677726518000},{"_id":"source/_posts/ThreadPoolExecutor-API-explain.md","hash":"d704da42eb5a21801750fc06aee546ef23724ff2","modified":1656437044000},{"_id":"source/_posts/data-synchronization-thinking.md","hash":"8de4cece8461af43414d60cf8cac824a1f732b27","modified":1670566950000},{"_id":"source/_posts/db-sql-practice.md","hash":"efb423890471abaf1d53c113d80768fa6eec1207","modified":1656437120000},{"_id":"source/_posts/distributed-systems-research-paradigm.md","hash":"021d195f2396f527774000d65733174a31e49fb1","modified":1668832328000},{"_id":"source/_posts/guava-retry-code-analysis.md","hash":"c9d87788392c145584b21ae8a8142012b8eae8a0","modified":1597489142000},{"_id":"source/_posts/elasticsearch-series1-common.md","hash":"04938a6e35dc66f0d2d0ca87c35b54bb1667894d","modified":1630222124000},{"_id":"source/_posts/distributed-transaction.md","hash":"a9ec61486d4943983f37b72e804193fd3d74c589","modified":1641732288000},{"_id":"source/_posts/elasticsearch-series2-match-term.md","hash":"bc396f6662f6ca7373ed26b724bd878de9785420","modified":1630245456000},{"_id":"source/_posts/java-application-cluster.md","hash":"d72e3ba941421a00140b63b59b9008208b6d7ebf","modified":1656436730000},{"_id":"source/_posts/kafka-manager-explain.md","hash":"5651b8ef472c77045547dd05e21202a12cd42035","modified":1667115376000},{"_id":"source/_posts/kafka-project-consumer-group.md","hash":"b9d26b43509d4cb3c057220751ebb9c46eb04167","modified":1662978852000},{"_id":"source/_posts/java-impl-rw-separate.md","hash":"0ffa28679d6a14a962ddf711b28e4122dfb6bc1b","modified":1656907838000},{"_id":"source/_posts/kafka-series1-design-and-implementation.md","hash":"782b07350c43d1f0fb788cb748c4060f8654aa42","modified":1656482010000},{"_id":"source/_posts/ood-heuristics-translate.md","hash":"2d7325c114f0c9c799778b504c0a1d231c38cbe9","modified":1599288898000},{"_id":"source/_posts/ruankao-architect-comprehensive-knowledge.md","hash":"6108059e46387b19e299dc70238c6475409d14eb","modified":1635686770000},{"_id":"source/_posts/ruankao-architect-case-analysis.md","hash":"292f8097886cfeea4120a5b201127c37804ad157","modified":1635685182000},{"_id":"source/_posts/ruankao-architect-paper.md","hash":"e2421fb73ca587225249fbcd5247f7a55aeea162","modified":1633978208000},{"_id":"source/_posts/lintcode-algorithm.md","hash":"37b5fbd431446a5da917195da3c4d1ec8db7fcc5","modified":1656437090000},{"_id":"source/_posts/system-research-template.md","hash":"7429a1061942d8781279833b900a0a80c78ceedc","modified":1667532198000},{"_id":"source/categories/index.md","hash":"728e27f9ff6f0e27189e7bce68774bb2cbfa076c","modified":1656435854000},{"_id":"source/about/index.md","hash":"eec4f9e33a3dd33289721faa8c282099f6d3ec16","modified":1670662766000},{"_id":"source/_posts/unit-test.md","hash":"397ff41e844cef5eb3875793697b08e34354f948","modified":1656437330000},{"_id":"source/images/ArrayBlockingQueue.png","hash":"56d96f09de16d3c88654051f5637b5bbfef0a70d","modified":1605209506000},{"_id":"source/images/CI.png","hash":"6549d12c4c31a240cd441f97856af4ff0a0409a6","modified":1606844868000},{"_id":"source/images/Deque-Impl.png","hash":"1798fb22d9d7c4b010a8677c740dda079c6b988b","modified":1604858784000},{"_id":"source/images/Executor-Class-Diagram.png","hash":"11bc6a1cc1fa7a861cf205a1ca6d2ad0d21b1e3e","modified":1604821216000},{"_id":"source/images/CompletionService.png","hash":"97893fb248200f88b5b86867bc57bc296156530c","modified":1605208354000},{"_id":"source/images/FutureTaskStack.png","hash":"ec24b790b041ff85f9de0b604969e2a793c47a99","modified":1605203630000},{"_id":"source/images/GOF-Proxy.png","hash":"2683a235ade9a48a9a8a084cd36428d9d1e8803f","modified":1605969856000},{"_id":"source/images/FutureTask.png","hash":"2982cbf7967d0234c8caa3066ac27fe5508bd35e","modified":1605197430000},{"_id":"source/images/FutureTaskStatus.png","hash":"39802c8216e10a40aea04a13f161e75b5e22eb6b","modified":1605197950000},{"_id":"source/images/JCF-Base.png","hash":"8191f8fa63a966c8f2d06efe52563a4a5dbd49f8","modified":1604859884000},{"_id":"source/images/JUC-Task-Diagram.png","hash":"db70290f29d49f898e22ef63f93c4692418f1ac3","modified":1604822350000},{"_id":"source/images/Proxy.png","hash":"7b80020e06e7208af3501cf11f2f14048e6c9a5f","modified":1605969684000},{"_id":"source/images/List-Impl.png","hash":"4112821fc7c87b223650c3211c4505ef384b97c3","modified":1604857932000},{"_id":"source/images/Queue-Impl.png","hash":"13ee12b0513be46020a65013708522e3ec2a06b9","modified":1604858654000},{"_id":"source/images/Map-Impl.png","hash":"abea14b4f6865b0ba53bace511c0c14f6d12345d","modified":1604858452000},{"_id":"source/images/String-Design.png","hash":"4393421f7bcc6f3c91d846b350aabbb3a733c32e","modified":1604833250000},{"_id":"source/images/System-Reasearch.png","hash":"94103f587020be749cd0cad1e18a6aed8950c7f2","modified":1667278266000},{"_id":"source/images/ThreadLocal.png","hash":"abe397d8325b23f8861ed14605510d229d3e3859","modified":1605458506000},{"_id":"source/images/ThreadLocalMap.png","hash":"ff1eedaf14ce3d4a7c7d21411ccf7f081e2abd9f","modified":1605458376000},{"_id":"source/images/ThreadPoolExecutor.png","hash":"709402df0ecb32c61d89979fc4228cb486e227cb","modified":1605372734000},{"_id":"source/images/ThreadLocalMultiThread.png","hash":"b9f9614b20491b3253baf79ddc17fc78460db468","modified":1605500996000},{"_id":"source/tags/index.md","hash":"3f5063acc04183e01285b2e9d182a48255cd0ca0","modified":1656435842000},{"_id":"source/images/shard-legend.png","hash":"f7126ddc3d5541d00a0a3513446f7d3c534f9f1d","modified":1630215872000},{"_id":"source/images/set-impl.jpg","hash":"3ffb7880871e4f6aca5e52408f92f2fd631128ca","modified":1604858244000},{"_id":"themes/next/.github/CONTRIBUTING.md","hash":"5adfad3ef1b870063e621bc0838268eb2c7c697a","modified":1594023552000},{"_id":"themes/next/.github/ISSUE_TEMPLATE.md","hash":"a0a82dbfabdef9a9d7c17a08ceebfb4052d98d81","modified":1594023552000},{"_id":"themes/next/.github/PULL_REQUEST_TEMPLATE.md","hash":"1228506a940114288d61812bfe60c045a0abeac1","modified":1594023552000},{"_id":"themes/next/.github/browserstack_logo.png","hash":"a6c43887f64a7f48a2814e3714eaa1215e542037","modified":1594023552000},{"_id":"themes/next/languages/default.yml","hash":"b3bcd8934327448a43d9bfada5dd11b1b8c1402e","modified":1594023552000},{"_id":"themes/next/languages/de.yml","hash":"fd02d9c2035798d5dc7c1a96b4c3e24b05b31a47","modified":1594023552000},{"_id":"themes/next/languages/en.yml","hash":"2f4b4776ca1a08cc266a19afb0d1350a3926f42c","modified":1594023552000},{"_id":"themes/next/languages/fr-FR.yml","hash":"efeeb55d5c4add54ad59a612fc0630ee1300388c","modified":1594023552000},{"_id":"themes/next/languages/id.yml","hash":"dccae33e2a5b3c9f11c0e05ec4a7201af1b25745","modified":1594023552000},{"_id":"themes/next/languages/it.yml","hash":"a215d016146b1bd92cef046042081cbe0c7f976f","modified":1594023552000},{"_id":"themes/next/languages/ko.yml","hash":"dc8f3e8c64eb7c4bb2385025b3006b8efec8b31d","modified":1594023552000},{"_id":"themes/next/languages/ja.yml","hash":"37f954e47a3bc669620ca559e3edb3b0072a4be5","modified":1594023552000},{"_id":"themes/next/languages/pt-BR.yml","hash":"568d494a1f37726a5375b11452a45c71c3e2852d","modified":1594023552000},{"_id":"themes/next/languages/nl-NL.yml","hash":"213e7a002b82fb265f69dabafbbc382cfd460030","modified":1594023552000},{"_id":"themes/next/languages/ru.yml","hash":"e33ee44e80f82e329900fc41eb0bb6823397a4d6","modified":1594023552000},{"_id":"themes/next/languages/pt.yml","hash":"2efcd240c66ab1a122f061505ca0fb1e8819877b","modified":1594023552000},{"_id":"themes/next/languages/vi.yml","hash":"a9b89ebd3e5933033d1386c7c56b66c44aca299a","modified":1594023552000},{"_id":"themes/next/languages/zh-Hans.yml","hash":"2958d1502308b0d23a1fcb40282acc474940cfe6","modified":1656434868000},{"_id":"themes/next/languages/zh-hk.yml","hash":"fe0d45807d015082049f05b54714988c244888da","modified":1594023552000},{"_id":"themes/next/languages/zh-tw.yml","hash":"432463b481e105073accda16c3e590e54c8e7b74","modified":1594023552000},{"_id":"themes/next/layout/_layout.swig","hash":"2164570bb05db11ee4bcfbbb5d183a759afe9d07","modified":1594023552000},{"_id":"themes/next/layout/archive.swig","hash":"9a2c14874a75c7085d2bada5e39201d3fc4fd2b4","modified":1594023552000},{"_id":"themes/next/layout/category.swig","hash":"3cbb3f72429647411f9e85f2544bdf0e3ad2e6b2","modified":1594023552000},{"_id":"themes/next/layout/page.swig","hash":"e8fcaa641d46930237675d2ad4b56964d9e262e9","modified":1594023552000},{"_id":"themes/next/layout/index.swig","hash":"555a357ecf17128db4e29346c92bb6298e66547a","modified":1594023552000},{"_id":"themes/next/layout/post.swig","hash":"7a6ce102ca82c3a80f776e555dddae1a9981e1ed","modified":1594023552000},{"_id":"themes/next/layout/schedule.swig","hash":"87ad6055df01fa2e63e51887d34a2d8f0fbd2f5a","modified":1594023552000},{"_id":"themes/next/layout/tag.swig","hash":"34e1c016cbdf94a31f9c5d494854ff46b2a182e9","modified":1594023552000},{"_id":"themes/next/scripts/merge-configs.js","hash":"38d86aab4fc12fb741ae52099be475196b9db972","modified":1594023552000},{"_id":"themes/next/scripts/merge.js","hash":"39b84b937b2a9608b94e5872349a47200e1800ff","modified":1594023552000},{"_id":"themes/next/test/.jshintrc","hash":"c9fca43ae0d99718e45a6f5ce736a18ba5fc8fb6","modified":1594023552000},{"_id":"themes/next/test/intern.js","hash":"db90b1063356727d72be0d77054fdc32fa882a66","modified":1594023552000},{"_id":"themes/next/test/helpers.js","hash":"f25e7f3265eb5a6e1ccbb5e5012fa9bebf134105","modified":1594023552000},{"_id":"source/images/HashMap.png","hash":"6f72d979b236dd70423013fd495c9b9e290d875f","modified":1605373528000},{"_id":"source/images/JCF-Summary.png","hash":"ef5e8e05e3cc0399854e612b13c455434a5b3797","modified":1605358242000},{"_id":"source/images/avatar.png","hash":"48492a5d2242556a5fc07025a14bde4786da4078","modified":1594036494000},{"_id":"source/reading-list/index.md","hash":"c302f2ba6631a86b1dbd417188aaf32995551527","modified":1673504254000},{"_id":"themes/next/source/fonts/.gitkeep","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1594023552000},{"_id":"source/images/kafka/Broker-Single2.png","hash":"6dff09ebe0240302fd32fa922127c2f5bc721448","modified":1667111788000},{"_id":"source/images/kafka/ConsumerList.png","hash":"873e0fec1e6d9e1d831ee72b83ba5ff2d7fb5949","modified":1667112596000},{"_id":"source/images/kafka/Broker-Single.png","hash":"1e977dee6bc2fce9bd75d8a4880b6332cca8dc12","modified":1667111698000},{"_id":"source/images/kafka/Consumer.png","hash":"6ac5b76c7959f74f3d2befa818d29d372811124e","modified":1667112446000},{"_id":"source/images/kafka/Broker.png","hash":"c3afa6e019c4614a96753c31f936004a06e879cb","modified":1667111626000},{"_id":"source/images/kafka/ConsumerList2.png","hash":"4e799ce8a01ee564e95dc1655e93368c4ea241d9","modified":1667112722000},{"_id":"source/images/kafka/Topic2.png","hash":"86e8014314d5ac109e946497d5f20eed03319ea5","modified":1667112392000},{"_id":"source/images/kafka/Topic1.png","hash":"a61e4f5c2e21a2b60e9f6c4bc6b9aa790335cb77","modified":1667112380000},{"_id":"source/images/kafka/TopicList.png","hash":"964971dc06f412cd196ccff17f748238744436b4","modified":1667112484000},{"_id":"source/images/guava-retry.png","hash":"9162a6b41a6330f341e777ad133f8cd8834b0759","modified":1597484272000},{"_id":"source/images/kafka/kafka-cluster-info.png","hash":"69fd6387e3ec007c384829782107c9ea3bf970c7","modified":1667111592000},{"_id":"themes/next/layout/_custom/sidebar.swig","hash":"ba8ab5a0280b953aa97435ff8946cbcbb2755a27","modified":1594023552000},{"_id":"themes/next/layout/_macro/post-collapse.swig","hash":"8c56dd26157cbc580ae41d97ac34b90ab48ced3f","modified":1594023552000},{"_id":"themes/next/layout/_macro/reward.swig","hash":"357d86ec9586705bfbb2c40a8c7d247a407db21a","modified":1594023552000},{"_id":"themes/next/layout/_custom/header.swig","hash":"ba8ab5a0280b953aa97435ff8946cbcbb2755a27","modified":1594023552000},{"_id":"themes/next/layout/_macro/post-copyright.swig","hash":"f83befdc740beb8dc88805efd7fbb0fef9ed19be","modified":1594023552000},{"_id":"themes/next/layout/_macro/post.swig","hash":"4ba938822d56c597490f0731893eaa2443942e0f","modified":1594023552000},{"_id":"themes/next/layout/_macro/sidebar.swig","hash":"9c7343fd470e0943ebd75f227a083a980816290b","modified":1594023552000},{"_id":"themes/next/layout/_macro/wechat-subscriber.swig","hash":"e2e4eae391476da994045ed4c7faf5e05aca2cd7","modified":1594023552000},{"_id":"themes/next/layout/_partials/comments.swig","hash":"e861acbface68916be86a9a1127e4cb88dc6c5d4","modified":1656426006000},{"_id":"themes/next/layout/_partials/footer.swig","hash":"26e93336dc57a39590ba8dc80564a1d2ad5ff93b","modified":1594023552000},{"_id":"themes/next/layout/_partials/head.swig","hash":"dc1b1519e109c4ba5f1416173f96261acd21f6c8","modified":1639931864000},{"_id":"themes/next/layout/_partials/header.swig","hash":"c54b32263bc8d75918688fb21f795103b3f57f03","modified":1594023552000},{"_id":"themes/next/layout/_partials/page-header.swig","hash":"77c61e0baea3544df361b7338c3cd13dc84dde22","modified":1594023552000},{"_id":"themes/next/layout/_partials/pagination.swig","hash":"1634fb887842698e01ff6e632597fe03c75d2d01","modified":1594023552000},{"_id":"themes/next/layout/_partials/search.swig","hash":"b4ebe4a52a3b51efe549dd1cdee846103664f5eb","modified":1594023552000},{"_id":"themes/next/layout/_scripts/boostrap.swig","hash":"c0f5a0955f69ca4ed9ee64a2d5f8aa75064935ad","modified":1594023552000},{"_id":"themes/next/layout/_scripts/commons.swig","hash":"931808ad9b8d8390c0dcf9bdeb0954eeb9185d68","modified":1594023552000},{"_id":"themes/next/layout/_scripts/vendors.swig","hash":"9be624634703be496a5d2535228bc568a8373af9","modified":1594023552000},{"_id":"themes/next/layout/_third-party/duoshuo-hot-articles.swig","hash":"ba75672183d94f1de7c8bd0eeee497a58c70e889","modified":1594023552000},{"_id":"themes/next/layout/_third-party/exturl.swig","hash":"8301c9600bb3e47f7fb98b0e0332ef3c51bb1688","modified":1594023552000},{"_id":"themes/next/layout/_third-party/mathjax.swig","hash":"a0bd3388587fd943baae0d84ca779a707fbcad89","modified":1594023552000},{"_id":"themes/next/layout/_third-party/needsharebutton.swig","hash":"fa882641da3bd83d9a58a8a97f9d4c62a9ee7b5c","modified":1594023552000},{"_id":"themes/next/layout/_third-party/rating.swig","hash":"554ec568e9d2c71e4a624a8de3cb5929050811d6","modified":1594023552000},{"_id":"themes/next/layout/_third-party/scroll-cookie.swig","hash":"9a188938d46931d5f3882a140aa1c48b3a893f0c","modified":1594023552000},{"_id":"themes/next/layout/_third-party/schedule.swig","hash":"db15d7e1552aa2d2386a6b8a33b3b3a40bf9e43d","modified":1594023552000},{"_id":"themes/next/scripts/tags/button.js","hash":"eddbb612c15ac27faf11c59c019ce188f33dec2c","modified":1594023552000},{"_id":"themes/next/scripts/tags/center-quote.js","hash":"99b66949f18398689b904907af23c013be1b978f","modified":1594023552000},{"_id":"themes/next/scripts/tags/exturl.js","hash":"5022c0ba9f1d13192677cf1fd66005c57c3d0f53","modified":1594023552000},{"_id":"themes/next/scripts/tags/group-pictures.js","hash":"ac681b0d0d8d39ba3817336c0270c6787c2b6b70","modified":1594023552000},{"_id":"themes/next/scripts/tags/full-image.js","hash":"c9f833158c66bd72f627a0559cf96550e867aa72","modified":1594023552000},{"_id":"themes/next/scripts/tags/label.js","hash":"6f00952d70aadece844ce7fd27adc52816cc7374","modified":1594023552000},{"_id":"themes/next/scripts/tags/lazy-image.js","hash":"bcba2ff25cd7850ce6da322d8bd85a8dd00b5ceb","modified":1594023552000},{"_id":"themes/next/scripts/tags/note.js","hash":"f7eae135f35cdab23728e9d0d88b76e00715faa0","modified":1594023552000},{"_id":"themes/next/scripts/tags/tabs.js","hash":"aa7fc94a5ec27737458d9fe1a75c0db7593352fd","modified":1594023552000},{"_id":"themes/next/source/css/main.styl","hash":"a91dbb7ef799f0a171b5e726c801139efe545176","modified":1594023552000},{"_id":"themes/next/source/images/avatar.gif","hash":"264082bb3a1af70d5499c7d22b0902cb454b6d12","modified":1594023552000},{"_id":"themes/next/source/images/algolia_logo.svg","hash":"45eeea0b5fba833e21e38ea10ed5ab385ceb4f01","modified":1594023552000},{"_id":"themes/next/source/images/apple-touch-icon-next.png","hash":"2959dbc97f31c80283e67104fe0854e2369e40aa","modified":1594023552000},{"_id":"themes/next/source/images/cc-by-nc-sa.svg","hash":"6f55543d1fb9cbc436c101d24f802dec7b41efc3","modified":1594023552000},{"_id":"themes/next/source/images/cc-by-nd.svg","hash":"42cd73da328077ccc92f859bb8f3cf621b3484f8","modified":1594023552000},{"_id":"themes/next/source/images/cc-by-nc-nd.svg","hash":"bc3588c9b2d7c68830524783120ff6cf957cf668","modified":1594023552000},{"_id":"themes/next/source/images/cc-by-nc.svg","hash":"6f076713fb9bf934aa2c1046bdf2cf2e37bc1eab","modified":1594023552000},{"_id":"themes/next/source/images/cc-by-sa.svg","hash":"70c1535f43e54e5ff35ca81419e77e4c0c301398","modified":1594023552000},{"_id":"themes/next/source/images/cc-zero.svg","hash":"9bfb52b2f63527a7049247bf00d44e6dc1170e7d","modified":1594023552000},{"_id":"themes/next/source/images/favicon-16x16-next.png","hash":"8d1ef522ccef3c8356324038faa206a75c603e5a","modified":1604819418000},{"_id":"themes/next/source/images/cc-by.svg","hash":"e92a33c32d1dac8ed94849b2b4e6456e887efe70","modified":1594023552000},{"_id":"themes/next/source/images/favicon-16x16-next.png.bak","hash":"943a0d67a9cdf8c198109b28f9dbd42f761d11c3","modified":1594023552000},{"_id":"themes/next/source/images/favicon-32x32-next.png","hash":"1849e7fe6da54c06363804d39eb7a5aee11f58b1","modified":1604819208000},{"_id":"themes/next/source/images/loading.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1594023552000},{"_id":"themes/next/source/images/favicon-32x32next.png.bak","hash":"0749d7b24b0d2fae1c8eb7f671ad4646ee1894b1","modified":1594023552000},{"_id":"themes/next/source/images/logo.svg","hash":"169f56fd82941591dad3abd734a50ec7259be950","modified":1594023552000},{"_id":"themes/next/source/images/placeholder.gif","hash":"5fbd472222feb8a22cf5b8aa5dc5b8e13af88e2b","modified":1594023552000},{"_id":"themes/next/source/images/quote-l.svg","hash":"cd108d6f44351cadf8e6742565217f88818a0458","modified":1594023552000},{"_id":"themes/next/source/images/quote-r.svg","hash":"2a2a250b32a87c69dcc1b1976c74b747bedbfb41","modified":1594023552000},{"_id":"themes/next/source/images/searchicon.png","hash":"67727a6a969be0b2659b908518fa6706eed307b8","modified":1594023552000},{"_id":"themes/next/layout/_scripts/schemes/mist.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1594023552000},{"_id":"themes/next/layout/_scripts/schemes/muse.swig","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1594023552000},{"_id":"themes/next/source/css/_variables/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1594023552000},{"_id":"themes/next/source/css/_variables/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1594023552000},{"_id":"themes/next/source/css/_mixins/Muse.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1594023552000},{"_id":"themes/next/source/css/_mixins/Mist.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1594023552000},{"_id":"themes/next/source/css/_mixins/custom.styl","hash":"da39a3ee5e6b4b0d3255bfef95601890afd80709","modified":1594023552000},{"_id":"themes/next/layout/_partials/head/external-fonts.swig","hash":"f5e487b0d213ca0bd94aa30bc23b240d65081627","modified":1594023552000},{"_id":"themes/next/layout/_partials/head/custom-head.swig","hash":"a223919d2e1bf17ca4d6abb2c86f2efca9883dc1","modified":1594023552000},{"_id":"themes/next/layout/_partials/search/localsearch.swig","hash":"b2f0d247b213e4cf8de47af6a304d98070cc7256","modified":1594023552000},{"_id":"themes/next/layout/_partials/search/swiftype.swig","hash":"a8c7f9ca7c605d039a1f3bf4e4d3183700a3dd62","modified":1594023552000},{"_id":"themes/next/layout/_partials/search/tinysou.swig","hash":"b25002a83cbd2ca0c4a5df87ad5bff26477c0457","modified":1594023552000},{"_id":"themes/next/layout/_partials/share/add-this.swig","hash":"9e3d133ac5bcc6cb51702c83b2611a49811abad1","modified":1594023552000},{"_id":"themes/next/layout/_partials/share/baidushare.swig","hash":"d9e2d9282f9be6e04eae105964abb81e512bffed","modified":1594023552000},{"_id":"themes/next/layout/_partials/share/duoshuo_share.swig","hash":"d4fbffd7fa8f2090eb32a871872665d90a885fac","modified":1594023552000},{"_id":"themes/next/layout/_partials/share/jiathis.swig","hash":"0a9cdd6958395fcdffc80ab60f0c6301b63664a5","modified":1594023552000},{"_id":"themes/next/layout/_scripts/pages/post-details.swig","hash":"9b84ab576982b2c3bb0291da49143bc77fba3cc6","modified":1594023552000},{"_id":"themes/next/layout/_scripts/schemes/gemini.swig","hash":"a9a3995b9615adfb8d6b127c78c6771627bee19a","modified":1594023552000},{"_id":"themes/next/layout/_scripts/schemes/pisces.swig","hash":"a9a3995b9615adfb8d6b127c78c6771627bee19a","modified":1594023552000},{"_id":"themes/next/layout/_third-party/analytics/application-insights.swig","hash":"71397a5823e8ec8aad3b68aace13150623b3e19d","modified":1594023552000},{"_id":"themes/next/layout/_third-party/analytics/analytics-with-widget.swig","hash":"ff947f3561b229bc528cb1837d4ca19612219411","modified":1594023552000},{"_id":"themes/next/layout/_third-party/analytics/baidu-analytics.swig","hash":"753d262911c27baf663fcaf199267133528656af","modified":1594023552000},{"_id":"themes/next/layout/_third-party/analytics/busuanzi-counter.swig","hash":"4aa55cd424389cf5626aa019c15ef6f3e4da09f2","modified":1656423658000},{"_id":"themes/next/layout/_third-party/analytics/cnzz-analytics.swig","hash":"a10b7f19d7b5725527514622899df413a34a89db","modified":1594023552000},{"_id":"themes/next/layout/_third-party/analytics/facebook-sdk.swig","hash":"7d94845f96197d9d84a405fa5d4ede75fb81b225","modified":1594023552000},{"_id":"themes/next/layout/_third-party/analytics/firestore.swig","hash":"ccc443b22bd4f8c7ac4145664686c756395b90e0","modified":1594023552000},{"_id":"themes/next/layout/_third-party/analytics/google-analytics.swig","hash":"b1e13df83fb2b1d5d513b30b7aa6158b0837daab","modified":1594023552000},{"_id":"themes/next/layout/_third-party/analytics/index.swig","hash":"45f3f629c2aacc381095750e1c8649041a71a84b","modified":1594023552000},{"_id":"themes/next/layout/_third-party/analytics/lean-analytics.swig","hash":"e6d10ee4fb70b3ae1cd37e9e36e000306734aa2e","modified":1594023552000},{"_id":"themes/next/layout/_third-party/analytics/tencent-analytics.swig","hash":"8a399df90dadba5ad4e781445b58f4765aeb701e","modified":1594023552000},{"_id":"themes/next/layout/_third-party/analytics/tencent-mta.swig","hash":"5a8027328f060f965b3014060bebec1d7cf149c1","modified":1594023552000},{"_id":"themes/next/layout/_third-party/analytics/vkontakte-api.swig","hash":"f9a1647a8f1866deeb94052d1f87a5df99cb1e70","modified":1594023552000},{"_id":"themes/next/layout/_third-party/comments/disqus.swig","hash":"b83a51bbe0f1e2ded9819070840b0ea145f003a6","modified":1594023552000},{"_id":"themes/next/layout/_third-party/comments/changyan.swig","hash":"4c501ea0b9c494181eb3c607c5526a5754e7fbd8","modified":1594023552000},{"_id":"themes/next/layout/_third-party/comments/gitalk.swig","hash":"593421e25f50156d0e44211eb8c50b82c063fe7c","modified":1656425750000},{"_id":"themes/next/layout/_third-party/comments/gitment.swig","hash":"43f3c7a25e0e38e1554b6b5dcbeef9e75267beb6","modified":1656425322000},{"_id":"themes/next/layout/_third-party/comments/duoshuo.swig","hash":"1600f340e0225361580c44890568dc07dbcf2c89","modified":1594023552000},{"_id":"themes/next/layout/_third-party/comments/hypercomments.swig","hash":"af7f3e43cbdc4f88c13f101f0f341af96ace3383","modified":1594023552000},{"_id":"themes/next/layout/_third-party/comments/index.swig","hash":"08338cba394ebef11bd9473675237fbb8ba06f04","modified":1656425764000},{"_id":"themes/next/layout/_third-party/comments/livere.swig","hash":"9246162d4bc7e949ce1d12d135cbbaf5dc3024ec","modified":1594023552000},{"_id":"themes/next/layout/_third-party/comments/valine.swig","hash":"4050553d44ba1396174161c9a6bb0f89fa779eca","modified":1594023552000},{"_id":"themes/next/layout/_third-party/comments/youyan.swig","hash":"7e65ff8fe586cd655b0e9d1ad2912663ff9bd36c","modified":1594023552000},{"_id":"themes/next/layout/_third-party/search/index.swig","hash":"34599633658f3b0ffb487728b7766e1c7b551f5a","modified":1594023552000},{"_id":"themes/next/layout/_third-party/search/tinysou.swig","hash":"fe95dd3d166634c466e19aa756e65ad6e8254d3e","modified":1594023552000},{"_id":"themes/next/layout/_third-party/search/localsearch.swig","hash":"93479642fd076a1257fecc25fcf5d20ccdefe509","modified":1594023552000},{"_id":"themes/next/layout/_third-party/seo/baidu-push.swig","hash":"d8c98938719284fa06492c114d99a1904652a555","modified":1594023552000},{"_id":"themes/next/source/css/_variables/Mist.styl","hash":"a25408534f8fe6e321db4bbf9dd03335d648fe17","modified":1594023552000},{"_id":"themes/next/source/css/_variables/Gemini.styl","hash":"58e7dd5947817d9fc30770712fc39b2f52230d1e","modified":1594023552000},{"_id":"themes/next/source/css/_custom/custom.styl","hash":"3403fdd8efde1a0afd11ae8a5a97673f5903087f","modified":1594023552000},{"_id":"themes/next/source/css/_variables/base.styl","hash":"b1f6ea881a4938a54603d68282b0f8efb4d7915d","modified":1594023552000},{"_id":"themes/next/source/css/_variables/Pisces.styl","hash":"4069f918ccc312da86db6c51205fc6c6eaabb116","modified":1594023552000},{"_id":"themes/next/source/css/_mixins/Gemini.styl","hash":"07f7da320689f828f6e36a6123807964a45157a0","modified":1594023552000},{"_id":"themes/next/source/css/_mixins/Pisces.styl","hash":"7896c3ee107e1a8b9108b6019f1c070600a1e8cc","modified":1594023552000},{"_id":"themes/next/source/css/_mixins/base.styl","hash":"0e55cbd93852dc3f8ccb44df74d35d9918f847e0","modified":1594023552000},{"_id":"themes/next/source/js/src/bootstrap.js","hash":"0289031200c3d4c2bdd801ee10fff13bb2c353e4","modified":1594023552000},{"_id":"themes/next/source/js/src/affix.js","hash":"1b509c3b5b290a6f4607f0f06461a0c33acb69b1","modified":1594023552000},{"_id":"themes/next/source/js/src/hook-duoshuo.js","hash":"b35a7dc47b634197b93487cea8671a40a9fdffce","modified":1594023552000},{"_id":"themes/next/source/js/src/exturl.js","hash":"a2a0f0de07e46211f74942a468f42ee270aa555c","modified":1594023552000},{"_id":"themes/next/source/js/src/js.cookie.js","hash":"1512c751d219577d338ac0780fb2bbd9075d5298","modified":1594023552000},{"_id":"themes/next/source/js/src/motion.js","hash":"885176ed51d468f662fbf0fc09611f45c7e5a3b1","modified":1594023552000},{"_id":"themes/next/source/js/src/post-details.js","hash":"93a18271b4123dd8f94f09d1439b47c3c19a8712","modified":1594023552000},{"_id":"themes/next/source/js/src/scroll-cookie.js","hash":"02cf91514e41200bc9df5d8bdbeb58575ec06074","modified":1594023552000},{"_id":"themes/next/source/js/src/scrollspy.js","hash":"b7657be25fc52ec67c75ab5481bdcb483573338b","modified":1594023552000},{"_id":"themes/next/source/js/src/utils.js","hash":"b3e9eca64aba59403334f3fa821f100d98d40337","modified":1594023552000},{"_id":"themes/next/source/js/src/algolia-search.js","hash":"cb431b54ba9c692165a1f5a12e4c564a560f8058","modified":1594023552000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.css","hash":"90ef19edc982645b118b095615838d9c5eaba0de","modified":1594023552000},{"_id":"themes/next/source/lib/canvas-nest/canvas-nest.min.js","hash":"0387e75e23b1db108a755073fe52a0d03eb391a7","modified":1594023552000},{"_id":"themes/next/source/lib/fancybox/.bower.json","hash":"9be892a4e14e0da18ff9cb962c9ef71f163b1b22","modified":1594023552000},{"_id":"themes/next/source/lib/fancybox/.gitattributes","hash":"672d3b5767e0eacd83bb41b188c913f2cf754793","modified":1594023552000},{"_id":"themes/next/source/lib/fastclick/.bower.json","hash":"bf3eef9d647cd7c9b62feda3bc708c6cdd7c0877","modified":1594023552000},{"_id":"themes/next/source/lib/canvas-ribbon/canvas-ribbon.js","hash":"b02737510e9b89aeed6b54f89f602a9c24b06ff2","modified":1594023552000},{"_id":"themes/next/source/lib/fastclick/LICENSE","hash":"6f474ea75c42442da7bbcf2e9143ce98258efd8d","modified":1594023552000},{"_id":"themes/next/source/lib/fastclick/README.md","hash":"68a9b9d53126405b0fa5f3324f1fb96dbcc547aa","modified":1594023552000},{"_id":"themes/next/source/lib/fastclick/bower.json","hash":"a9b3ee1e4db71a0e4ea6d5bed292d176dd68b261","modified":1594023552000},{"_id":"themes/next/source/lib/jquery_lazyload/.bower.json","hash":"90fa628f156d8045357ff11eaf32e61abacf10e8","modified":1594023552000},{"_id":"themes/next/source/lib/jquery/.bower.json","hash":"865d6c1328ab209a4376b9d2b7a7824369565f28","modified":1594023552000},{"_id":"themes/next/source/lib/jquery_lazyload/CONTRIBUTING.md","hash":"4ded6fee668544778e97e38c2b211fc56c848e77","modified":1594023552000},{"_id":"themes/next/source/lib/jquery_lazyload/bower.json","hash":"e0acf1db27b0cc16128a59c46db1db406b5c4c58","modified":1594023552000},{"_id":"themes/next/source/lib/jquery_lazyload/README.md","hash":"b930297cb98b8e1dbd5abe9bc1ed9d5935d18ce8","modified":1594023552000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.lazyload.js","hash":"f4a570908f6c89c6edfb1c74959e733eaadea4f2","modified":1594023552000},{"_id":"themes/next/source/lib/jquery_lazyload/jquery.scrollstop.js","hash":"bf773ad48a0b9aa77681a89d7569eefc0f7b7b18","modified":1594023552000},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.css","hash":"e33aa8fa48b6639d8d8b937d13261597dd473b3a","modified":1594023552000},{"_id":"themes/next/source/lib/needsharebutton/needsharebutton.js","hash":"2ce5f3bf15c523b9bfc97720d8884bb22602a454","modified":1594023552000},{"_id":"themes/next/source/lib/needsharebutton/font-embedded.css","hash":"14264a210bf94232d58d7599ea2ba93bfa4fb458","modified":1594023552000},{"_id":"themes/next/source/lib/font-awesome/.gitignore","hash":"03ddbf76c1dd1afb93eed0b670d2eee747472ef1","modified":1594023552000},{"_id":"themes/next/source/lib/font-awesome/.bower.json","hash":"b4aefc910578d76b267e86dfffdd5121c8db9aec","modified":1594023552000},{"_id":"themes/next/source/lib/font-awesome/.npmignore","hash":"c31ff06a740955e44edd4403902e653ccabfd4db","modified":1594023552000},{"_id":"themes/next/source/lib/font-awesome/HELP-US-OUT.txt","hash":"ee33b2798b1e714b904d663436c6b3521011d1fa","modified":1594023552000},{"_id":"themes/next/source/lib/font-awesome/bower.json","hash":"71e7183634dc1b9449f590f15ebd7201add22ca7","modified":1594023552000},{"_id":"themes/next/source/lib/three/canvas_lines.min.js","hash":"2d9a9f38c493fdf7c0b833bb9184b6a1645c11b2","modified":1594023552000},{"_id":"themes/next/source/lib/three/three-waves.min.js","hash":"8148492dd49aa876d32bb7d5b728d3f5bf6f5074","modified":1594023552000},{"_id":"themes/next/source/lib/three/canvas_sphere.min.js","hash":"46a50b91c98b639c9a2b9265c5a1e66a5c656881","modified":1594023552000},{"_id":"themes/next/source/lib/pace/pace-theme-barber-shop.min.css","hash":"ee0d51446cb4ffe1bb96bd7bc8c8e046dddfcf46","modified":1594023552000},{"_id":"themes/next/source/lib/pace/pace-theme-big-counter.min.css","hash":"5b561dc328af4c4d512e20a76fe964d113a32ba8","modified":1594023552000},{"_id":"themes/next/source/lib/pace/pace-theme-bounce.min.css","hash":"f6bdb9a785b7979dd8ec5c60e278af955ef1e585","modified":1594023552000},{"_id":"themes/next/source/lib/pace/pace-theme-center-atom.min.css","hash":"dcf79c24fe5350fb73d8038573a104e73639e9d3","modified":1594023552000},{"_id":"themes/next/source/lib/pace/pace-theme-center-circle.min.css","hash":"a4066769c78affbfbc5e30a600e2c7862cd532e0","modified":1594023552000},{"_id":"themes/next/source/lib/pace/pace-theme-center-radar.min.css","hash":"ab7cba998bf4c03b13df342bf43647fa4f419783","modified":1594023552000},{"_id":"themes/next/source/lib/pace/pace-theme-corner-indicator.min.css","hash":"b3c64c973f31884e3d8145989476707333406b9a","modified":1594023552000},{"_id":"themes/next/source/lib/pace/pace-theme-center-simple.min.css","hash":"67f44c947548bd4d77e7590d3f59e236cbf9e98a","modified":1594023552000},{"_id":"themes/next/source/lib/pace/pace-theme-fill-left.min.css","hash":"0bec1e235a4a2cccda3f993b205424e1441a44ae","modified":1594023552000},{"_id":"themes/next/source/lib/pace/pace-theme-loading-bar.min.css","hash":"7ee28875dfc1230d76c537f6605766e8d4011e9f","modified":1594023552000},{"_id":"themes/next/source/lib/pace/pace-theme-mac-osx.min.css","hash":"9f2e7b51b084da407863826b25265b31150b3821","modified":1594023552000},{"_id":"themes/next/source/lib/pace/pace-theme-minimal.min.css","hash":"9cd783cceb8a191f3c8b5d81f7a430ecc3e489d3","modified":1594023552000},{"_id":"themes/next/source/lib/pace/pace.min.js","hash":"8aaa675f577d5501f5f22d5ccb07c2b76310b690","modified":1594023552000},{"_id":"themes/next/source/lib/velocity/.bower.json","hash":"63da5e80ebb61bb66a2794d5936315ca44231f0c","modified":1594023552000},{"_id":"themes/next/source/lib/velocity/bower.json","hash":"92d92860418c4216aa59eb4cb4a556290a7ad9c3","modified":1594023552000},{"_id":"themes/next/source/lib/pace/pace-theme-flash.min.css","hash":"13ace22c40312d7bbd8d9c1e50eff897a7a497d8","modified":1594023552000},{"_id":"themes/next/source/lib/velocity/velocity.ui.js","hash":"dbbfb50f6502f6b81dcc9fee7b31f1e812da3464","modified":1594023552000},{"_id":"themes/next/source/lib/velocity/velocity.ui.min.js","hash":"dde584994ac13dc601836e86f4cf490e418d9723","modified":1594023552000},{"_id":"themes/next/source/lib/velocity/velocity.min.js","hash":"bf172816a9c57f9040e3d19c24e181a142daf92b","modified":1594023552000},{"_id":"themes/next/source/lib/jquery/index.js","hash":"17a740d68a1c330876c198b6a4d9319f379f3af2","modified":1594023552000},{"_id":"themes/next/layout/_third-party/search/algolia-search/assets.swig","hash":"218cc936ba3518a3591b2c9eda46bc701edf7710","modified":1594023552000},{"_id":"themes/next/layout/_third-party/search/algolia-search/dom.swig","hash":"2530de0f3125a912756f6c0e9090cd012134a4c5","modified":1594023552000},{"_id":"themes/next/source/css/_common/components/back-to-top-sidebar.styl","hash":"8f86f694c0749a18ab3ad6f6df75466ca137a4bc","modified":1594023552000},{"_id":"themes/next/source/css/_common/components/back-to-top.styl","hash":"237d185ac62ec9877e300947fa0109c44fb8db19","modified":1594023552000},{"_id":"themes/next/source/css/_common/components/comments.styl","hash":"ff4489cd582f518bba6909a301ac1292a38b4e96","modified":1594023552000},{"_id":"themes/next/source/css/_common/components/buttons.styl","hash":"8b32928686c327151e13d3ab100157f9a03cd59f","modified":1594023552000},{"_id":"themes/next/source/css/_common/components/components.styl","hash":"7ad4081466b397e2a6204141bb7768b7c01bd93c","modified":1594023552000},{"_id":"themes/next/source/css/_common/components/pagination.styl","hash":"4f2801fc4cf3f31bf2069f41db8c6ce0e3da9e39","modified":1594023552000},{"_id":"themes/next/source/css/_common/components/tag-cloud.styl","hash":"6eb4bcc3056bd279d000607e8b4dad50d368ca69","modified":1594023552000},{"_id":"themes/next/source/css/_common/scaffolding/helpers.styl","hash":"1da5c800d025345f212a3bf1be035060f4e5e6ed","modified":1594023552000},{"_id":"themes/next/source/css/_common/scaffolding/base.styl","hash":"24ee4b356ff55fc6e58f26a929fa07750002cf29","modified":1594023552000},{"_id":"themes/next/source/css/_common/scaffolding/mobile.styl","hash":"91ca75492cd51f2553f4d294ed2f48239fcd55eb","modified":1594023552000},{"_id":"themes/next/source/css/_common/scaffolding/scaffolding.styl","hash":"a17e2b871a335f290afb392a08f94fd35f59c715","modified":1594023552000},{"_id":"themes/next/source/css/_common/scaffolding/normalize.styl","hash":"3f40e8a9fe8e7bd5cfc4cf4cbbbcb9539462e973","modified":1594023552000},{"_id":"themes/next/source/css/_common/scaffolding/tables.styl","hash":"ea9069645696f86c5df64208490876fe150c8cae","modified":1594023552000},{"_id":"themes/next/source/css/_common/outline/outline.styl","hash":"12662536c7a07fff548abe94171f34b768dd610f","modified":1594023552000},{"_id":"themes/next/source/css/_schemes/Gemini/index.styl","hash":"60fa84aa7731760f05f52dd7d8f79b5f74ac478d","modified":1594023552000},{"_id":"themes/next/source/css/_schemes/Mist/_base.styl","hash":"25d5e45a355ee2093f3b8b8eeac125ebf3905026","modified":1594023552000},{"_id":"themes/next/source/css/_schemes/Mist/_header.styl","hash":"d0bfd1bef988c76f7d7dd72d88af6f0908a8b0db","modified":1594023552000},{"_id":"themes/next/source/css/_schemes/Mist/_logo.styl","hash":"b1025c421406d2c24cc92a02ae28c1915b01e240","modified":1594023552000},{"_id":"themes/next/source/css/_schemes/Mist/_menu.styl","hash":"26666c1f472bf5f3fb9bc62081cca22b4de15ccb","modified":1594023552000},{"_id":"themes/next/source/css/_schemes/Mist/_search.styl","hash":"09c965022c13b84ed8a661fee8ac2a6d550495ae","modified":1594023552000},{"_id":"themes/next/source/css/_schemes/Mist/_posts-expanded.styl","hash":"9c99034f8e00d47e978b3959f51eb4a9ded0fcc8","modified":1594023552000},{"_id":"themes/next/source/css/_schemes/Mist/index.styl","hash":"9b913b73d31d21f057f97115ffab93cfa578b884","modified":1594023552000},{"_id":"themes/next/source/css/_schemes/Muse/_layout.styl","hash":"31127dcbf4c7b4ada53ffbf1638b5fe325b7cbc0","modified":1594023552000},{"_id":"themes/next/source/css/_schemes/Muse/_logo.styl","hash":"748dbfbf9c08e719ddc775958003c64b00d39dab","modified":1594023552000},{"_id":"themes/next/source/css/_schemes/Muse/_menu.styl","hash":"e695e58f714129ca292c2e54cd62c251aca7f7fe","modified":1594023552000},{"_id":"themes/next/source/css/_schemes/Muse/_search.styl","hash":"09c965022c13b84ed8a661fee8ac2a6d550495ae","modified":1594023552000},{"_id":"themes/next/source/css/_schemes/Muse/index.styl","hash":"5dbc0d0c897e46760e5dbee416530d485c747bba","modified":1594023552000},{"_id":"themes/next/source/css/_schemes/Pisces/_layout.styl","hash":"416988dca389e6e2fdfa51fa7f4ee07eb53f82fb","modified":1594023552000},{"_id":"themes/next/source/css/_schemes/Pisces/_menu.styl","hash":"4642e30010af8b2b037f5b43146b10a934941958","modified":1594023552000},{"_id":"themes/next/source/css/_schemes/Pisces/_brand.styl","hash":"bce344d3a665b4c55230d2a91eac2ad16d6f32fd","modified":1594023552000},{"_id":"themes/next/source/css/_schemes/Pisces/_posts.styl","hash":"1f6e2ce674735269599acc6d77b3ea18d31967fc","modified":1594023552000},{"_id":"themes/next/source/css/_schemes/Pisces/_sidebar.styl","hash":"ad2dcedf393ed1f3f5afd2508d24969c916d02fc","modified":1594023552000},{"_id":"themes/next/source/css/_schemes/Pisces/index.styl","hash":"86197902dfd3bededba10ba62b8f9f22e0420bde","modified":1594023552000},{"_id":"themes/next/source/js/src/schemes/pisces.js","hash":"f1d0b5d7af32c423eaa8bb93ab6a0b45655645dc","modified":1594023552000},{"_id":"themes/next/source/lib/Han/dist/han.css","hash":"6c26cdb36687d4f0a11dabf5290a909c3506be5c","modified":1594023552000},{"_id":"themes/next/source/lib/Han/dist/han.min.css","hash":"6d586bfcfb7ae48f1b12f76eec82d3ad31947501","modified":1594023552000},{"_id":"themes/next/source/lib/Han/dist/han.min.js","hash":"16b03db23a52623348f37c04544f2792032c1fb6","modified":1594023552000},{"_id":"themes/next/source/lib/fancybox/source/blank.gif","hash":"2daeaa8b5f19f0bc209d976c02bd6acb51b00b0a","modified":1594023552000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite.png","hash":"17df19f97628e77be09c352bf27425faea248251","modified":1594023552000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_sprite@2x.png","hash":"30c58913f327e28f466a00f4c1ac8001b560aed8","modified":1594023552000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_overlay.png","hash":"b3a4ee645ba494f52840ef8412015ba0f465dbe0","modified":1594023552000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading@2x.gif","hash":"273b123496a42ba45c3416adb027cd99745058b0","modified":1594023552000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.pack.js","hash":"ae6318aeb62ad4ce7a7e9a4cdacd93ffb004f0fb","modified":1594023552000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.css","hash":"82f33ad0842aa9c154d029e0dada2497d4eb1d57","modified":1594023552000},{"_id":"themes/next/source/lib/fancybox/source/jquery.fancybox.js","hash":"d71602cbca33b9ecdb7ab291b7f86a49530f3601","modified":1594023552000},{"_id":"themes/next/source/lib/fancybox/source/fancybox_loading.gif","hash":"1a755fb2599f3a313cc6cfdb14df043f8c14a99c","modified":1594023552000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.min.js","hash":"2cae0f5a6c5d6f3cb993015e6863f9483fc4de18","modified":1594023552000},{"_id":"themes/next/source/lib/fastclick/lib/fastclick.js","hash":"1d6aeda0480d0e4cb6198edf7719d601d4ae2ccc","modified":1594023552000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css","hash":"3655f1fdf1e584c4d8e8d39026093ca306a5a341","modified":1594023552000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.css.map","hash":"1573904b82807abbb32c97a3632c6c6808eaac50","modified":1594023552000},{"_id":"themes/next/source/lib/font-awesome/css/font-awesome.min.css","hash":"88af80502c44cd52ca81ffe7dc7276b7eccb06cf","modified":1594023552000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.min.js","hash":"41ea797c68dbcff2f6fb3aba1d1043a22e7cc0f6","modified":1594023552000},{"_id":"themes/next/source/lib/ua-parser-js/dist/ua-parser.pack.js","hash":"a817b6c158cbc5bab3582713de9fe18a18a80552","modified":1594023552000},{"_id":"themes/next/source/lib/Han/dist/han.js","hash":"4ac683b2bc8531c84d98f51b86957be0e6f830f3","modified":1594023552000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff","hash":"28b782240b3e76db824e12c02754a9731a167527","modified":1594023552000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.woff2","hash":"d6f48cba7d076fb6f2fd6ba993a75b9dc1ecbf0c","modified":1594023552000},{"_id":"themes/next/source/lib/velocity/velocity.js","hash":"4237c6e9d59da349639de20e559e87c2c0218cfd","modified":1594023552000},{"_id":"themes/next/source/css/_common/components/header/headerband.styl","hash":"d63e0cacc53dd375fcc113465a4328c59ff5f2c1","modified":1594023552000},{"_id":"themes/next/source/css/_common/components/header/header.styl","hash":"53cde051e0337f4bf42fb8d6d7a79fa3fa6d4ef2","modified":1594023552000},{"_id":"themes/next/source/css/_common/components/header/menu.styl","hash":"1a0d059799a298fe17c49a44298d32cebde93785","modified":1594023552000},{"_id":"themes/next/source/css/_common/components/header/site-meta.styl","hash":"0656e753f182c9f47fef7304c847b7587a85ef0d","modified":1594023552000},{"_id":"themes/next/source/css/_common/components/footer/footer.styl","hash":"9f73c4696f0907aa451a855444f88fc0698fa472","modified":1594023552000},{"_id":"themes/next/source/css/_common/components/header/site-nav.styl","hash":"1727702eac5d326b5c81a667944a245016668231","modified":1594023552000},{"_id":"themes/next/source/css/_common/components/highlight/diff.styl","hash":"167986d0f649516671ddf7193eebba7b421cd115","modified":1594023552000},{"_id":"themes/next/source/css/_common/components/highlight/theme.styl","hash":"7fe4d4d656e86276c17cb4e48a560cb6a4def703","modified":1594023552000},{"_id":"themes/next/source/css/_common/components/pages/archive.styl","hash":"b6f3a06a94a6ee5470c956663164d58eda818a64","modified":1594023552000},{"_id":"themes/next/source/css/_common/components/pages/categories.styl","hash":"7fb593f90d74a99c21840679933b9ef6fdc16a61","modified":1594023552000},{"_id":"themes/next/source/css/_common/components/highlight/highlight.styl","hash":"50450d9fdc8a2b2be8cfca51e3e1a01ffd636c0b","modified":1594023552000},{"_id":"themes/next/source/css/_common/components/pages/schedule.styl","hash":"8cf318644acc8b4978537c263290363e21c7f5af","modified":1594023552000},{"_id":"themes/next/source/css/_common/components/pages/pages.styl","hash":"f9760ecf186954cee3ba4a149be334e9ba296b89","modified":1594023552000},{"_id":"themes/next/source/css/_common/components/pages/post-detail.styl","hash":"4e3838d7ac81d9ad133960f0f7ed58a44a015285","modified":1594023552000},{"_id":"themes/next/source/css/_common/components/post/post-button.styl","hash":"62fbbd32cf5a99ae550c45c763a2c4813a138d01","modified":1594023552000},{"_id":"themes/next/source/css/_common/components/post/post-collapse.styl","hash":"875cbe88d5c7f6248990e2beb97c9828920e7e24","modified":1594023552000},{"_id":"themes/next/source/css/_common/components/post/post-copyright.styl","hash":"caf263d1928496688c0e1419801eafd7e6919ce5","modified":1594023552000},{"_id":"themes/next/source/css/_common/components/post/post-eof.styl","hash":"a200c0a1c5a895ac9dc41e0641a5dfcd766be99b","modified":1594023552000},{"_id":"themes/next/source/css/_common/components/post/post-expand.styl","hash":"a6c6eb8adba0a090ad1f4b9124e866887f20d10d","modified":1594023552000},{"_id":"themes/next/source/css/_common/components/post/post-gallery.styl","hash":"cd9e214e502697f2f2db84eb721bac57a49b0fce","modified":1594023552000},{"_id":"themes/next/source/css/_common/components/post/post-meta.styl","hash":"d0d7a5c90d62b685520d2b47fea8ba6019ff5402","modified":1594023552000},{"_id":"themes/next/source/css/_common/components/post/post-nav.styl","hash":"27deb3d3a243d30022055dac7dad851024099a8b","modified":1594023552000},{"_id":"themes/next/source/css/_common/components/post/post-reward.styl","hash":"ca88ea6999a61fb905eb6e72eba5f92d4ee31e6e","modified":1594023552000},{"_id":"themes/next/source/css/_common/components/post/post-rtl.styl","hash":"b2495ae5e04dcca610aacadc47881d9e716cd440","modified":1594023552000},{"_id":"themes/next/source/css/_common/components/post/post-tags.styl","hash":"5a982d8ef3b3623ea5f59e63728990f5623c1b57","modified":1594023552000},{"_id":"themes/next/source/css/_common/components/post/post-title.styl","hash":"ccb34c52be8adba5996c6b94f9e723bd07d34c16","modified":1594023552000},{"_id":"themes/next/source/css/_common/components/post/post-type.styl","hash":"01567edaea6978628aa5521a122a85434c418bfd","modified":1594023552000},{"_id":"themes/next/source/css/_common/components/post/post-widgets.styl","hash":"7968343e41f8b94b318c36289dff1196c3eb1791","modified":1594023552000},{"_id":"themes/next/source/css/_common/components/post/post.styl","hash":"89d6c3b697efc63de42afd2e89194b1be14152af","modified":1594023552000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author-links.styl","hash":"39f04c4c7237a4e10acd3002331992b79945d241","modified":1594023552000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-author.styl","hash":"761eba9811b050b25d548cc0854de4824b41eb08","modified":1594023552000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-blogroll.styl","hash":"8dd9a1c6f4f6baa00c2cf01837e7617120cf9660","modified":1594023552000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-dimmer.styl","hash":"11c22f0fb3f6beb13e5a425ec064a4ff974c13b7","modified":1594023552000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toc.styl","hash":"c8fe49a4bc014c24dead05b782a7082411a4abc5","modified":1594023552000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-feed-link.styl","hash":"61f8cea3c01acd600e90e1bc2a07def405503748","modified":1594023552000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-nav.styl","hash":"1153bb71edf253765145559674390e16dd67c633","modified":1594023552000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar-toggle.styl","hash":"a1521d48bb06d8d703753f52a198baa197af7da2","modified":1594023552000},{"_id":"themes/next/source/css/_common/components/sidebar/sidebar.styl","hash":"5ef6343835f484a2c0770bd1eb9cc443609e4c39","modified":1594023552000},{"_id":"themes/next/source/css/_common/components/sidebar/site-state.styl","hash":"e71652d3216e289c8548b1ea2357822c1476a425","modified":1594023552000},{"_id":"themes/next/source/css/_common/components/tags/blockquote-center.styl","hash":"2fe76476432b31993338cb45cdb3b29a518b6379","modified":1594023552000},{"_id":"themes/next/source/css/_common/components/tags/group-pictures.styl","hash":"2ad1a2a9bbf6742d1b0762c4c623b68113d1e0fe","modified":1594023552000},{"_id":"themes/next/source/css/_common/components/tags/exturl.styl","hash":"a3bdd71237afc112b2aa255f278cab6baeb25351","modified":1594023552000},{"_id":"themes/next/source/css/_common/components/tags/full-image.styl","hash":"f825da191816eef69ea8efb498a7f756d5ebb498","modified":1594023552000},{"_id":"themes/next/source/css/_common/components/tags/label.styl","hash":"2ab1322fe52ab5aafd49e68f5bd890e8380ee927","modified":1594023552000},{"_id":"themes/next/source/css/_common/components/tags/note-modern.styl","hash":"b7076e58d647265ee0ad2b461fe8ce72c9373bc5","modified":1594023552000},{"_id":"themes/next/source/css/_common/components/tags/note.styl","hash":"9a409b798decdefdaf7a23f0b11004a8c27e82f3","modified":1594023552000},{"_id":"themes/next/source/css/_common/components/tags/tabs.styl","hash":"154a87a32d2fead480d5e909c37f6c476671c5e6","modified":1594023552000},{"_id":"themes/next/source/css/_common/components/third-party/baidushare.styl","hash":"5dbeed535d63a50265d96b396a5440f9bb31e4ba","modified":1594023552000},{"_id":"themes/next/source/css/_common/components/tags/tags.styl","hash":"b80604868e4f5cf20fccafd7ee415c20c804f700","modified":1594023552000},{"_id":"themes/next/source/css/_common/components/third-party/algolia-search.styl","hash":"bba4f3bdb7517cd85376df3e1209b570c0548c69","modified":1594023552000},{"_id":"themes/next/source/css/_common/components/third-party/busuanzi-counter.styl","hash":"a6e7d698702c2e383dde3fde2abde27951679084","modified":1594023552000},{"_id":"themes/next/source/css/_common/components/third-party/duoshuo.styl","hash":"717cc7f82be9cc151e23a7678601ff2fd3a7fa1d","modified":1594023552000},{"_id":"themes/next/source/css/_common/components/third-party/gitment.styl","hash":"874278147115601d2abf15987f5f7a84ada1ac6b","modified":1594023552000},{"_id":"themes/next/source/css/_common/components/third-party/han.styl","hash":"10599e16414a8b7a76c4e79e6617b5fe3d4d1adf","modified":1594023552000},{"_id":"themes/next/source/css/_common/components/third-party/jiathis.styl","hash":"15975ba7456b96916b1dbac448a1a0d2c38b8f3d","modified":1594023552000},{"_id":"themes/next/source/css/_common/components/third-party/localsearch.styl","hash":"16087276945fa038f199692e3eabb1c52b8ea633","modified":1594023552000},{"_id":"themes/next/source/css/_common/components/third-party/needsharebutton.styl","hash":"28825ae15fa20ae3942cdaa7bcc1f3523ce59acc","modified":1594023552000},{"_id":"themes/next/source/css/_common/components/third-party/third-party.styl","hash":"9c8196394a89dfa40b87bf0019e80144365a9c93","modified":1594023552000},{"_id":"themes/next/source/css/_schemes/Mist/sidebar/sidebar-blogroll.styl","hash":"1f09be9bb38411f0629b58c3b23873589a6dbcaa","modified":1594023552000},{"_id":"themes/next/source/css/_schemes/Mist/outline/outline.styl","hash":"a07aa12cc36ac5c819670c2a3c17d07ed7a08986","modified":1594023552000},{"_id":"themes/next/source/css/_schemes/Muse/sidebar/sidebar-blogroll.styl","hash":"1f09be9bb38411f0629b58c3b23873589a6dbcaa","modified":1594023552000},{"_id":"themes/next/source/lib/Han/dist/font/han-space.otf","hash":"07436f011b44051f61b8329c99de4bec64e86f4b","modified":1594023552000},{"_id":"themes/next/source/lib/Han/dist/font/han-space.woff","hash":"7a635062b10bf5662ae1d218ba0980171005d060","modified":1594023552000},{"_id":"themes/next/source/lib/Han/dist/font/han.otf","hash":"f1f6bb8f461f5672e000380195d3d2358a28494c","modified":1594023552000},{"_id":"themes/next/source/lib/Han/dist/font/han.woff2","hash":"623af3ed5423371ac136a4fe0e8cc7bb7396037a","modified":1594023552000},{"_id":"themes/next/source/lib/Han/dist/font/han.woff","hash":"f38ff9b2eecaa17b50b66aa2dae87e9e7436d195","modified":1594023552000},{"_id":"themes/next/source/lib/fancybox/source/helpers/fancybox_buttons.png","hash":"e385b139516c6813dcd64b8fc431c364ceafe5f3","modified":1594023552000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-media.js","hash":"51139a4c79573d372a347ef01a493222a1eaf10a","modified":1594023552000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.css","hash":"6394c48092085788a8c0ef72670b0652006231a1","modified":1594023552000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-buttons.js","hash":"ee948b4489aedeb548a77c9e45d8c7c5732fd62d","modified":1594023552000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.css","hash":"b88b589f5f1aa1b3d87cc7eef34c281ff749b1ae","modified":1594023552000},{"_id":"themes/next/source/lib/fancybox/source/helpers/jquery.fancybox-thumbs.js","hash":"d22b1629cb23a6181bebb70d0cf653ffe4b835c8","modified":1594023552000},{"_id":"themes/next/source/lib/font-awesome/fonts/FontAwesome.otf","hash":"048707bc52ac4b6563aaa383bfe8660a0ddc908c","modified":1594023552000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.eot","hash":"d980c2ce873dc43af460d4d572d441304499f400","modified":1594023552000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.ttf","hash":"13b1eab65a983c7a73bc7997c479d66943f7c6cb","modified":1594023552000},{"_id":"themes/next/source/lib/algolia-instant-search/instantsearch.min.js","hash":"90a1b22129efc172e2dfcceeeb76bff58bc3192f","modified":1594023552000},{"_id":"themes/next/source/lib/three/three.min.js","hash":"26273b1cb4914850a89529b48091dc584f2c57b8","modified":1594023552000},{"_id":"themes/next/source/lib/font-awesome/fonts/fontawesome-webfont.svg","hash":"b5483b11f8ba213e733b5b8af9927a04fec996f6","modified":1594023552000}],"Category":[{"name":"JDK源码","_id":"clh7s5ctf0004xt8jfu9wbegj"},{"name":"算法","_id":"clh7s5ctj0009xt8j0tox5dqc"},{"name":"Java并发框架","parent":"clh7s5ctf0004xt8jfu9wbegj","_id":"clh7s5ctp000kxt8j30libp8v"},{"name":"Java集合框架","parent":"clh7s5ctf0004xt8jfu9wbegj","_id":"clh7s5ctt000txt8j9w7zacve"},{"name":"规划","_id":"clh7s5ctv0012xt8jhsehamt7"},{"name":"工程算法","parent":"clh7s5ctj0009xt8j0tox5dqc","_id":"clh7s5cty001bxt8jgj4u5bbk"},{"name":"杂谈","_id":"clh7s5cu50023xt8j2bsn6aqp"},{"name":"Java核心","parent":"clh7s5ctf0004xt8jfu9wbegj","_id":"clh7s5cu7002axt8jhp8l374n"},{"name":"JVM","_id":"clh7s5cu9002ixt8jft0v8lhz"},{"name":"买房","_id":"clh7s5cub002oxt8jc8mlbl1f"},{"name":"system design","_id":"clh7s5cuc002uxt8j162ya1rr"},{"name":"数据库","_id":"clh7s5cud002xxt8j8e3ncpnu"},{"name":"分布式系统","_id":"clh7s5cud0030xt8j9zs7g58m"},{"name":"源码分析","_id":"clh7s5cue0034xt8je3jffvo0"},{"name":"消息中间件","_id":"clh7s5cuh003mxt8j970xbong"},{"name":"考试","_id":"clh7s5cuj003zxt8jfeu4fe28"},{"name":"翻译","_id":"clh7s5cuk0043xt8j1idx6tvi"},{"name":"模型","_id":"clh7s5cul004dxt8jgg8851ow"},{"name":"面试算法","parent":"clh7s5ctj0009xt8j0tox5dqc","_id":"clh7s5cum004fxt8j16z28ws1"},{"name":"持续集成","_id":"clh7s5cun004kxt8j2b4vflto"},{"name":"买房的坑","parent":"clh7s5cub002oxt8jc8mlbl1f","_id":"clh7s5cun004oxt8j0sai266m"},{"name":"SQL","parent":"clh7s5cud002xxt8j8e3ncpnu","_id":"clh7s5cun004sxt8j98wf0r9o"},{"name":"搜索","parent":"clh7s5cud0030xt8j9zs7g58m","_id":"clh7s5cuo004wxt8j1df77lxk"},{"name":"kafka","parent":"clh7s5cuh003mxt8j970xbong","_id":"clh7s5cup0054xt8j5lwl9u8f"},{"name":"应用集群","parent":"clh7s5cud0030xt8j9zs7g58m","_id":"clh7s5cuq0056xt8j749x2oah"},{"name":"软考","parent":"clh7s5cuj003zxt8jfeu4fe28","_id":"clh7s5cur005ext8j0nhz2o6j"},{"name":"软件模型","parent":"clh7s5cul004dxt8jgg8851ow","_id":"clh7s5cus005sxt8j9ckhd1ia"},{"name":"单元测试","parent":"clh7s5cun004kxt8j2b4vflto","_id":"clh7s5cut005wxt8jap6vfc27"},{"name":"elasticsearch","parent":"clh7s5cuo004wxt8j1df77lxk","_id":"clh7s5cut005zxt8j2zdceti1"}],"Data":[],"Page":[{"title":"关于我","date":"2020-07-06T08:51:23.000Z","_content":"\n笔名**简单**，博客叫小知了，喜欢读书。1993年出生，陕西人，2015年本科毕业于西安理工大学。对软件设计与架构，分布式系统，数据库/存储系统比较感兴趣。\n\n别的研究方向：金融投资，饮食健康。\n\n## 博客(用于记录一些解决方案的博客)\n\n[https://blog.51cto.com/thinklili](https://blog.51cto.com/thinklili)\n\n## 读书笔记(买的书看了没多少)\n\n[https://xiaozhiliaoo.github.io/reading-note](https://xiaozhiliaoo.github.io/reading-note)\n\n\n## 工程实践汇总(实践，研究过的技术)\n\n[https://xiaozhiliaoo.github.io/practice-hub/](https://xiaozhiliaoo.github.io/practice-hub/)\n","source":"about/index.md","raw":"---\ntitle: 关于我 \ndate: 2020-07-06 16:51:23\n---\n\n笔名**简单**，博客叫小知了，喜欢读书。1993年出生，陕西人，2015年本科毕业于西安理工大学。对软件设计与架构，分布式系统，数据库/存储系统比较感兴趣。\n\n别的研究方向：金融投资，饮食健康。\n\n## 博客(用于记录一些解决方案的博客)\n\n[https://blog.51cto.com/thinklili](https://blog.51cto.com/thinklili)\n\n## 读书笔记(买的书看了没多少)\n\n[https://xiaozhiliaoo.github.io/reading-note](https://xiaozhiliaoo.github.io/reading-note)\n\n\n## 工程实践汇总(实践，研究过的技术)\n\n[https://xiaozhiliaoo.github.io/practice-hub/](https://xiaozhiliaoo.github.io/practice-hub/)\n","updated":"2022-12-10T08:59:26.000Z","path":"about/index.html","comments":1,"layout":"page","_id":"clh7s5ctd0001xt8j0eb3cg5m","content":"<p>笔名<strong>简单</strong>，博客叫小知了，喜欢读书。1993年出生，陕西人，2015年本科毕业于西安理工大学。对软件设计与架构，分布式系统，数据库/存储系统比较感兴趣。</p>\n<p>别的研究方向：金融投资，饮食健康。</p>\n<h2 id=\"博客-用于记录一些解决方案的博客\"><a href=\"#博客-用于记录一些解决方案的博客\" class=\"headerlink\" title=\"博客(用于记录一些解决方案的博客)\"></a>博客(用于记录一些解决方案的博客)</h2><p><a href=\"https://blog.51cto.com/thinklili\" target=\"_blank\" rel=\"noopener\">https://blog.51cto.com/thinklili</a></p>\n<h2 id=\"读书笔记-买的书看了没多少\"><a href=\"#读书笔记-买的书看了没多少\" class=\"headerlink\" title=\"读书笔记(买的书看了没多少)\"></a>读书笔记(买的书看了没多少)</h2><p><a href=\"https://xiaozhiliaoo.github.io/reading-note\" target=\"_blank\" rel=\"noopener\">https://xiaozhiliaoo.github.io/reading-note</a></p>\n<h2 id=\"工程实践汇总-实践，研究过的技术\"><a href=\"#工程实践汇总-实践，研究过的技术\" class=\"headerlink\" title=\"工程实践汇总(实践，研究过的技术)\"></a>工程实践汇总(实践，研究过的技术)</h2><p><a href=\"https://xiaozhiliaoo.github.io/practice-hub/\" target=\"_blank\" rel=\"noopener\">https://xiaozhiliaoo.github.io/practice-hub/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<p>笔名<strong>简单</strong>，博客叫小知了，喜欢读书。1993年出生，陕西人，2015年本科毕业于西安理工大学。对软件设计与架构，分布式系统，数据库/存储系统比较感兴趣。</p>\n<p>别的研究方向：金融投资，饮食健康。</p>\n<h2 id=\"博客-用于记录一些解决方案的博客\"><a href=\"#博客-用于记录一些解决方案的博客\" class=\"headerlink\" title=\"博客(用于记录一些解决方案的博客)\"></a>博客(用于记录一些解决方案的博客)</h2><p><a href=\"https://blog.51cto.com/thinklili\" target=\"_blank\" rel=\"noopener\">https://blog.51cto.com/thinklili</a></p>\n<h2 id=\"读书笔记-买的书看了没多少\"><a href=\"#读书笔记-买的书看了没多少\" class=\"headerlink\" title=\"读书笔记(买的书看了没多少)\"></a>读书笔记(买的书看了没多少)</h2><p><a href=\"https://xiaozhiliaoo.github.io/reading-note\" target=\"_blank\" rel=\"noopener\">https://xiaozhiliaoo.github.io/reading-note</a></p>\n<h2 id=\"工程实践汇总-实践，研究过的技术\"><a href=\"#工程实践汇总-实践，研究过的技术\" class=\"headerlink\" title=\"工程实践汇总(实践，研究过的技术)\"></a>工程实践汇总(实践，研究过的技术)</h2><p><a href=\"https://xiaozhiliaoo.github.io/practice-hub/\" target=\"_blank\" rel=\"noopener\">https://xiaozhiliaoo.github.io/practice-hub/</a></p>\n"},{"title":"分类","date":"2020-07-06T08:51:14.000Z","type":"categories","comments":0,"_content":"","source":"categories/index.md","raw":"---\ntitle: 分类\ndate: 2020-07-06 16:51:14\ntype: \"categories\"\ncomments: false\n---\n","updated":"2022-06-28T17:04:14.000Z","path":"categories/index.html","layout":"page","_id":"clh7s5ctf0003xt8j57tuh8u6","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"标签","date":"2020-07-06T08:49:04.000Z","type":"tags","comments":0,"_content":"","source":"tags/index.md","raw":"---\ntitle: 标签\ndate: 2020-07-06 16:49:04\ntype: \"tags\"\ncomments: false\n---\n","updated":"2022-06-28T17:04:02.000Z","path":"tags/index.html","layout":"page","_id":"clh7s5cxw006axt8j3uov13no","content":"","site":{"data":{}},"excerpt":"","more":""},{"title":"我的技术书单","date":"2020-12-05T19:05:18.000Z","tags":["我的技术书单","Book"],"categories":["读书"],"_content":"\n# 绪论\n\n突发奇想，想对买过技术书单进行汇总。看看自己都买过哪些书，哪些看了，哪些没看。以后买的书也会进行汇总。\n\n总结了我最喜欢的十本书，它的顺序和书可能在变，但是是对我个人启发较多的十本书。\n\n1. 分布式系统原理与范型 第二版 / 分布式系统概念与设计 第五版\n2. Effective Java 第三版\n3. Java并发编程实战\n4. 高性能的MySQL第三版\n5. Spring系列: Expert One on one J2EE Development Without EJB/Expert One on one J2EE Design And Implement/Spring框架高级编程\n6. 面向对象分析与设计 第三版\n7. UML和模式应用 第三版\n8. 设计模式-可复用面向对象软件的基础\n9. Streaming System\n10. Designing Data-Intensive Applications: The Big Ideas Behind Reliable, Scalable, and Maintainable Systems\n\n# 读后感\n\n[读书笔记-**reading note**](https://xiaozhiliaoo.github.io/reading-note/)\n\n# 书单汇总(共507本)\n\n最近统计时间：2023-01-12 总数**507**本。增加60本。\n\n最近统计时间：2022-03-31 总数**507**本。增加60本。\n\n最近统计时间：2021-12-12   总数**447**本。增加60本。\n\n最近统计时间：2021-08-26   总数**387**本。增加42本。\n\n最近统计时间：2021-07-14   总数**345**本。  增加25本。\n\n最近统计时间：2021-05-02  总数**320**本。 \n\n书单会以分类展示，并且写明作者，很多书的作者非常知名，阅读情况 会包含阅读时间(严重缺失)和阅读进度，阅读进度分为6级进行打分，**0**  没有读过，**1**  阅读25%  **2**, 50%  **3**, 75%  **4**,100%  **5**  读过多次 ， 书名加粗的是个人觉得非常好的经典书，值得多次阅读。汇总不好的一点是没有时间维度，后期读书时候会在阅读情况中加上。\n\n\n\n## 计算机科学(37)\n\n| 编号 | 书名                                | 作者                               | 阅读情况 | 读书笔记 |\n| ---- | ----------------------------------- | ---------------------------------- | -------- | -------- |\n| 1    | 操作系统概念第九版                  | Abraham Silberschatz               | 1        |          |\n| 2    | 程序设计语言:设计与实现第四版       | Terrence W. Pratt                  | 1        |          |\n| 3    | 数据库系统概念第五版                | Abraham Silberschatz               | 2        |          |\n| 4    | Solaris内核结构第二版               | Richard McDougall                  | 0        |          |\n| 5    | Linux内核设计与实现-第三版          | Robert Love                        | 1        |          |\n| 6    | 现代操作系统 英文第四版             | Abdrew S. Tanenbaum                | 0        |          |\n| 7    | 现代操作系统 中文第四版             | Abdrew S. Tanenbaum                | 2        |          |\n| 8    | 编译原理 英文第二版                 | Alfred V.Aho                       | 0        |          |\n| 9    | 分布式计算-原理，算法与实践         | Ajay Kshemkalyani                  | 1        |          |\n| 10   | 分布式数据库系统及其应用第三版      | 徐俊刚                             | 0        |          |\n| 11   | 计算机网络 英文第五版               | Abdrew S. Tanenbaum                | 0        |          |\n| 12   | 计算机组成与汇编语言原理 英文版     | Patricj Juola                      | 0        |          |\n| 13   | 算法第四版                          | Robert Sedgewick                   | 1        |          |\n| 14   | 程序设计语言-实践之路第三版         | Michael L. Soctt                   | 1        |          |\n| 15   | 计算机网络-第五版                   | Abdrew S. Tanenbaum                | 1        |          |\n| 16   | 软件工程-面向对象和传统的方法第八版 | Stephen R. Schach                  | 1        |          |\n| 17   | **分布式系统原理与范型 第二版**     | Abdrew S. Tanenbaum                | 4        |          |\n| 18   | 多处理器编程的艺术 修订版           | Nir Shavit                         | 2        |          |\n| 19   | 数据结构 Java版第四版               | 叶核亚                             | 4        |          |\n| 20   | 数据结构与算法                      | 张铭                               | 0        |          |\n| 21   | 算法设计与分析 第四版               | 王晓东                             | 1        |          |\n| 22   | 计算机组成与设计                    | David A. Patterson等               | 0        |          |\n| 23   | 操作系统-精髓与设计原理             | William Stallings                  | 0        |          |\n| 24   | 计算机程序的构造和解释              | Harold Abelson                     | 0        |          |\n| 25   | 编译原理第二版                      | Alfred V. Aho                      | 1        |          |\n| 26   | 分布式系统概念与设计                | George Coulouris                   | 1        |          |\n| 27   | 数据结构与算法 Java语言描述         | Mark Allen Weiss                   | 1        |          |\n| 28   | 设计原本                            | Frederick P. Brooks                | 4        |          |\n| 29   | 数据库系统公司概念 第六版           | Abraham Silberschazta              | 1        |          |\n| 30   | 深入理解计算机系统                  | Randal Bryant                      | 2        |          |\n| 31   | 程序设计语言概念-第九版             | Robert W.Sebesta                   | 1        |          |\n| 32   | 云计算与分布式系统                  | Kai Hwang等                        | 1        |          |\n| 33   | 算法心得（第二版）                  | Henry.S Warren                     | 0        |          |\n| 34   | 算法设计指南(第二版)                | Steven S.Skiena                    | 0        |          |\n| 35   | 分布式数据系统原理(第三版)          | M.Tamer Ozsu                       | 0        |          |\n| 36   | 计算机网络 系统方法 第五版          | Larry L. Peterson / Bruce S. Davie | 0        |          |\n| 37   | 计算之魂                            | 吴军                               | 0        |          |\n\n\n\n## 语言(61)\n\n| 编号 | 书名                                   | 作者                          | 阅读情况 | 读书笔记 |\n| ---- | -------------------------------------- | ----------------------------- | -------- | -------- |\n| 1    | Beginnig Java Object从概念到代码第二版 | Jacquie Barker                | 0        |          |\n| 2    | 深入理解java虚拟机第二版               | Bill Venners                  | 1        |          |\n| 3    | Java脚本编程                           | Dejan Bosanac                 | 0        |          |\n| 4    | 七周七语言                             | Bruce Tate                    | 1        |          |\n| 5    | Scala编程第三版                        | Martin Odersky                | 1        |          |\n| 6    | Perl语言入门                           | Pandal L. Schwartz            | 2        |          |\n| 7    | 编程语言实现模式                       | Terence Parr                  | 1        |          |\n| 8    | Practical Java                         | Peter Haggar                  | 2        |          |\n| 9    | 分布式Java应用基础与实践               | 林昊                          | 4        |          |\n| 10   | 深入浅出NodeJS                         | 朴灵                          | 1        |          |\n| 11   | 七周七并发                             | Paul Butcher                  | 1        |          |\n| 12   | Java加密与解密的艺术 第二版            | 梁栋                          | 2        |          |\n| 13   | Living Clojure                         | Carin Meier                   | 0        |          |\n| 14   | 领域特定语言                           | Martin Fowler                 | 1        |          |\n| 15   | 精通正则表达式                         | Jeffrey Friedl                | 1        |          |\n| 16   | ANTLR4权威指南                         | Terence Parr                  | 1        |          |\n| 17   | Java并发编程从入门到精通               | 张振华                        | 4        |          |\n| 18   | Go程序设计语言 英文版                  | Alan A. Donovan               | 3        |          |\n| 19   | Lua设计与实现                          | codedump                      | 3        |          |\n| 20   | **Effective Java 第二版**              | Joshua Bloch                  | 5        |          |\n| 21   | **Effective Java 第三版**              | Joshua Bloch                  | 5        |          |\n| 22   | Java并发编程的艺术                     | 方腾飞                        | 3        |          |\n| 23   | 虚拟机设计与实现-以JVM为例             | 李晓峰                        | 0        |          |\n| 24   | Java多线程编程实战指南-设计模式-第二版 | 黄文海                        | 1        |          |\n| 25   | Java并发实现原理-JDK源码剖析           | 余春龙                        | 0        |          |\n| 26   | **Java并发编程实战**                   | Brian Goetz                   | 5        |          |\n| 27   | **深入理解Java虚拟机第二版**           | 周志明                        | 5        |          |\n| 28   | **深入理解Java虚拟机第三版**           | 周志明                        | 1        |          |\n| 29   | Java并发设计模式                       | Doug Lea                      | 2        |          |\n| 30   | 实战Java高并发程序设计                 | 葛一鸣                        | 3        |          |\n| 31   | 精通Lambda表达式                       | Maurice Naftalin              | 3        |          |\n| 32   | Java编程思想第四版                     | Bruce Eckel                   | 4        |          |\n| 33   | 函数式编程思维                         | Neal Ford                     | 3        |          |\n| 34   | Java解惑                               | Joshua Bloch                  | 2        |          |\n| 35   | Java性能优化权威指南                   | Charlie Hunt                  | 2        |          |\n| 36   | Java技术手册                           | Benjamin J. Evans             | 2        |          |\n| 37   | Java虚拟机规范（JavaSE8）              | Tim Lindholm等                | 1        |          |\n| 38   | Java性能权威指南                       | Scott Oaks                    | 2        |          |\n| 39   | Java虚拟机并发编程                     | Venkat Subramaniam            | 1        |          |\n| 40   | Java编程方法论-响应式rxjava            | 知秋                          | 1        |          |\n| 41   | Java编程方法论-spring-reactor          | 知秋                          | 1        |          |\n| 42   | Spring响应式编程                       |                               | 2        |          |\n| 43   | RxJava反应式编程                       | 张卫滨翻译                    | 1        |          |\n| 44   | Java8函数式编程                        | Richard Warbuton              | 2        |          |\n| 45   | Rxjava2.x实战                          | 沈哲                          | 4        |          |\n| 46   | Java9模块化开发：核心原则与实践        | Sander Mark                   | 0        |          |\n| 47   | ECMAScript 2018快速入门                | 黄灯桥                        | 0        |          |\n| 48   | Java网络编程                           | Elliotte Rusty Harold)]       | 0        |          |\n| 49   | Java程序性能优化                       | 葛一鸣                        | 0        |          |\n| 50   | Go语言高级编程                         | 柴树杉                        | 0        |          |\n| 51   | Go语言底层原理剖析                     | 郑建勋                        | 0        |          |\n| 52   | 深入学习Go语言                         | 李晓钧                        | 0        |          |\n| 53   | C语言程序设计-现代方法                 | K.N.King                      | 0        |          |\n| 54   | Go程序设计语言                         | Alan Donovan                  | 0        |          |\n| 55   | Rust权威指南                           | Steve Klabnik / Carol Nichols | 0        |          |\n| 56   | C++ Primer 中文版（第五版）            | Stanley B. Lippman            | 0        |          |\n| 57   | C++ Primer 习题集                      | Stanley B. Lippman            | 0        |          |\n| 58   | latex入门                              | 刘海洋                        | 0        |          |\n| 59   | Koltin实战                             | Dmitry Jemerov                | 0        |          |\n| 60   | Grovvy程序设计                         | Venkat Subramaniam            | 0        |          |\n| 61   | **Effective Java 第三版英文版**        | Joshua Bloch                  | 0        |          |\n\n\n\n## 数据库(47)\n\n| 编号 | 书名                                          | 作者                                                         | 阅读情况 | 读书笔记 |\n| ---- | --------------------------------------------- | ------------------------------------------------------------ | -------- | -------- |\n| 1    | 高性能的MySQL第三版                           | Perter Zaitsev等                                             | 3        |          |\n| 2    | 高可用的MySQL第二版                           | Charles Bell                                                 | 1        |          |\n| 3    | 深入理解MySQL核心技术                         | Sasha Pachev                                                 | 2        |          |\n| 4    | HBase权威指南                                 | Lars George                                                  | 0        |          |\n| 5    | 海量数据库解决方案                            | 韩.李华植                                                    | 0        |          |\n| 6    | 数据库事务处理的艺术                          | 李海翔                                                       | 1        |          |\n| 7    | Effective MySQL之深入解析复制技术             | Ronald Bradford                                              | 2        |          |\n| 8    | Effective MySQL之SQL语句最优化                | Ronald Bradford                                              | 4        |          |\n| 9    | MySQL技术内幕：InnoDB存储引擎                 | 姜承尧                                                       | 4        |          |\n| 10   | 数据库系统内幕                                | Alex Petrov                                                  | 0        |          |\n| 11   | 数据密集型应用系统设计                        | Martin Kleppmann                                             | 3        |          |\n| 12   | NoSQL精粹                                     | Martin Flower                                                | 3        |          |\n| 13   | 数据库索引设计与优化                          | Michael Leach等                                              | 1        |          |\n| 14   | Cassandra权威指南第二版                       | Jeff Carpenter                                               | 2        |          |\n| 15   | Greenplum:从大数据战略到实现                  | 冯雷                                                         | 3        |          |\n| 16   | Clickhouse原理解析与应用实践                  | 朱凯                                                         | 0        |          |\n| 17   | MySQL技术内幕：SQL编程                        | 姜承尧                                                       | 2        |          |\n| 18   | Druid实时大数据分析                           |                                                              |          |          |\n| 19   | 图数据库                                      | Ian Robinson                                                 | 0        |          |\n| 20   | 企业级大数据平台构建：架构与实现              | 朱凯                                                         | 0        |          |\n| 21   | Apache Kylin权威指南                          | Apache Kylin核心团队                                         | 0        |          |\n| 22   | 数据仓储-第四版                               | Inmon W.H                                                    | 0        |          |\n| 23   | 大数据平台基础架构指南                        | 刘旭辉                                                       | 0        |          |\n| 24   | MySQL管理之道（第二版）性能调优，高可用与监控 | 贺春旸                                                       | 0        |          |\n| 25   | Hikaricp数据库连接池实战                      | 朱政科                                                       | 0        |          |\n| 26   | 精通LevelDB                                   | 廖环宇                                                       | 0        |          |\n| 27   | 数据库重构                                    | Scott W. Ambler                                              | 0        |          |\n| 28   | MySQL是怎样运行的？                           | 小孩子4919                                                   | 0        |          |\n| 29   | 解读NoSQL                                     | Dan McCreary                                                 | 0        |          |\n| 30   | 大数据挑战与NoSQL数据技术                     | 陆嘉恒                                                       | 0        |          |\n| 31   | 分布式数据库原理 架构与实践                   | 李海翔                                                       | 0        |          |\n| 32   | 分布式数据库系统原理 第三版                   | [M. Tamer Özsu](https://cs.uwaterloo.ca/~tozsu/) [Patrick Valduriez](http://www-sop.inria.fr/members/Patrick.Valduriez/) | 0        |          |\n| 33   | 七周七数据库                                  | Eric Redmond                                                 | 0        |          |\n| 34   | 对象存储实战指南                              | 罗庆超                                                       | 0        |          |\n| 35   | 数据分析之图算法：基于spark和neo4j            | Mark Needham                                                 | 0        |          |\n| 36   | 分布式对象存储 原理 架构以及Go语言实现        | 胡世杰                                                       | 0        |          |\n| 37   | 云数据库架构                                  | 朱明                                                         | 0        |          |\n| 38   | 大数据日知录                                  | 张俊林                                                       | 0        |          |\n| 39   | 云原生数据库 原理与最佳实践                   | 阿里巴巴                                                     | 0        |          |\n| 40   | postgresql指南                                | 【日】铃木启修                                               | 0        |          |\n| 41   | 数据库系统实现                                | Hector Garcia-Molina                                         | 0        |          |\n| 42   | Design Data Intensive Application             | Martin Kleppmann                                             | 0        |          |\n| 43   | 分布式数据库系统：大数据时代新型数据库技术    |                                                              | 0        |          |\n| 44   | 分布式 云计算 大数据                          | 林伟伟                                                       | 0        |          |\n| 45   | 寻路大数据                                    | Michael Manoochehri                                          | 0        |          |\n| 46   | 大数据技术与应用：数据密集型计算和模型        |                                                              | 0        |          |\n| 47   | 数据库系统，设计 实现与管理 基础篇            |                                                              |          |          |\n\n\n\n\n\n## 分布式与中间件(110)\n\n| 编号 | 书名                                                         | 作者                                       | 阅读情况 | 读书笔记 |\n| ---- | ------------------------------------------------------------ | ------------------------------------------ | -------- | -------- |\n| 1    | Rabbitmq实战指南                                             | 朱忠华                                     | 2        |          |\n| 2    | Lucene实战第二版                                             | Michael McCandless                         | 0        |          |\n| 3    | Docker实战                                                   | Jeff Nickoloff                             | 3        |          |\n| 4    | 深入剖析Nginx                                                | 高群凯                                     | 1        |          |\n| 5    | Http权威指南                                                 | David Gourley等                            | 3        |          |\n| 6    | Http/2基础教程                                               | Stephen Ludin                              | 2        |          |\n| 7    | Docker进阶与实战                                             | 华为                                       | 1        |          |\n| 8    | Etcd技术内幕                                                 | 百丽燊**shēn**                             | 0        |          |\n| 9    | 分布式数据库架构基于MyCat中间件                              | 周继锋等                                   | 1        |          |\n| 10   | Web容量规划的艺术                                            | John Allspaw                               | 1        |          |\n| 11   | Mongodb实战第一版                                            | Kyle Banker                                | 3        |          |\n| 12   | 从Paxos到Zookeeper                                           | 倪超                                       | 2        |          |\n| 13   | Rabbitmq实战                                                 | Alvaro Videla                              | 3        |          |\n| 14   | Netty实战                                                    | Morman Maurer                              | 2        |          |\n| 15   | Kafka权威指南                                                | Neha Narkhede                              | 0        |          |\n| 16   | Elsaticsearch服务器开发第二版                                | Rafa Kuc                                   | 2        |          |\n| 17   | 分布式服务框架原理与实践                                     | 李林锋                                     | 2        |          |\n| 18   | 大型网站系统与Java中间件实践                                 | 曾宪杰                                     | 4        |          |\n| 19   | Kubernetes in Action                                         | Marko Luksa                                | 3        |          |\n| 20   | Java RESTful Web Service实战第二版                           | 韩陆                                       | 2        |          |\n| 21   | Zookeeper 分布式过程协同技术详解                             | Flavio Junqueira                           | 2        |          |\n| 22   | 深入分析Java Web技术内幕 修订版                              | 许令波                                     | 4        |          |\n| 23   | Redis实战                                                    | Josiah L. Carlson                          | 4        |          |\n| 24   | Redis设计与实现                                              | 黄健宏                                     | 4        |          |\n| 25   | 大规模分布式系统架构与设计实战                               | 彭渊                                       | 0        |          |\n| 26   | 大规模分布式存储系统原理解析和架构实战                       | 杨传辉                                     | 1        |          |\n| 27   | 分布式消息中间件实践                                         | 倪伟                                       | 2        |          |\n| 28   | 深入分布式缓存-从原理到实践                                  | 于君泽等                                   | 3        |          |\n| 29   | 分布式系统应用设计                                           | Brendan Burns                              | 0        |          |\n| 30   | 企业集成模式-设计构建及部署消息传递解决方案                  | Gregor Hohpe                               | 1        |          |\n| 31   | NoSQL数据库技术实战                                          | 皮雄军                                     | 0        |          |\n| 32   | 反应式设计模式                                               | 何品等翻译                                 | 0        |          |\n| 33   | Redis5设计与源码分析                                         | 陈雷                                       | 0        |          |\n| 34   | Redis深度历险                                                | 钱文品                                     |          |          |\n| 35   | Akka入门和实践                                               | Jason Goodwin                              | 0        |          |\n| 36   | Akka实战：快速构建高可用分布式应用                           | 杜云飞                                     | 0        |          |\n| 37   | 响应式架构消息模式Actor实现与Scala应用集成                   | Vaughn Vernon                              |          |          |\n| 38   | Apache Kafka实战                                             | 胡夕                                       | 0        |          |\n| 39   | 深入理解Apache kafka核心设计与实践原理                       | 朱忠华                                     | 0        |          |\n| 40   | Apache kafka源码剖析                                         | 徐郡明                                     | 0        |          |\n| 41   | 实战Gradle                                                   | Benjamin Muschko                           | 0        |          |\n| 42   | Elasticssearch源码解析与优化实战                             | 张超                                       | 0        |          |\n| 43   | 深入理解Elasticsearch第三版                                  | 波哈维                                     | 0        |          |\n| 44   | Elasticssearch实战                                           | Radu Gheorghe                              | 0        |          |\n| 45   | 离线和实时大数据开发实战                                     | 朱松岭                                     | 0        |          |\n| 46   | Springboot解密                                               | 王福强                                     | 0        |          |\n| 47   | Hbase实战                                                    | Nick Dimiduk                               | 0        |          |\n| 48   | 尽在双十一                                                   | 双十一团队                                 | 0        |          |\n| 49   | 大型系统应用架构实战部署，容灾性能优化                       | 李彦超                                     | 0        |          |\n| 50   | Storm分布式实时计算模式                                      | P.Taylor Goetz                             | 0        |          |\n| 51   | Spark核心技术与高级应用                                      | 于俊                                       | 0        |          |\n| 52   | Hadoop技术内幕                                               | 董西成                                     | 0        |          |\n| 53   | RocketMq技术内幕                                             | 丁威                                       | 0        |          |\n| 54   | 大数据之路阿里巴巴大数据实践                                 | 阿里巴巴数据技术及产品部                   | 0        |          |\n| 55   | 大数据技术体系详解 原理架构与实践                            | 董西成                                     | 0        |          |\n| 56   | 深度剖析HadoopHDFS                                           | 林意群                                     | 0        |          |\n| 57   | 数据仓储工具箱：维度建模指南                                 | Ralph Kimball                              | 0        |          |\n| 58   | 深入理解Flink：实时大数据处理实践                            | 余海峰                                     | 0        |          |\n| 59   | 分布式实时处理系统：原理，架构与实现                         | 卢誉声                                     | 0        |          |\n| 60   | 分布式一致性算法开发实战                                     | 赵辰                                       | 0        |          |\n| 61   | KafkaStream实战                                              | William Bejeck                             | 0        |          |\n| 62   | akka应用模式：分布式应用程序设计实践指南                     | Michael Nash                               | 1        |          |\n| 63   | flink基础教程                                                | Tzoumas                                    | 0        |          |\n| 64   | akka实战（akka in action）                                   |                                            | 0        |          |\n| 65   | Hadoop技术内幕：深入解析YARN架构设计与实现原理               | 董西成                                     | 0        |          |\n| 66   | Hadoop技术内幕：深入解析Hadoop Common和HDFS架构设计ui实现原理 | 蔡斌                                       |          |          |\n| 67   | 大数据基础编程：实践和案例教程-第二版                        | 林子雨                                     | 0        |          |\n| 68   | 大数据实训案例：电信用户行为分析                             | 林子雨                                     | 0        |          |\n| 69   | 大数据实训案例：电影推荐系统Scala版                          | 林子雨                                     | 0        |          |\n| 70   | 疯狂VirtualBox实战讲学录                                     | 小耗子                                     | 0        |          |\n| 71   | 走进搜索引擎（第二版）                                       | 潘学峰                                     | 0        |          |\n| 72   | gRPC与云原生应用开发 以Go和Java为例                          | Kasun Indrasiri                            | 4        |          |\n| 73   | 深入理解RPC框架原理与实现                                    | 华钟明                                     | 0        |          |\n| 74   | 分布式事务之Seata                                            | 姜宇                                       | 0        |          |\n| 75   | 分布式缓存 原理架构及Go语言实现                              | 胡世杰                                     | 0        |          |\n| 76   | 深入理解分布式事务：原理与实践                               | 冰河                                       | 0        |          |\n| 77   | 分布式系统与一致性                                           | 陈东明                                     | 0        |          |\n| 78   | 分布式系统设计实践                                           | 李庆旭                                     | 0        |          |\n| 79   | 日志管理与分析权威指南                                       | Anton A. Chuvakin                          | 0        |          |\n| 80   | 搜索引擎：信息检索实践                                       | W.Bruce Croft                              | 0        |          |\n| 81   | 搜索引擎-原理技术与系统（第二版）                            | 李晓明                                     | 0        |          |\n| 82   | 自制搜索引擎                                                 | [日]山田浩之                               | 0        |          |\n| 83   | 这就是搜索引擎：核心技术详解                                 | 张俊林                                     | 0        |          |\n| 84   | 解密搜索引擎技术实战 : Lucene&Java精华版（第3版）            | 罗刚                                       | 0        |          |\n| 85   | 信息检索导论（修订版）                                       | Prabhakar Raghavan                         | 0        |          |\n| 86   | 自己动手写Java虚拟机                                         | 张秀宏                                     | 0        |          |\n| 87   | 深入理解分布式系统                                           | 唐伟志                                     | 0        |          |\n| 88   | HBase应用架构                                                | Jean-Marc Spaggiari                        | 0        |          |\n| 89   | 深入解析apache pulsar                                        | 林琳                                       | 0        |          |\n| 90   | 深入集群-大型数据中心资源调度与管理                          | 李雨前                                     | 0        |          |\n| 91   | ceph企业级分布式存储 原理与工程实践                          | 龚向宇                                     | 0        |          |\n| 92   | Linux开源网络全栈详解                                        |                                            | 0        |          |\n| 93   | 分布式操作系统原理与实践                                     | Doreen L. Galli                            | 0        |          |\n| 94   | NoSQL权威指南                                                | [美] 乔·塞科                               | 0        |          |\n| 95   | Ceph分布式存储学习指南                                       | [(芬兰)卡伦·辛格                           | 0        |          |\n| 96   | 大数据系统构建：可扩展实时数据系统构建原理与最佳实践         | Nathan Marz                                | 0        |          |\n| 97   | 流式架构 kafka和mapr streams数据流处理                       | Ted Dunning                                | 0        |          |\n| 98   | 流式系统 Streaming System                                    | Tyler Akidau / Slava Chernyak / Reuven Lax | 0        |          |\n| 99   | Hadoop应用架构                                               | Mark Grover                                | 0        |          |\n| 100  | Hadoop权威指南 第四版                                        | Tom white                                  | 0        |          |\n| 101  | 基于Apache Flink的流处理： 流式应用基础、实现及操作          |                                            | 0        |          |\n| 102  | Spark权威指南                                                | Bill Chambers                              | 0        |          |\n| 103  | 数据中台：基于Google Facebook和微博实践                      | 詹盈                                       | 0        |          |\n| 104  | Hive编程指南                                                 | Edward Capriolo                            | 0        |          |\n| 105  | MapReduce设计模式                                            | Donald Miner                               | 0        |          |\n| 106  | Spark快速大数据分析                                          | Holden Karau                               | 0        |          |\n| 107  | OpenTSDB技术内幕                                             | 百里燊                                     | 0        |          |\n| 108  | NoSQL实践指南                                                | Dan Sullivan                               | 0        |          |\n| 109  | Mesos实战                                                    | Roger Ignazio                              | 0        |          |\n| 110  | MongoDB权威指南 第二版                                       | Kristina Chodorow                          | 0        |          |\n\n\n\n\n\n\n\n## 框架(21)\n\n| 编号 | 书名                                               | 作者              | 阅读情况 | 读书笔记 |\n| ---- | -------------------------------------------------- | ----------------- | -------- | -------- |\n| 1    | 重新定义SpringCloud实战                            | 许进等            | 1        |          |\n| 2    | Spring实现第四版                                   | Craig Walls       | 2        |          |\n| 3    | J2EE核心模式第二版                                 | Deepak Alur       | 2        |          |\n| 4    | 精通Spring4.0企业应用开发实战                      | 陈雄华等          | 3        |          |\n| 5    | Java WebSocket编程                                 | Danny Coward      | 2        |          |\n| 6    | Spring框架高级编程                                 | Rod Johnson等     | 1        |          |\n| 7    | Mybatis技术内幕                                    | 徐郡明            | 1        |          |\n| 8    | Spring技术内幕第二版                               | 计文柯            | 1        |          |\n| 9    | Spring源码深度解析第二版                           | 郝佳              | 1        |          |\n| 10   | 深入理解SpringMVC源代码                            | 王耀              | 0        |          |\n| 11   | **Expert One on one J2EE Development Without EJB** | Rod Johnson等     | 3        |          |\n| 12   | **Expert One on one J2EE Design And Implement**    | Rod Johnson       | 2        |          |\n| 13   | 软件框架设计的艺术                                 | Jaroslav Tulach   | 2        |          |\n| 14   | .NET设计规范，约定，惯用法与模式                   | Krzysztof Cwalina | 0        |          |\n| 15   | iBatis实战                                         | Clinton Begin     | 0        |          |\n| 16   | GraphQL实战写给全栈工程师们                        | 王北南            | 0        |          |\n| 17   | SpringData实战                                     |                   | 0        |          |\n| 18   | 深入浅出MyBatis技术原理与实战                      | 杨开振            | 0        |          |\n| 19   | Apache ShardingSphere实战                          | 郑天民            | 0        |          |\n| 20   | Webassembly实战                                    | C. Gerard Gallant | 0        |          |\n| 21   | 反应式应用开发                                     | Duncan DeVore     | 0        |          |\n| 22   |                                                    |                   |          |          |\n\n\n\n## 架构(59)\n\n| 编号 | 书名                                      | 作者                | 阅读情况 | 读书笔记                                                     |\n| ---- | :---------------------------------------- | ------------------- | -------- | ------------------------------------------------------------ |\n| 1    | 从0开始学架构                             | 李运华              | 4        |                                                              |\n| 2    | 大型网站技术架构-核心原理与案例分析       | 李智慧              | 2        |                                                              |\n| 3    | 软考：软件设计师教程                      | 诸华                | 0        |                                                              |\n| 4    | 大数据技术原理与应用第二版                | 林子雨              | 1        |                                                              |\n| 5    | 企业IT架构转型之道                        | 钟华                | 3        |                                                              |\n| 6    | Kubernates权威指南纪念版                  | 垄正等              | 1        |                                                              |\n| 7    | 构建实时机器学习系统                      | 彭江森              | 1        |                                                              |\n| 8    | 云系统管理-大规模分布式系统设计与运营     | Thomas A.Limoncelli | 2        |                                                              |\n| 9    | 恰如其分的软件架构                        | George Fairbanks    | 1        |                                                              |\n| 10   | 软件架构设计                              | 温昱                | 4        |                                                              |\n| 11   | 软件架构设计-第二版                       | 温昱                | 3        |                                                              |\n| 12   | 进化：运维技术变革与实践探索              | 赵成                | 2        |                                                              |\n| 13   | 企业应用架构模式                          | Martin Flower       | 2        |                                                              |\n| 14   | Paas程序设计                              | Lucas Carlson       | 4        |                                                              |\n| 15   | 让云落地 云计算服务模式                   | Michael Kavis       | 4        |                                                              |\n| 16   | 架构之美                                  | Diomidis Spinellis  | 1        |                                                              |\n| 17   | 软件构架编档                              | Paul Clements等     | 0        |                                                              |\n| 18   | IT架构思维                                | Peter Beijer等      | 0        |                                                              |\n| 19   | 架构整洁之道                              | Robert C.Martin     | 4        |                                                              |\n| 20   | 云计算架构设计模式                        | Alex Homer等        | 3        |                                                              |\n| 21   | 简单之美 软件开发实践者的思考             | 倪健                | 4        |                                                              |\n| 22   | 架构即未来                                | Martin L.Abbott     | 1        |                                                              |\n| 23   | 高扩展性网站的50条原则                    | Martin L.Abbott     | 1        |                                                              |\n| 24   | 持续集成-软件质量改进的风险降低之道       | Paul M. Duvall      | 2        | [notes](https://xiaozhiliaoo.github.io/2020/11/28/CI-Book-Reading/) |\n| 25   | 持续交付-发布可靠软件的系统方法           | Jez Humble          | 1        |                                                              |\n| 26   | 演进式架构                                | Neal Ford           | 0        |                                                              |\n| 27   | Tomcat架构解析                            | 刘光瑞              | 1        |                                                              |\n| 28   | 白帽子讲Web安全                           | 吴翰清              | 1        |                                                              |\n| 29   | 深入浅出大型网站架构设计                  | 李力非              | 1        |                                                              |\n| 30   | 程序员必读软件架构                        | Simon Brown         | 0        |                                                              |\n| 31   | 代码之美                                  | Oram Wilson         | 0        |                                                              |\n| 32   | Prometheus云原生监控                      | 朱政科-阿里巴巴     | 1        |                                                              |\n| 33   | Apache SkyWalking实战                     | 吴晟                | 4        |                                                              |\n| 34   | Cloud Foundry：从数字化战略到实现         | 冯雷                | 1        |                                                              |\n| 35   | 逆流而上：阿里巴巴技术成长之路            | 阿里巴巴成长编委会  | 1        |                                                              |\n| 36   | 淘宝技术这十年                            | 子柳                | 0        |                                                              |\n| 37   | 架构解密：从分布式到微服务                | leader Us           | 1        |                                                              |\n| 38   | 亿级流量网站架构核心技术                  | 张开涛              | 0        |                                                              |\n| 39   | 分布式服务架构：原理，设计与实战          | 李艳鹏              | 0        |                                                              |\n| 40   | 微服务治理 体系 结构及实践                | 李鑫                | 0        |                                                              |\n| 41   | 微服务之道:度量驱动开发                   | 范亚敏              | 0        |                                                              |\n| 42   | 数字化转型的道与术                        | 钟华                | 0        |                                                              |\n| 43   | 业务架构  业务架构，应用架构，数据架构    | 温昱                | 4        |                                                              |\n| 44   | 大型网站性能优化实战                      | 周涛明              | 0        |                                                              |\n| 45   | 大型网站技术架构演进与性能优化            | 许令波              | 0        |                                                              |\n| 46   | 架构修炼之道：亿级网关，平台开放          | 王新栋              | 0        |                                                              |\n| 47   | 分布式一致性算法开发实战                  | 赵辰                | 0        |                                                              |\n| 48   | 大数据技术原理与应用第三版                | 林子雨              | 0        |                                                              |\n| 49   | 代码里的世界观：通往架构师之路            | 余叶                | 0        |                                                              |\n| 50   | 软件架构                                  | 沙巴纳              | 0        |                                                              |\n| 51   | 前端工程化：体系设计与实践                | 周俊鹏              | 0        |                                                              |\n| 52   | 可伸缩架构 第二版                         | 张若飞              | 0        |                                                              |\n| 53   | 凤凰架构                                  | 周志明              | 0        |                                                              |\n| 54   | AWS云计算实战                             | 安德烈亚斯·威蒂格   | 0        |                                                              |\n| 55   | 大数据技术架构-核心原理与应用实践         | 李智慧-极客时间专栏 | 1        |                                                              |\n| 56   | 企业数字化基石-阿里巴巴云计算基础设施实践 | 阿里巴巴            | 0        |                                                              |\n| 57   | 阿里云原生架构实践                        | 阿里巴巴            | 0        |                                                              |\n| 58   | 云原生架构：从技术演进到最佳实践          | 贺阮云              | 0        |                                                              |\n| 59   | 分布式架构原理与实践                      | 崔浩                | 0        |                                                              |\n\n\n\n\n\n\n\n## 软件工程(71)\n\n| 编号 | 书名                                                   | 作者                                                 | 阅读情况 | 读书笔记   |\n| ---- | ------------------------------------------------------ | ---------------------------------------------------- | -------- | ---------- |\n| 1    | 超越软件架构                                           | Luke Hohmann                                         | 0        |            |\n| 2    | 重构与模式                                             | Joshua Kerievsky                                     | 0        |            |\n| 3    | Contributing To Eclipse                                | Erich Gamma&Kent Beck                                | 1        |            |\n| 4    | 软件工艺                                               | Pete McBreen                                         | 3        |            |\n| 5    | 程序员修炼之道从小工到专家                             | Andrew Hunt                                          | 2        |            |\n| 6    | **面向对象分析与设计第二版**                           | Grady Booch                                          | 2        |            |\n| 7    | **面向对象分析与设计第三版**                           | Grady Booch                                          | 1        |            |\n| 8    | 人月神话                                               | Frederick P. Brooks                                  | 4        |            |\n| 9    | 敏捷中国史话                                           | 熊节                                                 | 4        |            |\n| 10   | 软件开发本质论                                         | Ron Jeffries                                         | 2        |            |\n| 11   | 大教堂与集市                                           | Eric Raymond                                         | 4        |            |\n| 12   | 快速软件开发                                           | Steve McConnell                                      | 1        |            |\n| 13   | 程序开发心理学                                         | Gerald Weinberg                                      | 0        |            |\n| 14   | 个体软件工程                                           | Watts S. Humphrey                                    | 0        |            |\n| 15   | 走出软件工坊                                           | 阿朱                                                 | 1        |            |\n| 16   | UNIX编程艺术                                           | Eric S.Raymond                                       | 1        |            |\n| 17   | 解析极限编程-拥抱变化第一版                            | Kent Beck                                            | 3        |            |\n| 18   | 敏捷软件开发-原则，模式-实践                           | Robert C.Martin                                      | 1        |            |\n| 19   | **实现模式**                                           | Kent Beck                                            | 4        |            |\n| 20   | 面向模式的软件架构 资源管理模式                        | Michael Kircher                                      | 2        |            |\n| 21   | 编程珠玑第二版                                         | Jon Bentley                                          | 1        |            |\n| 22   | 数据库访问模式                                         | Clifton Nock                                         | 1        |            |\n| 23   | 反模式-危机中的软件，架构和项目的重构                  | William Brown                                        | 2        |            |\n| 24   | 面向对象项目的解决方案                                 | Grady Booch                                          | 2        |            |\n| 25   | 软件构架实践                                           | Len Bass                                             | 1        |            |\n| 26   | 面向模式的软件架构-模式系统第一卷                      | Frank Buschmann                                      | 3        |            |\n| 27   | 发布! 软件的设计与部署-第一版                          | Michael T. Mygard                                    | 1        |            |\n| 28   | 发布! 软件的设计与部署-第二版                          | Michael T. Mygard                                    | 0        |            |\n| 29   | 构建之法-现代软件工程0第三版                           | 邹欣                                                 | 0        |            |\n| 30   | 混沌工程Netflix系统稳定性之道                          | Casey Rosenthal等                                    | 0        |            |\n| 31   | 设计模式-可复用面向对象软件的基础                      | GOF4                                                 | 0        |            |\n| 32   | 精益软件度量                                           | 张松                                                 | 0        |            |\n| 33   | 测试驱动开发-英文版                                    | Kent Beck                                            | 2        |            |\n| 34   | Xunit测试模式                                          | Gerard Meszaros                                      | 1        |            |\n| 35   | Google软件测试之道                                     | James Whittaker                                      | 0        |            |\n| 36   | UML用户指南                                            | Grady Booch                                          | 2        |            |\n| 37   | 敏捷革命                                               | Jeff Sutherland                                      | 4        |            |\n| 38   | 看板方法-科技企业渐进变革成功之道                      | David J. Anderson                                    | 1        |            |\n| 39   | 敏捷迭代开发-管理者指南                                | Craig Larman                                         | 0        |            |\n| 40   | **UML和模式应用第三版**                                | Craig Larman                                         | 3        |            |\n| 41   | 面向对象编程导论 第三版                                | Timothy A. Budd                                      | 0        |            |\n| 42   | 编写有效用例                                           | Alistair Cockburn                                    | 1        |            |\n| 43   | 代码大全第二版                                         | Steve McConnell                                      | 0        |            |\n| 44   | 统一软件开发过程                                       | Ivar Jacobson                                        | 1        |            |\n| 45   | 用户故事与敏捷方法                                     | Mike Cohn                                            | 1        |            |\n| 46   | 面向快速交付的软件开发                                 | 翟宏宝                                               | 0        |            |\n| 47   | 有效的单元测试                                         | Lasse Koskela                                        | 0        | 2020-12-15 |\n| 48   | 构建高质量软件-程序开发人员测试指南                    | Alexander Tarlinder                                  | 0        | 2020-12-22 |\n| 49   | 程序员应该知道的97件事                                 | Kevlin Henney                                        | 0        | 2020-12-22 |\n| 50   | 软件架构师应该知道的97件事                             | Richard Monson-Haefel                                | 0        | 2020-12-22 |\n| 51   | Cucumber行为驱动开发指南                               | Matt Waynne等                                        | 0        | 2020-12-22 |\n| 52   | 实例化需求                                             | Gojko Adzic                                          | 0        | 2020-12-21 |\n| 53   | 驯服烂代码                                             | 伍斌                                                 | 0        | 2020-12-28 |\n| 54   | 软件工程通史1930-2019                                  | Capers Jones                                         | 0        |            |\n| 55   | 人件(原书第三版)                                       | Tom DeMarco Timothy Lister                           | 0        | 2021-05-02 |\n| 56   | 软件困局：为什么聪明的程序员写出糟糕的代码             | Adam Barr                                            | 0        |            |\n| 57   | 项目百态：深入理解软件项目行为模式                     | 金明翻译                                             | 0        |            |\n| 58   | 硝烟中的Scrum和XP-我们如何实施Scrum                    | Henrik Kniberg                                       | 0        |            |\n| 59   | 敏捷整洁之道                                           | Robert C. Martin                                     | 0        |            |\n| 60   | 精益软件开发管理之道                                   | Mary  Poppendieck                                    | 0        |            |\n| 61   | 敏捷软件开发工具-精益开发方法                          | Mary  Poppendieck                                    | 0        |            |\n| 62   | 活文档 与代码共同演进                                  | Cyrille Matraire                                     | 0        |            |\n| 63   | 凤凰项目 一个IT运维的传奇故事-修订版                   | Gene Kim                                             | 0        |            |\n| 64   | 产品研发管理：构建世界一流的产品研发管理体系（第二版） | 周辉                                                 | 0        |            |\n| 65   | 敏捷技能修炼：敏捷软件开发与设计的最佳实践             | Alan Shalloway / Scott Bain / Ken Pugh / Amir Kolsky | 0        |            |\n| 66   | Scrum敏捷软件开发                                      | Mike Cohn                                            | 0        |            |\n| 67   | 敏捷软件开发时间：估算与计划                           | Mike Cohn                                            | 0        |            |\n| 68   | SCRUM敏捷项目管理                                      | Ken Schwaber                                         | 0        |            |\n| 69   | 这就是软件工程师                                       | 丁丛丛 靳冉                                          | 0        |            |\n| 70   | 30天软件开发：告别瀑布拥抱敏捷                         | Ken Schwaber,Jeff Sutherland                         | 0        |            |\n| 71   | Vim实用技巧 第二版                                     | Drew Neil                                            | 0        |            |\n\n\n\n## 设计(27)\n\n| 编号 | 书名                                       | 作者                     | 阅读情况 | 读书笔记   |\n| ---- | ------------------------------------------ | ------------------------ | -------- | ---------- |\n| 1    | **重构-第一版**                            | Martin Flower            | 4        |            |\n| 2    | 微服务设计                                 | Sam Newman               | 3        |            |\n| 3    | UML和OOAD快速入门                          | 邱郁惠                   | 2        |            |\n| 4    | 软件设计之道：那些值得借鉴的实践案例       | 麦思博                   | 0        |            |\n| 5    | 分析模式                                   | Martin Fowler            | 0        |            |\n| 6    | 生产微服务                                 | Susan J.Fowler           | 0        |            |\n| 7    | 修改代码的艺术-构建易维护代码的9条最佳实践 | David Scott Bernstein    | 3        |            |\n| 8    | 修改代码的艺术                             | Michael Feathers         | 1        |            |\n| 9    | 遗留系统重建实战                           | Chris Birchall           | 2        |            |\n| 10   | Junit实战第二版                            | Peter Tahchiev           | 3        |            |\n| 11   | 软件设计哲学                               | John Ousterhout          | 4        |            |\n| 12   | 领域驱动设计全面解析与实战                 | 彭晨阳                   | 1        |            |\n| 13   | 软件工程-实践者的研究方法-第八版           | Roger S.Pressman         | 0        |            |\n| 14   | 实现领域驱动设计                           | Vaughn Vernon            | 2        |            |\n| 15   | 编程格调                                   | Brian W.Kernighan        | 0        |            |\n| 16   | 对象设计：角色，责任和协作                 | Rebecca Wirfs-Brock      | 1        |            |\n| 17   | **OOD启思录**                              | Arthur J. Riel           | 4        |            |\n| 18   | 软件设计重构                               | Tushar Sharma等          | 4        |            |\n| 19   | 领域驱动设计精粹                           | Vaughn Vernon            | 3        |            |\n| 20   | 设计模式的艺术                             | 刘伟                     | 4        |            |\n| 21   | 代码精进之路-从码农到工匠                  | 张建飞                   | 4        |            |\n| 22   | 领域驱动设计                               | Eric Evans               | 2        |            |\n| 23   | 特征驱动开发方法原理与实践                 | Stephen R. Palmer        | 0        |            |\n| 24   | 浮现式设计：专业软件开发的演进本质         | Scott L.Bain             | 0        |            |\n| 25   | 微服务设计模式和最佳实践                   | Vinicius Feitosa Pacheco | 0        | 2020-12-22 |\n| 26   | 微服务架构设计模式                         | Chris Richardson         | 0        |            |\n| 27   | 软件预构的艺术                             | Ken Pugh                 | 0        |            |\n\n\n\n## 考试与考证(16)\n\n| 编号 | 书名                                  | 作者                             | 阅读情况 |\n| ---- | ------------------------------------- | -------------------------------- | -------- |\n| 1    | 软考:系统架构设计师 2009-2016试题分析 | 全国计算机专业技术资格考试办公室 | 0        |\n| 2    | 软件体系架构：原理方法与实践          | 张友生                           | 0        |\n| 3    | 产品经理认证NPDP知识体系指南          | (美)产品开发与管理协会           | 0        |\n| 4    | 软考：信息系统项目管理师教程          | 全国计算机专业技术资格考试办公室 | 0        |\n| 5    | 软考：信息系统项目管理师考试论文执导  | 全国计算机专业技术资格考试办公室 | 0        |\n| 6    | 软考：信息系统项目管理师案例分析指南  | 全国计算机专业技术资格考试办公室 | 0        |\n| 7    | 软考:系统架构设计师 2013-2018试题分析 | 全国计算机专业技术资格考试办公室 | 0        |\n| 8    | 软考:系统架构设计师教程               | 全国计算机专业技术资格考试办公室 | 0        |\n| 9    | 软考:系统架构设计师全程指导           | 全国计算机专业技术资格考试办公室 | 0        |\n| 10   | 软考：系统架构设计师考试32小时通关    | 全国计算机专业技术资格考试办公室 | 0        |\n| 11   | 软考：系统架构设计师教程              | 希赛教育                         | 0        |\n| 12   | 项目管理知识体系指南 第六版           | [美]项目管理协会                 | 0        |\n| 13   | 敏捷实践指南                          | [美]项目管理协会                 | 0        |\n| 14   | Head First PMP 第三版                 | 格林 / 斯泰曼                    | 0        |\n| 15   | 敏捷项目管理(第二版):快速交付创新产品 | Jim,Highsmith                    | 0        |\n| 16   | 汪博士解读PMP 第五版                  | 汪博士                           | 0        |\n\n## 产品(16)\n\n| 编号 | 书名                                          | 作者                      | 阅读情况 | 读书笔记 |\n| ---- | --------------------------------------------- | ------------------------- | -------- | -------- |\n| 1    | 产品设计与开发第五版                          | Karl T.Ullrich            | 0        |          |\n| 2    | 疯传                                          | Jonah Berger              | 0        |          |\n| 3    | 人人都是产品经理-第二版                       | 苏杰                      | 0        |          |\n| 4    | 你的灯还亮着吗？                              | Gerald M.Weinberg         | 4        |          |\n| 5    | 淘宝产品十年事                                | 苏杰                      | 0        |          |\n| 6    | 俞军 产品方法论                               | 俞军                      | 1        |          |\n| 7    | 支付平台架构-业务，规划，设计与实现           | 曹兵强                    | 4        |          |\n| 8    | 电商产品经理宝典                              | 刘志远                    | 3        |          |\n| 9    | 电商产品经理：基于人货场内容的产品设计攻略    | 王伟                      | 0        |          |\n| 10   | 业务中台产品搭建指南                          | 高晖                      | 0        |          |\n| 11   | 增长黑客                                      | 肖恩·埃利斯 （Sean Ellis) | 0        |          |\n| 12   | 数据产品经理修炼手册-从零基础到大数据产品实践 | 梁旭鹏                    | 0        |          |\n| 13   | 数据产品经理必须课：从零经验到令人惊艳        | 李鑫                      | 0        |          |\n| 14   | 数据驱动：从方法到实践                        | 桑文锋                    | 0        |          |\n| 15   | 支付方法论                                    | 王伟                      | 0        |          |\n| 16   | 云计算时代 本质，计算，创新，战略             | 刘黎明                    | 0        |          |\n\n\n\n## 系统(13)\n\n| 编号 | 书名                              | 作者              | 阅读情况 | 读书笔记 |\n| ---- | --------------------------------- | ----------------- | -------- | -------- |\n| 1    | Linux系统编程手册-上              | Michael Kerrisk   | 1        |          |\n| 2    | Linux系统编程手册-下              | Michael Kerrisk   | 1        |          |\n| 3    | 系统性能优化第二版                | Mike Loukides     | 0        |          |\n| 4    | 性能之巅                          | Brendan Gregg     | 2        |          |\n| 5    | Linux大棚命令百篇上：文件和文本篇 | 大棚              | 0        |          |\n| 6    | Linux大棚命令百篇下：网络和系统篇 | 大棚              | 0        |          |\n| 7    | Linux就该这么学                   | 刘遄              | 0        |          |\n| 8    | UNIX环境高级编程 第三版           | W.Richard Stevens | 0        |          |\n| 9    | Linux系统编程 第二版              | Robert Love       | 0        |          |\n| 10   | UNIX网络编程卷2：进程间通信       | W.Richard Stevens | 0        |          |\n| 11   | UNIX网络编程卷2：套接字联网API    | W.Richard Stevens | 0        |          |\n| 12   | 深入理解Linux内核 第三版          | 西斯特            | 0        |          |\n| 13   | Unix/Linux编程实践教程            | Bruce Molay       | 0        |          |\n\n\n\n## 区块链(7)\n\n| 编号 | 书名                                               | 作者         | 阅读情况 | 读书笔记 |\n| ---- | -------------------------------------------------- | ------------ | -------- | -------- |\n| 1    | 以太坊技术详解与实战                               | 闫莺等       | 0        |          |\n| 2    | EOS区块链应用开发指南                              | 家男         | 0        |          |\n| 3    | 虚拟货币革命                                       | 野口悠纪雄   | 0        |          |\n| 4    | 区块链革命：比特币底层技术如何改变货币，商业和世界 | Don Tapscott | 0        |          |\n| 5    | 区块链原理，设计与应用                             | 杨保华       | 0        |          |\n| 6    | 区块链100问                                        | 赵何娟       | 0        |          |\n| 7    | 区块链 新经济蓝图及导读                            | 梅兰妮       | 0        |          |\n\n\n\n## 其他(22)\n\n| 编号 | 书名                               | 作者                    | 阅读情况 | 读书笔记 |\n| ---- | ---------------------------------- | ----------------------- | -------- | -------- |\n| 1    | 金领简历                           | Gayle Laakmann McDowell | 3        |          |\n| 2    | IEEE计算机先驱奖(1980-2014)        | 崔林                    | 1        |          |\n| 3    | 图灵和ACM图灵奖品(1966-2011)       | 吴鹤龄                  | 1        |          |\n| 4    | 黑客与画家                         | Paul Graham             | 3        |          |\n| 5    | 延长万物之尺                       | 保罗.汉弗莱斯           | 0        |          |\n| 6    | Effective Debugging                | Diomidis Spinellis      | 1        |          |\n| 7    | 跨越鸿沟                           | Geoffrey Moore          | 2        |          |\n| 8    | 微软团队成功墨诀                   | 麦卡锡                  | 0        |          |\n| 9    | 开源软件之道                       | 蔡俊杰                  | 3        |          |\n| 10   | 计算机英语教程双色版               | 张强华                  | 0        |          |\n| 11   | 设计领导力                         | Richard Banfield        | 0        |          |\n| 12   | 开源软件与专有软件的竞争           | 王广凤                  | 1        |          |\n| 13   | 程序员代码面试指南第二版           | 左程云                  | 1        |          |\n| 14   | 剑指Offer 第二版                   | 何海涛                  | 1        |          |\n| 15   | OKR工作法-谷歌等顶级公司高绩效秘籍 | 沃特克                  | 3        |          |\n| 16   | 程序员的成长课                     | 安晓辉等                | 0        |          |\n| 17   | Java程序员面试算法宝典             | 猿媛之家                | 0        |          |\n| 18   | 程序员面试金典 第六版              | 盖尔-拉克曼             | 1        |          |\n| 19   | 开源法则                           | 何宝宏博士              | 4        |          |\n| 20   | 计算机英语 第五版                  | 刘艺                    | 0        |          |\n| 21   | 研究是一门艺术 第四版              | Wayne C. Booth          | 0        |          |\n| 22   | 程序员的英语                       | [韩]朴栽浒              | 0        |          |\n\n","source":"reading-list/index.md","raw":"---\ntitle: 我的技术书单\ndate: 2020-12-06 03:05:18\ntags:\n  - 我的技术书单\n  - Book\ncategories:\n  - 读书\n---\n\n# 绪论\n\n突发奇想，想对买过技术书单进行汇总。看看自己都买过哪些书，哪些看了，哪些没看。以后买的书也会进行汇总。\n\n总结了我最喜欢的十本书，它的顺序和书可能在变，但是是对我个人启发较多的十本书。\n\n1. 分布式系统原理与范型 第二版 / 分布式系统概念与设计 第五版\n2. Effective Java 第三版\n3. Java并发编程实战\n4. 高性能的MySQL第三版\n5. Spring系列: Expert One on one J2EE Development Without EJB/Expert One on one J2EE Design And Implement/Spring框架高级编程\n6. 面向对象分析与设计 第三版\n7. UML和模式应用 第三版\n8. 设计模式-可复用面向对象软件的基础\n9. Streaming System\n10. Designing Data-Intensive Applications: The Big Ideas Behind Reliable, Scalable, and Maintainable Systems\n\n# 读后感\n\n[读书笔记-**reading note**](https://xiaozhiliaoo.github.io/reading-note/)\n\n# 书单汇总(共507本)\n\n最近统计时间：2023-01-12 总数**507**本。增加60本。\n\n最近统计时间：2022-03-31 总数**507**本。增加60本。\n\n最近统计时间：2021-12-12   总数**447**本。增加60本。\n\n最近统计时间：2021-08-26   总数**387**本。增加42本。\n\n最近统计时间：2021-07-14   总数**345**本。  增加25本。\n\n最近统计时间：2021-05-02  总数**320**本。 \n\n书单会以分类展示，并且写明作者，很多书的作者非常知名，阅读情况 会包含阅读时间(严重缺失)和阅读进度，阅读进度分为6级进行打分，**0**  没有读过，**1**  阅读25%  **2**, 50%  **3**, 75%  **4**,100%  **5**  读过多次 ， 书名加粗的是个人觉得非常好的经典书，值得多次阅读。汇总不好的一点是没有时间维度，后期读书时候会在阅读情况中加上。\n\n\n\n## 计算机科学(37)\n\n| 编号 | 书名                                | 作者                               | 阅读情况 | 读书笔记 |\n| ---- | ----------------------------------- | ---------------------------------- | -------- | -------- |\n| 1    | 操作系统概念第九版                  | Abraham Silberschatz               | 1        |          |\n| 2    | 程序设计语言:设计与实现第四版       | Terrence W. Pratt                  | 1        |          |\n| 3    | 数据库系统概念第五版                | Abraham Silberschatz               | 2        |          |\n| 4    | Solaris内核结构第二版               | Richard McDougall                  | 0        |          |\n| 5    | Linux内核设计与实现-第三版          | Robert Love                        | 1        |          |\n| 6    | 现代操作系统 英文第四版             | Abdrew S. Tanenbaum                | 0        |          |\n| 7    | 现代操作系统 中文第四版             | Abdrew S. Tanenbaum                | 2        |          |\n| 8    | 编译原理 英文第二版                 | Alfred V.Aho                       | 0        |          |\n| 9    | 分布式计算-原理，算法与实践         | Ajay Kshemkalyani                  | 1        |          |\n| 10   | 分布式数据库系统及其应用第三版      | 徐俊刚                             | 0        |          |\n| 11   | 计算机网络 英文第五版               | Abdrew S. Tanenbaum                | 0        |          |\n| 12   | 计算机组成与汇编语言原理 英文版     | Patricj Juola                      | 0        |          |\n| 13   | 算法第四版                          | Robert Sedgewick                   | 1        |          |\n| 14   | 程序设计语言-实践之路第三版         | Michael L. Soctt                   | 1        |          |\n| 15   | 计算机网络-第五版                   | Abdrew S. Tanenbaum                | 1        |          |\n| 16   | 软件工程-面向对象和传统的方法第八版 | Stephen R. Schach                  | 1        |          |\n| 17   | **分布式系统原理与范型 第二版**     | Abdrew S. Tanenbaum                | 4        |          |\n| 18   | 多处理器编程的艺术 修订版           | Nir Shavit                         | 2        |          |\n| 19   | 数据结构 Java版第四版               | 叶核亚                             | 4        |          |\n| 20   | 数据结构与算法                      | 张铭                               | 0        |          |\n| 21   | 算法设计与分析 第四版               | 王晓东                             | 1        |          |\n| 22   | 计算机组成与设计                    | David A. Patterson等               | 0        |          |\n| 23   | 操作系统-精髓与设计原理             | William Stallings                  | 0        |          |\n| 24   | 计算机程序的构造和解释              | Harold Abelson                     | 0        |          |\n| 25   | 编译原理第二版                      | Alfred V. Aho                      | 1        |          |\n| 26   | 分布式系统概念与设计                | George Coulouris                   | 1        |          |\n| 27   | 数据结构与算法 Java语言描述         | Mark Allen Weiss                   | 1        |          |\n| 28   | 设计原本                            | Frederick P. Brooks                | 4        |          |\n| 29   | 数据库系统公司概念 第六版           | Abraham Silberschazta              | 1        |          |\n| 30   | 深入理解计算机系统                  | Randal Bryant                      | 2        |          |\n| 31   | 程序设计语言概念-第九版             | Robert W.Sebesta                   | 1        |          |\n| 32   | 云计算与分布式系统                  | Kai Hwang等                        | 1        |          |\n| 33   | 算法心得（第二版）                  | Henry.S Warren                     | 0        |          |\n| 34   | 算法设计指南(第二版)                | Steven S.Skiena                    | 0        |          |\n| 35   | 分布式数据系统原理(第三版)          | M.Tamer Ozsu                       | 0        |          |\n| 36   | 计算机网络 系统方法 第五版          | Larry L. Peterson / Bruce S. Davie | 0        |          |\n| 37   | 计算之魂                            | 吴军                               | 0        |          |\n\n\n\n## 语言(61)\n\n| 编号 | 书名                                   | 作者                          | 阅读情况 | 读书笔记 |\n| ---- | -------------------------------------- | ----------------------------- | -------- | -------- |\n| 1    | Beginnig Java Object从概念到代码第二版 | Jacquie Barker                | 0        |          |\n| 2    | 深入理解java虚拟机第二版               | Bill Venners                  | 1        |          |\n| 3    | Java脚本编程                           | Dejan Bosanac                 | 0        |          |\n| 4    | 七周七语言                             | Bruce Tate                    | 1        |          |\n| 5    | Scala编程第三版                        | Martin Odersky                | 1        |          |\n| 6    | Perl语言入门                           | Pandal L. Schwartz            | 2        |          |\n| 7    | 编程语言实现模式                       | Terence Parr                  | 1        |          |\n| 8    | Practical Java                         | Peter Haggar                  | 2        |          |\n| 9    | 分布式Java应用基础与实践               | 林昊                          | 4        |          |\n| 10   | 深入浅出NodeJS                         | 朴灵                          | 1        |          |\n| 11   | 七周七并发                             | Paul Butcher                  | 1        |          |\n| 12   | Java加密与解密的艺术 第二版            | 梁栋                          | 2        |          |\n| 13   | Living Clojure                         | Carin Meier                   | 0        |          |\n| 14   | 领域特定语言                           | Martin Fowler                 | 1        |          |\n| 15   | 精通正则表达式                         | Jeffrey Friedl                | 1        |          |\n| 16   | ANTLR4权威指南                         | Terence Parr                  | 1        |          |\n| 17   | Java并发编程从入门到精通               | 张振华                        | 4        |          |\n| 18   | Go程序设计语言 英文版                  | Alan A. Donovan               | 3        |          |\n| 19   | Lua设计与实现                          | codedump                      | 3        |          |\n| 20   | **Effective Java 第二版**              | Joshua Bloch                  | 5        |          |\n| 21   | **Effective Java 第三版**              | Joshua Bloch                  | 5        |          |\n| 22   | Java并发编程的艺术                     | 方腾飞                        | 3        |          |\n| 23   | 虚拟机设计与实现-以JVM为例             | 李晓峰                        | 0        |          |\n| 24   | Java多线程编程实战指南-设计模式-第二版 | 黄文海                        | 1        |          |\n| 25   | Java并发实现原理-JDK源码剖析           | 余春龙                        | 0        |          |\n| 26   | **Java并发编程实战**                   | Brian Goetz                   | 5        |          |\n| 27   | **深入理解Java虚拟机第二版**           | 周志明                        | 5        |          |\n| 28   | **深入理解Java虚拟机第三版**           | 周志明                        | 1        |          |\n| 29   | Java并发设计模式                       | Doug Lea                      | 2        |          |\n| 30   | 实战Java高并发程序设计                 | 葛一鸣                        | 3        |          |\n| 31   | 精通Lambda表达式                       | Maurice Naftalin              | 3        |          |\n| 32   | Java编程思想第四版                     | Bruce Eckel                   | 4        |          |\n| 33   | 函数式编程思维                         | Neal Ford                     | 3        |          |\n| 34   | Java解惑                               | Joshua Bloch                  | 2        |          |\n| 35   | Java性能优化权威指南                   | Charlie Hunt                  | 2        |          |\n| 36   | Java技术手册                           | Benjamin J. Evans             | 2        |          |\n| 37   | Java虚拟机规范（JavaSE8）              | Tim Lindholm等                | 1        |          |\n| 38   | Java性能权威指南                       | Scott Oaks                    | 2        |          |\n| 39   | Java虚拟机并发编程                     | Venkat Subramaniam            | 1        |          |\n| 40   | Java编程方法论-响应式rxjava            | 知秋                          | 1        |          |\n| 41   | Java编程方法论-spring-reactor          | 知秋                          | 1        |          |\n| 42   | Spring响应式编程                       |                               | 2        |          |\n| 43   | RxJava反应式编程                       | 张卫滨翻译                    | 1        |          |\n| 44   | Java8函数式编程                        | Richard Warbuton              | 2        |          |\n| 45   | Rxjava2.x实战                          | 沈哲                          | 4        |          |\n| 46   | Java9模块化开发：核心原则与实践        | Sander Mark                   | 0        |          |\n| 47   | ECMAScript 2018快速入门                | 黄灯桥                        | 0        |          |\n| 48   | Java网络编程                           | Elliotte Rusty Harold)]       | 0        |          |\n| 49   | Java程序性能优化                       | 葛一鸣                        | 0        |          |\n| 50   | Go语言高级编程                         | 柴树杉                        | 0        |          |\n| 51   | Go语言底层原理剖析                     | 郑建勋                        | 0        |          |\n| 52   | 深入学习Go语言                         | 李晓钧                        | 0        |          |\n| 53   | C语言程序设计-现代方法                 | K.N.King                      | 0        |          |\n| 54   | Go程序设计语言                         | Alan Donovan                  | 0        |          |\n| 55   | Rust权威指南                           | Steve Klabnik / Carol Nichols | 0        |          |\n| 56   | C++ Primer 中文版（第五版）            | Stanley B. Lippman            | 0        |          |\n| 57   | C++ Primer 习题集                      | Stanley B. Lippman            | 0        |          |\n| 58   | latex入门                              | 刘海洋                        | 0        |          |\n| 59   | Koltin实战                             | Dmitry Jemerov                | 0        |          |\n| 60   | Grovvy程序设计                         | Venkat Subramaniam            | 0        |          |\n| 61   | **Effective Java 第三版英文版**        | Joshua Bloch                  | 0        |          |\n\n\n\n## 数据库(47)\n\n| 编号 | 书名                                          | 作者                                                         | 阅读情况 | 读书笔记 |\n| ---- | --------------------------------------------- | ------------------------------------------------------------ | -------- | -------- |\n| 1    | 高性能的MySQL第三版                           | Perter Zaitsev等                                             | 3        |          |\n| 2    | 高可用的MySQL第二版                           | Charles Bell                                                 | 1        |          |\n| 3    | 深入理解MySQL核心技术                         | Sasha Pachev                                                 | 2        |          |\n| 4    | HBase权威指南                                 | Lars George                                                  | 0        |          |\n| 5    | 海量数据库解决方案                            | 韩.李华植                                                    | 0        |          |\n| 6    | 数据库事务处理的艺术                          | 李海翔                                                       | 1        |          |\n| 7    | Effective MySQL之深入解析复制技术             | Ronald Bradford                                              | 2        |          |\n| 8    | Effective MySQL之SQL语句最优化                | Ronald Bradford                                              | 4        |          |\n| 9    | MySQL技术内幕：InnoDB存储引擎                 | 姜承尧                                                       | 4        |          |\n| 10   | 数据库系统内幕                                | Alex Petrov                                                  | 0        |          |\n| 11   | 数据密集型应用系统设计                        | Martin Kleppmann                                             | 3        |          |\n| 12   | NoSQL精粹                                     | Martin Flower                                                | 3        |          |\n| 13   | 数据库索引设计与优化                          | Michael Leach等                                              | 1        |          |\n| 14   | Cassandra权威指南第二版                       | Jeff Carpenter                                               | 2        |          |\n| 15   | Greenplum:从大数据战略到实现                  | 冯雷                                                         | 3        |          |\n| 16   | Clickhouse原理解析与应用实践                  | 朱凯                                                         | 0        |          |\n| 17   | MySQL技术内幕：SQL编程                        | 姜承尧                                                       | 2        |          |\n| 18   | Druid实时大数据分析                           |                                                              |          |          |\n| 19   | 图数据库                                      | Ian Robinson                                                 | 0        |          |\n| 20   | 企业级大数据平台构建：架构与实现              | 朱凯                                                         | 0        |          |\n| 21   | Apache Kylin权威指南                          | Apache Kylin核心团队                                         | 0        |          |\n| 22   | 数据仓储-第四版                               | Inmon W.H                                                    | 0        |          |\n| 23   | 大数据平台基础架构指南                        | 刘旭辉                                                       | 0        |          |\n| 24   | MySQL管理之道（第二版）性能调优，高可用与监控 | 贺春旸                                                       | 0        |          |\n| 25   | Hikaricp数据库连接池实战                      | 朱政科                                                       | 0        |          |\n| 26   | 精通LevelDB                                   | 廖环宇                                                       | 0        |          |\n| 27   | 数据库重构                                    | Scott W. Ambler                                              | 0        |          |\n| 28   | MySQL是怎样运行的？                           | 小孩子4919                                                   | 0        |          |\n| 29   | 解读NoSQL                                     | Dan McCreary                                                 | 0        |          |\n| 30   | 大数据挑战与NoSQL数据技术                     | 陆嘉恒                                                       | 0        |          |\n| 31   | 分布式数据库原理 架构与实践                   | 李海翔                                                       | 0        |          |\n| 32   | 分布式数据库系统原理 第三版                   | [M. Tamer Özsu](https://cs.uwaterloo.ca/~tozsu/) [Patrick Valduriez](http://www-sop.inria.fr/members/Patrick.Valduriez/) | 0        |          |\n| 33   | 七周七数据库                                  | Eric Redmond                                                 | 0        |          |\n| 34   | 对象存储实战指南                              | 罗庆超                                                       | 0        |          |\n| 35   | 数据分析之图算法：基于spark和neo4j            | Mark Needham                                                 | 0        |          |\n| 36   | 分布式对象存储 原理 架构以及Go语言实现        | 胡世杰                                                       | 0        |          |\n| 37   | 云数据库架构                                  | 朱明                                                         | 0        |          |\n| 38   | 大数据日知录                                  | 张俊林                                                       | 0        |          |\n| 39   | 云原生数据库 原理与最佳实践                   | 阿里巴巴                                                     | 0        |          |\n| 40   | postgresql指南                                | 【日】铃木启修                                               | 0        |          |\n| 41   | 数据库系统实现                                | Hector Garcia-Molina                                         | 0        |          |\n| 42   | Design Data Intensive Application             | Martin Kleppmann                                             | 0        |          |\n| 43   | 分布式数据库系统：大数据时代新型数据库技术    |                                                              | 0        |          |\n| 44   | 分布式 云计算 大数据                          | 林伟伟                                                       | 0        |          |\n| 45   | 寻路大数据                                    | Michael Manoochehri                                          | 0        |          |\n| 46   | 大数据技术与应用：数据密集型计算和模型        |                                                              | 0        |          |\n| 47   | 数据库系统，设计 实现与管理 基础篇            |                                                              |          |          |\n\n\n\n\n\n## 分布式与中间件(110)\n\n| 编号 | 书名                                                         | 作者                                       | 阅读情况 | 读书笔记 |\n| ---- | ------------------------------------------------------------ | ------------------------------------------ | -------- | -------- |\n| 1    | Rabbitmq实战指南                                             | 朱忠华                                     | 2        |          |\n| 2    | Lucene实战第二版                                             | Michael McCandless                         | 0        |          |\n| 3    | Docker实战                                                   | Jeff Nickoloff                             | 3        |          |\n| 4    | 深入剖析Nginx                                                | 高群凯                                     | 1        |          |\n| 5    | Http权威指南                                                 | David Gourley等                            | 3        |          |\n| 6    | Http/2基础教程                                               | Stephen Ludin                              | 2        |          |\n| 7    | Docker进阶与实战                                             | 华为                                       | 1        |          |\n| 8    | Etcd技术内幕                                                 | 百丽燊**shēn**                             | 0        |          |\n| 9    | 分布式数据库架构基于MyCat中间件                              | 周继锋等                                   | 1        |          |\n| 10   | Web容量规划的艺术                                            | John Allspaw                               | 1        |          |\n| 11   | Mongodb实战第一版                                            | Kyle Banker                                | 3        |          |\n| 12   | 从Paxos到Zookeeper                                           | 倪超                                       | 2        |          |\n| 13   | Rabbitmq实战                                                 | Alvaro Videla                              | 3        |          |\n| 14   | Netty实战                                                    | Morman Maurer                              | 2        |          |\n| 15   | Kafka权威指南                                                | Neha Narkhede                              | 0        |          |\n| 16   | Elsaticsearch服务器开发第二版                                | Rafa Kuc                                   | 2        |          |\n| 17   | 分布式服务框架原理与实践                                     | 李林锋                                     | 2        |          |\n| 18   | 大型网站系统与Java中间件实践                                 | 曾宪杰                                     | 4        |          |\n| 19   | Kubernetes in Action                                         | Marko Luksa                                | 3        |          |\n| 20   | Java RESTful Web Service实战第二版                           | 韩陆                                       | 2        |          |\n| 21   | Zookeeper 分布式过程协同技术详解                             | Flavio Junqueira                           | 2        |          |\n| 22   | 深入分析Java Web技术内幕 修订版                              | 许令波                                     | 4        |          |\n| 23   | Redis实战                                                    | Josiah L. Carlson                          | 4        |          |\n| 24   | Redis设计与实现                                              | 黄健宏                                     | 4        |          |\n| 25   | 大规模分布式系统架构与设计实战                               | 彭渊                                       | 0        |          |\n| 26   | 大规模分布式存储系统原理解析和架构实战                       | 杨传辉                                     | 1        |          |\n| 27   | 分布式消息中间件实践                                         | 倪伟                                       | 2        |          |\n| 28   | 深入分布式缓存-从原理到实践                                  | 于君泽等                                   | 3        |          |\n| 29   | 分布式系统应用设计                                           | Brendan Burns                              | 0        |          |\n| 30   | 企业集成模式-设计构建及部署消息传递解决方案                  | Gregor Hohpe                               | 1        |          |\n| 31   | NoSQL数据库技术实战                                          | 皮雄军                                     | 0        |          |\n| 32   | 反应式设计模式                                               | 何品等翻译                                 | 0        |          |\n| 33   | Redis5设计与源码分析                                         | 陈雷                                       | 0        |          |\n| 34   | Redis深度历险                                                | 钱文品                                     |          |          |\n| 35   | Akka入门和实践                                               | Jason Goodwin                              | 0        |          |\n| 36   | Akka实战：快速构建高可用分布式应用                           | 杜云飞                                     | 0        |          |\n| 37   | 响应式架构消息模式Actor实现与Scala应用集成                   | Vaughn Vernon                              |          |          |\n| 38   | Apache Kafka实战                                             | 胡夕                                       | 0        |          |\n| 39   | 深入理解Apache kafka核心设计与实践原理                       | 朱忠华                                     | 0        |          |\n| 40   | Apache kafka源码剖析                                         | 徐郡明                                     | 0        |          |\n| 41   | 实战Gradle                                                   | Benjamin Muschko                           | 0        |          |\n| 42   | Elasticssearch源码解析与优化实战                             | 张超                                       | 0        |          |\n| 43   | 深入理解Elasticsearch第三版                                  | 波哈维                                     | 0        |          |\n| 44   | Elasticssearch实战                                           | Radu Gheorghe                              | 0        |          |\n| 45   | 离线和实时大数据开发实战                                     | 朱松岭                                     | 0        |          |\n| 46   | Springboot解密                                               | 王福强                                     | 0        |          |\n| 47   | Hbase实战                                                    | Nick Dimiduk                               | 0        |          |\n| 48   | 尽在双十一                                                   | 双十一团队                                 | 0        |          |\n| 49   | 大型系统应用架构实战部署，容灾性能优化                       | 李彦超                                     | 0        |          |\n| 50   | Storm分布式实时计算模式                                      | P.Taylor Goetz                             | 0        |          |\n| 51   | Spark核心技术与高级应用                                      | 于俊                                       | 0        |          |\n| 52   | Hadoop技术内幕                                               | 董西成                                     | 0        |          |\n| 53   | RocketMq技术内幕                                             | 丁威                                       | 0        |          |\n| 54   | 大数据之路阿里巴巴大数据实践                                 | 阿里巴巴数据技术及产品部                   | 0        |          |\n| 55   | 大数据技术体系详解 原理架构与实践                            | 董西成                                     | 0        |          |\n| 56   | 深度剖析HadoopHDFS                                           | 林意群                                     | 0        |          |\n| 57   | 数据仓储工具箱：维度建模指南                                 | Ralph Kimball                              | 0        |          |\n| 58   | 深入理解Flink：实时大数据处理实践                            | 余海峰                                     | 0        |          |\n| 59   | 分布式实时处理系统：原理，架构与实现                         | 卢誉声                                     | 0        |          |\n| 60   | 分布式一致性算法开发实战                                     | 赵辰                                       | 0        |          |\n| 61   | KafkaStream实战                                              | William Bejeck                             | 0        |          |\n| 62   | akka应用模式：分布式应用程序设计实践指南                     | Michael Nash                               | 1        |          |\n| 63   | flink基础教程                                                | Tzoumas                                    | 0        |          |\n| 64   | akka实战（akka in action）                                   |                                            | 0        |          |\n| 65   | Hadoop技术内幕：深入解析YARN架构设计与实现原理               | 董西成                                     | 0        |          |\n| 66   | Hadoop技术内幕：深入解析Hadoop Common和HDFS架构设计ui实现原理 | 蔡斌                                       |          |          |\n| 67   | 大数据基础编程：实践和案例教程-第二版                        | 林子雨                                     | 0        |          |\n| 68   | 大数据实训案例：电信用户行为分析                             | 林子雨                                     | 0        |          |\n| 69   | 大数据实训案例：电影推荐系统Scala版                          | 林子雨                                     | 0        |          |\n| 70   | 疯狂VirtualBox实战讲学录                                     | 小耗子                                     | 0        |          |\n| 71   | 走进搜索引擎（第二版）                                       | 潘学峰                                     | 0        |          |\n| 72   | gRPC与云原生应用开发 以Go和Java为例                          | Kasun Indrasiri                            | 4        |          |\n| 73   | 深入理解RPC框架原理与实现                                    | 华钟明                                     | 0        |          |\n| 74   | 分布式事务之Seata                                            | 姜宇                                       | 0        |          |\n| 75   | 分布式缓存 原理架构及Go语言实现                              | 胡世杰                                     | 0        |          |\n| 76   | 深入理解分布式事务：原理与实践                               | 冰河                                       | 0        |          |\n| 77   | 分布式系统与一致性                                           | 陈东明                                     | 0        |          |\n| 78   | 分布式系统设计实践                                           | 李庆旭                                     | 0        |          |\n| 79   | 日志管理与分析权威指南                                       | Anton A. Chuvakin                          | 0        |          |\n| 80   | 搜索引擎：信息检索实践                                       | W.Bruce Croft                              | 0        |          |\n| 81   | 搜索引擎-原理技术与系统（第二版）                            | 李晓明                                     | 0        |          |\n| 82   | 自制搜索引擎                                                 | [日]山田浩之                               | 0        |          |\n| 83   | 这就是搜索引擎：核心技术详解                                 | 张俊林                                     | 0        |          |\n| 84   | 解密搜索引擎技术实战 : Lucene&Java精华版（第3版）            | 罗刚                                       | 0        |          |\n| 85   | 信息检索导论（修订版）                                       | Prabhakar Raghavan                         | 0        |          |\n| 86   | 自己动手写Java虚拟机                                         | 张秀宏                                     | 0        |          |\n| 87   | 深入理解分布式系统                                           | 唐伟志                                     | 0        |          |\n| 88   | HBase应用架构                                                | Jean-Marc Spaggiari                        | 0        |          |\n| 89   | 深入解析apache pulsar                                        | 林琳                                       | 0        |          |\n| 90   | 深入集群-大型数据中心资源调度与管理                          | 李雨前                                     | 0        |          |\n| 91   | ceph企业级分布式存储 原理与工程实践                          | 龚向宇                                     | 0        |          |\n| 92   | Linux开源网络全栈详解                                        |                                            | 0        |          |\n| 93   | 分布式操作系统原理与实践                                     | Doreen L. Galli                            | 0        |          |\n| 94   | NoSQL权威指南                                                | [美] 乔·塞科                               | 0        |          |\n| 95   | Ceph分布式存储学习指南                                       | [(芬兰)卡伦·辛格                           | 0        |          |\n| 96   | 大数据系统构建：可扩展实时数据系统构建原理与最佳实践         | Nathan Marz                                | 0        |          |\n| 97   | 流式架构 kafka和mapr streams数据流处理                       | Ted Dunning                                | 0        |          |\n| 98   | 流式系统 Streaming System                                    | Tyler Akidau / Slava Chernyak / Reuven Lax | 0        |          |\n| 99   | Hadoop应用架构                                               | Mark Grover                                | 0        |          |\n| 100  | Hadoop权威指南 第四版                                        | Tom white                                  | 0        |          |\n| 101  | 基于Apache Flink的流处理： 流式应用基础、实现及操作          |                                            | 0        |          |\n| 102  | Spark权威指南                                                | Bill Chambers                              | 0        |          |\n| 103  | 数据中台：基于Google Facebook和微博实践                      | 詹盈                                       | 0        |          |\n| 104  | Hive编程指南                                                 | Edward Capriolo                            | 0        |          |\n| 105  | MapReduce设计模式                                            | Donald Miner                               | 0        |          |\n| 106  | Spark快速大数据分析                                          | Holden Karau                               | 0        |          |\n| 107  | OpenTSDB技术内幕                                             | 百里燊                                     | 0        |          |\n| 108  | NoSQL实践指南                                                | Dan Sullivan                               | 0        |          |\n| 109  | Mesos实战                                                    | Roger Ignazio                              | 0        |          |\n| 110  | MongoDB权威指南 第二版                                       | Kristina Chodorow                          | 0        |          |\n\n\n\n\n\n\n\n## 框架(21)\n\n| 编号 | 书名                                               | 作者              | 阅读情况 | 读书笔记 |\n| ---- | -------------------------------------------------- | ----------------- | -------- | -------- |\n| 1    | 重新定义SpringCloud实战                            | 许进等            | 1        |          |\n| 2    | Spring实现第四版                                   | Craig Walls       | 2        |          |\n| 3    | J2EE核心模式第二版                                 | Deepak Alur       | 2        |          |\n| 4    | 精通Spring4.0企业应用开发实战                      | 陈雄华等          | 3        |          |\n| 5    | Java WebSocket编程                                 | Danny Coward      | 2        |          |\n| 6    | Spring框架高级编程                                 | Rod Johnson等     | 1        |          |\n| 7    | Mybatis技术内幕                                    | 徐郡明            | 1        |          |\n| 8    | Spring技术内幕第二版                               | 计文柯            | 1        |          |\n| 9    | Spring源码深度解析第二版                           | 郝佳              | 1        |          |\n| 10   | 深入理解SpringMVC源代码                            | 王耀              | 0        |          |\n| 11   | **Expert One on one J2EE Development Without EJB** | Rod Johnson等     | 3        |          |\n| 12   | **Expert One on one J2EE Design And Implement**    | Rod Johnson       | 2        |          |\n| 13   | 软件框架设计的艺术                                 | Jaroslav Tulach   | 2        |          |\n| 14   | .NET设计规范，约定，惯用法与模式                   | Krzysztof Cwalina | 0        |          |\n| 15   | iBatis实战                                         | Clinton Begin     | 0        |          |\n| 16   | GraphQL实战写给全栈工程师们                        | 王北南            | 0        |          |\n| 17   | SpringData实战                                     |                   | 0        |          |\n| 18   | 深入浅出MyBatis技术原理与实战                      | 杨开振            | 0        |          |\n| 19   | Apache ShardingSphere实战                          | 郑天民            | 0        |          |\n| 20   | Webassembly实战                                    | C. Gerard Gallant | 0        |          |\n| 21   | 反应式应用开发                                     | Duncan DeVore     | 0        |          |\n| 22   |                                                    |                   |          |          |\n\n\n\n## 架构(59)\n\n| 编号 | 书名                                      | 作者                | 阅读情况 | 读书笔记                                                     |\n| ---- | :---------------------------------------- | ------------------- | -------- | ------------------------------------------------------------ |\n| 1    | 从0开始学架构                             | 李运华              | 4        |                                                              |\n| 2    | 大型网站技术架构-核心原理与案例分析       | 李智慧              | 2        |                                                              |\n| 3    | 软考：软件设计师教程                      | 诸华                | 0        |                                                              |\n| 4    | 大数据技术原理与应用第二版                | 林子雨              | 1        |                                                              |\n| 5    | 企业IT架构转型之道                        | 钟华                | 3        |                                                              |\n| 6    | Kubernates权威指南纪念版                  | 垄正等              | 1        |                                                              |\n| 7    | 构建实时机器学习系统                      | 彭江森              | 1        |                                                              |\n| 8    | 云系统管理-大规模分布式系统设计与运营     | Thomas A.Limoncelli | 2        |                                                              |\n| 9    | 恰如其分的软件架构                        | George Fairbanks    | 1        |                                                              |\n| 10   | 软件架构设计                              | 温昱                | 4        |                                                              |\n| 11   | 软件架构设计-第二版                       | 温昱                | 3        |                                                              |\n| 12   | 进化：运维技术变革与实践探索              | 赵成                | 2        |                                                              |\n| 13   | 企业应用架构模式                          | Martin Flower       | 2        |                                                              |\n| 14   | Paas程序设计                              | Lucas Carlson       | 4        |                                                              |\n| 15   | 让云落地 云计算服务模式                   | Michael Kavis       | 4        |                                                              |\n| 16   | 架构之美                                  | Diomidis Spinellis  | 1        |                                                              |\n| 17   | 软件构架编档                              | Paul Clements等     | 0        |                                                              |\n| 18   | IT架构思维                                | Peter Beijer等      | 0        |                                                              |\n| 19   | 架构整洁之道                              | Robert C.Martin     | 4        |                                                              |\n| 20   | 云计算架构设计模式                        | Alex Homer等        | 3        |                                                              |\n| 21   | 简单之美 软件开发实践者的思考             | 倪健                | 4        |                                                              |\n| 22   | 架构即未来                                | Martin L.Abbott     | 1        |                                                              |\n| 23   | 高扩展性网站的50条原则                    | Martin L.Abbott     | 1        |                                                              |\n| 24   | 持续集成-软件质量改进的风险降低之道       | Paul M. Duvall      | 2        | [notes](https://xiaozhiliaoo.github.io/2020/11/28/CI-Book-Reading/) |\n| 25   | 持续交付-发布可靠软件的系统方法           | Jez Humble          | 1        |                                                              |\n| 26   | 演进式架构                                | Neal Ford           | 0        |                                                              |\n| 27   | Tomcat架构解析                            | 刘光瑞              | 1        |                                                              |\n| 28   | 白帽子讲Web安全                           | 吴翰清              | 1        |                                                              |\n| 29   | 深入浅出大型网站架构设计                  | 李力非              | 1        |                                                              |\n| 30   | 程序员必读软件架构                        | Simon Brown         | 0        |                                                              |\n| 31   | 代码之美                                  | Oram Wilson         | 0        |                                                              |\n| 32   | Prometheus云原生监控                      | 朱政科-阿里巴巴     | 1        |                                                              |\n| 33   | Apache SkyWalking实战                     | 吴晟                | 4        |                                                              |\n| 34   | Cloud Foundry：从数字化战略到实现         | 冯雷                | 1        |                                                              |\n| 35   | 逆流而上：阿里巴巴技术成长之路            | 阿里巴巴成长编委会  | 1        |                                                              |\n| 36   | 淘宝技术这十年                            | 子柳                | 0        |                                                              |\n| 37   | 架构解密：从分布式到微服务                | leader Us           | 1        |                                                              |\n| 38   | 亿级流量网站架构核心技术                  | 张开涛              | 0        |                                                              |\n| 39   | 分布式服务架构：原理，设计与实战          | 李艳鹏              | 0        |                                                              |\n| 40   | 微服务治理 体系 结构及实践                | 李鑫                | 0        |                                                              |\n| 41   | 微服务之道:度量驱动开发                   | 范亚敏              | 0        |                                                              |\n| 42   | 数字化转型的道与术                        | 钟华                | 0        |                                                              |\n| 43   | 业务架构  业务架构，应用架构，数据架构    | 温昱                | 4        |                                                              |\n| 44   | 大型网站性能优化实战                      | 周涛明              | 0        |                                                              |\n| 45   | 大型网站技术架构演进与性能优化            | 许令波              | 0        |                                                              |\n| 46   | 架构修炼之道：亿级网关，平台开放          | 王新栋              | 0        |                                                              |\n| 47   | 分布式一致性算法开发实战                  | 赵辰                | 0        |                                                              |\n| 48   | 大数据技术原理与应用第三版                | 林子雨              | 0        |                                                              |\n| 49   | 代码里的世界观：通往架构师之路            | 余叶                | 0        |                                                              |\n| 50   | 软件架构                                  | 沙巴纳              | 0        |                                                              |\n| 51   | 前端工程化：体系设计与实践                | 周俊鹏              | 0        |                                                              |\n| 52   | 可伸缩架构 第二版                         | 张若飞              | 0        |                                                              |\n| 53   | 凤凰架构                                  | 周志明              | 0        |                                                              |\n| 54   | AWS云计算实战                             | 安德烈亚斯·威蒂格   | 0        |                                                              |\n| 55   | 大数据技术架构-核心原理与应用实践         | 李智慧-极客时间专栏 | 1        |                                                              |\n| 56   | 企业数字化基石-阿里巴巴云计算基础设施实践 | 阿里巴巴            | 0        |                                                              |\n| 57   | 阿里云原生架构实践                        | 阿里巴巴            | 0        |                                                              |\n| 58   | 云原生架构：从技术演进到最佳实践          | 贺阮云              | 0        |                                                              |\n| 59   | 分布式架构原理与实践                      | 崔浩                | 0        |                                                              |\n\n\n\n\n\n\n\n## 软件工程(71)\n\n| 编号 | 书名                                                   | 作者                                                 | 阅读情况 | 读书笔记   |\n| ---- | ------------------------------------------------------ | ---------------------------------------------------- | -------- | ---------- |\n| 1    | 超越软件架构                                           | Luke Hohmann                                         | 0        |            |\n| 2    | 重构与模式                                             | Joshua Kerievsky                                     | 0        |            |\n| 3    | Contributing To Eclipse                                | Erich Gamma&Kent Beck                                | 1        |            |\n| 4    | 软件工艺                                               | Pete McBreen                                         | 3        |            |\n| 5    | 程序员修炼之道从小工到专家                             | Andrew Hunt                                          | 2        |            |\n| 6    | **面向对象分析与设计第二版**                           | Grady Booch                                          | 2        |            |\n| 7    | **面向对象分析与设计第三版**                           | Grady Booch                                          | 1        |            |\n| 8    | 人月神话                                               | Frederick P. Brooks                                  | 4        |            |\n| 9    | 敏捷中国史话                                           | 熊节                                                 | 4        |            |\n| 10   | 软件开发本质论                                         | Ron Jeffries                                         | 2        |            |\n| 11   | 大教堂与集市                                           | Eric Raymond                                         | 4        |            |\n| 12   | 快速软件开发                                           | Steve McConnell                                      | 1        |            |\n| 13   | 程序开发心理学                                         | Gerald Weinberg                                      | 0        |            |\n| 14   | 个体软件工程                                           | Watts S. Humphrey                                    | 0        |            |\n| 15   | 走出软件工坊                                           | 阿朱                                                 | 1        |            |\n| 16   | UNIX编程艺术                                           | Eric S.Raymond                                       | 1        |            |\n| 17   | 解析极限编程-拥抱变化第一版                            | Kent Beck                                            | 3        |            |\n| 18   | 敏捷软件开发-原则，模式-实践                           | Robert C.Martin                                      | 1        |            |\n| 19   | **实现模式**                                           | Kent Beck                                            | 4        |            |\n| 20   | 面向模式的软件架构 资源管理模式                        | Michael Kircher                                      | 2        |            |\n| 21   | 编程珠玑第二版                                         | Jon Bentley                                          | 1        |            |\n| 22   | 数据库访问模式                                         | Clifton Nock                                         | 1        |            |\n| 23   | 反模式-危机中的软件，架构和项目的重构                  | William Brown                                        | 2        |            |\n| 24   | 面向对象项目的解决方案                                 | Grady Booch                                          | 2        |            |\n| 25   | 软件构架实践                                           | Len Bass                                             | 1        |            |\n| 26   | 面向模式的软件架构-模式系统第一卷                      | Frank Buschmann                                      | 3        |            |\n| 27   | 发布! 软件的设计与部署-第一版                          | Michael T. Mygard                                    | 1        |            |\n| 28   | 发布! 软件的设计与部署-第二版                          | Michael T. Mygard                                    | 0        |            |\n| 29   | 构建之法-现代软件工程0第三版                           | 邹欣                                                 | 0        |            |\n| 30   | 混沌工程Netflix系统稳定性之道                          | Casey Rosenthal等                                    | 0        |            |\n| 31   | 设计模式-可复用面向对象软件的基础                      | GOF4                                                 | 0        |            |\n| 32   | 精益软件度量                                           | 张松                                                 | 0        |            |\n| 33   | 测试驱动开发-英文版                                    | Kent Beck                                            | 2        |            |\n| 34   | Xunit测试模式                                          | Gerard Meszaros                                      | 1        |            |\n| 35   | Google软件测试之道                                     | James Whittaker                                      | 0        |            |\n| 36   | UML用户指南                                            | Grady Booch                                          | 2        |            |\n| 37   | 敏捷革命                                               | Jeff Sutherland                                      | 4        |            |\n| 38   | 看板方法-科技企业渐进变革成功之道                      | David J. Anderson                                    | 1        |            |\n| 39   | 敏捷迭代开发-管理者指南                                | Craig Larman                                         | 0        |            |\n| 40   | **UML和模式应用第三版**                                | Craig Larman                                         | 3        |            |\n| 41   | 面向对象编程导论 第三版                                | Timothy A. Budd                                      | 0        |            |\n| 42   | 编写有效用例                                           | Alistair Cockburn                                    | 1        |            |\n| 43   | 代码大全第二版                                         | Steve McConnell                                      | 0        |            |\n| 44   | 统一软件开发过程                                       | Ivar Jacobson                                        | 1        |            |\n| 45   | 用户故事与敏捷方法                                     | Mike Cohn                                            | 1        |            |\n| 46   | 面向快速交付的软件开发                                 | 翟宏宝                                               | 0        |            |\n| 47   | 有效的单元测试                                         | Lasse Koskela                                        | 0        | 2020-12-15 |\n| 48   | 构建高质量软件-程序开发人员测试指南                    | Alexander Tarlinder                                  | 0        | 2020-12-22 |\n| 49   | 程序员应该知道的97件事                                 | Kevlin Henney                                        | 0        | 2020-12-22 |\n| 50   | 软件架构师应该知道的97件事                             | Richard Monson-Haefel                                | 0        | 2020-12-22 |\n| 51   | Cucumber行为驱动开发指南                               | Matt Waynne等                                        | 0        | 2020-12-22 |\n| 52   | 实例化需求                                             | Gojko Adzic                                          | 0        | 2020-12-21 |\n| 53   | 驯服烂代码                                             | 伍斌                                                 | 0        | 2020-12-28 |\n| 54   | 软件工程通史1930-2019                                  | Capers Jones                                         | 0        |            |\n| 55   | 人件(原书第三版)                                       | Tom DeMarco Timothy Lister                           | 0        | 2021-05-02 |\n| 56   | 软件困局：为什么聪明的程序员写出糟糕的代码             | Adam Barr                                            | 0        |            |\n| 57   | 项目百态：深入理解软件项目行为模式                     | 金明翻译                                             | 0        |            |\n| 58   | 硝烟中的Scrum和XP-我们如何实施Scrum                    | Henrik Kniberg                                       | 0        |            |\n| 59   | 敏捷整洁之道                                           | Robert C. Martin                                     | 0        |            |\n| 60   | 精益软件开发管理之道                                   | Mary  Poppendieck                                    | 0        |            |\n| 61   | 敏捷软件开发工具-精益开发方法                          | Mary  Poppendieck                                    | 0        |            |\n| 62   | 活文档 与代码共同演进                                  | Cyrille Matraire                                     | 0        |            |\n| 63   | 凤凰项目 一个IT运维的传奇故事-修订版                   | Gene Kim                                             | 0        |            |\n| 64   | 产品研发管理：构建世界一流的产品研发管理体系（第二版） | 周辉                                                 | 0        |            |\n| 65   | 敏捷技能修炼：敏捷软件开发与设计的最佳实践             | Alan Shalloway / Scott Bain / Ken Pugh / Amir Kolsky | 0        |            |\n| 66   | Scrum敏捷软件开发                                      | Mike Cohn                                            | 0        |            |\n| 67   | 敏捷软件开发时间：估算与计划                           | Mike Cohn                                            | 0        |            |\n| 68   | SCRUM敏捷项目管理                                      | Ken Schwaber                                         | 0        |            |\n| 69   | 这就是软件工程师                                       | 丁丛丛 靳冉                                          | 0        |            |\n| 70   | 30天软件开发：告别瀑布拥抱敏捷                         | Ken Schwaber,Jeff Sutherland                         | 0        |            |\n| 71   | Vim实用技巧 第二版                                     | Drew Neil                                            | 0        |            |\n\n\n\n## 设计(27)\n\n| 编号 | 书名                                       | 作者                     | 阅读情况 | 读书笔记   |\n| ---- | ------------------------------------------ | ------------------------ | -------- | ---------- |\n| 1    | **重构-第一版**                            | Martin Flower            | 4        |            |\n| 2    | 微服务设计                                 | Sam Newman               | 3        |            |\n| 3    | UML和OOAD快速入门                          | 邱郁惠                   | 2        |            |\n| 4    | 软件设计之道：那些值得借鉴的实践案例       | 麦思博                   | 0        |            |\n| 5    | 分析模式                                   | Martin Fowler            | 0        |            |\n| 6    | 生产微服务                                 | Susan J.Fowler           | 0        |            |\n| 7    | 修改代码的艺术-构建易维护代码的9条最佳实践 | David Scott Bernstein    | 3        |            |\n| 8    | 修改代码的艺术                             | Michael Feathers         | 1        |            |\n| 9    | 遗留系统重建实战                           | Chris Birchall           | 2        |            |\n| 10   | Junit实战第二版                            | Peter Tahchiev           | 3        |            |\n| 11   | 软件设计哲学                               | John Ousterhout          | 4        |            |\n| 12   | 领域驱动设计全面解析与实战                 | 彭晨阳                   | 1        |            |\n| 13   | 软件工程-实践者的研究方法-第八版           | Roger S.Pressman         | 0        |            |\n| 14   | 实现领域驱动设计                           | Vaughn Vernon            | 2        |            |\n| 15   | 编程格调                                   | Brian W.Kernighan        | 0        |            |\n| 16   | 对象设计：角色，责任和协作                 | Rebecca Wirfs-Brock      | 1        |            |\n| 17   | **OOD启思录**                              | Arthur J. Riel           | 4        |            |\n| 18   | 软件设计重构                               | Tushar Sharma等          | 4        |            |\n| 19   | 领域驱动设计精粹                           | Vaughn Vernon            | 3        |            |\n| 20   | 设计模式的艺术                             | 刘伟                     | 4        |            |\n| 21   | 代码精进之路-从码农到工匠                  | 张建飞                   | 4        |            |\n| 22   | 领域驱动设计                               | Eric Evans               | 2        |            |\n| 23   | 特征驱动开发方法原理与实践                 | Stephen R. Palmer        | 0        |            |\n| 24   | 浮现式设计：专业软件开发的演进本质         | Scott L.Bain             | 0        |            |\n| 25   | 微服务设计模式和最佳实践                   | Vinicius Feitosa Pacheco | 0        | 2020-12-22 |\n| 26   | 微服务架构设计模式                         | Chris Richardson         | 0        |            |\n| 27   | 软件预构的艺术                             | Ken Pugh                 | 0        |            |\n\n\n\n## 考试与考证(16)\n\n| 编号 | 书名                                  | 作者                             | 阅读情况 |\n| ---- | ------------------------------------- | -------------------------------- | -------- |\n| 1    | 软考:系统架构设计师 2009-2016试题分析 | 全国计算机专业技术资格考试办公室 | 0        |\n| 2    | 软件体系架构：原理方法与实践          | 张友生                           | 0        |\n| 3    | 产品经理认证NPDP知识体系指南          | (美)产品开发与管理协会           | 0        |\n| 4    | 软考：信息系统项目管理师教程          | 全国计算机专业技术资格考试办公室 | 0        |\n| 5    | 软考：信息系统项目管理师考试论文执导  | 全国计算机专业技术资格考试办公室 | 0        |\n| 6    | 软考：信息系统项目管理师案例分析指南  | 全国计算机专业技术资格考试办公室 | 0        |\n| 7    | 软考:系统架构设计师 2013-2018试题分析 | 全国计算机专业技术资格考试办公室 | 0        |\n| 8    | 软考:系统架构设计师教程               | 全国计算机专业技术资格考试办公室 | 0        |\n| 9    | 软考:系统架构设计师全程指导           | 全国计算机专业技术资格考试办公室 | 0        |\n| 10   | 软考：系统架构设计师考试32小时通关    | 全国计算机专业技术资格考试办公室 | 0        |\n| 11   | 软考：系统架构设计师教程              | 希赛教育                         | 0        |\n| 12   | 项目管理知识体系指南 第六版           | [美]项目管理协会                 | 0        |\n| 13   | 敏捷实践指南                          | [美]项目管理协会                 | 0        |\n| 14   | Head First PMP 第三版                 | 格林 / 斯泰曼                    | 0        |\n| 15   | 敏捷项目管理(第二版):快速交付创新产品 | Jim,Highsmith                    | 0        |\n| 16   | 汪博士解读PMP 第五版                  | 汪博士                           | 0        |\n\n## 产品(16)\n\n| 编号 | 书名                                          | 作者                      | 阅读情况 | 读书笔记 |\n| ---- | --------------------------------------------- | ------------------------- | -------- | -------- |\n| 1    | 产品设计与开发第五版                          | Karl T.Ullrich            | 0        |          |\n| 2    | 疯传                                          | Jonah Berger              | 0        |          |\n| 3    | 人人都是产品经理-第二版                       | 苏杰                      | 0        |          |\n| 4    | 你的灯还亮着吗？                              | Gerald M.Weinberg         | 4        |          |\n| 5    | 淘宝产品十年事                                | 苏杰                      | 0        |          |\n| 6    | 俞军 产品方法论                               | 俞军                      | 1        |          |\n| 7    | 支付平台架构-业务，规划，设计与实现           | 曹兵强                    | 4        |          |\n| 8    | 电商产品经理宝典                              | 刘志远                    | 3        |          |\n| 9    | 电商产品经理：基于人货场内容的产品设计攻略    | 王伟                      | 0        |          |\n| 10   | 业务中台产品搭建指南                          | 高晖                      | 0        |          |\n| 11   | 增长黑客                                      | 肖恩·埃利斯 （Sean Ellis) | 0        |          |\n| 12   | 数据产品经理修炼手册-从零基础到大数据产品实践 | 梁旭鹏                    | 0        |          |\n| 13   | 数据产品经理必须课：从零经验到令人惊艳        | 李鑫                      | 0        |          |\n| 14   | 数据驱动：从方法到实践                        | 桑文锋                    | 0        |          |\n| 15   | 支付方法论                                    | 王伟                      | 0        |          |\n| 16   | 云计算时代 本质，计算，创新，战略             | 刘黎明                    | 0        |          |\n\n\n\n## 系统(13)\n\n| 编号 | 书名                              | 作者              | 阅读情况 | 读书笔记 |\n| ---- | --------------------------------- | ----------------- | -------- | -------- |\n| 1    | Linux系统编程手册-上              | Michael Kerrisk   | 1        |          |\n| 2    | Linux系统编程手册-下              | Michael Kerrisk   | 1        |          |\n| 3    | 系统性能优化第二版                | Mike Loukides     | 0        |          |\n| 4    | 性能之巅                          | Brendan Gregg     | 2        |          |\n| 5    | Linux大棚命令百篇上：文件和文本篇 | 大棚              | 0        |          |\n| 6    | Linux大棚命令百篇下：网络和系统篇 | 大棚              | 0        |          |\n| 7    | Linux就该这么学                   | 刘遄              | 0        |          |\n| 8    | UNIX环境高级编程 第三版           | W.Richard Stevens | 0        |          |\n| 9    | Linux系统编程 第二版              | Robert Love       | 0        |          |\n| 10   | UNIX网络编程卷2：进程间通信       | W.Richard Stevens | 0        |          |\n| 11   | UNIX网络编程卷2：套接字联网API    | W.Richard Stevens | 0        |          |\n| 12   | 深入理解Linux内核 第三版          | 西斯特            | 0        |          |\n| 13   | Unix/Linux编程实践教程            | Bruce Molay       | 0        |          |\n\n\n\n## 区块链(7)\n\n| 编号 | 书名                                               | 作者         | 阅读情况 | 读书笔记 |\n| ---- | -------------------------------------------------- | ------------ | -------- | -------- |\n| 1    | 以太坊技术详解与实战                               | 闫莺等       | 0        |          |\n| 2    | EOS区块链应用开发指南                              | 家男         | 0        |          |\n| 3    | 虚拟货币革命                                       | 野口悠纪雄   | 0        |          |\n| 4    | 区块链革命：比特币底层技术如何改变货币，商业和世界 | Don Tapscott | 0        |          |\n| 5    | 区块链原理，设计与应用                             | 杨保华       | 0        |          |\n| 6    | 区块链100问                                        | 赵何娟       | 0        |          |\n| 7    | 区块链 新经济蓝图及导读                            | 梅兰妮       | 0        |          |\n\n\n\n## 其他(22)\n\n| 编号 | 书名                               | 作者                    | 阅读情况 | 读书笔记 |\n| ---- | ---------------------------------- | ----------------------- | -------- | -------- |\n| 1    | 金领简历                           | Gayle Laakmann McDowell | 3        |          |\n| 2    | IEEE计算机先驱奖(1980-2014)        | 崔林                    | 1        |          |\n| 3    | 图灵和ACM图灵奖品(1966-2011)       | 吴鹤龄                  | 1        |          |\n| 4    | 黑客与画家                         | Paul Graham             | 3        |          |\n| 5    | 延长万物之尺                       | 保罗.汉弗莱斯           | 0        |          |\n| 6    | Effective Debugging                | Diomidis Spinellis      | 1        |          |\n| 7    | 跨越鸿沟                           | Geoffrey Moore          | 2        |          |\n| 8    | 微软团队成功墨诀                   | 麦卡锡                  | 0        |          |\n| 9    | 开源软件之道                       | 蔡俊杰                  | 3        |          |\n| 10   | 计算机英语教程双色版               | 张强华                  | 0        |          |\n| 11   | 设计领导力                         | Richard Banfield        | 0        |          |\n| 12   | 开源软件与专有软件的竞争           | 王广凤                  | 1        |          |\n| 13   | 程序员代码面试指南第二版           | 左程云                  | 1        |          |\n| 14   | 剑指Offer 第二版                   | 何海涛                  | 1        |          |\n| 15   | OKR工作法-谷歌等顶级公司高绩效秘籍 | 沃特克                  | 3        |          |\n| 16   | 程序员的成长课                     | 安晓辉等                | 0        |          |\n| 17   | Java程序员面试算法宝典             | 猿媛之家                | 0        |          |\n| 18   | 程序员面试金典 第六版              | 盖尔-拉克曼             | 1        |          |\n| 19   | 开源法则                           | 何宝宏博士              | 4        |          |\n| 20   | 计算机英语 第五版                  | 刘艺                    | 0        |          |\n| 21   | 研究是一门艺术 第四版              | Wayne C. Booth          | 0        |          |\n| 22   | 程序员的英语                       | [韩]朴栽浒              | 0        |          |\n\n","updated":"2023-01-12T06:17:34.000Z","path":"reading-list/index.html","comments":1,"layout":"page","_id":"clh7s5cyk006bxt8j7o5u2kid","content":"<h1 id=\"绪论\"><a href=\"#绪论\" class=\"headerlink\" title=\"绪论\"></a>绪论</h1><p>突发奇想，想对买过技术书单进行汇总。看看自己都买过哪些书，哪些看了，哪些没看。以后买的书也会进行汇总。</p>\n<p>总结了我最喜欢的十本书，它的顺序和书可能在变，但是是对我个人启发较多的十本书。</p>\n<ol>\n<li>分布式系统原理与范型 第二版 / 分布式系统概念与设计 第五版</li>\n<li>Effective Java 第三版</li>\n<li>Java并发编程实战</li>\n<li>高性能的MySQL第三版</li>\n<li>Spring系列: Expert One on one J2EE Development Without EJB/Expert One on one J2EE Design And Implement/Spring框架高级编程</li>\n<li>面向对象分析与设计 第三版</li>\n<li>UML和模式应用 第三版</li>\n<li>设计模式-可复用面向对象软件的基础</li>\n<li>Streaming System</li>\n<li>Designing Data-Intensive Applications: The Big Ideas Behind Reliable, Scalable, and Maintainable Systems</li>\n</ol>\n<h1 id=\"读后感\"><a href=\"#读后感\" class=\"headerlink\" title=\"读后感\"></a>读后感</h1><p><a href=\"https://xiaozhiliaoo.github.io/reading-note/\" target=\"_blank\" rel=\"noopener\">读书笔记-<strong>reading note</strong></a></p>\n<h1 id=\"书单汇总-共507本\"><a href=\"#书单汇总-共507本\" class=\"headerlink\" title=\"书单汇总(共507本)\"></a>书单汇总(共507本)</h1><p>最近统计时间：2023-01-12 总数<strong>507</strong>本。增加60本。</p>\n<p>最近统计时间：2022-03-31 总数<strong>507</strong>本。增加60本。</p>\n<p>最近统计时间：2021-12-12   总数<strong>447</strong>本。增加60本。</p>\n<p>最近统计时间：2021-08-26   总数<strong>387</strong>本。增加42本。</p>\n<p>最近统计时间：2021-07-14   总数<strong>345</strong>本。  增加25本。</p>\n<p>最近统计时间：2021-05-02  总数<strong>320</strong>本。 </p>\n<p>书单会以分类展示，并且写明作者，很多书的作者非常知名，阅读情况 会包含阅读时间(严重缺失)和阅读进度，阅读进度分为6级进行打分，<strong>0</strong>  没有读过，<strong>1</strong>  阅读25%  <strong>2</strong>, 50%  <strong>3</strong>, 75%  <strong>4</strong>,100%  <strong>5</strong>  读过多次 ， 书名加粗的是个人觉得非常好的经典书，值得多次阅读。汇总不好的一点是没有时间维度，后期读书时候会在阅读情况中加上。</p>\n<h2 id=\"计算机科学-37\"><a href=\"#计算机科学-37\" class=\"headerlink\" title=\"计算机科学(37)\"></a>计算机科学(37)</h2><table>\n<thead>\n<tr>\n<th>编号</th>\n<th>书名</th>\n<th>作者</th>\n<th>阅读情况</th>\n<th>读书笔记</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>操作系统概念第九版</td>\n<td>Abraham Silberschatz</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>2</td>\n<td>程序设计语言:设计与实现第四版</td>\n<td>Terrence W. Pratt</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>3</td>\n<td>数据库系统概念第五版</td>\n<td>Abraham Silberschatz</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>4</td>\n<td>Solaris内核结构第二版</td>\n<td>Richard McDougall</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>5</td>\n<td>Linux内核设计与实现-第三版</td>\n<td>Robert Love</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>6</td>\n<td>现代操作系统 英文第四版</td>\n<td>Abdrew S. Tanenbaum</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>7</td>\n<td>现代操作系统 中文第四版</td>\n<td>Abdrew S. Tanenbaum</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>8</td>\n<td>编译原理 英文第二版</td>\n<td>Alfred V.Aho</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>9</td>\n<td>分布式计算-原理，算法与实践</td>\n<td>Ajay Kshemkalyani</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>10</td>\n<td>分布式数据库系统及其应用第三版</td>\n<td>徐俊刚</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>11</td>\n<td>计算机网络 英文第五版</td>\n<td>Abdrew S. Tanenbaum</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>12</td>\n<td>计算机组成与汇编语言原理 英文版</td>\n<td>Patricj Juola</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>13</td>\n<td>算法第四版</td>\n<td>Robert Sedgewick</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>14</td>\n<td>程序设计语言-实践之路第三版</td>\n<td>Michael L. Soctt</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>15</td>\n<td>计算机网络-第五版</td>\n<td>Abdrew S. Tanenbaum</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>16</td>\n<td>软件工程-面向对象和传统的方法第八版</td>\n<td>Stephen R. Schach</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>17</td>\n<td><strong>分布式系统原理与范型 第二版</strong></td>\n<td>Abdrew S. Tanenbaum</td>\n<td>4</td>\n<td></td>\n</tr>\n<tr>\n<td>18</td>\n<td>多处理器编程的艺术 修订版</td>\n<td>Nir Shavit</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>19</td>\n<td>数据结构 Java版第四版</td>\n<td>叶核亚</td>\n<td>4</td>\n<td></td>\n</tr>\n<tr>\n<td>20</td>\n<td>数据结构与算法</td>\n<td>张铭</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>21</td>\n<td>算法设计与分析 第四版</td>\n<td>王晓东</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>22</td>\n<td>计算机组成与设计</td>\n<td>David A. Patterson等</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>23</td>\n<td>操作系统-精髓与设计原理</td>\n<td>William Stallings</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>24</td>\n<td>计算机程序的构造和解释</td>\n<td>Harold Abelson</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>25</td>\n<td>编译原理第二版</td>\n<td>Alfred V. Aho</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>26</td>\n<td>分布式系统概念与设计</td>\n<td>George Coulouris</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>27</td>\n<td>数据结构与算法 Java语言描述</td>\n<td>Mark Allen Weiss</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>28</td>\n<td>设计原本</td>\n<td>Frederick P. Brooks</td>\n<td>4</td>\n<td></td>\n</tr>\n<tr>\n<td>29</td>\n<td>数据库系统公司概念 第六版</td>\n<td>Abraham Silberschazta</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>30</td>\n<td>深入理解计算机系统</td>\n<td>Randal Bryant</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>31</td>\n<td>程序设计语言概念-第九版</td>\n<td>Robert W.Sebesta</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>32</td>\n<td>云计算与分布式系统</td>\n<td>Kai Hwang等</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>33</td>\n<td>算法心得（第二版）</td>\n<td>Henry.S Warren</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>34</td>\n<td>算法设计指南(第二版)</td>\n<td>Steven S.Skiena</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>35</td>\n<td>分布式数据系统原理(第三版)</td>\n<td>M.Tamer Ozsu</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>36</td>\n<td>计算机网络 系统方法 第五版</td>\n<td>Larry L. Peterson / Bruce S. Davie</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>37</td>\n<td>计算之魂</td>\n<td>吴军</td>\n<td>0</td>\n<td></td>\n</tr>\n</tbody></table>\n<h2 id=\"语言-61\"><a href=\"#语言-61\" class=\"headerlink\" title=\"语言(61)\"></a>语言(61)</h2><table>\n<thead>\n<tr>\n<th>编号</th>\n<th>书名</th>\n<th>作者</th>\n<th>阅读情况</th>\n<th>读书笔记</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>Beginnig Java Object从概念到代码第二版</td>\n<td>Jacquie Barker</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>2</td>\n<td>深入理解java虚拟机第二版</td>\n<td>Bill Venners</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>3</td>\n<td>Java脚本编程</td>\n<td>Dejan Bosanac</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>4</td>\n<td>七周七语言</td>\n<td>Bruce Tate</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>5</td>\n<td>Scala编程第三版</td>\n<td>Martin Odersky</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>6</td>\n<td>Perl语言入门</td>\n<td>Pandal L. Schwartz</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>7</td>\n<td>编程语言实现模式</td>\n<td>Terence Parr</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>8</td>\n<td>Practical Java</td>\n<td>Peter Haggar</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>9</td>\n<td>分布式Java应用基础与实践</td>\n<td>林昊</td>\n<td>4</td>\n<td></td>\n</tr>\n<tr>\n<td>10</td>\n<td>深入浅出NodeJS</td>\n<td>朴灵</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>11</td>\n<td>七周七并发</td>\n<td>Paul Butcher</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>12</td>\n<td>Java加密与解密的艺术 第二版</td>\n<td>梁栋</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>13</td>\n<td>Living Clojure</td>\n<td>Carin Meier</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>14</td>\n<td>领域特定语言</td>\n<td>Martin Fowler</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>15</td>\n<td>精通正则表达式</td>\n<td>Jeffrey Friedl</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>16</td>\n<td>ANTLR4权威指南</td>\n<td>Terence Parr</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>17</td>\n<td>Java并发编程从入门到精通</td>\n<td>张振华</td>\n<td>4</td>\n<td></td>\n</tr>\n<tr>\n<td>18</td>\n<td>Go程序设计语言 英文版</td>\n<td>Alan A. Donovan</td>\n<td>3</td>\n<td></td>\n</tr>\n<tr>\n<td>19</td>\n<td>Lua设计与实现</td>\n<td>codedump</td>\n<td>3</td>\n<td></td>\n</tr>\n<tr>\n<td>20</td>\n<td><strong>Effective Java 第二版</strong></td>\n<td>Joshua Bloch</td>\n<td>5</td>\n<td></td>\n</tr>\n<tr>\n<td>21</td>\n<td><strong>Effective Java 第三版</strong></td>\n<td>Joshua Bloch</td>\n<td>5</td>\n<td></td>\n</tr>\n<tr>\n<td>22</td>\n<td>Java并发编程的艺术</td>\n<td>方腾飞</td>\n<td>3</td>\n<td></td>\n</tr>\n<tr>\n<td>23</td>\n<td>虚拟机设计与实现-以JVM为例</td>\n<td>李晓峰</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>24</td>\n<td>Java多线程编程实战指南-设计模式-第二版</td>\n<td>黄文海</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>25</td>\n<td>Java并发实现原理-JDK源码剖析</td>\n<td>余春龙</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>26</td>\n<td><strong>Java并发编程实战</strong></td>\n<td>Brian Goetz</td>\n<td>5</td>\n<td></td>\n</tr>\n<tr>\n<td>27</td>\n<td><strong>深入理解Java虚拟机第二版</strong></td>\n<td>周志明</td>\n<td>5</td>\n<td></td>\n</tr>\n<tr>\n<td>28</td>\n<td><strong>深入理解Java虚拟机第三版</strong></td>\n<td>周志明</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>29</td>\n<td>Java并发设计模式</td>\n<td>Doug Lea</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>30</td>\n<td>实战Java高并发程序设计</td>\n<td>葛一鸣</td>\n<td>3</td>\n<td></td>\n</tr>\n<tr>\n<td>31</td>\n<td>精通Lambda表达式</td>\n<td>Maurice Naftalin</td>\n<td>3</td>\n<td></td>\n</tr>\n<tr>\n<td>32</td>\n<td>Java编程思想第四版</td>\n<td>Bruce Eckel</td>\n<td>4</td>\n<td></td>\n</tr>\n<tr>\n<td>33</td>\n<td>函数式编程思维</td>\n<td>Neal Ford</td>\n<td>3</td>\n<td></td>\n</tr>\n<tr>\n<td>34</td>\n<td>Java解惑</td>\n<td>Joshua Bloch</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>35</td>\n<td>Java性能优化权威指南</td>\n<td>Charlie Hunt</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>36</td>\n<td>Java技术手册</td>\n<td>Benjamin J. Evans</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>37</td>\n<td>Java虚拟机规范（JavaSE8）</td>\n<td>Tim Lindholm等</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>38</td>\n<td>Java性能权威指南</td>\n<td>Scott Oaks</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>39</td>\n<td>Java虚拟机并发编程</td>\n<td>Venkat Subramaniam</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>40</td>\n<td>Java编程方法论-响应式rxjava</td>\n<td>知秋</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>41</td>\n<td>Java编程方法论-spring-reactor</td>\n<td>知秋</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>42</td>\n<td>Spring响应式编程</td>\n<td></td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>43</td>\n<td>RxJava反应式编程</td>\n<td>张卫滨翻译</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>44</td>\n<td>Java8函数式编程</td>\n<td>Richard Warbuton</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>45</td>\n<td>Rxjava2.x实战</td>\n<td>沈哲</td>\n<td>4</td>\n<td></td>\n</tr>\n<tr>\n<td>46</td>\n<td>Java9模块化开发：核心原则与实践</td>\n<td>Sander Mark</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>47</td>\n<td>ECMAScript 2018快速入门</td>\n<td>黄灯桥</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>48</td>\n<td>Java网络编程</td>\n<td>Elliotte Rusty Harold)]</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>49</td>\n<td>Java程序性能优化</td>\n<td>葛一鸣</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>50</td>\n<td>Go语言高级编程</td>\n<td>柴树杉</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>51</td>\n<td>Go语言底层原理剖析</td>\n<td>郑建勋</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>52</td>\n<td>深入学习Go语言</td>\n<td>李晓钧</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>53</td>\n<td>C语言程序设计-现代方法</td>\n<td>K.N.King</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>54</td>\n<td>Go程序设计语言</td>\n<td>Alan Donovan</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>55</td>\n<td>Rust权威指南</td>\n<td>Steve Klabnik / Carol Nichols</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>56</td>\n<td>C++ Primer 中文版（第五版）</td>\n<td>Stanley B. Lippman</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>57</td>\n<td>C++ Primer 习题集</td>\n<td>Stanley B. Lippman</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>58</td>\n<td>latex入门</td>\n<td>刘海洋</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>59</td>\n<td>Koltin实战</td>\n<td>Dmitry Jemerov</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>60</td>\n<td>Grovvy程序设计</td>\n<td>Venkat Subramaniam</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>61</td>\n<td><strong>Effective Java 第三版英文版</strong></td>\n<td>Joshua Bloch</td>\n<td>0</td>\n<td></td>\n</tr>\n</tbody></table>\n<h2 id=\"数据库-47\"><a href=\"#数据库-47\" class=\"headerlink\" title=\"数据库(47)\"></a>数据库(47)</h2><table>\n<thead>\n<tr>\n<th>编号</th>\n<th>书名</th>\n<th>作者</th>\n<th>阅读情况</th>\n<th>读书笔记</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>高性能的MySQL第三版</td>\n<td>Perter Zaitsev等</td>\n<td>3</td>\n<td></td>\n</tr>\n<tr>\n<td>2</td>\n<td>高可用的MySQL第二版</td>\n<td>Charles Bell</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>3</td>\n<td>深入理解MySQL核心技术</td>\n<td>Sasha Pachev</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>4</td>\n<td>HBase权威指南</td>\n<td>Lars George</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>5</td>\n<td>海量数据库解决方案</td>\n<td>韩.李华植</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>6</td>\n<td>数据库事务处理的艺术</td>\n<td>李海翔</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>7</td>\n<td>Effective MySQL之深入解析复制技术</td>\n<td>Ronald Bradford</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>8</td>\n<td>Effective MySQL之SQL语句最优化</td>\n<td>Ronald Bradford</td>\n<td>4</td>\n<td></td>\n</tr>\n<tr>\n<td>9</td>\n<td>MySQL技术内幕：InnoDB存储引擎</td>\n<td>姜承尧</td>\n<td>4</td>\n<td></td>\n</tr>\n<tr>\n<td>10</td>\n<td>数据库系统内幕</td>\n<td>Alex Petrov</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>11</td>\n<td>数据密集型应用系统设计</td>\n<td>Martin Kleppmann</td>\n<td>3</td>\n<td></td>\n</tr>\n<tr>\n<td>12</td>\n<td>NoSQL精粹</td>\n<td>Martin Flower</td>\n<td>3</td>\n<td></td>\n</tr>\n<tr>\n<td>13</td>\n<td>数据库索引设计与优化</td>\n<td>Michael Leach等</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>14</td>\n<td>Cassandra权威指南第二版</td>\n<td>Jeff Carpenter</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>15</td>\n<td>Greenplum:从大数据战略到实现</td>\n<td>冯雷</td>\n<td>3</td>\n<td></td>\n</tr>\n<tr>\n<td>16</td>\n<td>Clickhouse原理解析与应用实践</td>\n<td>朱凯</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>17</td>\n<td>MySQL技术内幕：SQL编程</td>\n<td>姜承尧</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>18</td>\n<td>Druid实时大数据分析</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>19</td>\n<td>图数据库</td>\n<td>Ian Robinson</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>20</td>\n<td>企业级大数据平台构建：架构与实现</td>\n<td>朱凯</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>21</td>\n<td>Apache Kylin权威指南</td>\n<td>Apache Kylin核心团队</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>22</td>\n<td>数据仓储-第四版</td>\n<td>Inmon W.H</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>23</td>\n<td>大数据平台基础架构指南</td>\n<td>刘旭辉</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>24</td>\n<td>MySQL管理之道（第二版）性能调优，高可用与监控</td>\n<td>贺春旸</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>25</td>\n<td>Hikaricp数据库连接池实战</td>\n<td>朱政科</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>26</td>\n<td>精通LevelDB</td>\n<td>廖环宇</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>27</td>\n<td>数据库重构</td>\n<td>Scott W. Ambler</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>28</td>\n<td>MySQL是怎样运行的？</td>\n<td>小孩子4919</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>29</td>\n<td>解读NoSQL</td>\n<td>Dan McCreary</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>30</td>\n<td>大数据挑战与NoSQL数据技术</td>\n<td>陆嘉恒</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>31</td>\n<td>分布式数据库原理 架构与实践</td>\n<td>李海翔</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>32</td>\n<td>分布式数据库系统原理 第三版</td>\n<td><a href=\"https://cs.uwaterloo.ca/~tozsu/\" target=\"_blank\" rel=\"noopener\">M. Tamer Özsu</a> <a href=\"http://www-sop.inria.fr/members/Patrick.Valduriez/\" target=\"_blank\" rel=\"noopener\">Patrick Valduriez</a></td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>33</td>\n<td>七周七数据库</td>\n<td>Eric Redmond</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>34</td>\n<td>对象存储实战指南</td>\n<td>罗庆超</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>35</td>\n<td>数据分析之图算法：基于spark和neo4j</td>\n<td>Mark Needham</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>36</td>\n<td>分布式对象存储 原理 架构以及Go语言实现</td>\n<td>胡世杰</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>37</td>\n<td>云数据库架构</td>\n<td>朱明</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>38</td>\n<td>大数据日知录</td>\n<td>张俊林</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>39</td>\n<td>云原生数据库 原理与最佳实践</td>\n<td>阿里巴巴</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>40</td>\n<td>postgresql指南</td>\n<td>【日】铃木启修</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>41</td>\n<td>数据库系统实现</td>\n<td>Hector Garcia-Molina</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>42</td>\n<td>Design Data Intensive Application</td>\n<td>Martin Kleppmann</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>43</td>\n<td>分布式数据库系统：大数据时代新型数据库技术</td>\n<td></td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>44</td>\n<td>分布式 云计算 大数据</td>\n<td>林伟伟</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>45</td>\n<td>寻路大数据</td>\n<td>Michael Manoochehri</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>46</td>\n<td>大数据技术与应用：数据密集型计算和模型</td>\n<td></td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>47</td>\n<td>数据库系统，设计 实现与管理 基础篇</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h2 id=\"分布式与中间件-110\"><a href=\"#分布式与中间件-110\" class=\"headerlink\" title=\"分布式与中间件(110)\"></a>分布式与中间件(110)</h2><table>\n<thead>\n<tr>\n<th>编号</th>\n<th>书名</th>\n<th>作者</th>\n<th>阅读情况</th>\n<th>读书笔记</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>Rabbitmq实战指南</td>\n<td>朱忠华</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>2</td>\n<td>Lucene实战第二版</td>\n<td>Michael McCandless</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>3</td>\n<td>Docker实战</td>\n<td>Jeff Nickoloff</td>\n<td>3</td>\n<td></td>\n</tr>\n<tr>\n<td>4</td>\n<td>深入剖析Nginx</td>\n<td>高群凯</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>5</td>\n<td>Http权威指南</td>\n<td>David Gourley等</td>\n<td>3</td>\n<td></td>\n</tr>\n<tr>\n<td>6</td>\n<td>Http/2基础教程</td>\n<td>Stephen Ludin</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>7</td>\n<td>Docker进阶与实战</td>\n<td>华为</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>8</td>\n<td>Etcd技术内幕</td>\n<td>百丽燊<strong>shēn</strong></td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>9</td>\n<td>分布式数据库架构基于MyCat中间件</td>\n<td>周继锋等</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>10</td>\n<td>Web容量规划的艺术</td>\n<td>John Allspaw</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>11</td>\n<td>Mongodb实战第一版</td>\n<td>Kyle Banker</td>\n<td>3</td>\n<td></td>\n</tr>\n<tr>\n<td>12</td>\n<td>从Paxos到Zookeeper</td>\n<td>倪超</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>13</td>\n<td>Rabbitmq实战</td>\n<td>Alvaro Videla</td>\n<td>3</td>\n<td></td>\n</tr>\n<tr>\n<td>14</td>\n<td>Netty实战</td>\n<td>Morman Maurer</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>15</td>\n<td>Kafka权威指南</td>\n<td>Neha Narkhede</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>16</td>\n<td>Elsaticsearch服务器开发第二版</td>\n<td>Rafa Kuc</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>17</td>\n<td>分布式服务框架原理与实践</td>\n<td>李林锋</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>18</td>\n<td>大型网站系统与Java中间件实践</td>\n<td>曾宪杰</td>\n<td>4</td>\n<td></td>\n</tr>\n<tr>\n<td>19</td>\n<td>Kubernetes in Action</td>\n<td>Marko Luksa</td>\n<td>3</td>\n<td></td>\n</tr>\n<tr>\n<td>20</td>\n<td>Java RESTful Web Service实战第二版</td>\n<td>韩陆</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>21</td>\n<td>Zookeeper 分布式过程协同技术详解</td>\n<td>Flavio Junqueira</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>22</td>\n<td>深入分析Java Web技术内幕 修订版</td>\n<td>许令波</td>\n<td>4</td>\n<td></td>\n</tr>\n<tr>\n<td>23</td>\n<td>Redis实战</td>\n<td>Josiah L. Carlson</td>\n<td>4</td>\n<td></td>\n</tr>\n<tr>\n<td>24</td>\n<td>Redis设计与实现</td>\n<td>黄健宏</td>\n<td>4</td>\n<td></td>\n</tr>\n<tr>\n<td>25</td>\n<td>大规模分布式系统架构与设计实战</td>\n<td>彭渊</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>26</td>\n<td>大规模分布式存储系统原理解析和架构实战</td>\n<td>杨传辉</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>27</td>\n<td>分布式消息中间件实践</td>\n<td>倪伟</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>28</td>\n<td>深入分布式缓存-从原理到实践</td>\n<td>于君泽等</td>\n<td>3</td>\n<td></td>\n</tr>\n<tr>\n<td>29</td>\n<td>分布式系统应用设计</td>\n<td>Brendan Burns</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>30</td>\n<td>企业集成模式-设计构建及部署消息传递解决方案</td>\n<td>Gregor Hohpe</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>31</td>\n<td>NoSQL数据库技术实战</td>\n<td>皮雄军</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>32</td>\n<td>反应式设计模式</td>\n<td>何品等翻译</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>33</td>\n<td>Redis5设计与源码分析</td>\n<td>陈雷</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>34</td>\n<td>Redis深度历险</td>\n<td>钱文品</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>35</td>\n<td>Akka入门和实践</td>\n<td>Jason Goodwin</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>36</td>\n<td>Akka实战：快速构建高可用分布式应用</td>\n<td>杜云飞</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>37</td>\n<td>响应式架构消息模式Actor实现与Scala应用集成</td>\n<td>Vaughn Vernon</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>38</td>\n<td>Apache Kafka实战</td>\n<td>胡夕</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>39</td>\n<td>深入理解Apache kafka核心设计与实践原理</td>\n<td>朱忠华</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>40</td>\n<td>Apache kafka源码剖析</td>\n<td>徐郡明</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>41</td>\n<td>实战Gradle</td>\n<td>Benjamin Muschko</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>42</td>\n<td>Elasticssearch源码解析与优化实战</td>\n<td>张超</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>43</td>\n<td>深入理解Elasticsearch第三版</td>\n<td>波哈维</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>44</td>\n<td>Elasticssearch实战</td>\n<td>Radu Gheorghe</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>45</td>\n<td>离线和实时大数据开发实战</td>\n<td>朱松岭</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>46</td>\n<td>Springboot解密</td>\n<td>王福强</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>47</td>\n<td>Hbase实战</td>\n<td>Nick Dimiduk</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>48</td>\n<td>尽在双十一</td>\n<td>双十一团队</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>49</td>\n<td>大型系统应用架构实战部署，容灾性能优化</td>\n<td>李彦超</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>50</td>\n<td>Storm分布式实时计算模式</td>\n<td>P.Taylor Goetz</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>51</td>\n<td>Spark核心技术与高级应用</td>\n<td>于俊</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>52</td>\n<td>Hadoop技术内幕</td>\n<td>董西成</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>53</td>\n<td>RocketMq技术内幕</td>\n<td>丁威</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>54</td>\n<td>大数据之路阿里巴巴大数据实践</td>\n<td>阿里巴巴数据技术及产品部</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>55</td>\n<td>大数据技术体系详解 原理架构与实践</td>\n<td>董西成</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>56</td>\n<td>深度剖析HadoopHDFS</td>\n<td>林意群</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>57</td>\n<td>数据仓储工具箱：维度建模指南</td>\n<td>Ralph Kimball</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>58</td>\n<td>深入理解Flink：实时大数据处理实践</td>\n<td>余海峰</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>59</td>\n<td>分布式实时处理系统：原理，架构与实现</td>\n<td>卢誉声</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>60</td>\n<td>分布式一致性算法开发实战</td>\n<td>赵辰</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>61</td>\n<td>KafkaStream实战</td>\n<td>William Bejeck</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>62</td>\n<td>akka应用模式：分布式应用程序设计实践指南</td>\n<td>Michael Nash</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>63</td>\n<td>flink基础教程</td>\n<td>Tzoumas</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>64</td>\n<td>akka实战（akka in action）</td>\n<td></td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>65</td>\n<td>Hadoop技术内幕：深入解析YARN架构设计与实现原理</td>\n<td>董西成</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>66</td>\n<td>Hadoop技术内幕：深入解析Hadoop Common和HDFS架构设计ui实现原理</td>\n<td>蔡斌</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>67</td>\n<td>大数据基础编程：实践和案例教程-第二版</td>\n<td>林子雨</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>68</td>\n<td>大数据实训案例：电信用户行为分析</td>\n<td>林子雨</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>69</td>\n<td>大数据实训案例：电影推荐系统Scala版</td>\n<td>林子雨</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>70</td>\n<td>疯狂VirtualBox实战讲学录</td>\n<td>小耗子</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>71</td>\n<td>走进搜索引擎（第二版）</td>\n<td>潘学峰</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>72</td>\n<td>gRPC与云原生应用开发 以Go和Java为例</td>\n<td>Kasun Indrasiri</td>\n<td>4</td>\n<td></td>\n</tr>\n<tr>\n<td>73</td>\n<td>深入理解RPC框架原理与实现</td>\n<td>华钟明</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>74</td>\n<td>分布式事务之Seata</td>\n<td>姜宇</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>75</td>\n<td>分布式缓存 原理架构及Go语言实现</td>\n<td>胡世杰</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>76</td>\n<td>深入理解分布式事务：原理与实践</td>\n<td>冰河</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>77</td>\n<td>分布式系统与一致性</td>\n<td>陈东明</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>78</td>\n<td>分布式系统设计实践</td>\n<td>李庆旭</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>79</td>\n<td>日志管理与分析权威指南</td>\n<td>Anton A. Chuvakin</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>80</td>\n<td>搜索引擎：信息检索实践</td>\n<td>W.Bruce Croft</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>81</td>\n<td>搜索引擎-原理技术与系统（第二版）</td>\n<td>李晓明</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>82</td>\n<td>自制搜索引擎</td>\n<td>[日]山田浩之</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>83</td>\n<td>这就是搜索引擎：核心技术详解</td>\n<td>张俊林</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>84</td>\n<td>解密搜索引擎技术实战 : Lucene&amp;Java精华版（第3版）</td>\n<td>罗刚</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>85</td>\n<td>信息检索导论（修订版）</td>\n<td>Prabhakar Raghavan</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>86</td>\n<td>自己动手写Java虚拟机</td>\n<td>张秀宏</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>87</td>\n<td>深入理解分布式系统</td>\n<td>唐伟志</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>88</td>\n<td>HBase应用架构</td>\n<td>Jean-Marc Spaggiari</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>89</td>\n<td>深入解析apache pulsar</td>\n<td>林琳</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>90</td>\n<td>深入集群-大型数据中心资源调度与管理</td>\n<td>李雨前</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>91</td>\n<td>ceph企业级分布式存储 原理与工程实践</td>\n<td>龚向宇</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>92</td>\n<td>Linux开源网络全栈详解</td>\n<td></td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>93</td>\n<td>分布式操作系统原理与实践</td>\n<td>Doreen L. Galli</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>94</td>\n<td>NoSQL权威指南</td>\n<td>[美] 乔·塞科</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>95</td>\n<td>Ceph分布式存储学习指南</td>\n<td>[(芬兰)卡伦·辛格</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>96</td>\n<td>大数据系统构建：可扩展实时数据系统构建原理与最佳实践</td>\n<td>Nathan Marz</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>97</td>\n<td>流式架构 kafka和mapr streams数据流处理</td>\n<td>Ted Dunning</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>98</td>\n<td>流式系统 Streaming System</td>\n<td>Tyler Akidau / Slava Chernyak / Reuven Lax</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>99</td>\n<td>Hadoop应用架构</td>\n<td>Mark Grover</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>100</td>\n<td>Hadoop权威指南 第四版</td>\n<td>Tom white</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>101</td>\n<td>基于Apache Flink的流处理： 流式应用基础、实现及操作</td>\n<td></td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>102</td>\n<td>Spark权威指南</td>\n<td>Bill Chambers</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>103</td>\n<td>数据中台：基于Google Facebook和微博实践</td>\n<td>詹盈</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>104</td>\n<td>Hive编程指南</td>\n<td>Edward Capriolo</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>105</td>\n<td>MapReduce设计模式</td>\n<td>Donald Miner</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>106</td>\n<td>Spark快速大数据分析</td>\n<td>Holden Karau</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>107</td>\n<td>OpenTSDB技术内幕</td>\n<td>百里燊</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>108</td>\n<td>NoSQL实践指南</td>\n<td>Dan Sullivan</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>109</td>\n<td>Mesos实战</td>\n<td>Roger Ignazio</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>110</td>\n<td>MongoDB权威指南 第二版</td>\n<td>Kristina Chodorow</td>\n<td>0</td>\n<td></td>\n</tr>\n</tbody></table>\n<h2 id=\"框架-21\"><a href=\"#框架-21\" class=\"headerlink\" title=\"框架(21)\"></a>框架(21)</h2><table>\n<thead>\n<tr>\n<th>编号</th>\n<th>书名</th>\n<th>作者</th>\n<th>阅读情况</th>\n<th>读书笔记</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>重新定义SpringCloud实战</td>\n<td>许进等</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>2</td>\n<td>Spring实现第四版</td>\n<td>Craig Walls</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>3</td>\n<td>J2EE核心模式第二版</td>\n<td>Deepak Alur</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>4</td>\n<td>精通Spring4.0企业应用开发实战</td>\n<td>陈雄华等</td>\n<td>3</td>\n<td></td>\n</tr>\n<tr>\n<td>5</td>\n<td>Java WebSocket编程</td>\n<td>Danny Coward</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>6</td>\n<td>Spring框架高级编程</td>\n<td>Rod Johnson等</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>7</td>\n<td>Mybatis技术内幕</td>\n<td>徐郡明</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>8</td>\n<td>Spring技术内幕第二版</td>\n<td>计文柯</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>9</td>\n<td>Spring源码深度解析第二版</td>\n<td>郝佳</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>10</td>\n<td>深入理解SpringMVC源代码</td>\n<td>王耀</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>11</td>\n<td><strong>Expert One on one J2EE Development Without EJB</strong></td>\n<td>Rod Johnson等</td>\n<td>3</td>\n<td></td>\n</tr>\n<tr>\n<td>12</td>\n<td><strong>Expert One on one J2EE Design And Implement</strong></td>\n<td>Rod Johnson</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>13</td>\n<td>软件框架设计的艺术</td>\n<td>Jaroslav Tulach</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>14</td>\n<td>.NET设计规范，约定，惯用法与模式</td>\n<td>Krzysztof Cwalina</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>15</td>\n<td>iBatis实战</td>\n<td>Clinton Begin</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>16</td>\n<td>GraphQL实战写给全栈工程师们</td>\n<td>王北南</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>17</td>\n<td>SpringData实战</td>\n<td></td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>18</td>\n<td>深入浅出MyBatis技术原理与实战</td>\n<td>杨开振</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>19</td>\n<td>Apache ShardingSphere实战</td>\n<td>郑天民</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>20</td>\n<td>Webassembly实战</td>\n<td>C. Gerard Gallant</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>21</td>\n<td>反应式应用开发</td>\n<td>Duncan DeVore</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>22</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h2 id=\"架构-59\"><a href=\"#架构-59\" class=\"headerlink\" title=\"架构(59)\"></a>架构(59)</h2><table>\n<thead>\n<tr>\n<th>编号</th>\n<th align=\"left\">书名</th>\n<th>作者</th>\n<th>阅读情况</th>\n<th>读书笔记</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td align=\"left\">从0开始学架构</td>\n<td>李运华</td>\n<td>4</td>\n<td></td>\n</tr>\n<tr>\n<td>2</td>\n<td align=\"left\">大型网站技术架构-核心原理与案例分析</td>\n<td>李智慧</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>3</td>\n<td align=\"left\">软考：软件设计师教程</td>\n<td>诸华</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>4</td>\n<td align=\"left\">大数据技术原理与应用第二版</td>\n<td>林子雨</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>5</td>\n<td align=\"left\">企业IT架构转型之道</td>\n<td>钟华</td>\n<td>3</td>\n<td></td>\n</tr>\n<tr>\n<td>6</td>\n<td align=\"left\">Kubernates权威指南纪念版</td>\n<td>垄正等</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>7</td>\n<td align=\"left\">构建实时机器学习系统</td>\n<td>彭江森</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>8</td>\n<td align=\"left\">云系统管理-大规模分布式系统设计与运营</td>\n<td>Thomas A.Limoncelli</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>9</td>\n<td align=\"left\">恰如其分的软件架构</td>\n<td>George Fairbanks</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>10</td>\n<td align=\"left\">软件架构设计</td>\n<td>温昱</td>\n<td>4</td>\n<td></td>\n</tr>\n<tr>\n<td>11</td>\n<td align=\"left\">软件架构设计-第二版</td>\n<td>温昱</td>\n<td>3</td>\n<td></td>\n</tr>\n<tr>\n<td>12</td>\n<td align=\"left\">进化：运维技术变革与实践探索</td>\n<td>赵成</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>13</td>\n<td align=\"left\">企业应用架构模式</td>\n<td>Martin Flower</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>14</td>\n<td align=\"left\">Paas程序设计</td>\n<td>Lucas Carlson</td>\n<td>4</td>\n<td></td>\n</tr>\n<tr>\n<td>15</td>\n<td align=\"left\">让云落地 云计算服务模式</td>\n<td>Michael Kavis</td>\n<td>4</td>\n<td></td>\n</tr>\n<tr>\n<td>16</td>\n<td align=\"left\">架构之美</td>\n<td>Diomidis Spinellis</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>17</td>\n<td align=\"left\">软件构架编档</td>\n<td>Paul Clements等</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>18</td>\n<td align=\"left\">IT架构思维</td>\n<td>Peter Beijer等</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>19</td>\n<td align=\"left\">架构整洁之道</td>\n<td>Robert C.Martin</td>\n<td>4</td>\n<td></td>\n</tr>\n<tr>\n<td>20</td>\n<td align=\"left\">云计算架构设计模式</td>\n<td>Alex Homer等</td>\n<td>3</td>\n<td></td>\n</tr>\n<tr>\n<td>21</td>\n<td align=\"left\">简单之美 软件开发实践者的思考</td>\n<td>倪健</td>\n<td>4</td>\n<td></td>\n</tr>\n<tr>\n<td>22</td>\n<td align=\"left\">架构即未来</td>\n<td>Martin L.Abbott</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>23</td>\n<td align=\"left\">高扩展性网站的50条原则</td>\n<td>Martin L.Abbott</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>24</td>\n<td align=\"left\">持续集成-软件质量改进的风险降低之道</td>\n<td>Paul M. Duvall</td>\n<td>2</td>\n<td><a href=\"https://xiaozhiliaoo.github.io/2020/11/28/CI-Book-Reading/\" target=\"_blank\" rel=\"noopener\">notes</a></td>\n</tr>\n<tr>\n<td>25</td>\n<td align=\"left\">持续交付-发布可靠软件的系统方法</td>\n<td>Jez Humble</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>26</td>\n<td align=\"left\">演进式架构</td>\n<td>Neal Ford</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>27</td>\n<td align=\"left\">Tomcat架构解析</td>\n<td>刘光瑞</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>28</td>\n<td align=\"left\">白帽子讲Web安全</td>\n<td>吴翰清</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>29</td>\n<td align=\"left\">深入浅出大型网站架构设计</td>\n<td>李力非</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>30</td>\n<td align=\"left\">程序员必读软件架构</td>\n<td>Simon Brown</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>31</td>\n<td align=\"left\">代码之美</td>\n<td>Oram Wilson</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>32</td>\n<td align=\"left\">Prometheus云原生监控</td>\n<td>朱政科-阿里巴巴</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>33</td>\n<td align=\"left\">Apache SkyWalking实战</td>\n<td>吴晟</td>\n<td>4</td>\n<td></td>\n</tr>\n<tr>\n<td>34</td>\n<td align=\"left\">Cloud Foundry：从数字化战略到实现</td>\n<td>冯雷</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>35</td>\n<td align=\"left\">逆流而上：阿里巴巴技术成长之路</td>\n<td>阿里巴巴成长编委会</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>36</td>\n<td align=\"left\">淘宝技术这十年</td>\n<td>子柳</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>37</td>\n<td align=\"left\">架构解密：从分布式到微服务</td>\n<td>leader Us</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>38</td>\n<td align=\"left\">亿级流量网站架构核心技术</td>\n<td>张开涛</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>39</td>\n<td align=\"left\">分布式服务架构：原理，设计与实战</td>\n<td>李艳鹏</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>40</td>\n<td align=\"left\">微服务治理 体系 结构及实践</td>\n<td>李鑫</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>41</td>\n<td align=\"left\">微服务之道:度量驱动开发</td>\n<td>范亚敏</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>42</td>\n<td align=\"left\">数字化转型的道与术</td>\n<td>钟华</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>43</td>\n<td align=\"left\">业务架构  业务架构，应用架构，数据架构</td>\n<td>温昱</td>\n<td>4</td>\n<td></td>\n</tr>\n<tr>\n<td>44</td>\n<td align=\"left\">大型网站性能优化实战</td>\n<td>周涛明</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>45</td>\n<td align=\"left\">大型网站技术架构演进与性能优化</td>\n<td>许令波</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>46</td>\n<td align=\"left\">架构修炼之道：亿级网关，平台开放</td>\n<td>王新栋</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>47</td>\n<td align=\"left\">分布式一致性算法开发实战</td>\n<td>赵辰</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>48</td>\n<td align=\"left\">大数据技术原理与应用第三版</td>\n<td>林子雨</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>49</td>\n<td align=\"left\">代码里的世界观：通往架构师之路</td>\n<td>余叶</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>50</td>\n<td align=\"left\">软件架构</td>\n<td>沙巴纳</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>51</td>\n<td align=\"left\">前端工程化：体系设计与实践</td>\n<td>周俊鹏</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>52</td>\n<td align=\"left\">可伸缩架构 第二版</td>\n<td>张若飞</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>53</td>\n<td align=\"left\">凤凰架构</td>\n<td>周志明</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>54</td>\n<td align=\"left\">AWS云计算实战</td>\n<td>安德烈亚斯·威蒂格</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>55</td>\n<td align=\"left\">大数据技术架构-核心原理与应用实践</td>\n<td>李智慧-极客时间专栏</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>56</td>\n<td align=\"left\">企业数字化基石-阿里巴巴云计算基础设施实践</td>\n<td>阿里巴巴</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>57</td>\n<td align=\"left\">阿里云原生架构实践</td>\n<td>阿里巴巴</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>58</td>\n<td align=\"left\">云原生架构：从技术演进到最佳实践</td>\n<td>贺阮云</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>59</td>\n<td align=\"left\">分布式架构原理与实践</td>\n<td>崔浩</td>\n<td>0</td>\n<td></td>\n</tr>\n</tbody></table>\n<h2 id=\"软件工程-71\"><a href=\"#软件工程-71\" class=\"headerlink\" title=\"软件工程(71)\"></a>软件工程(71)</h2><table>\n<thead>\n<tr>\n<th>编号</th>\n<th>书名</th>\n<th>作者</th>\n<th>阅读情况</th>\n<th>读书笔记</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>超越软件架构</td>\n<td>Luke Hohmann</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>2</td>\n<td>重构与模式</td>\n<td>Joshua Kerievsky</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>3</td>\n<td>Contributing To Eclipse</td>\n<td>Erich Gamma&amp;Kent Beck</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>4</td>\n<td>软件工艺</td>\n<td>Pete McBreen</td>\n<td>3</td>\n<td></td>\n</tr>\n<tr>\n<td>5</td>\n<td>程序员修炼之道从小工到专家</td>\n<td>Andrew Hunt</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>6</td>\n<td><strong>面向对象分析与设计第二版</strong></td>\n<td>Grady Booch</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>7</td>\n<td><strong>面向对象分析与设计第三版</strong></td>\n<td>Grady Booch</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>8</td>\n<td>人月神话</td>\n<td>Frederick P. Brooks</td>\n<td>4</td>\n<td></td>\n</tr>\n<tr>\n<td>9</td>\n<td>敏捷中国史话</td>\n<td>熊节</td>\n<td>4</td>\n<td></td>\n</tr>\n<tr>\n<td>10</td>\n<td>软件开发本质论</td>\n<td>Ron Jeffries</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>11</td>\n<td>大教堂与集市</td>\n<td>Eric Raymond</td>\n<td>4</td>\n<td></td>\n</tr>\n<tr>\n<td>12</td>\n<td>快速软件开发</td>\n<td>Steve McConnell</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>13</td>\n<td>程序开发心理学</td>\n<td>Gerald Weinberg</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>14</td>\n<td>个体软件工程</td>\n<td>Watts S. Humphrey</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>15</td>\n<td>走出软件工坊</td>\n<td>阿朱</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>16</td>\n<td>UNIX编程艺术</td>\n<td>Eric S.Raymond</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>17</td>\n<td>解析极限编程-拥抱变化第一版</td>\n<td>Kent Beck</td>\n<td>3</td>\n<td></td>\n</tr>\n<tr>\n<td>18</td>\n<td>敏捷软件开发-原则，模式-实践</td>\n<td>Robert C.Martin</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>19</td>\n<td><strong>实现模式</strong></td>\n<td>Kent Beck</td>\n<td>4</td>\n<td></td>\n</tr>\n<tr>\n<td>20</td>\n<td>面向模式的软件架构 资源管理模式</td>\n<td>Michael Kircher</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>21</td>\n<td>编程珠玑第二版</td>\n<td>Jon Bentley</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>22</td>\n<td>数据库访问模式</td>\n<td>Clifton Nock</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>23</td>\n<td>反模式-危机中的软件，架构和项目的重构</td>\n<td>William Brown</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>24</td>\n<td>面向对象项目的解决方案</td>\n<td>Grady Booch</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>25</td>\n<td>软件构架实践</td>\n<td>Len Bass</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>26</td>\n<td>面向模式的软件架构-模式系统第一卷</td>\n<td>Frank Buschmann</td>\n<td>3</td>\n<td></td>\n</tr>\n<tr>\n<td>27</td>\n<td>发布! 软件的设计与部署-第一版</td>\n<td>Michael T. Mygard</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>28</td>\n<td>发布! 软件的设计与部署-第二版</td>\n<td>Michael T. Mygard</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>29</td>\n<td>构建之法-现代软件工程0第三版</td>\n<td>邹欣</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>30</td>\n<td>混沌工程Netflix系统稳定性之道</td>\n<td>Casey Rosenthal等</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>31</td>\n<td>设计模式-可复用面向对象软件的基础</td>\n<td>GOF4</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>32</td>\n<td>精益软件度量</td>\n<td>张松</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>33</td>\n<td>测试驱动开发-英文版</td>\n<td>Kent Beck</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>34</td>\n<td>Xunit测试模式</td>\n<td>Gerard Meszaros</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>35</td>\n<td>Google软件测试之道</td>\n<td>James Whittaker</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>36</td>\n<td>UML用户指南</td>\n<td>Grady Booch</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>37</td>\n<td>敏捷革命</td>\n<td>Jeff Sutherland</td>\n<td>4</td>\n<td></td>\n</tr>\n<tr>\n<td>38</td>\n<td>看板方法-科技企业渐进变革成功之道</td>\n<td>David J. Anderson</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>39</td>\n<td>敏捷迭代开发-管理者指南</td>\n<td>Craig Larman</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>40</td>\n<td><strong>UML和模式应用第三版</strong></td>\n<td>Craig Larman</td>\n<td>3</td>\n<td></td>\n</tr>\n<tr>\n<td>41</td>\n<td>面向对象编程导论 第三版</td>\n<td>Timothy A. Budd</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>42</td>\n<td>编写有效用例</td>\n<td>Alistair Cockburn</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>43</td>\n<td>代码大全第二版</td>\n<td>Steve McConnell</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>44</td>\n<td>统一软件开发过程</td>\n<td>Ivar Jacobson</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>45</td>\n<td>用户故事与敏捷方法</td>\n<td>Mike Cohn</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>46</td>\n<td>面向快速交付的软件开发</td>\n<td>翟宏宝</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>47</td>\n<td>有效的单元测试</td>\n<td>Lasse Koskela</td>\n<td>0</td>\n<td>2020-12-15</td>\n</tr>\n<tr>\n<td>48</td>\n<td>构建高质量软件-程序开发人员测试指南</td>\n<td>Alexander Tarlinder</td>\n<td>0</td>\n<td>2020-12-22</td>\n</tr>\n<tr>\n<td>49</td>\n<td>程序员应该知道的97件事</td>\n<td>Kevlin Henney</td>\n<td>0</td>\n<td>2020-12-22</td>\n</tr>\n<tr>\n<td>50</td>\n<td>软件架构师应该知道的97件事</td>\n<td>Richard Monson-Haefel</td>\n<td>0</td>\n<td>2020-12-22</td>\n</tr>\n<tr>\n<td>51</td>\n<td>Cucumber行为驱动开发指南</td>\n<td>Matt Waynne等</td>\n<td>0</td>\n<td>2020-12-22</td>\n</tr>\n<tr>\n<td>52</td>\n<td>实例化需求</td>\n<td>Gojko Adzic</td>\n<td>0</td>\n<td>2020-12-21</td>\n</tr>\n<tr>\n<td>53</td>\n<td>驯服烂代码</td>\n<td>伍斌</td>\n<td>0</td>\n<td>2020-12-28</td>\n</tr>\n<tr>\n<td>54</td>\n<td>软件工程通史1930-2019</td>\n<td>Capers Jones</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>55</td>\n<td>人件(原书第三版)</td>\n<td>Tom DeMarco Timothy Lister</td>\n<td>0</td>\n<td>2021-05-02</td>\n</tr>\n<tr>\n<td>56</td>\n<td>软件困局：为什么聪明的程序员写出糟糕的代码</td>\n<td>Adam Barr</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>57</td>\n<td>项目百态：深入理解软件项目行为模式</td>\n<td>金明翻译</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>58</td>\n<td>硝烟中的Scrum和XP-我们如何实施Scrum</td>\n<td>Henrik Kniberg</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>59</td>\n<td>敏捷整洁之道</td>\n<td>Robert C. Martin</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>60</td>\n<td>精益软件开发管理之道</td>\n<td>Mary  Poppendieck</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>61</td>\n<td>敏捷软件开发工具-精益开发方法</td>\n<td>Mary  Poppendieck</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>62</td>\n<td>活文档 与代码共同演进</td>\n<td>Cyrille Matraire</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>63</td>\n<td>凤凰项目 一个IT运维的传奇故事-修订版</td>\n<td>Gene Kim</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>64</td>\n<td>产品研发管理：构建世界一流的产品研发管理体系（第二版）</td>\n<td>周辉</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>65</td>\n<td>敏捷技能修炼：敏捷软件开发与设计的最佳实践</td>\n<td>Alan Shalloway / Scott Bain / Ken Pugh / Amir Kolsky</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>66</td>\n<td>Scrum敏捷软件开发</td>\n<td>Mike Cohn</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>67</td>\n<td>敏捷软件开发时间：估算与计划</td>\n<td>Mike Cohn</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>68</td>\n<td>SCRUM敏捷项目管理</td>\n<td>Ken Schwaber</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>69</td>\n<td>这就是软件工程师</td>\n<td>丁丛丛 靳冉</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>70</td>\n<td>30天软件开发：告别瀑布拥抱敏捷</td>\n<td>Ken Schwaber,Jeff Sutherland</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>71</td>\n<td>Vim实用技巧 第二版</td>\n<td>Drew Neil</td>\n<td>0</td>\n<td></td>\n</tr>\n</tbody></table>\n<h2 id=\"设计-27\"><a href=\"#设计-27\" class=\"headerlink\" title=\"设计(27)\"></a>设计(27)</h2><table>\n<thead>\n<tr>\n<th>编号</th>\n<th>书名</th>\n<th>作者</th>\n<th>阅读情况</th>\n<th>读书笔记</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td><strong>重构-第一版</strong></td>\n<td>Martin Flower</td>\n<td>4</td>\n<td></td>\n</tr>\n<tr>\n<td>2</td>\n<td>微服务设计</td>\n<td>Sam Newman</td>\n<td>3</td>\n<td></td>\n</tr>\n<tr>\n<td>3</td>\n<td>UML和OOAD快速入门</td>\n<td>邱郁惠</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>4</td>\n<td>软件设计之道：那些值得借鉴的实践案例</td>\n<td>麦思博</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>5</td>\n<td>分析模式</td>\n<td>Martin Fowler</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>6</td>\n<td>生产微服务</td>\n<td>Susan J.Fowler</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>7</td>\n<td>修改代码的艺术-构建易维护代码的9条最佳实践</td>\n<td>David Scott Bernstein</td>\n<td>3</td>\n<td></td>\n</tr>\n<tr>\n<td>8</td>\n<td>修改代码的艺术</td>\n<td>Michael Feathers</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>9</td>\n<td>遗留系统重建实战</td>\n<td>Chris Birchall</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>10</td>\n<td>Junit实战第二版</td>\n<td>Peter Tahchiev</td>\n<td>3</td>\n<td></td>\n</tr>\n<tr>\n<td>11</td>\n<td>软件设计哲学</td>\n<td>John Ousterhout</td>\n<td>4</td>\n<td></td>\n</tr>\n<tr>\n<td>12</td>\n<td>领域驱动设计全面解析与实战</td>\n<td>彭晨阳</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>13</td>\n<td>软件工程-实践者的研究方法-第八版</td>\n<td>Roger S.Pressman</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>14</td>\n<td>实现领域驱动设计</td>\n<td>Vaughn Vernon</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>15</td>\n<td>编程格调</td>\n<td>Brian W.Kernighan</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>16</td>\n<td>对象设计：角色，责任和协作</td>\n<td>Rebecca Wirfs-Brock</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>17</td>\n<td><strong>OOD启思录</strong></td>\n<td>Arthur J. Riel</td>\n<td>4</td>\n<td></td>\n</tr>\n<tr>\n<td>18</td>\n<td>软件设计重构</td>\n<td>Tushar Sharma等</td>\n<td>4</td>\n<td></td>\n</tr>\n<tr>\n<td>19</td>\n<td>领域驱动设计精粹</td>\n<td>Vaughn Vernon</td>\n<td>3</td>\n<td></td>\n</tr>\n<tr>\n<td>20</td>\n<td>设计模式的艺术</td>\n<td>刘伟</td>\n<td>4</td>\n<td></td>\n</tr>\n<tr>\n<td>21</td>\n<td>代码精进之路-从码农到工匠</td>\n<td>张建飞</td>\n<td>4</td>\n<td></td>\n</tr>\n<tr>\n<td>22</td>\n<td>领域驱动设计</td>\n<td>Eric Evans</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>23</td>\n<td>特征驱动开发方法原理与实践</td>\n<td>Stephen R. Palmer</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>24</td>\n<td>浮现式设计：专业软件开发的演进本质</td>\n<td>Scott L.Bain</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>25</td>\n<td>微服务设计模式和最佳实践</td>\n<td>Vinicius Feitosa Pacheco</td>\n<td>0</td>\n<td>2020-12-22</td>\n</tr>\n<tr>\n<td>26</td>\n<td>微服务架构设计模式</td>\n<td>Chris Richardson</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>27</td>\n<td>软件预构的艺术</td>\n<td>Ken Pugh</td>\n<td>0</td>\n<td></td>\n</tr>\n</tbody></table>\n<h2 id=\"考试与考证-16\"><a href=\"#考试与考证-16\" class=\"headerlink\" title=\"考试与考证(16)\"></a>考试与考证(16)</h2><table>\n<thead>\n<tr>\n<th>编号</th>\n<th>书名</th>\n<th>作者</th>\n<th>阅读情况</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>软考:系统架构设计师 2009-2016试题分析</td>\n<td>全国计算机专业技术资格考试办公室</td>\n<td>0</td>\n</tr>\n<tr>\n<td>2</td>\n<td>软件体系架构：原理方法与实践</td>\n<td>张友生</td>\n<td>0</td>\n</tr>\n<tr>\n<td>3</td>\n<td>产品经理认证NPDP知识体系指南</td>\n<td>(美)产品开发与管理协会</td>\n<td>0</td>\n</tr>\n<tr>\n<td>4</td>\n<td>软考：信息系统项目管理师教程</td>\n<td>全国计算机专业技术资格考试办公室</td>\n<td>0</td>\n</tr>\n<tr>\n<td>5</td>\n<td>软考：信息系统项目管理师考试论文执导</td>\n<td>全国计算机专业技术资格考试办公室</td>\n<td>0</td>\n</tr>\n<tr>\n<td>6</td>\n<td>软考：信息系统项目管理师案例分析指南</td>\n<td>全国计算机专业技术资格考试办公室</td>\n<td>0</td>\n</tr>\n<tr>\n<td>7</td>\n<td>软考:系统架构设计师 2013-2018试题分析</td>\n<td>全国计算机专业技术资格考试办公室</td>\n<td>0</td>\n</tr>\n<tr>\n<td>8</td>\n<td>软考:系统架构设计师教程</td>\n<td>全国计算机专业技术资格考试办公室</td>\n<td>0</td>\n</tr>\n<tr>\n<td>9</td>\n<td>软考:系统架构设计师全程指导</td>\n<td>全国计算机专业技术资格考试办公室</td>\n<td>0</td>\n</tr>\n<tr>\n<td>10</td>\n<td>软考：系统架构设计师考试32小时通关</td>\n<td>全国计算机专业技术资格考试办公室</td>\n<td>0</td>\n</tr>\n<tr>\n<td>11</td>\n<td>软考：系统架构设计师教程</td>\n<td>希赛教育</td>\n<td>0</td>\n</tr>\n<tr>\n<td>12</td>\n<td>项目管理知识体系指南 第六版</td>\n<td>[美]项目管理协会</td>\n<td>0</td>\n</tr>\n<tr>\n<td>13</td>\n<td>敏捷实践指南</td>\n<td>[美]项目管理协会</td>\n<td>0</td>\n</tr>\n<tr>\n<td>14</td>\n<td>Head First PMP 第三版</td>\n<td>格林 / 斯泰曼</td>\n<td>0</td>\n</tr>\n<tr>\n<td>15</td>\n<td>敏捷项目管理(第二版):快速交付创新产品</td>\n<td>Jim,Highsmith</td>\n<td>0</td>\n</tr>\n<tr>\n<td>16</td>\n<td>汪博士解读PMP 第五版</td>\n<td>汪博士</td>\n<td>0</td>\n</tr>\n</tbody></table>\n<h2 id=\"产品-16\"><a href=\"#产品-16\" class=\"headerlink\" title=\"产品(16)\"></a>产品(16)</h2><table>\n<thead>\n<tr>\n<th>编号</th>\n<th>书名</th>\n<th>作者</th>\n<th>阅读情况</th>\n<th>读书笔记</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>产品设计与开发第五版</td>\n<td>Karl T.Ullrich</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>2</td>\n<td>疯传</td>\n<td>Jonah Berger</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>3</td>\n<td>人人都是产品经理-第二版</td>\n<td>苏杰</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>4</td>\n<td>你的灯还亮着吗？</td>\n<td>Gerald M.Weinberg</td>\n<td>4</td>\n<td></td>\n</tr>\n<tr>\n<td>5</td>\n<td>淘宝产品十年事</td>\n<td>苏杰</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>6</td>\n<td>俞军 产品方法论</td>\n<td>俞军</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>7</td>\n<td>支付平台架构-业务，规划，设计与实现</td>\n<td>曹兵强</td>\n<td>4</td>\n<td></td>\n</tr>\n<tr>\n<td>8</td>\n<td>电商产品经理宝典</td>\n<td>刘志远</td>\n<td>3</td>\n<td></td>\n</tr>\n<tr>\n<td>9</td>\n<td>电商产品经理：基于人货场内容的产品设计攻略</td>\n<td>王伟</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>10</td>\n<td>业务中台产品搭建指南</td>\n<td>高晖</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>11</td>\n<td>增长黑客</td>\n<td>肖恩·埃利斯 （Sean Ellis)</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>12</td>\n<td>数据产品经理修炼手册-从零基础到大数据产品实践</td>\n<td>梁旭鹏</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>13</td>\n<td>数据产品经理必须课：从零经验到令人惊艳</td>\n<td>李鑫</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>14</td>\n<td>数据驱动：从方法到实践</td>\n<td>桑文锋</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>15</td>\n<td>支付方法论</td>\n<td>王伟</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>16</td>\n<td>云计算时代 本质，计算，创新，战略</td>\n<td>刘黎明</td>\n<td>0</td>\n<td></td>\n</tr>\n</tbody></table>\n<h2 id=\"系统-13\"><a href=\"#系统-13\" class=\"headerlink\" title=\"系统(13)\"></a>系统(13)</h2><table>\n<thead>\n<tr>\n<th>编号</th>\n<th>书名</th>\n<th>作者</th>\n<th>阅读情况</th>\n<th>读书笔记</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>Linux系统编程手册-上</td>\n<td>Michael Kerrisk</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>2</td>\n<td>Linux系统编程手册-下</td>\n<td>Michael Kerrisk</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>3</td>\n<td>系统性能优化第二版</td>\n<td>Mike Loukides</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>4</td>\n<td>性能之巅</td>\n<td>Brendan Gregg</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>5</td>\n<td>Linux大棚命令百篇上：文件和文本篇</td>\n<td>大棚</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>6</td>\n<td>Linux大棚命令百篇下：网络和系统篇</td>\n<td>大棚</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>7</td>\n<td>Linux就该这么学</td>\n<td>刘遄</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>8</td>\n<td>UNIX环境高级编程 第三版</td>\n<td>W.Richard Stevens</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>9</td>\n<td>Linux系统编程 第二版</td>\n<td>Robert Love</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>10</td>\n<td>UNIX网络编程卷2：进程间通信</td>\n<td>W.Richard Stevens</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>11</td>\n<td>UNIX网络编程卷2：套接字联网API</td>\n<td>W.Richard Stevens</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>12</td>\n<td>深入理解Linux内核 第三版</td>\n<td>西斯特</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>13</td>\n<td>Unix/Linux编程实践教程</td>\n<td>Bruce Molay</td>\n<td>0</td>\n<td></td>\n</tr>\n</tbody></table>\n<h2 id=\"区块链-7\"><a href=\"#区块链-7\" class=\"headerlink\" title=\"区块链(7)\"></a>区块链(7)</h2><table>\n<thead>\n<tr>\n<th>编号</th>\n<th>书名</th>\n<th>作者</th>\n<th>阅读情况</th>\n<th>读书笔记</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>以太坊技术详解与实战</td>\n<td>闫莺等</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>2</td>\n<td>EOS区块链应用开发指南</td>\n<td>家男</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>3</td>\n<td>虚拟货币革命</td>\n<td>野口悠纪雄</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>4</td>\n<td>区块链革命：比特币底层技术如何改变货币，商业和世界</td>\n<td>Don Tapscott</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>5</td>\n<td>区块链原理，设计与应用</td>\n<td>杨保华</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>6</td>\n<td>区块链100问</td>\n<td>赵何娟</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>7</td>\n<td>区块链 新经济蓝图及导读</td>\n<td>梅兰妮</td>\n<td>0</td>\n<td></td>\n</tr>\n</tbody></table>\n<h2 id=\"其他-22\"><a href=\"#其他-22\" class=\"headerlink\" title=\"其他(22)\"></a>其他(22)</h2><table>\n<thead>\n<tr>\n<th>编号</th>\n<th>书名</th>\n<th>作者</th>\n<th>阅读情况</th>\n<th>读书笔记</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>金领简历</td>\n<td>Gayle Laakmann McDowell</td>\n<td>3</td>\n<td></td>\n</tr>\n<tr>\n<td>2</td>\n<td>IEEE计算机先驱奖(1980-2014)</td>\n<td>崔林</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>3</td>\n<td>图灵和ACM图灵奖品(1966-2011)</td>\n<td>吴鹤龄</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>4</td>\n<td>黑客与画家</td>\n<td>Paul Graham</td>\n<td>3</td>\n<td></td>\n</tr>\n<tr>\n<td>5</td>\n<td>延长万物之尺</td>\n<td>保罗.汉弗莱斯</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>6</td>\n<td>Effective Debugging</td>\n<td>Diomidis Spinellis</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>7</td>\n<td>跨越鸿沟</td>\n<td>Geoffrey Moore</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>8</td>\n<td>微软团队成功墨诀</td>\n<td>麦卡锡</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>9</td>\n<td>开源软件之道</td>\n<td>蔡俊杰</td>\n<td>3</td>\n<td></td>\n</tr>\n<tr>\n<td>10</td>\n<td>计算机英语教程双色版</td>\n<td>张强华</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>11</td>\n<td>设计领导力</td>\n<td>Richard Banfield</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>12</td>\n<td>开源软件与专有软件的竞争</td>\n<td>王广凤</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>13</td>\n<td>程序员代码面试指南第二版</td>\n<td>左程云</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>14</td>\n<td>剑指Offer 第二版</td>\n<td>何海涛</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>15</td>\n<td>OKR工作法-谷歌等顶级公司高绩效秘籍</td>\n<td>沃特克</td>\n<td>3</td>\n<td></td>\n</tr>\n<tr>\n<td>16</td>\n<td>程序员的成长课</td>\n<td>安晓辉等</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>17</td>\n<td>Java程序员面试算法宝典</td>\n<td>猿媛之家</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>18</td>\n<td>程序员面试金典 第六版</td>\n<td>盖尔-拉克曼</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>19</td>\n<td>开源法则</td>\n<td>何宝宏博士</td>\n<td>4</td>\n<td></td>\n</tr>\n<tr>\n<td>20</td>\n<td>计算机英语 第五版</td>\n<td>刘艺</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>21</td>\n<td>研究是一门艺术 第四版</td>\n<td>Wayne C. Booth</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>22</td>\n<td>程序员的英语</td>\n<td>[韩]朴栽浒</td>\n<td>0</td>\n<td></td>\n</tr>\n</tbody></table>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"绪论\"><a href=\"#绪论\" class=\"headerlink\" title=\"绪论\"></a>绪论</h1><p>突发奇想，想对买过技术书单进行汇总。看看自己都买过哪些书，哪些看了，哪些没看。以后买的书也会进行汇总。</p>\n<p>总结了我最喜欢的十本书，它的顺序和书可能在变，但是是对我个人启发较多的十本书。</p>\n<ol>\n<li>分布式系统原理与范型 第二版 / 分布式系统概念与设计 第五版</li>\n<li>Effective Java 第三版</li>\n<li>Java并发编程实战</li>\n<li>高性能的MySQL第三版</li>\n<li>Spring系列: Expert One on one J2EE Development Without EJB/Expert One on one J2EE Design And Implement/Spring框架高级编程</li>\n<li>面向对象分析与设计 第三版</li>\n<li>UML和模式应用 第三版</li>\n<li>设计模式-可复用面向对象软件的基础</li>\n<li>Streaming System</li>\n<li>Designing Data-Intensive Applications: The Big Ideas Behind Reliable, Scalable, and Maintainable Systems</li>\n</ol>\n<h1 id=\"读后感\"><a href=\"#读后感\" class=\"headerlink\" title=\"读后感\"></a>读后感</h1><p><a href=\"https://xiaozhiliaoo.github.io/reading-note/\" target=\"_blank\" rel=\"noopener\">读书笔记-<strong>reading note</strong></a></p>\n<h1 id=\"书单汇总-共507本\"><a href=\"#书单汇总-共507本\" class=\"headerlink\" title=\"书单汇总(共507本)\"></a>书单汇总(共507本)</h1><p>最近统计时间：2023-01-12 总数<strong>507</strong>本。增加60本。</p>\n<p>最近统计时间：2022-03-31 总数<strong>507</strong>本。增加60本。</p>\n<p>最近统计时间：2021-12-12   总数<strong>447</strong>本。增加60本。</p>\n<p>最近统计时间：2021-08-26   总数<strong>387</strong>本。增加42本。</p>\n<p>最近统计时间：2021-07-14   总数<strong>345</strong>本。  增加25本。</p>\n<p>最近统计时间：2021-05-02  总数<strong>320</strong>本。 </p>\n<p>书单会以分类展示，并且写明作者，很多书的作者非常知名，阅读情况 会包含阅读时间(严重缺失)和阅读进度，阅读进度分为6级进行打分，<strong>0</strong>  没有读过，<strong>1</strong>  阅读25%  <strong>2</strong>, 50%  <strong>3</strong>, 75%  <strong>4</strong>,100%  <strong>5</strong>  读过多次 ， 书名加粗的是个人觉得非常好的经典书，值得多次阅读。汇总不好的一点是没有时间维度，后期读书时候会在阅读情况中加上。</p>\n<h2 id=\"计算机科学-37\"><a href=\"#计算机科学-37\" class=\"headerlink\" title=\"计算机科学(37)\"></a>计算机科学(37)</h2><table>\n<thead>\n<tr>\n<th>编号</th>\n<th>书名</th>\n<th>作者</th>\n<th>阅读情况</th>\n<th>读书笔记</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>操作系统概念第九版</td>\n<td>Abraham Silberschatz</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>2</td>\n<td>程序设计语言:设计与实现第四版</td>\n<td>Terrence W. Pratt</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>3</td>\n<td>数据库系统概念第五版</td>\n<td>Abraham Silberschatz</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>4</td>\n<td>Solaris内核结构第二版</td>\n<td>Richard McDougall</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>5</td>\n<td>Linux内核设计与实现-第三版</td>\n<td>Robert Love</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>6</td>\n<td>现代操作系统 英文第四版</td>\n<td>Abdrew S. Tanenbaum</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>7</td>\n<td>现代操作系统 中文第四版</td>\n<td>Abdrew S. Tanenbaum</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>8</td>\n<td>编译原理 英文第二版</td>\n<td>Alfred V.Aho</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>9</td>\n<td>分布式计算-原理，算法与实践</td>\n<td>Ajay Kshemkalyani</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>10</td>\n<td>分布式数据库系统及其应用第三版</td>\n<td>徐俊刚</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>11</td>\n<td>计算机网络 英文第五版</td>\n<td>Abdrew S. Tanenbaum</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>12</td>\n<td>计算机组成与汇编语言原理 英文版</td>\n<td>Patricj Juola</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>13</td>\n<td>算法第四版</td>\n<td>Robert Sedgewick</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>14</td>\n<td>程序设计语言-实践之路第三版</td>\n<td>Michael L. Soctt</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>15</td>\n<td>计算机网络-第五版</td>\n<td>Abdrew S. Tanenbaum</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>16</td>\n<td>软件工程-面向对象和传统的方法第八版</td>\n<td>Stephen R. Schach</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>17</td>\n<td><strong>分布式系统原理与范型 第二版</strong></td>\n<td>Abdrew S. Tanenbaum</td>\n<td>4</td>\n<td></td>\n</tr>\n<tr>\n<td>18</td>\n<td>多处理器编程的艺术 修订版</td>\n<td>Nir Shavit</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>19</td>\n<td>数据结构 Java版第四版</td>\n<td>叶核亚</td>\n<td>4</td>\n<td></td>\n</tr>\n<tr>\n<td>20</td>\n<td>数据结构与算法</td>\n<td>张铭</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>21</td>\n<td>算法设计与分析 第四版</td>\n<td>王晓东</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>22</td>\n<td>计算机组成与设计</td>\n<td>David A. Patterson等</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>23</td>\n<td>操作系统-精髓与设计原理</td>\n<td>William Stallings</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>24</td>\n<td>计算机程序的构造和解释</td>\n<td>Harold Abelson</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>25</td>\n<td>编译原理第二版</td>\n<td>Alfred V. Aho</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>26</td>\n<td>分布式系统概念与设计</td>\n<td>George Coulouris</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>27</td>\n<td>数据结构与算法 Java语言描述</td>\n<td>Mark Allen Weiss</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>28</td>\n<td>设计原本</td>\n<td>Frederick P. Brooks</td>\n<td>4</td>\n<td></td>\n</tr>\n<tr>\n<td>29</td>\n<td>数据库系统公司概念 第六版</td>\n<td>Abraham Silberschazta</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>30</td>\n<td>深入理解计算机系统</td>\n<td>Randal Bryant</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>31</td>\n<td>程序设计语言概念-第九版</td>\n<td>Robert W.Sebesta</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>32</td>\n<td>云计算与分布式系统</td>\n<td>Kai Hwang等</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>33</td>\n<td>算法心得（第二版）</td>\n<td>Henry.S Warren</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>34</td>\n<td>算法设计指南(第二版)</td>\n<td>Steven S.Skiena</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>35</td>\n<td>分布式数据系统原理(第三版)</td>\n<td>M.Tamer Ozsu</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>36</td>\n<td>计算机网络 系统方法 第五版</td>\n<td>Larry L. Peterson / Bruce S. Davie</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>37</td>\n<td>计算之魂</td>\n<td>吴军</td>\n<td>0</td>\n<td></td>\n</tr>\n</tbody></table>\n<h2 id=\"语言-61\"><a href=\"#语言-61\" class=\"headerlink\" title=\"语言(61)\"></a>语言(61)</h2><table>\n<thead>\n<tr>\n<th>编号</th>\n<th>书名</th>\n<th>作者</th>\n<th>阅读情况</th>\n<th>读书笔记</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>Beginnig Java Object从概念到代码第二版</td>\n<td>Jacquie Barker</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>2</td>\n<td>深入理解java虚拟机第二版</td>\n<td>Bill Venners</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>3</td>\n<td>Java脚本编程</td>\n<td>Dejan Bosanac</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>4</td>\n<td>七周七语言</td>\n<td>Bruce Tate</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>5</td>\n<td>Scala编程第三版</td>\n<td>Martin Odersky</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>6</td>\n<td>Perl语言入门</td>\n<td>Pandal L. Schwartz</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>7</td>\n<td>编程语言实现模式</td>\n<td>Terence Parr</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>8</td>\n<td>Practical Java</td>\n<td>Peter Haggar</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>9</td>\n<td>分布式Java应用基础与实践</td>\n<td>林昊</td>\n<td>4</td>\n<td></td>\n</tr>\n<tr>\n<td>10</td>\n<td>深入浅出NodeJS</td>\n<td>朴灵</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>11</td>\n<td>七周七并发</td>\n<td>Paul Butcher</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>12</td>\n<td>Java加密与解密的艺术 第二版</td>\n<td>梁栋</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>13</td>\n<td>Living Clojure</td>\n<td>Carin Meier</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>14</td>\n<td>领域特定语言</td>\n<td>Martin Fowler</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>15</td>\n<td>精通正则表达式</td>\n<td>Jeffrey Friedl</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>16</td>\n<td>ANTLR4权威指南</td>\n<td>Terence Parr</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>17</td>\n<td>Java并发编程从入门到精通</td>\n<td>张振华</td>\n<td>4</td>\n<td></td>\n</tr>\n<tr>\n<td>18</td>\n<td>Go程序设计语言 英文版</td>\n<td>Alan A. Donovan</td>\n<td>3</td>\n<td></td>\n</tr>\n<tr>\n<td>19</td>\n<td>Lua设计与实现</td>\n<td>codedump</td>\n<td>3</td>\n<td></td>\n</tr>\n<tr>\n<td>20</td>\n<td><strong>Effective Java 第二版</strong></td>\n<td>Joshua Bloch</td>\n<td>5</td>\n<td></td>\n</tr>\n<tr>\n<td>21</td>\n<td><strong>Effective Java 第三版</strong></td>\n<td>Joshua Bloch</td>\n<td>5</td>\n<td></td>\n</tr>\n<tr>\n<td>22</td>\n<td>Java并发编程的艺术</td>\n<td>方腾飞</td>\n<td>3</td>\n<td></td>\n</tr>\n<tr>\n<td>23</td>\n<td>虚拟机设计与实现-以JVM为例</td>\n<td>李晓峰</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>24</td>\n<td>Java多线程编程实战指南-设计模式-第二版</td>\n<td>黄文海</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>25</td>\n<td>Java并发实现原理-JDK源码剖析</td>\n<td>余春龙</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>26</td>\n<td><strong>Java并发编程实战</strong></td>\n<td>Brian Goetz</td>\n<td>5</td>\n<td></td>\n</tr>\n<tr>\n<td>27</td>\n<td><strong>深入理解Java虚拟机第二版</strong></td>\n<td>周志明</td>\n<td>5</td>\n<td></td>\n</tr>\n<tr>\n<td>28</td>\n<td><strong>深入理解Java虚拟机第三版</strong></td>\n<td>周志明</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>29</td>\n<td>Java并发设计模式</td>\n<td>Doug Lea</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>30</td>\n<td>实战Java高并发程序设计</td>\n<td>葛一鸣</td>\n<td>3</td>\n<td></td>\n</tr>\n<tr>\n<td>31</td>\n<td>精通Lambda表达式</td>\n<td>Maurice Naftalin</td>\n<td>3</td>\n<td></td>\n</tr>\n<tr>\n<td>32</td>\n<td>Java编程思想第四版</td>\n<td>Bruce Eckel</td>\n<td>4</td>\n<td></td>\n</tr>\n<tr>\n<td>33</td>\n<td>函数式编程思维</td>\n<td>Neal Ford</td>\n<td>3</td>\n<td></td>\n</tr>\n<tr>\n<td>34</td>\n<td>Java解惑</td>\n<td>Joshua Bloch</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>35</td>\n<td>Java性能优化权威指南</td>\n<td>Charlie Hunt</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>36</td>\n<td>Java技术手册</td>\n<td>Benjamin J. Evans</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>37</td>\n<td>Java虚拟机规范（JavaSE8）</td>\n<td>Tim Lindholm等</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>38</td>\n<td>Java性能权威指南</td>\n<td>Scott Oaks</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>39</td>\n<td>Java虚拟机并发编程</td>\n<td>Venkat Subramaniam</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>40</td>\n<td>Java编程方法论-响应式rxjava</td>\n<td>知秋</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>41</td>\n<td>Java编程方法论-spring-reactor</td>\n<td>知秋</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>42</td>\n<td>Spring响应式编程</td>\n<td></td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>43</td>\n<td>RxJava反应式编程</td>\n<td>张卫滨翻译</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>44</td>\n<td>Java8函数式编程</td>\n<td>Richard Warbuton</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>45</td>\n<td>Rxjava2.x实战</td>\n<td>沈哲</td>\n<td>4</td>\n<td></td>\n</tr>\n<tr>\n<td>46</td>\n<td>Java9模块化开发：核心原则与实践</td>\n<td>Sander Mark</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>47</td>\n<td>ECMAScript 2018快速入门</td>\n<td>黄灯桥</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>48</td>\n<td>Java网络编程</td>\n<td>Elliotte Rusty Harold)]</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>49</td>\n<td>Java程序性能优化</td>\n<td>葛一鸣</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>50</td>\n<td>Go语言高级编程</td>\n<td>柴树杉</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>51</td>\n<td>Go语言底层原理剖析</td>\n<td>郑建勋</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>52</td>\n<td>深入学习Go语言</td>\n<td>李晓钧</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>53</td>\n<td>C语言程序设计-现代方法</td>\n<td>K.N.King</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>54</td>\n<td>Go程序设计语言</td>\n<td>Alan Donovan</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>55</td>\n<td>Rust权威指南</td>\n<td>Steve Klabnik / Carol Nichols</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>56</td>\n<td>C++ Primer 中文版（第五版）</td>\n<td>Stanley B. Lippman</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>57</td>\n<td>C++ Primer 习题集</td>\n<td>Stanley B. Lippman</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>58</td>\n<td>latex入门</td>\n<td>刘海洋</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>59</td>\n<td>Koltin实战</td>\n<td>Dmitry Jemerov</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>60</td>\n<td>Grovvy程序设计</td>\n<td>Venkat Subramaniam</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>61</td>\n<td><strong>Effective Java 第三版英文版</strong></td>\n<td>Joshua Bloch</td>\n<td>0</td>\n<td></td>\n</tr>\n</tbody></table>\n<h2 id=\"数据库-47\"><a href=\"#数据库-47\" class=\"headerlink\" title=\"数据库(47)\"></a>数据库(47)</h2><table>\n<thead>\n<tr>\n<th>编号</th>\n<th>书名</th>\n<th>作者</th>\n<th>阅读情况</th>\n<th>读书笔记</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>高性能的MySQL第三版</td>\n<td>Perter Zaitsev等</td>\n<td>3</td>\n<td></td>\n</tr>\n<tr>\n<td>2</td>\n<td>高可用的MySQL第二版</td>\n<td>Charles Bell</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>3</td>\n<td>深入理解MySQL核心技术</td>\n<td>Sasha Pachev</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>4</td>\n<td>HBase权威指南</td>\n<td>Lars George</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>5</td>\n<td>海量数据库解决方案</td>\n<td>韩.李华植</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>6</td>\n<td>数据库事务处理的艺术</td>\n<td>李海翔</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>7</td>\n<td>Effective MySQL之深入解析复制技术</td>\n<td>Ronald Bradford</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>8</td>\n<td>Effective MySQL之SQL语句最优化</td>\n<td>Ronald Bradford</td>\n<td>4</td>\n<td></td>\n</tr>\n<tr>\n<td>9</td>\n<td>MySQL技术内幕：InnoDB存储引擎</td>\n<td>姜承尧</td>\n<td>4</td>\n<td></td>\n</tr>\n<tr>\n<td>10</td>\n<td>数据库系统内幕</td>\n<td>Alex Petrov</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>11</td>\n<td>数据密集型应用系统设计</td>\n<td>Martin Kleppmann</td>\n<td>3</td>\n<td></td>\n</tr>\n<tr>\n<td>12</td>\n<td>NoSQL精粹</td>\n<td>Martin Flower</td>\n<td>3</td>\n<td></td>\n</tr>\n<tr>\n<td>13</td>\n<td>数据库索引设计与优化</td>\n<td>Michael Leach等</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>14</td>\n<td>Cassandra权威指南第二版</td>\n<td>Jeff Carpenter</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>15</td>\n<td>Greenplum:从大数据战略到实现</td>\n<td>冯雷</td>\n<td>3</td>\n<td></td>\n</tr>\n<tr>\n<td>16</td>\n<td>Clickhouse原理解析与应用实践</td>\n<td>朱凯</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>17</td>\n<td>MySQL技术内幕：SQL编程</td>\n<td>姜承尧</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>18</td>\n<td>Druid实时大数据分析</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>19</td>\n<td>图数据库</td>\n<td>Ian Robinson</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>20</td>\n<td>企业级大数据平台构建：架构与实现</td>\n<td>朱凯</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>21</td>\n<td>Apache Kylin权威指南</td>\n<td>Apache Kylin核心团队</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>22</td>\n<td>数据仓储-第四版</td>\n<td>Inmon W.H</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>23</td>\n<td>大数据平台基础架构指南</td>\n<td>刘旭辉</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>24</td>\n<td>MySQL管理之道（第二版）性能调优，高可用与监控</td>\n<td>贺春旸</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>25</td>\n<td>Hikaricp数据库连接池实战</td>\n<td>朱政科</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>26</td>\n<td>精通LevelDB</td>\n<td>廖环宇</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>27</td>\n<td>数据库重构</td>\n<td>Scott W. Ambler</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>28</td>\n<td>MySQL是怎样运行的？</td>\n<td>小孩子4919</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>29</td>\n<td>解读NoSQL</td>\n<td>Dan McCreary</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>30</td>\n<td>大数据挑战与NoSQL数据技术</td>\n<td>陆嘉恒</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>31</td>\n<td>分布式数据库原理 架构与实践</td>\n<td>李海翔</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>32</td>\n<td>分布式数据库系统原理 第三版</td>\n<td><a href=\"https://cs.uwaterloo.ca/~tozsu/\" target=\"_blank\" rel=\"noopener\">M. Tamer Özsu</a> <a href=\"http://www-sop.inria.fr/members/Patrick.Valduriez/\" target=\"_blank\" rel=\"noopener\">Patrick Valduriez</a></td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>33</td>\n<td>七周七数据库</td>\n<td>Eric Redmond</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>34</td>\n<td>对象存储实战指南</td>\n<td>罗庆超</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>35</td>\n<td>数据分析之图算法：基于spark和neo4j</td>\n<td>Mark Needham</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>36</td>\n<td>分布式对象存储 原理 架构以及Go语言实现</td>\n<td>胡世杰</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>37</td>\n<td>云数据库架构</td>\n<td>朱明</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>38</td>\n<td>大数据日知录</td>\n<td>张俊林</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>39</td>\n<td>云原生数据库 原理与最佳实践</td>\n<td>阿里巴巴</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>40</td>\n<td>postgresql指南</td>\n<td>【日】铃木启修</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>41</td>\n<td>数据库系统实现</td>\n<td>Hector Garcia-Molina</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>42</td>\n<td>Design Data Intensive Application</td>\n<td>Martin Kleppmann</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>43</td>\n<td>分布式数据库系统：大数据时代新型数据库技术</td>\n<td></td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>44</td>\n<td>分布式 云计算 大数据</td>\n<td>林伟伟</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>45</td>\n<td>寻路大数据</td>\n<td>Michael Manoochehri</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>46</td>\n<td>大数据技术与应用：数据密集型计算和模型</td>\n<td></td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>47</td>\n<td>数据库系统，设计 实现与管理 基础篇</td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h2 id=\"分布式与中间件-110\"><a href=\"#分布式与中间件-110\" class=\"headerlink\" title=\"分布式与中间件(110)\"></a>分布式与中间件(110)</h2><table>\n<thead>\n<tr>\n<th>编号</th>\n<th>书名</th>\n<th>作者</th>\n<th>阅读情况</th>\n<th>读书笔记</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>Rabbitmq实战指南</td>\n<td>朱忠华</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>2</td>\n<td>Lucene实战第二版</td>\n<td>Michael McCandless</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>3</td>\n<td>Docker实战</td>\n<td>Jeff Nickoloff</td>\n<td>3</td>\n<td></td>\n</tr>\n<tr>\n<td>4</td>\n<td>深入剖析Nginx</td>\n<td>高群凯</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>5</td>\n<td>Http权威指南</td>\n<td>David Gourley等</td>\n<td>3</td>\n<td></td>\n</tr>\n<tr>\n<td>6</td>\n<td>Http/2基础教程</td>\n<td>Stephen Ludin</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>7</td>\n<td>Docker进阶与实战</td>\n<td>华为</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>8</td>\n<td>Etcd技术内幕</td>\n<td>百丽燊<strong>shēn</strong></td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>9</td>\n<td>分布式数据库架构基于MyCat中间件</td>\n<td>周继锋等</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>10</td>\n<td>Web容量规划的艺术</td>\n<td>John Allspaw</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>11</td>\n<td>Mongodb实战第一版</td>\n<td>Kyle Banker</td>\n<td>3</td>\n<td></td>\n</tr>\n<tr>\n<td>12</td>\n<td>从Paxos到Zookeeper</td>\n<td>倪超</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>13</td>\n<td>Rabbitmq实战</td>\n<td>Alvaro Videla</td>\n<td>3</td>\n<td></td>\n</tr>\n<tr>\n<td>14</td>\n<td>Netty实战</td>\n<td>Morman Maurer</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>15</td>\n<td>Kafka权威指南</td>\n<td>Neha Narkhede</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>16</td>\n<td>Elsaticsearch服务器开发第二版</td>\n<td>Rafa Kuc</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>17</td>\n<td>分布式服务框架原理与实践</td>\n<td>李林锋</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>18</td>\n<td>大型网站系统与Java中间件实践</td>\n<td>曾宪杰</td>\n<td>4</td>\n<td></td>\n</tr>\n<tr>\n<td>19</td>\n<td>Kubernetes in Action</td>\n<td>Marko Luksa</td>\n<td>3</td>\n<td></td>\n</tr>\n<tr>\n<td>20</td>\n<td>Java RESTful Web Service实战第二版</td>\n<td>韩陆</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>21</td>\n<td>Zookeeper 分布式过程协同技术详解</td>\n<td>Flavio Junqueira</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>22</td>\n<td>深入分析Java Web技术内幕 修订版</td>\n<td>许令波</td>\n<td>4</td>\n<td></td>\n</tr>\n<tr>\n<td>23</td>\n<td>Redis实战</td>\n<td>Josiah L. Carlson</td>\n<td>4</td>\n<td></td>\n</tr>\n<tr>\n<td>24</td>\n<td>Redis设计与实现</td>\n<td>黄健宏</td>\n<td>4</td>\n<td></td>\n</tr>\n<tr>\n<td>25</td>\n<td>大规模分布式系统架构与设计实战</td>\n<td>彭渊</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>26</td>\n<td>大规模分布式存储系统原理解析和架构实战</td>\n<td>杨传辉</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>27</td>\n<td>分布式消息中间件实践</td>\n<td>倪伟</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>28</td>\n<td>深入分布式缓存-从原理到实践</td>\n<td>于君泽等</td>\n<td>3</td>\n<td></td>\n</tr>\n<tr>\n<td>29</td>\n<td>分布式系统应用设计</td>\n<td>Brendan Burns</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>30</td>\n<td>企业集成模式-设计构建及部署消息传递解决方案</td>\n<td>Gregor Hohpe</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>31</td>\n<td>NoSQL数据库技术实战</td>\n<td>皮雄军</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>32</td>\n<td>反应式设计模式</td>\n<td>何品等翻译</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>33</td>\n<td>Redis5设计与源码分析</td>\n<td>陈雷</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>34</td>\n<td>Redis深度历险</td>\n<td>钱文品</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>35</td>\n<td>Akka入门和实践</td>\n<td>Jason Goodwin</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>36</td>\n<td>Akka实战：快速构建高可用分布式应用</td>\n<td>杜云飞</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>37</td>\n<td>响应式架构消息模式Actor实现与Scala应用集成</td>\n<td>Vaughn Vernon</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>38</td>\n<td>Apache Kafka实战</td>\n<td>胡夕</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>39</td>\n<td>深入理解Apache kafka核心设计与实践原理</td>\n<td>朱忠华</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>40</td>\n<td>Apache kafka源码剖析</td>\n<td>徐郡明</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>41</td>\n<td>实战Gradle</td>\n<td>Benjamin Muschko</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>42</td>\n<td>Elasticssearch源码解析与优化实战</td>\n<td>张超</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>43</td>\n<td>深入理解Elasticsearch第三版</td>\n<td>波哈维</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>44</td>\n<td>Elasticssearch实战</td>\n<td>Radu Gheorghe</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>45</td>\n<td>离线和实时大数据开发实战</td>\n<td>朱松岭</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>46</td>\n<td>Springboot解密</td>\n<td>王福强</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>47</td>\n<td>Hbase实战</td>\n<td>Nick Dimiduk</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>48</td>\n<td>尽在双十一</td>\n<td>双十一团队</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>49</td>\n<td>大型系统应用架构实战部署，容灾性能优化</td>\n<td>李彦超</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>50</td>\n<td>Storm分布式实时计算模式</td>\n<td>P.Taylor Goetz</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>51</td>\n<td>Spark核心技术与高级应用</td>\n<td>于俊</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>52</td>\n<td>Hadoop技术内幕</td>\n<td>董西成</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>53</td>\n<td>RocketMq技术内幕</td>\n<td>丁威</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>54</td>\n<td>大数据之路阿里巴巴大数据实践</td>\n<td>阿里巴巴数据技术及产品部</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>55</td>\n<td>大数据技术体系详解 原理架构与实践</td>\n<td>董西成</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>56</td>\n<td>深度剖析HadoopHDFS</td>\n<td>林意群</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>57</td>\n<td>数据仓储工具箱：维度建模指南</td>\n<td>Ralph Kimball</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>58</td>\n<td>深入理解Flink：实时大数据处理实践</td>\n<td>余海峰</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>59</td>\n<td>分布式实时处理系统：原理，架构与实现</td>\n<td>卢誉声</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>60</td>\n<td>分布式一致性算法开发实战</td>\n<td>赵辰</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>61</td>\n<td>KafkaStream实战</td>\n<td>William Bejeck</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>62</td>\n<td>akka应用模式：分布式应用程序设计实践指南</td>\n<td>Michael Nash</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>63</td>\n<td>flink基础教程</td>\n<td>Tzoumas</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>64</td>\n<td>akka实战（akka in action）</td>\n<td></td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>65</td>\n<td>Hadoop技术内幕：深入解析YARN架构设计与实现原理</td>\n<td>董西成</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>66</td>\n<td>Hadoop技术内幕：深入解析Hadoop Common和HDFS架构设计ui实现原理</td>\n<td>蔡斌</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>67</td>\n<td>大数据基础编程：实践和案例教程-第二版</td>\n<td>林子雨</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>68</td>\n<td>大数据实训案例：电信用户行为分析</td>\n<td>林子雨</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>69</td>\n<td>大数据实训案例：电影推荐系统Scala版</td>\n<td>林子雨</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>70</td>\n<td>疯狂VirtualBox实战讲学录</td>\n<td>小耗子</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>71</td>\n<td>走进搜索引擎（第二版）</td>\n<td>潘学峰</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>72</td>\n<td>gRPC与云原生应用开发 以Go和Java为例</td>\n<td>Kasun Indrasiri</td>\n<td>4</td>\n<td></td>\n</tr>\n<tr>\n<td>73</td>\n<td>深入理解RPC框架原理与实现</td>\n<td>华钟明</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>74</td>\n<td>分布式事务之Seata</td>\n<td>姜宇</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>75</td>\n<td>分布式缓存 原理架构及Go语言实现</td>\n<td>胡世杰</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>76</td>\n<td>深入理解分布式事务：原理与实践</td>\n<td>冰河</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>77</td>\n<td>分布式系统与一致性</td>\n<td>陈东明</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>78</td>\n<td>分布式系统设计实践</td>\n<td>李庆旭</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>79</td>\n<td>日志管理与分析权威指南</td>\n<td>Anton A. Chuvakin</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>80</td>\n<td>搜索引擎：信息检索实践</td>\n<td>W.Bruce Croft</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>81</td>\n<td>搜索引擎-原理技术与系统（第二版）</td>\n<td>李晓明</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>82</td>\n<td>自制搜索引擎</td>\n<td>[日]山田浩之</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>83</td>\n<td>这就是搜索引擎：核心技术详解</td>\n<td>张俊林</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>84</td>\n<td>解密搜索引擎技术实战 : Lucene&amp;Java精华版（第3版）</td>\n<td>罗刚</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>85</td>\n<td>信息检索导论（修订版）</td>\n<td>Prabhakar Raghavan</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>86</td>\n<td>自己动手写Java虚拟机</td>\n<td>张秀宏</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>87</td>\n<td>深入理解分布式系统</td>\n<td>唐伟志</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>88</td>\n<td>HBase应用架构</td>\n<td>Jean-Marc Spaggiari</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>89</td>\n<td>深入解析apache pulsar</td>\n<td>林琳</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>90</td>\n<td>深入集群-大型数据中心资源调度与管理</td>\n<td>李雨前</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>91</td>\n<td>ceph企业级分布式存储 原理与工程实践</td>\n<td>龚向宇</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>92</td>\n<td>Linux开源网络全栈详解</td>\n<td></td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>93</td>\n<td>分布式操作系统原理与实践</td>\n<td>Doreen L. Galli</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>94</td>\n<td>NoSQL权威指南</td>\n<td>[美] 乔·塞科</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>95</td>\n<td>Ceph分布式存储学习指南</td>\n<td>[(芬兰)卡伦·辛格</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>96</td>\n<td>大数据系统构建：可扩展实时数据系统构建原理与最佳实践</td>\n<td>Nathan Marz</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>97</td>\n<td>流式架构 kafka和mapr streams数据流处理</td>\n<td>Ted Dunning</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>98</td>\n<td>流式系统 Streaming System</td>\n<td>Tyler Akidau / Slava Chernyak / Reuven Lax</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>99</td>\n<td>Hadoop应用架构</td>\n<td>Mark Grover</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>100</td>\n<td>Hadoop权威指南 第四版</td>\n<td>Tom white</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>101</td>\n<td>基于Apache Flink的流处理： 流式应用基础、实现及操作</td>\n<td></td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>102</td>\n<td>Spark权威指南</td>\n<td>Bill Chambers</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>103</td>\n<td>数据中台：基于Google Facebook和微博实践</td>\n<td>詹盈</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>104</td>\n<td>Hive编程指南</td>\n<td>Edward Capriolo</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>105</td>\n<td>MapReduce设计模式</td>\n<td>Donald Miner</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>106</td>\n<td>Spark快速大数据分析</td>\n<td>Holden Karau</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>107</td>\n<td>OpenTSDB技术内幕</td>\n<td>百里燊</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>108</td>\n<td>NoSQL实践指南</td>\n<td>Dan Sullivan</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>109</td>\n<td>Mesos实战</td>\n<td>Roger Ignazio</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>110</td>\n<td>MongoDB权威指南 第二版</td>\n<td>Kristina Chodorow</td>\n<td>0</td>\n<td></td>\n</tr>\n</tbody></table>\n<h2 id=\"框架-21\"><a href=\"#框架-21\" class=\"headerlink\" title=\"框架(21)\"></a>框架(21)</h2><table>\n<thead>\n<tr>\n<th>编号</th>\n<th>书名</th>\n<th>作者</th>\n<th>阅读情况</th>\n<th>读书笔记</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>重新定义SpringCloud实战</td>\n<td>许进等</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>2</td>\n<td>Spring实现第四版</td>\n<td>Craig Walls</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>3</td>\n<td>J2EE核心模式第二版</td>\n<td>Deepak Alur</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>4</td>\n<td>精通Spring4.0企业应用开发实战</td>\n<td>陈雄华等</td>\n<td>3</td>\n<td></td>\n</tr>\n<tr>\n<td>5</td>\n<td>Java WebSocket编程</td>\n<td>Danny Coward</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>6</td>\n<td>Spring框架高级编程</td>\n<td>Rod Johnson等</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>7</td>\n<td>Mybatis技术内幕</td>\n<td>徐郡明</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>8</td>\n<td>Spring技术内幕第二版</td>\n<td>计文柯</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>9</td>\n<td>Spring源码深度解析第二版</td>\n<td>郝佳</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>10</td>\n<td>深入理解SpringMVC源代码</td>\n<td>王耀</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>11</td>\n<td><strong>Expert One on one J2EE Development Without EJB</strong></td>\n<td>Rod Johnson等</td>\n<td>3</td>\n<td></td>\n</tr>\n<tr>\n<td>12</td>\n<td><strong>Expert One on one J2EE Design And Implement</strong></td>\n<td>Rod Johnson</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>13</td>\n<td>软件框架设计的艺术</td>\n<td>Jaroslav Tulach</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>14</td>\n<td>.NET设计规范，约定，惯用法与模式</td>\n<td>Krzysztof Cwalina</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>15</td>\n<td>iBatis实战</td>\n<td>Clinton Begin</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>16</td>\n<td>GraphQL实战写给全栈工程师们</td>\n<td>王北南</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>17</td>\n<td>SpringData实战</td>\n<td></td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>18</td>\n<td>深入浅出MyBatis技术原理与实战</td>\n<td>杨开振</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>19</td>\n<td>Apache ShardingSphere实战</td>\n<td>郑天民</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>20</td>\n<td>Webassembly实战</td>\n<td>C. Gerard Gallant</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>21</td>\n<td>反应式应用开发</td>\n<td>Duncan DeVore</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>22</td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<h2 id=\"架构-59\"><a href=\"#架构-59\" class=\"headerlink\" title=\"架构(59)\"></a>架构(59)</h2><table>\n<thead>\n<tr>\n<th>编号</th>\n<th align=\"left\">书名</th>\n<th>作者</th>\n<th>阅读情况</th>\n<th>读书笔记</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td align=\"left\">从0开始学架构</td>\n<td>李运华</td>\n<td>4</td>\n<td></td>\n</tr>\n<tr>\n<td>2</td>\n<td align=\"left\">大型网站技术架构-核心原理与案例分析</td>\n<td>李智慧</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>3</td>\n<td align=\"left\">软考：软件设计师教程</td>\n<td>诸华</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>4</td>\n<td align=\"left\">大数据技术原理与应用第二版</td>\n<td>林子雨</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>5</td>\n<td align=\"left\">企业IT架构转型之道</td>\n<td>钟华</td>\n<td>3</td>\n<td></td>\n</tr>\n<tr>\n<td>6</td>\n<td align=\"left\">Kubernates权威指南纪念版</td>\n<td>垄正等</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>7</td>\n<td align=\"left\">构建实时机器学习系统</td>\n<td>彭江森</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>8</td>\n<td align=\"left\">云系统管理-大规模分布式系统设计与运营</td>\n<td>Thomas A.Limoncelli</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>9</td>\n<td align=\"left\">恰如其分的软件架构</td>\n<td>George Fairbanks</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>10</td>\n<td align=\"left\">软件架构设计</td>\n<td>温昱</td>\n<td>4</td>\n<td></td>\n</tr>\n<tr>\n<td>11</td>\n<td align=\"left\">软件架构设计-第二版</td>\n<td>温昱</td>\n<td>3</td>\n<td></td>\n</tr>\n<tr>\n<td>12</td>\n<td align=\"left\">进化：运维技术变革与实践探索</td>\n<td>赵成</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>13</td>\n<td align=\"left\">企业应用架构模式</td>\n<td>Martin Flower</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>14</td>\n<td align=\"left\">Paas程序设计</td>\n<td>Lucas Carlson</td>\n<td>4</td>\n<td></td>\n</tr>\n<tr>\n<td>15</td>\n<td align=\"left\">让云落地 云计算服务模式</td>\n<td>Michael Kavis</td>\n<td>4</td>\n<td></td>\n</tr>\n<tr>\n<td>16</td>\n<td align=\"left\">架构之美</td>\n<td>Diomidis Spinellis</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>17</td>\n<td align=\"left\">软件构架编档</td>\n<td>Paul Clements等</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>18</td>\n<td align=\"left\">IT架构思维</td>\n<td>Peter Beijer等</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>19</td>\n<td align=\"left\">架构整洁之道</td>\n<td>Robert C.Martin</td>\n<td>4</td>\n<td></td>\n</tr>\n<tr>\n<td>20</td>\n<td align=\"left\">云计算架构设计模式</td>\n<td>Alex Homer等</td>\n<td>3</td>\n<td></td>\n</tr>\n<tr>\n<td>21</td>\n<td align=\"left\">简单之美 软件开发实践者的思考</td>\n<td>倪健</td>\n<td>4</td>\n<td></td>\n</tr>\n<tr>\n<td>22</td>\n<td align=\"left\">架构即未来</td>\n<td>Martin L.Abbott</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>23</td>\n<td align=\"left\">高扩展性网站的50条原则</td>\n<td>Martin L.Abbott</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>24</td>\n<td align=\"left\">持续集成-软件质量改进的风险降低之道</td>\n<td>Paul M. Duvall</td>\n<td>2</td>\n<td><a href=\"https://xiaozhiliaoo.github.io/2020/11/28/CI-Book-Reading/\" target=\"_blank\" rel=\"noopener\">notes</a></td>\n</tr>\n<tr>\n<td>25</td>\n<td align=\"left\">持续交付-发布可靠软件的系统方法</td>\n<td>Jez Humble</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>26</td>\n<td align=\"left\">演进式架构</td>\n<td>Neal Ford</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>27</td>\n<td align=\"left\">Tomcat架构解析</td>\n<td>刘光瑞</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>28</td>\n<td align=\"left\">白帽子讲Web安全</td>\n<td>吴翰清</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>29</td>\n<td align=\"left\">深入浅出大型网站架构设计</td>\n<td>李力非</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>30</td>\n<td align=\"left\">程序员必读软件架构</td>\n<td>Simon Brown</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>31</td>\n<td align=\"left\">代码之美</td>\n<td>Oram Wilson</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>32</td>\n<td align=\"left\">Prometheus云原生监控</td>\n<td>朱政科-阿里巴巴</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>33</td>\n<td align=\"left\">Apache SkyWalking实战</td>\n<td>吴晟</td>\n<td>4</td>\n<td></td>\n</tr>\n<tr>\n<td>34</td>\n<td align=\"left\">Cloud Foundry：从数字化战略到实现</td>\n<td>冯雷</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>35</td>\n<td align=\"left\">逆流而上：阿里巴巴技术成长之路</td>\n<td>阿里巴巴成长编委会</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>36</td>\n<td align=\"left\">淘宝技术这十年</td>\n<td>子柳</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>37</td>\n<td align=\"left\">架构解密：从分布式到微服务</td>\n<td>leader Us</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>38</td>\n<td align=\"left\">亿级流量网站架构核心技术</td>\n<td>张开涛</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>39</td>\n<td align=\"left\">分布式服务架构：原理，设计与实战</td>\n<td>李艳鹏</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>40</td>\n<td align=\"left\">微服务治理 体系 结构及实践</td>\n<td>李鑫</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>41</td>\n<td align=\"left\">微服务之道:度量驱动开发</td>\n<td>范亚敏</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>42</td>\n<td align=\"left\">数字化转型的道与术</td>\n<td>钟华</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>43</td>\n<td align=\"left\">业务架构  业务架构，应用架构，数据架构</td>\n<td>温昱</td>\n<td>4</td>\n<td></td>\n</tr>\n<tr>\n<td>44</td>\n<td align=\"left\">大型网站性能优化实战</td>\n<td>周涛明</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>45</td>\n<td align=\"left\">大型网站技术架构演进与性能优化</td>\n<td>许令波</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>46</td>\n<td align=\"left\">架构修炼之道：亿级网关，平台开放</td>\n<td>王新栋</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>47</td>\n<td align=\"left\">分布式一致性算法开发实战</td>\n<td>赵辰</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>48</td>\n<td align=\"left\">大数据技术原理与应用第三版</td>\n<td>林子雨</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>49</td>\n<td align=\"left\">代码里的世界观：通往架构师之路</td>\n<td>余叶</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>50</td>\n<td align=\"left\">软件架构</td>\n<td>沙巴纳</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>51</td>\n<td align=\"left\">前端工程化：体系设计与实践</td>\n<td>周俊鹏</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>52</td>\n<td align=\"left\">可伸缩架构 第二版</td>\n<td>张若飞</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>53</td>\n<td align=\"left\">凤凰架构</td>\n<td>周志明</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>54</td>\n<td align=\"left\">AWS云计算实战</td>\n<td>安德烈亚斯·威蒂格</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>55</td>\n<td align=\"left\">大数据技术架构-核心原理与应用实践</td>\n<td>李智慧-极客时间专栏</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>56</td>\n<td align=\"left\">企业数字化基石-阿里巴巴云计算基础设施实践</td>\n<td>阿里巴巴</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>57</td>\n<td align=\"left\">阿里云原生架构实践</td>\n<td>阿里巴巴</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>58</td>\n<td align=\"left\">云原生架构：从技术演进到最佳实践</td>\n<td>贺阮云</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>59</td>\n<td align=\"left\">分布式架构原理与实践</td>\n<td>崔浩</td>\n<td>0</td>\n<td></td>\n</tr>\n</tbody></table>\n<h2 id=\"软件工程-71\"><a href=\"#软件工程-71\" class=\"headerlink\" title=\"软件工程(71)\"></a>软件工程(71)</h2><table>\n<thead>\n<tr>\n<th>编号</th>\n<th>书名</th>\n<th>作者</th>\n<th>阅读情况</th>\n<th>读书笔记</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>超越软件架构</td>\n<td>Luke Hohmann</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>2</td>\n<td>重构与模式</td>\n<td>Joshua Kerievsky</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>3</td>\n<td>Contributing To Eclipse</td>\n<td>Erich Gamma&amp;Kent Beck</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>4</td>\n<td>软件工艺</td>\n<td>Pete McBreen</td>\n<td>3</td>\n<td></td>\n</tr>\n<tr>\n<td>5</td>\n<td>程序员修炼之道从小工到专家</td>\n<td>Andrew Hunt</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>6</td>\n<td><strong>面向对象分析与设计第二版</strong></td>\n<td>Grady Booch</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>7</td>\n<td><strong>面向对象分析与设计第三版</strong></td>\n<td>Grady Booch</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>8</td>\n<td>人月神话</td>\n<td>Frederick P. Brooks</td>\n<td>4</td>\n<td></td>\n</tr>\n<tr>\n<td>9</td>\n<td>敏捷中国史话</td>\n<td>熊节</td>\n<td>4</td>\n<td></td>\n</tr>\n<tr>\n<td>10</td>\n<td>软件开发本质论</td>\n<td>Ron Jeffries</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>11</td>\n<td>大教堂与集市</td>\n<td>Eric Raymond</td>\n<td>4</td>\n<td></td>\n</tr>\n<tr>\n<td>12</td>\n<td>快速软件开发</td>\n<td>Steve McConnell</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>13</td>\n<td>程序开发心理学</td>\n<td>Gerald Weinberg</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>14</td>\n<td>个体软件工程</td>\n<td>Watts S. Humphrey</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>15</td>\n<td>走出软件工坊</td>\n<td>阿朱</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>16</td>\n<td>UNIX编程艺术</td>\n<td>Eric S.Raymond</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>17</td>\n<td>解析极限编程-拥抱变化第一版</td>\n<td>Kent Beck</td>\n<td>3</td>\n<td></td>\n</tr>\n<tr>\n<td>18</td>\n<td>敏捷软件开发-原则，模式-实践</td>\n<td>Robert C.Martin</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>19</td>\n<td><strong>实现模式</strong></td>\n<td>Kent Beck</td>\n<td>4</td>\n<td></td>\n</tr>\n<tr>\n<td>20</td>\n<td>面向模式的软件架构 资源管理模式</td>\n<td>Michael Kircher</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>21</td>\n<td>编程珠玑第二版</td>\n<td>Jon Bentley</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>22</td>\n<td>数据库访问模式</td>\n<td>Clifton Nock</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>23</td>\n<td>反模式-危机中的软件，架构和项目的重构</td>\n<td>William Brown</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>24</td>\n<td>面向对象项目的解决方案</td>\n<td>Grady Booch</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>25</td>\n<td>软件构架实践</td>\n<td>Len Bass</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>26</td>\n<td>面向模式的软件架构-模式系统第一卷</td>\n<td>Frank Buschmann</td>\n<td>3</td>\n<td></td>\n</tr>\n<tr>\n<td>27</td>\n<td>发布! 软件的设计与部署-第一版</td>\n<td>Michael T. Mygard</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>28</td>\n<td>发布! 软件的设计与部署-第二版</td>\n<td>Michael T. Mygard</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>29</td>\n<td>构建之法-现代软件工程0第三版</td>\n<td>邹欣</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>30</td>\n<td>混沌工程Netflix系统稳定性之道</td>\n<td>Casey Rosenthal等</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>31</td>\n<td>设计模式-可复用面向对象软件的基础</td>\n<td>GOF4</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>32</td>\n<td>精益软件度量</td>\n<td>张松</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>33</td>\n<td>测试驱动开发-英文版</td>\n<td>Kent Beck</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>34</td>\n<td>Xunit测试模式</td>\n<td>Gerard Meszaros</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>35</td>\n<td>Google软件测试之道</td>\n<td>James Whittaker</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>36</td>\n<td>UML用户指南</td>\n<td>Grady Booch</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>37</td>\n<td>敏捷革命</td>\n<td>Jeff Sutherland</td>\n<td>4</td>\n<td></td>\n</tr>\n<tr>\n<td>38</td>\n<td>看板方法-科技企业渐进变革成功之道</td>\n<td>David J. Anderson</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>39</td>\n<td>敏捷迭代开发-管理者指南</td>\n<td>Craig Larman</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>40</td>\n<td><strong>UML和模式应用第三版</strong></td>\n<td>Craig Larman</td>\n<td>3</td>\n<td></td>\n</tr>\n<tr>\n<td>41</td>\n<td>面向对象编程导论 第三版</td>\n<td>Timothy A. Budd</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>42</td>\n<td>编写有效用例</td>\n<td>Alistair Cockburn</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>43</td>\n<td>代码大全第二版</td>\n<td>Steve McConnell</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>44</td>\n<td>统一软件开发过程</td>\n<td>Ivar Jacobson</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>45</td>\n<td>用户故事与敏捷方法</td>\n<td>Mike Cohn</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>46</td>\n<td>面向快速交付的软件开发</td>\n<td>翟宏宝</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>47</td>\n<td>有效的单元测试</td>\n<td>Lasse Koskela</td>\n<td>0</td>\n<td>2020-12-15</td>\n</tr>\n<tr>\n<td>48</td>\n<td>构建高质量软件-程序开发人员测试指南</td>\n<td>Alexander Tarlinder</td>\n<td>0</td>\n<td>2020-12-22</td>\n</tr>\n<tr>\n<td>49</td>\n<td>程序员应该知道的97件事</td>\n<td>Kevlin Henney</td>\n<td>0</td>\n<td>2020-12-22</td>\n</tr>\n<tr>\n<td>50</td>\n<td>软件架构师应该知道的97件事</td>\n<td>Richard Monson-Haefel</td>\n<td>0</td>\n<td>2020-12-22</td>\n</tr>\n<tr>\n<td>51</td>\n<td>Cucumber行为驱动开发指南</td>\n<td>Matt Waynne等</td>\n<td>0</td>\n<td>2020-12-22</td>\n</tr>\n<tr>\n<td>52</td>\n<td>实例化需求</td>\n<td>Gojko Adzic</td>\n<td>0</td>\n<td>2020-12-21</td>\n</tr>\n<tr>\n<td>53</td>\n<td>驯服烂代码</td>\n<td>伍斌</td>\n<td>0</td>\n<td>2020-12-28</td>\n</tr>\n<tr>\n<td>54</td>\n<td>软件工程通史1930-2019</td>\n<td>Capers Jones</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>55</td>\n<td>人件(原书第三版)</td>\n<td>Tom DeMarco Timothy Lister</td>\n<td>0</td>\n<td>2021-05-02</td>\n</tr>\n<tr>\n<td>56</td>\n<td>软件困局：为什么聪明的程序员写出糟糕的代码</td>\n<td>Adam Barr</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>57</td>\n<td>项目百态：深入理解软件项目行为模式</td>\n<td>金明翻译</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>58</td>\n<td>硝烟中的Scrum和XP-我们如何实施Scrum</td>\n<td>Henrik Kniberg</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>59</td>\n<td>敏捷整洁之道</td>\n<td>Robert C. Martin</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>60</td>\n<td>精益软件开发管理之道</td>\n<td>Mary  Poppendieck</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>61</td>\n<td>敏捷软件开发工具-精益开发方法</td>\n<td>Mary  Poppendieck</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>62</td>\n<td>活文档 与代码共同演进</td>\n<td>Cyrille Matraire</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>63</td>\n<td>凤凰项目 一个IT运维的传奇故事-修订版</td>\n<td>Gene Kim</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>64</td>\n<td>产品研发管理：构建世界一流的产品研发管理体系（第二版）</td>\n<td>周辉</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>65</td>\n<td>敏捷技能修炼：敏捷软件开发与设计的最佳实践</td>\n<td>Alan Shalloway / Scott Bain / Ken Pugh / Amir Kolsky</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>66</td>\n<td>Scrum敏捷软件开发</td>\n<td>Mike Cohn</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>67</td>\n<td>敏捷软件开发时间：估算与计划</td>\n<td>Mike Cohn</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>68</td>\n<td>SCRUM敏捷项目管理</td>\n<td>Ken Schwaber</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>69</td>\n<td>这就是软件工程师</td>\n<td>丁丛丛 靳冉</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>70</td>\n<td>30天软件开发：告别瀑布拥抱敏捷</td>\n<td>Ken Schwaber,Jeff Sutherland</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>71</td>\n<td>Vim实用技巧 第二版</td>\n<td>Drew Neil</td>\n<td>0</td>\n<td></td>\n</tr>\n</tbody></table>\n<h2 id=\"设计-27\"><a href=\"#设计-27\" class=\"headerlink\" title=\"设计(27)\"></a>设计(27)</h2><table>\n<thead>\n<tr>\n<th>编号</th>\n<th>书名</th>\n<th>作者</th>\n<th>阅读情况</th>\n<th>读书笔记</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td><strong>重构-第一版</strong></td>\n<td>Martin Flower</td>\n<td>4</td>\n<td></td>\n</tr>\n<tr>\n<td>2</td>\n<td>微服务设计</td>\n<td>Sam Newman</td>\n<td>3</td>\n<td></td>\n</tr>\n<tr>\n<td>3</td>\n<td>UML和OOAD快速入门</td>\n<td>邱郁惠</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>4</td>\n<td>软件设计之道：那些值得借鉴的实践案例</td>\n<td>麦思博</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>5</td>\n<td>分析模式</td>\n<td>Martin Fowler</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>6</td>\n<td>生产微服务</td>\n<td>Susan J.Fowler</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>7</td>\n<td>修改代码的艺术-构建易维护代码的9条最佳实践</td>\n<td>David Scott Bernstein</td>\n<td>3</td>\n<td></td>\n</tr>\n<tr>\n<td>8</td>\n<td>修改代码的艺术</td>\n<td>Michael Feathers</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>9</td>\n<td>遗留系统重建实战</td>\n<td>Chris Birchall</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>10</td>\n<td>Junit实战第二版</td>\n<td>Peter Tahchiev</td>\n<td>3</td>\n<td></td>\n</tr>\n<tr>\n<td>11</td>\n<td>软件设计哲学</td>\n<td>John Ousterhout</td>\n<td>4</td>\n<td></td>\n</tr>\n<tr>\n<td>12</td>\n<td>领域驱动设计全面解析与实战</td>\n<td>彭晨阳</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>13</td>\n<td>软件工程-实践者的研究方法-第八版</td>\n<td>Roger S.Pressman</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>14</td>\n<td>实现领域驱动设计</td>\n<td>Vaughn Vernon</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>15</td>\n<td>编程格调</td>\n<td>Brian W.Kernighan</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>16</td>\n<td>对象设计：角色，责任和协作</td>\n<td>Rebecca Wirfs-Brock</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>17</td>\n<td><strong>OOD启思录</strong></td>\n<td>Arthur J. Riel</td>\n<td>4</td>\n<td></td>\n</tr>\n<tr>\n<td>18</td>\n<td>软件设计重构</td>\n<td>Tushar Sharma等</td>\n<td>4</td>\n<td></td>\n</tr>\n<tr>\n<td>19</td>\n<td>领域驱动设计精粹</td>\n<td>Vaughn Vernon</td>\n<td>3</td>\n<td></td>\n</tr>\n<tr>\n<td>20</td>\n<td>设计模式的艺术</td>\n<td>刘伟</td>\n<td>4</td>\n<td></td>\n</tr>\n<tr>\n<td>21</td>\n<td>代码精进之路-从码农到工匠</td>\n<td>张建飞</td>\n<td>4</td>\n<td></td>\n</tr>\n<tr>\n<td>22</td>\n<td>领域驱动设计</td>\n<td>Eric Evans</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>23</td>\n<td>特征驱动开发方法原理与实践</td>\n<td>Stephen R. Palmer</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>24</td>\n<td>浮现式设计：专业软件开发的演进本质</td>\n<td>Scott L.Bain</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>25</td>\n<td>微服务设计模式和最佳实践</td>\n<td>Vinicius Feitosa Pacheco</td>\n<td>0</td>\n<td>2020-12-22</td>\n</tr>\n<tr>\n<td>26</td>\n<td>微服务架构设计模式</td>\n<td>Chris Richardson</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>27</td>\n<td>软件预构的艺术</td>\n<td>Ken Pugh</td>\n<td>0</td>\n<td></td>\n</tr>\n</tbody></table>\n<h2 id=\"考试与考证-16\"><a href=\"#考试与考证-16\" class=\"headerlink\" title=\"考试与考证(16)\"></a>考试与考证(16)</h2><table>\n<thead>\n<tr>\n<th>编号</th>\n<th>书名</th>\n<th>作者</th>\n<th>阅读情况</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>软考:系统架构设计师 2009-2016试题分析</td>\n<td>全国计算机专业技术资格考试办公室</td>\n<td>0</td>\n</tr>\n<tr>\n<td>2</td>\n<td>软件体系架构：原理方法与实践</td>\n<td>张友生</td>\n<td>0</td>\n</tr>\n<tr>\n<td>3</td>\n<td>产品经理认证NPDP知识体系指南</td>\n<td>(美)产品开发与管理协会</td>\n<td>0</td>\n</tr>\n<tr>\n<td>4</td>\n<td>软考：信息系统项目管理师教程</td>\n<td>全国计算机专业技术资格考试办公室</td>\n<td>0</td>\n</tr>\n<tr>\n<td>5</td>\n<td>软考：信息系统项目管理师考试论文执导</td>\n<td>全国计算机专业技术资格考试办公室</td>\n<td>0</td>\n</tr>\n<tr>\n<td>6</td>\n<td>软考：信息系统项目管理师案例分析指南</td>\n<td>全国计算机专业技术资格考试办公室</td>\n<td>0</td>\n</tr>\n<tr>\n<td>7</td>\n<td>软考:系统架构设计师 2013-2018试题分析</td>\n<td>全国计算机专业技术资格考试办公室</td>\n<td>0</td>\n</tr>\n<tr>\n<td>8</td>\n<td>软考:系统架构设计师教程</td>\n<td>全国计算机专业技术资格考试办公室</td>\n<td>0</td>\n</tr>\n<tr>\n<td>9</td>\n<td>软考:系统架构设计师全程指导</td>\n<td>全国计算机专业技术资格考试办公室</td>\n<td>0</td>\n</tr>\n<tr>\n<td>10</td>\n<td>软考：系统架构设计师考试32小时通关</td>\n<td>全国计算机专业技术资格考试办公室</td>\n<td>0</td>\n</tr>\n<tr>\n<td>11</td>\n<td>软考：系统架构设计师教程</td>\n<td>希赛教育</td>\n<td>0</td>\n</tr>\n<tr>\n<td>12</td>\n<td>项目管理知识体系指南 第六版</td>\n<td>[美]项目管理协会</td>\n<td>0</td>\n</tr>\n<tr>\n<td>13</td>\n<td>敏捷实践指南</td>\n<td>[美]项目管理协会</td>\n<td>0</td>\n</tr>\n<tr>\n<td>14</td>\n<td>Head First PMP 第三版</td>\n<td>格林 / 斯泰曼</td>\n<td>0</td>\n</tr>\n<tr>\n<td>15</td>\n<td>敏捷项目管理(第二版):快速交付创新产品</td>\n<td>Jim,Highsmith</td>\n<td>0</td>\n</tr>\n<tr>\n<td>16</td>\n<td>汪博士解读PMP 第五版</td>\n<td>汪博士</td>\n<td>0</td>\n</tr>\n</tbody></table>\n<h2 id=\"产品-16\"><a href=\"#产品-16\" class=\"headerlink\" title=\"产品(16)\"></a>产品(16)</h2><table>\n<thead>\n<tr>\n<th>编号</th>\n<th>书名</th>\n<th>作者</th>\n<th>阅读情况</th>\n<th>读书笔记</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>产品设计与开发第五版</td>\n<td>Karl T.Ullrich</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>2</td>\n<td>疯传</td>\n<td>Jonah Berger</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>3</td>\n<td>人人都是产品经理-第二版</td>\n<td>苏杰</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>4</td>\n<td>你的灯还亮着吗？</td>\n<td>Gerald M.Weinberg</td>\n<td>4</td>\n<td></td>\n</tr>\n<tr>\n<td>5</td>\n<td>淘宝产品十年事</td>\n<td>苏杰</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>6</td>\n<td>俞军 产品方法论</td>\n<td>俞军</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>7</td>\n<td>支付平台架构-业务，规划，设计与实现</td>\n<td>曹兵强</td>\n<td>4</td>\n<td></td>\n</tr>\n<tr>\n<td>8</td>\n<td>电商产品经理宝典</td>\n<td>刘志远</td>\n<td>3</td>\n<td></td>\n</tr>\n<tr>\n<td>9</td>\n<td>电商产品经理：基于人货场内容的产品设计攻略</td>\n<td>王伟</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>10</td>\n<td>业务中台产品搭建指南</td>\n<td>高晖</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>11</td>\n<td>增长黑客</td>\n<td>肖恩·埃利斯 （Sean Ellis)</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>12</td>\n<td>数据产品经理修炼手册-从零基础到大数据产品实践</td>\n<td>梁旭鹏</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>13</td>\n<td>数据产品经理必须课：从零经验到令人惊艳</td>\n<td>李鑫</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>14</td>\n<td>数据驱动：从方法到实践</td>\n<td>桑文锋</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>15</td>\n<td>支付方法论</td>\n<td>王伟</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>16</td>\n<td>云计算时代 本质，计算，创新，战略</td>\n<td>刘黎明</td>\n<td>0</td>\n<td></td>\n</tr>\n</tbody></table>\n<h2 id=\"系统-13\"><a href=\"#系统-13\" class=\"headerlink\" title=\"系统(13)\"></a>系统(13)</h2><table>\n<thead>\n<tr>\n<th>编号</th>\n<th>书名</th>\n<th>作者</th>\n<th>阅读情况</th>\n<th>读书笔记</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>Linux系统编程手册-上</td>\n<td>Michael Kerrisk</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>2</td>\n<td>Linux系统编程手册-下</td>\n<td>Michael Kerrisk</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>3</td>\n<td>系统性能优化第二版</td>\n<td>Mike Loukides</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>4</td>\n<td>性能之巅</td>\n<td>Brendan Gregg</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>5</td>\n<td>Linux大棚命令百篇上：文件和文本篇</td>\n<td>大棚</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>6</td>\n<td>Linux大棚命令百篇下：网络和系统篇</td>\n<td>大棚</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>7</td>\n<td>Linux就该这么学</td>\n<td>刘遄</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>8</td>\n<td>UNIX环境高级编程 第三版</td>\n<td>W.Richard Stevens</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>9</td>\n<td>Linux系统编程 第二版</td>\n<td>Robert Love</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>10</td>\n<td>UNIX网络编程卷2：进程间通信</td>\n<td>W.Richard Stevens</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>11</td>\n<td>UNIX网络编程卷2：套接字联网API</td>\n<td>W.Richard Stevens</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>12</td>\n<td>深入理解Linux内核 第三版</td>\n<td>西斯特</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>13</td>\n<td>Unix/Linux编程实践教程</td>\n<td>Bruce Molay</td>\n<td>0</td>\n<td></td>\n</tr>\n</tbody></table>\n<h2 id=\"区块链-7\"><a href=\"#区块链-7\" class=\"headerlink\" title=\"区块链(7)\"></a>区块链(7)</h2><table>\n<thead>\n<tr>\n<th>编号</th>\n<th>书名</th>\n<th>作者</th>\n<th>阅读情况</th>\n<th>读书笔记</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>以太坊技术详解与实战</td>\n<td>闫莺等</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>2</td>\n<td>EOS区块链应用开发指南</td>\n<td>家男</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>3</td>\n<td>虚拟货币革命</td>\n<td>野口悠纪雄</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>4</td>\n<td>区块链革命：比特币底层技术如何改变货币，商业和世界</td>\n<td>Don Tapscott</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>5</td>\n<td>区块链原理，设计与应用</td>\n<td>杨保华</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>6</td>\n<td>区块链100问</td>\n<td>赵何娟</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>7</td>\n<td>区块链 新经济蓝图及导读</td>\n<td>梅兰妮</td>\n<td>0</td>\n<td></td>\n</tr>\n</tbody></table>\n<h2 id=\"其他-22\"><a href=\"#其他-22\" class=\"headerlink\" title=\"其他(22)\"></a>其他(22)</h2><table>\n<thead>\n<tr>\n<th>编号</th>\n<th>书名</th>\n<th>作者</th>\n<th>阅读情况</th>\n<th>读书笔记</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td>金领简历</td>\n<td>Gayle Laakmann McDowell</td>\n<td>3</td>\n<td></td>\n</tr>\n<tr>\n<td>2</td>\n<td>IEEE计算机先驱奖(1980-2014)</td>\n<td>崔林</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>3</td>\n<td>图灵和ACM图灵奖品(1966-2011)</td>\n<td>吴鹤龄</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>4</td>\n<td>黑客与画家</td>\n<td>Paul Graham</td>\n<td>3</td>\n<td></td>\n</tr>\n<tr>\n<td>5</td>\n<td>延长万物之尺</td>\n<td>保罗.汉弗莱斯</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>6</td>\n<td>Effective Debugging</td>\n<td>Diomidis Spinellis</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>7</td>\n<td>跨越鸿沟</td>\n<td>Geoffrey Moore</td>\n<td>2</td>\n<td></td>\n</tr>\n<tr>\n<td>8</td>\n<td>微软团队成功墨诀</td>\n<td>麦卡锡</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>9</td>\n<td>开源软件之道</td>\n<td>蔡俊杰</td>\n<td>3</td>\n<td></td>\n</tr>\n<tr>\n<td>10</td>\n<td>计算机英语教程双色版</td>\n<td>张强华</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>11</td>\n<td>设计领导力</td>\n<td>Richard Banfield</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>12</td>\n<td>开源软件与专有软件的竞争</td>\n<td>王广凤</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>13</td>\n<td>程序员代码面试指南第二版</td>\n<td>左程云</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>14</td>\n<td>剑指Offer 第二版</td>\n<td>何海涛</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>15</td>\n<td>OKR工作法-谷歌等顶级公司高绩效秘籍</td>\n<td>沃特克</td>\n<td>3</td>\n<td></td>\n</tr>\n<tr>\n<td>16</td>\n<td>程序员的成长课</td>\n<td>安晓辉等</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>17</td>\n<td>Java程序员面试算法宝典</td>\n<td>猿媛之家</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>18</td>\n<td>程序员面试金典 第六版</td>\n<td>盖尔-拉克曼</td>\n<td>1</td>\n<td></td>\n</tr>\n<tr>\n<td>19</td>\n<td>开源法则</td>\n<td>何宝宏博士</td>\n<td>4</td>\n<td></td>\n</tr>\n<tr>\n<td>20</td>\n<td>计算机英语 第五版</td>\n<td>刘艺</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>21</td>\n<td>研究是一门艺术 第四版</td>\n<td>Wayne C. Booth</td>\n<td>0</td>\n<td></td>\n</tr>\n<tr>\n<td>22</td>\n<td>程序员的英语</td>\n<td>[韩]朴栽浒</td>\n<td>0</td>\n<td></td>\n</tr>\n</tbody></table>\n"}],"Post":[{"title":"CompletionService设计与实现","date":"2020-11-12T18:42:06.000Z","_content":"\n\n\n# 序言\n\n使用ExecutorService时候，我们只是向其中不断提交任务，然后通过Future获取get任务结果，但是有时候get需要等待，虽然可行，但是比较繁琐，可以有更好的方式，比如CompletionService实现了将完成的任务放在完成队列中，使得获取任务结果可以向队列一样通过take和poll任务结果，这样比ExecutorService更加方便。CompletionService通过ExecutorCompletionService实现，这两个实现均非常简单。\n\n\n\n# 结构\n\n<img src=\"/images/CompletionService.png\" style=\"zoom:60%;\" />\n\n通过类图，可以看出CompletionService并没有继承ExecutorService，而是内部包含了AbstractExecutorService类，CompletionService和ExecutorService比较类似地方是都有submit方法，而CompletionService获取执行结果是根据take和poll的方式去获取。\n\n\n\n# API\n\n\n\n\n\n# 实现\n\n## 任务结果排队的QueueingFuture\n\n```java\n//全部final，说明在构造函数里面会创建好这些实例变量\nprivate final Executor executor;\nprivate final AbstractExecutorService aes;\nprivate final BlockingQueue<Future<V>> completionQueue;\n\n/**\n * FutureTask extension to enqueue upon completion.\n */\nprivate static class QueueingFuture<V> extends FutureTask<Void> {\n    QueueingFuture(RunnableFuture<V> task,\n                   BlockingQueue<Future<V>> completionQueue) {\n        super(task, null);\n        this.task = task;\n        this.completionQueue = completionQueue;\n    }\n    private final Future<V> task;\n    private final BlockingQueue<Future<V>> completionQueue;\n    //FutureTask的钩子方法，用户任务结束时候的扩展，QueueingFuture继承了该方法，并将结束的\n    //任务放入阻塞队列\n    protected void done() { completionQueue.add(task); }\n}\n```\n\n\n\n## 构造函数\n\n```java\npublic ExecutorCompletionService(Executor executor) {\n    if (executor == null)\n        throw new NullPointerException();\n    this.executor = executor;\n    this.aes = (executor instanceof AbstractExecutorService) ?\n        (AbstractExecutorService) executor : null;\n    this.completionQueue = new LinkedBlockingQueue<Future<V>>();\n}\n```\n\n\n\n\n\n```java\npublic ExecutorCompletionService(Executor executor,\n                                 BlockingQueue<Future<V>> completionQueue) {\n    if (executor == null || completionQueue == null)\n        throw new NullPointerException();\n    this.executor = executor;\n    this.aes = (executor instanceof AbstractExecutorService) ?\n        (AbstractExecutorService) executor : null;\n    this.completionQueue = completionQueue;\n}\n```\n\n\n\n## 提交任务submit\n\n提交任务和AbstractExecutorService类似，只不过提交的是返回结果排队的QueueingFuture.\n\n```java\npublic Future<V> submit(Callable<V> task) {\n    if (task == null) throw new NullPointerException();\n    RunnableFuture<V> f = newTaskFor(task);\n    executor.execute(new QueueingFuture<V>(f, completionQueue));\n    return f;\n}\n\n\npublic Future<V> submit(Runnable task, V result) {\n        if (task == null) throw new NullPointerException();\n        RunnableFuture<V> f = newTaskFor(task, result);\n        executor.execute(new QueueingFuture<V>(f, completionQueue));\n        return f;\n}\n\n```\n\n\n\n## 从阻塞队列获取任务结果take，poll\n\n```java\n//如果没有完成的任务会阻塞等待\npublic Future<V> take() throws InterruptedException {\n    return completionQueue.take();\n}\n\n//如果没有完成的任务返回null\npublic Future<V> poll() {\n    return completionQueue.poll();\n}\n\n//带有超时的获取任务结果，任务超时，则被中断\npublic Future<V> poll(long timeout, TimeUnit unit)\n        throws InterruptedException {\n    return completionQueue.poll(timeout, unit);\n}\n```\n\n\n\n\n\n# 实战","source":"_posts/CompletionService-Design-And-Implementation.md","raw":"---\ntitle: CompletionService设计与实现\ndate: 2020-11-13 02:42:06\ntags: java.util.concurrent\ncategories:\n  - JDK源码\n  - Java并发框架\n---\n\n\n\n# 序言\n\n使用ExecutorService时候，我们只是向其中不断提交任务，然后通过Future获取get任务结果，但是有时候get需要等待，虽然可行，但是比较繁琐，可以有更好的方式，比如CompletionService实现了将完成的任务放在完成队列中，使得获取任务结果可以向队列一样通过take和poll任务结果，这样比ExecutorService更加方便。CompletionService通过ExecutorCompletionService实现，这两个实现均非常简单。\n\n\n\n# 结构\n\n<img src=\"/images/CompletionService.png\" style=\"zoom:60%;\" />\n\n通过类图，可以看出CompletionService并没有继承ExecutorService，而是内部包含了AbstractExecutorService类，CompletionService和ExecutorService比较类似地方是都有submit方法，而CompletionService获取执行结果是根据take和poll的方式去获取。\n\n\n\n# API\n\n\n\n\n\n# 实现\n\n## 任务结果排队的QueueingFuture\n\n```java\n//全部final，说明在构造函数里面会创建好这些实例变量\nprivate final Executor executor;\nprivate final AbstractExecutorService aes;\nprivate final BlockingQueue<Future<V>> completionQueue;\n\n/**\n * FutureTask extension to enqueue upon completion.\n */\nprivate static class QueueingFuture<V> extends FutureTask<Void> {\n    QueueingFuture(RunnableFuture<V> task,\n                   BlockingQueue<Future<V>> completionQueue) {\n        super(task, null);\n        this.task = task;\n        this.completionQueue = completionQueue;\n    }\n    private final Future<V> task;\n    private final BlockingQueue<Future<V>> completionQueue;\n    //FutureTask的钩子方法，用户任务结束时候的扩展，QueueingFuture继承了该方法，并将结束的\n    //任务放入阻塞队列\n    protected void done() { completionQueue.add(task); }\n}\n```\n\n\n\n## 构造函数\n\n```java\npublic ExecutorCompletionService(Executor executor) {\n    if (executor == null)\n        throw new NullPointerException();\n    this.executor = executor;\n    this.aes = (executor instanceof AbstractExecutorService) ?\n        (AbstractExecutorService) executor : null;\n    this.completionQueue = new LinkedBlockingQueue<Future<V>>();\n}\n```\n\n\n\n\n\n```java\npublic ExecutorCompletionService(Executor executor,\n                                 BlockingQueue<Future<V>> completionQueue) {\n    if (executor == null || completionQueue == null)\n        throw new NullPointerException();\n    this.executor = executor;\n    this.aes = (executor instanceof AbstractExecutorService) ?\n        (AbstractExecutorService) executor : null;\n    this.completionQueue = completionQueue;\n}\n```\n\n\n\n## 提交任务submit\n\n提交任务和AbstractExecutorService类似，只不过提交的是返回结果排队的QueueingFuture.\n\n```java\npublic Future<V> submit(Callable<V> task) {\n    if (task == null) throw new NullPointerException();\n    RunnableFuture<V> f = newTaskFor(task);\n    executor.execute(new QueueingFuture<V>(f, completionQueue));\n    return f;\n}\n\n\npublic Future<V> submit(Runnable task, V result) {\n        if (task == null) throw new NullPointerException();\n        RunnableFuture<V> f = newTaskFor(task, result);\n        executor.execute(new QueueingFuture<V>(f, completionQueue));\n        return f;\n}\n\n```\n\n\n\n## 从阻塞队列获取任务结果take，poll\n\n```java\n//如果没有完成的任务会阻塞等待\npublic Future<V> take() throws InterruptedException {\n    return completionQueue.take();\n}\n\n//如果没有完成的任务返回null\npublic Future<V> poll() {\n    return completionQueue.poll();\n}\n\n//带有超时的获取任务结果，任务超时，则被中断\npublic Future<V> poll(long timeout, TimeUnit unit)\n        throws InterruptedException {\n    return completionQueue.poll(timeout, unit);\n}\n```\n\n\n\n\n\n# 实战","slug":"CompletionService-Design-And-Implementation","published":1,"updated":"2022-06-28T17:22:38.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clh7s5ct80000xt8jb5dkdqe1","content":"<h1 id=\"序言\"><a href=\"#序言\" class=\"headerlink\" title=\"序言\"></a>序言</h1><p>使用ExecutorService时候，我们只是向其中不断提交任务，然后通过Future获取get任务结果，但是有时候get需要等待，虽然可行，但是比较繁琐，可以有更好的方式，比如CompletionService实现了将完成的任务放在完成队列中，使得获取任务结果可以向队列一样通过take和poll任务结果，这样比ExecutorService更加方便。CompletionService通过ExecutorCompletionService实现，这两个实现均非常简单。</p>\n<h1 id=\"结构\"><a href=\"#结构\" class=\"headerlink\" title=\"结构\"></a>结构</h1><img src=\"/images/CompletionService.png\" style=\"zoom:60%;\" />\n\n<p>通过类图，可以看出CompletionService并没有继承ExecutorService，而是内部包含了AbstractExecutorService类，CompletionService和ExecutorService比较类似地方是都有submit方法，而CompletionService获取执行结果是根据take和poll的方式去获取。</p>\n<h1 id=\"API\"><a href=\"#API\" class=\"headerlink\" title=\"API\"></a>API</h1><h1 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h1><h2 id=\"任务结果排队的QueueingFuture\"><a href=\"#任务结果排队的QueueingFuture\" class=\"headerlink\" title=\"任务结果排队的QueueingFuture\"></a>任务结果排队的QueueingFuture</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//全部final，说明在构造函数里面会创建好这些实例变量</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Executor executor;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> AbstractExecutorService aes;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> BlockingQueue&lt;Future&lt;V&gt;&gt; completionQueue;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * FutureTask extension to enqueue upon completion.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">QueueingFuture</span>&lt;<span class=\"title\">V</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">FutureTask</span>&lt;<span class=\"title\">Void</span>&gt; </span>&#123;</span><br><span class=\"line\">    QueueingFuture(RunnableFuture&lt;V&gt; task,</span><br><span class=\"line\">                   BlockingQueue&lt;Future&lt;V&gt;&gt; completionQueue) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(task, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.task = task;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.completionQueue = completionQueue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Future&lt;V&gt; task;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> BlockingQueue&lt;Future&lt;V&gt;&gt; completionQueue;</span><br><span class=\"line\">    <span class=\"comment\">//FutureTask的钩子方法，用户任务结束时候的扩展，QueueingFuture继承了该方法，并将结束的</span></span><br><span class=\"line\">    <span class=\"comment\">//任务放入阻塞队列</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">done</span><span class=\"params\">()</span> </span>&#123; completionQueue.add(task); &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ExecutorCompletionService</span><span class=\"params\">(Executor executor)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (executor == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.executor = executor;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.aes = (executor <span class=\"keyword\">instanceof</span> AbstractExecutorService) ?</span><br><span class=\"line\">        (AbstractExecutorService) executor : <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.completionQueue = <span class=\"keyword\">new</span> LinkedBlockingQueue&lt;Future&lt;V&gt;&gt;();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ExecutorCompletionService</span><span class=\"params\">(Executor executor,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                 BlockingQueue&lt;Future&lt;V&gt;&gt; completionQueue)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (executor == <span class=\"keyword\">null</span> || completionQueue == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.executor = executor;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.aes = (executor <span class=\"keyword\">instanceof</span> AbstractExecutorService) ?</span><br><span class=\"line\">        (AbstractExecutorService) executor : <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.completionQueue = completionQueue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"提交任务submit\"><a href=\"#提交任务submit\" class=\"headerlink\" title=\"提交任务submit\"></a>提交任务submit</h2><p>提交任务和AbstractExecutorService类似，只不过提交的是返回结果排队的QueueingFuture.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Future&lt;V&gt; <span class=\"title\">submit</span><span class=\"params\">(Callable&lt;V&gt; task)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (task == <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">    RunnableFuture&lt;V&gt; f = newTaskFor(task);</span><br><span class=\"line\">    executor.execute(<span class=\"keyword\">new</span> QueueingFuture&lt;V&gt;(f, completionQueue));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> f;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Future&lt;V&gt; <span class=\"title\">submit</span><span class=\"params\">(Runnable task, V result)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (task == <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">        RunnableFuture&lt;V&gt; f = newTaskFor(task, result);</span><br><span class=\"line\">        executor.execute(<span class=\"keyword\">new</span> QueueingFuture&lt;V&gt;(f, completionQueue));</span><br><span class=\"line\">        <span class=\"keyword\">return</span> f;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"从阻塞队列获取任务结果take，poll\"><a href=\"#从阻塞队列获取任务结果take，poll\" class=\"headerlink\" title=\"从阻塞队列获取任务结果take，poll\"></a>从阻塞队列获取任务结果take，poll</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//如果没有完成的任务会阻塞等待</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Future&lt;V&gt; <span class=\"title\">take</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> completionQueue.take();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//如果没有完成的任务返回null</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Future&lt;V&gt; <span class=\"title\">poll</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> completionQueue.poll();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//带有超时的获取任务结果，任务超时，则被中断</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Future&lt;V&gt; <span class=\"title\">poll</span><span class=\"params\">(<span class=\"keyword\">long</span> timeout, TimeUnit unit)</span></span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> completionQueue.poll(timeout, unit);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h1 id=\"实战\"><a href=\"#实战\" class=\"headerlink\" title=\"实战\"></a>实战</h1>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"序言\"><a href=\"#序言\" class=\"headerlink\" title=\"序言\"></a>序言</h1><p>使用ExecutorService时候，我们只是向其中不断提交任务，然后通过Future获取get任务结果，但是有时候get需要等待，虽然可行，但是比较繁琐，可以有更好的方式，比如CompletionService实现了将完成的任务放在完成队列中，使得获取任务结果可以向队列一样通过take和poll任务结果，这样比ExecutorService更加方便。CompletionService通过ExecutorCompletionService实现，这两个实现均非常简单。</p>\n<h1 id=\"结构\"><a href=\"#结构\" class=\"headerlink\" title=\"结构\"></a>结构</h1><img src=\"/images/CompletionService.png\" style=\"zoom:60%;\" />\n\n<p>通过类图，可以看出CompletionService并没有继承ExecutorService，而是内部包含了AbstractExecutorService类，CompletionService和ExecutorService比较类似地方是都有submit方法，而CompletionService获取执行结果是根据take和poll的方式去获取。</p>\n<h1 id=\"API\"><a href=\"#API\" class=\"headerlink\" title=\"API\"></a>API</h1><h1 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h1><h2 id=\"任务结果排队的QueueingFuture\"><a href=\"#任务结果排队的QueueingFuture\" class=\"headerlink\" title=\"任务结果排队的QueueingFuture\"></a>任务结果排队的QueueingFuture</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//全部final，说明在构造函数里面会创建好这些实例变量</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Executor executor;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> AbstractExecutorService aes;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> BlockingQueue&lt;Future&lt;V&gt;&gt; completionQueue;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\"> * FutureTask extension to enqueue upon completion.</span></span><br><span class=\"line\"><span class=\"comment\"> */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">QueueingFuture</span>&lt;<span class=\"title\">V</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">FutureTask</span>&lt;<span class=\"title\">Void</span>&gt; </span>&#123;</span><br><span class=\"line\">    QueueingFuture(RunnableFuture&lt;V&gt; task,</span><br><span class=\"line\">                   BlockingQueue&lt;Future&lt;V&gt;&gt; completionQueue) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(task, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.task = task;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.completionQueue = completionQueue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Future&lt;V&gt; task;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> BlockingQueue&lt;Future&lt;V&gt;&gt; completionQueue;</span><br><span class=\"line\">    <span class=\"comment\">//FutureTask的钩子方法，用户任务结束时候的扩展，QueueingFuture继承了该方法，并将结束的</span></span><br><span class=\"line\">    <span class=\"comment\">//任务放入阻塞队列</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">done</span><span class=\"params\">()</span> </span>&#123; completionQueue.add(task); &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"构造函数\"><a href=\"#构造函数\" class=\"headerlink\" title=\"构造函数\"></a>构造函数</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ExecutorCompletionService</span><span class=\"params\">(Executor executor)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (executor == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.executor = executor;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.aes = (executor <span class=\"keyword\">instanceof</span> AbstractExecutorService) ?</span><br><span class=\"line\">        (AbstractExecutorService) executor : <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.completionQueue = <span class=\"keyword\">new</span> LinkedBlockingQueue&lt;Future&lt;V&gt;&gt;();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ExecutorCompletionService</span><span class=\"params\">(Executor executor,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                 BlockingQueue&lt;Future&lt;V&gt;&gt; completionQueue)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (executor == <span class=\"keyword\">null</span> || completionQueue == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.executor = executor;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.aes = (executor <span class=\"keyword\">instanceof</span> AbstractExecutorService) ?</span><br><span class=\"line\">        (AbstractExecutorService) executor : <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.completionQueue = completionQueue;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"提交任务submit\"><a href=\"#提交任务submit\" class=\"headerlink\" title=\"提交任务submit\"></a>提交任务submit</h2><p>提交任务和AbstractExecutorService类似，只不过提交的是返回结果排队的QueueingFuture.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Future&lt;V&gt; <span class=\"title\">submit</span><span class=\"params\">(Callable&lt;V&gt; task)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (task == <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">    RunnableFuture&lt;V&gt; f = newTaskFor(task);</span><br><span class=\"line\">    executor.execute(<span class=\"keyword\">new</span> QueueingFuture&lt;V&gt;(f, completionQueue));</span><br><span class=\"line\">    <span class=\"keyword\">return</span> f;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Future&lt;V&gt; <span class=\"title\">submit</span><span class=\"params\">(Runnable task, V result)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (task == <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">        RunnableFuture&lt;V&gt; f = newTaskFor(task, result);</span><br><span class=\"line\">        executor.execute(<span class=\"keyword\">new</span> QueueingFuture&lt;V&gt;(f, completionQueue));</span><br><span class=\"line\">        <span class=\"keyword\">return</span> f;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"从阻塞队列获取任务结果take，poll\"><a href=\"#从阻塞队列获取任务结果take，poll\" class=\"headerlink\" title=\"从阻塞队列获取任务结果take，poll\"></a>从阻塞队列获取任务结果take，poll</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//如果没有完成的任务会阻塞等待</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Future&lt;V&gt; <span class=\"title\">take</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> completionQueue.take();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//如果没有完成的任务返回null</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Future&lt;V&gt; <span class=\"title\">poll</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> completionQueue.poll();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//带有超时的获取任务结果，任务超时，则被中断</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Future&lt;V&gt; <span class=\"title\">poll</span><span class=\"params\">(<span class=\"keyword\">long</span> timeout, TimeUnit unit)</span></span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> completionQueue.poll(timeout, unit);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h1 id=\"实战\"><a href=\"#实战\" class=\"headerlink\" title=\"实战\"></a>实战</h1>"},{"title":"惊奇的工程算法简介","date":"2021-01-03T11:37:35.000Z","_content":"\n\n\n# 简介\n\n本系列主要介绍比较经典/常用的工程算法，理解这些算法非常有意义，对于程序优化有很有帮助，会发出惊奇的感慨。这里算法以工程为出发点，而非严谨意义上的数学证明算法。\n\n\n\n# 工程算法分类\n\n算法主要分为以下几类：\n\n## 单机系统\n\n1. Membership:   HashSet.constains, BitSet.get, Bloom Filter，Counting Bloom Filter\n2. Cardinality:   HashSet.size, BitSet.cardinality, Linear counter，Log Log，HyperLogLog\n3. Frequency: HashMap.put, HashMultiset.count, Count Sketch，Count-Min Sketch\n4. Hash算法和一致性Hash算法\n5. 时间轮算法：Hashed and Hierarchical Timing Wheel\n6. 唯一ID生成器：snowflake，\n7. 负载均衡算法：Round robin，Weighted round robin\n8. 限流算法：Token Bucket，Leaky Bucket，Fixed Window，Sliding Log，Sliding Window\n9. 缓存淘汰算法：LFU，LRU，FIFO\n\n## 分布式系统\n\n1. 共识算法：ZAB，Paxos，Raft，Viewstamped Replication，PBFT，Atomic Broadcast\n2. 选举算法：Bully，Ring\n3. 快照算法：Chandy Lamport，Lightweight Asynchronous Snapshots\n\n","source":"_posts/Algorithm-Engineering.md","raw":"---\ntitle: 惊奇的工程算法简介\ndate: 2021-01-03 19:37:35\ntags: algorithm\ncategories:\n  - 算法\n  - 工程算法\n---\n\n\n\n# 简介\n\n本系列主要介绍比较经典/常用的工程算法，理解这些算法非常有意义，对于程序优化有很有帮助，会发出惊奇的感慨。这里算法以工程为出发点，而非严谨意义上的数学证明算法。\n\n\n\n# 工程算法分类\n\n算法主要分为以下几类：\n\n## 单机系统\n\n1. Membership:   HashSet.constains, BitSet.get, Bloom Filter，Counting Bloom Filter\n2. Cardinality:   HashSet.size, BitSet.cardinality, Linear counter，Log Log，HyperLogLog\n3. Frequency: HashMap.put, HashMultiset.count, Count Sketch，Count-Min Sketch\n4. Hash算法和一致性Hash算法\n5. 时间轮算法：Hashed and Hierarchical Timing Wheel\n6. 唯一ID生成器：snowflake，\n7. 负载均衡算法：Round robin，Weighted round robin\n8. 限流算法：Token Bucket，Leaky Bucket，Fixed Window，Sliding Log，Sliding Window\n9. 缓存淘汰算法：LFU，LRU，FIFO\n\n## 分布式系统\n\n1. 共识算法：ZAB，Paxos，Raft，Viewstamped Replication，PBFT，Atomic Broadcast\n2. 选举算法：Bully，Ring\n3. 快照算法：Chandy Lamport，Lightweight Asynchronous Snapshots\n\n","slug":"Algorithm-Engineering","published":1,"updated":"2022-06-28T17:24:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clh7s5cte0002xt8jac0p7s9t","content":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>本系列主要介绍比较经典/常用的工程算法，理解这些算法非常有意义，对于程序优化有很有帮助，会发出惊奇的感慨。这里算法以工程为出发点，而非严谨意义上的数学证明算法。</p>\n<h1 id=\"工程算法分类\"><a href=\"#工程算法分类\" class=\"headerlink\" title=\"工程算法分类\"></a>工程算法分类</h1><p>算法主要分为以下几类：</p>\n<h2 id=\"单机系统\"><a href=\"#单机系统\" class=\"headerlink\" title=\"单机系统\"></a>单机系统</h2><ol>\n<li>Membership:   HashSet.constains, BitSet.get, Bloom Filter，Counting Bloom Filter</li>\n<li>Cardinality:   HashSet.size, BitSet.cardinality, Linear counter，Log Log，HyperLogLog</li>\n<li>Frequency: HashMap.put, HashMultiset.count, Count Sketch，Count-Min Sketch</li>\n<li>Hash算法和一致性Hash算法</li>\n<li>时间轮算法：Hashed and Hierarchical Timing Wheel</li>\n<li>唯一ID生成器：snowflake，</li>\n<li>负载均衡算法：Round robin，Weighted round robin</li>\n<li>限流算法：Token Bucket，Leaky Bucket，Fixed Window，Sliding Log，Sliding Window</li>\n<li>缓存淘汰算法：LFU，LRU，FIFO</li>\n</ol>\n<h2 id=\"分布式系统\"><a href=\"#分布式系统\" class=\"headerlink\" title=\"分布式系统\"></a>分布式系统</h2><ol>\n<li>共识算法：ZAB，Paxos，Raft，Viewstamped Replication，PBFT，Atomic Broadcast</li>\n<li>选举算法：Bully，Ring</li>\n<li>快照算法：Chandy Lamport，Lightweight Asynchronous Snapshots</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"简介\"><a href=\"#简介\" class=\"headerlink\" title=\"简介\"></a>简介</h1><p>本系列主要介绍比较经典/常用的工程算法，理解这些算法非常有意义，对于程序优化有很有帮助，会发出惊奇的感慨。这里算法以工程为出发点，而非严谨意义上的数学证明算法。</p>\n<h1 id=\"工程算法分类\"><a href=\"#工程算法分类\" class=\"headerlink\" title=\"工程算法分类\"></a>工程算法分类</h1><p>算法主要分为以下几类：</p>\n<h2 id=\"单机系统\"><a href=\"#单机系统\" class=\"headerlink\" title=\"单机系统\"></a>单机系统</h2><ol>\n<li>Membership:   HashSet.constains, BitSet.get, Bloom Filter，Counting Bloom Filter</li>\n<li>Cardinality:   HashSet.size, BitSet.cardinality, Linear counter，Log Log，HyperLogLog</li>\n<li>Frequency: HashMap.put, HashMultiset.count, Count Sketch，Count-Min Sketch</li>\n<li>Hash算法和一致性Hash算法</li>\n<li>时间轮算法：Hashed and Hierarchical Timing Wheel</li>\n<li>唯一ID生成器：snowflake，</li>\n<li>负载均衡算法：Round robin，Weighted round robin</li>\n<li>限流算法：Token Bucket，Leaky Bucket，Fixed Window，Sliding Log，Sliding Window</li>\n<li>缓存淘汰算法：LFU，LRU，FIFO</li>\n</ol>\n<h2 id=\"分布式系统\"><a href=\"#分布式系统\" class=\"headerlink\" title=\"分布式系统\"></a>分布式系统</h2><ol>\n<li>共识算法：ZAB，Paxos，Raft，Viewstamped Replication，PBFT，Atomic Broadcast</li>\n<li>选举算法：Bully，Ring</li>\n<li>快照算法：Chandy Lamport，Lightweight Asynchronous Snapshots</li>\n</ol>\n"},{"title":"AQS(AbstractQueuedSynchronizer) API分析","date":"2020-11-07T17:18:02.000Z","_content":"\n\n\n# AQS概述\n\nAbstractQueuedSynchronizer是Java用于替代 **Synchronized+内置等待通知(wait/notify)+内置条件队列**的抽象队列同步器，该同步器管理锁，条件变量(状态变量)，条件谓词三元关系，从而技术上实现了锁，条件队列，等待通知，阻塞等同步语义。在JUC中广泛使用，其中有ReentrantLock，ReentrantReadWriteLock，Semaphore，CountDownLatch，ThreadPoolExecutor#Worker，而这些基石又组成了部分并发集合，可见其重要性，该同步器比内置的伸缩性和容错性更好，并且功能比内置的更加强大，文章主要分析AQS API设计，以及如何使用该类实现自定义的锁和同步器。\n\n\n\n# AQS API一览\n\nAQS API主要分为以下几类，1 public final 方法 ，用于实现类调用以完成获取锁/释放锁的操作，2  protected final方法，用于实现类获取，原子修改状态变量， 3  protected方法，用于实现类覆写，并且协同 protected final从而真正完成等待/通知的同步语义， 4 私有方法，作为内部实现，并非API，故不分析私有方法。\n\n## public final 方法\n\n```java\npublic final void acquire(int arg) {\n    if (!tryAcquire(arg) && acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n            selfInterrupt();\n}\n\n线程以独占方式用于获取锁，如果获取到，tryAcquire(arg)将会实现状态修改，否则线程将会入队，被阻塞。\n    \n    \npublic final void acquireInterruptibly(int arg) throws InterruptedException {\n    if (Thread.interrupted())\n        throw new InterruptedException();\n    if (!tryAcquire(arg))\n        doAcquireInterruptibly(arg);\n}\n\n线程以响应中断的方式获取锁。\n\npublic final void acquireShared(int arg) {\n    if (tryAcquireShared(arg) < 0)\n        doAcquireShared(arg);\n}\n\n小于0，共享获取失败，则线程入队阻塞。\n\npublic final void acquireSharedInterruptibly(int arg) throws InterruptedException {\n    if (Thread.interrupted())\n        throw new InterruptedException();\n    if (tryAcquireShared(arg) < 0)\n        doAcquireSharedInterruptibly(arg);\n}\n\n以可响应中断的方式共享获取。\n\npublic final boolean release(int arg) {\n    if (tryRelease(arg)) {\n        Node h = head;\n        if (h != null && h.waitStatus != 0)\n            unparkSuccessor(h);\n        return true;\n    }\n    return false;\n}\n\n以独占方式释放，释放成功将unparkSuccessor.\n\npublic final boolean releaseShared(int arg) {\n    if (tryReleaseShared(arg)) {\n        doReleaseShared();\n        return true;\n    }\n    return false;\n}\n\n以共享方式释放。\n\npublic final Collection<Thread> getWaitingThreads(ConditionObject condition)\npublic final int getWaitQueueLength(ConditionObject condition) \npublic final boolean hasContended() \npublic final boolean tryAcquireNanos(int arg, long nanosTimeout)\npublic final boolean tryAcquireSharedNanos(int arg, long nanosTimeout)\n```\n\n\n\n基本获取/释放方法包含了以**tryXXX**开头的方法，这些方法都需要实现类自己来定义，通过对tryXXX方法覆写，从而实现自定义的获取释放操作。\n\n\n\n## protect方法\n\ntryAcquire, tryRelease,isHeldExclusively是实现**独占语义**需要覆写的方法，而tryAcquireShared，tryReleaseShared是实现**共享语义**需要覆写的方法，其内部实现均为throw new UnsupportedOperationException()；简单而言，就是通过状态变量的修改来决定获取锁成功，获取锁失败被阻塞，释放锁失败，释放锁成功唤醒被阻塞线程的简单语义。本质是Synchronized+wait+notify+条件队列语义的高级实现。\n\n```java\nprotected boolean tryAcquire(int arg)     true,成功获取，false，失败获取，线程将入队阻塞。\nprotected boolean tryRelease(int arg)     true，成功释放，唤醒被阻塞的线程，false，释放失败。\nprotected boolean isHeldExclusively()     true，被当前线程持有，false，非当前线程持有。\nprotected int tryAcquireShared(int arg)   负值，获取失败，线程入队被阻塞，零值，以独占方式获取，正值，以共享方式获取\nprotected boolean tryReleaseShared(int arg) true，使得所有在获取时候阻塞的线程恢复执行，false 释放失败\n```\n\n\n\n当理解了protect的语义后，就需要在protect中调用protect final来真正操作状态变量了。\n\n\n\n## protect final  方法\n\n```java\nprotected final int getState()    获取状态\nprotected final void setState(int newState)  设置状态  \nprotected final boolean compareAndSetState(int expect, int update)  原子更新状态 \n```\n\n\n\n\n\n# AQS使用实战\n\n当我们实现一个锁或者同步器时候，最重要的思考是你的状态变量是什么？条件谓词是什么？状态变量和条件谓词之间的转换关系？首先应该清晰理解你需要被AQS管理的状态，其次是这些状态之间转换。可以说，状态变量及其转换带来的同步语义是最重要的设计思考。我们先从官方API实例Mutex 和BooleanLatch说起，然后深入JDK例子CountDownLatch，ReentrantLock，Semaphore，最后总结实现AQS的模板。\n\n\n\n##  Mutex锁实现\n\n互斥锁是最经典的锁，同一时刻只能有一个线程获取锁，并且不可重入。我们可以以0为释放，1为获取作为状态，当获取锁时候，将状态从0置为1，新的线程再次获取时候，将被阻塞。当释放锁时候，将状态从1置为0，并且唤醒之前被阻塞的线程。\n\n1 状态是什么？ 是否获取锁\n\n2  状态转换？ 获取锁时候，状态从0修改为1，释放锁时候，状态从1修改为0.\n\n3  实现细节？ 实现Lock接口，内部静态final类实现Sync，用于实现AQS的protected方法 ，公共方法调用AQS的public final方法。\n\n我们来看实现：\n\n```java\npublic class Mutex implements Lock, java.io.Serializable {\n\n   // 内部助手类，桥接模式\n   private static class Sync extends AbstractQueuedSynchronizer {\n     // Reports whether in locked state\n     protected boolean isHeldExclusively() {\n         //状态为1，认为是当前线程独占\n       return getState() == 1;\n     }\n\n     // Acquires the lock if state is zero\n     public boolean tryAcquire(int acquires) {\n       assert acquires == 1; // Otherwise unused\n       if (compareAndSetState(0, 1)) {\n         //获取锁时候将状态从0原子更新到1，并且设置当前获取者是自己，获取成功返回true\n         setExclusiveOwnerThread(Thread.currentThread());\n         return true;\n       }\n       return false;\n     }\n\n     // Releases the lock by setting state to zero\n     protected boolean tryRelease(int releases) {\n       assert releases == 1; // Otherwise unused\n       //释放锁时候状态不能为0\n       if (getState() == 0) throw new IllegalMonitorStateException();\n       setExclusiveOwnerThread(null);\n       //状态更新为0\n       setState(0);\n       return true;\n     }\n       \n     // Provides a Condition\n     Condition newCondition() { return new ConditionObject(); }\n\n     // Deserializes properly\n     private void readObject(ObjectInputStream s)\n         throws IOException, ClassNotFoundException {\n       s.defaultReadObject();\n       setState(0); // reset to unlocked state\n     }\n   }\n\n   // The sync object does all the hard work. We just forward to it.\n   private final Sync sync = new Sync();\n   //实现lock接口，并且公共方法调用AQS的public final方法\n   public void lock()                { sync.acquire(1); }\n   public boolean tryLock()          { return sync.tryAcquire(1); }\n   public void unlock()              { sync.release(1); }\n   public Condition newCondition()   { return sync.newCondition(); }\n   public boolean isLocked()         { return sync.isHeldExclusively(); }\n   public boolean hasQueuedThreads() { return sync.hasQueuedThreads(); }\n   public void lockInterruptibly() throws InterruptedException {\n     sync.acquireInterruptibly(1);\n   }\n   public boolean tryLock(long timeout, TimeUnit unit)\n       throws InterruptedException {\n     return sync.tryAcquireNanos(1, unit.toNanos(timeout));\n   }\n }\n```\n\n\n\n## BooleanLatch 同步器实现\n\n布尔Latch，可以来回切换，只允许一个信号被唤醒，但是是共享获取的，所以使用tryAcquireShared，tryReleaseShared.\n\n1  状态是什么？获取成功或者失败\n\n2  状态转换？    成功1，失败-1\n\n3  实现细节？ \n\n\n\n```java\npublic class BooleanLatch {\n   private static class Sync extends AbstractQueuedSynchronizer {\n     boolean isSignalled() { return getState() != 0; }\n     protected int tryAcquireShared(int ignore) {\n       //1  共享获取成功   -1 共享获取失败，线程阻塞\n       return isSignalled() ? 1 : -1;\n     }\n     protected boolean tryReleaseShared(int ignore) {\n       //释放锁时候，将状态设置为1，并且唤醒被阻塞的线程\n       setState(1);\n       return true;\n     }\n   }\n\n   private final Sync sync = new Sync();\n   public boolean isSignalled() { return sync.isSignalled(); }\n   public void signal()         { sync.releaseShared(1); }\n   public void await() throws InterruptedException {\n     sync.acquireSharedInterruptibly(1);\n   }\n }\n```\n\n\n\n## CountDownLatch同步器实现\n\n1  状态是什么？ 当前计数值\n\n2  状态转换？每次减少一个计数值，直到0，才进行唤醒，当计数器大于0的时候，一直等待计数器降为0\n\n3  实现细节？共享获取，\n\n```java\n//构造函数初始化内部同步器的计数值\npublic CountDownLatch(int count) {\n    if (count < 0) throw new IllegalArgumentException(\"count < 0\");\n    this.sync = new Sync(count);\n}\n\n//sync的实现\nprivate static final class Sync extends AbstractQueuedSynchronizer {\n\n    Sync(int count) {\n        //初始化状态设置计数值为count\n        setState(count);\n    }\n\n    int getCount() {\n        return getState();\n    }\n\n    //共享获取，状态为0的时候，获取成功，不为0的时候，获取失败，被阻塞\n    protected int tryAcquireShared(int acquires) {\n        return (getState() == 0) ? 1 : -1;\n    }\n\t//每次countDown时候，在for循环中不断减少初始化计数值，当减少到0的时候，释放成功，将会唤醒等待线程，当已经成为0的时候\n    //将一直释放失败，所以CountDownLatch只能用一次。\n    protected boolean tryReleaseShared(int releases) {\n        // Decrement count; signal when transition to zero\n        for (;;) {\n            int c = getState();\n            if (c == 0)\n                return false;\n            int nextc = c-1;\n            if (compareAndSetState(c, nextc))\n                //降低到0的那一次，返回true，唤醒await的线程\n                return nextc == 0;\n        }\n    }\n}\n\n//公共API实现\npublic void await() throws InterruptedException {\n     sync.acquireSharedInterruptibly(1);\n}\n\npublic void countDown() {\n     sync.releaseShared(1);\n}\n```\n\n在EffectiveJava3的item17中有句话点评到：构造器应该创建完全初始化的对象，并且建立起所有约束关系。CountDownLatch是可变的，但是它的状态被刻意设计的非常小，比如创建一个实例，只能用一次，一旦定时器的计数达到0，就不能再用了。\n\n\n\n## ReentrantLock锁实现\n\n1  状态是什么？获取锁操作次数\n\n2  状态转换是什么？同一个线程多次获取锁，累加锁操作次数，对应的多次释放锁，减少锁操作次数\n\n3  实现细节？实现Lock接口，独占锁\n\n```java\n//抽象同步器，设计为静态类，作为公平同步器和非公平同步器的父类\nabstract static class Sync extends AbstractQueuedSynchronizer {\n    private static final long serialVersionUID = -5179523762034025860L;\n\n    abstract void lock();\n\n    /**\n     * Performs non-fair tryLock.  tryAcquire is implemented in\n     * subclasses, but both need nonfair try for trylock method.\n     */\n    final boolean nonfairTryAcquire(int acquires) {\n        final Thread current = Thread.currentThread();\n        int c = getState();\n        if (c == 0) {\n            if (compareAndSetState(0, acquires)) {\n                setExclusiveOwnerThread(current);\n                return true;\n            }\n        }\n        else if (current == getExclusiveOwnerThread()) {\n            int nextc = c + acquires;\n            if (nextc < 0) // overflow\n                throw new Error(\"Maximum lock count exceeded\");\n            setState(nextc);\n            return true;\n        }\n        return false;\n    }\n\n    protected final boolean tryRelease(int releases) {\n        int c = getState() - releases;\n        if (Thread.currentThread() != getExclusiveOwnerThread())\n            throw new IllegalMonitorStateException();\n        boolean free = false;\n        if (c == 0) {\n            free = true;\n            setExclusiveOwnerThread(null);\n        }\n        setState(c);\n        return free;\n    }\n\n    protected final boolean isHeldExclusively() {\n        // While we must in general read state before owner,\n        // we don't need to do so to check if current thread is owner\n        return getExclusiveOwnerThread() == Thread.currentThread();\n    }\n\n    final ConditionObject newCondition() {\n        return new ConditionObject();\n    }\n\n    final Thread getOwner() {\n        return getState() == 0 ? null : getExclusiveOwnerThread();\n    }\n\n    final int getHoldCount() {\n        return isHeldExclusively() ? getState() : 0;\n    }\n\n    final boolean isLocked() {\n        return getState() != 0;\n    }\n}\n\n//公平同步器，静态final类\nstatic final class FairSync extends Sync {\n\n    final void lock() {acquire(1);}\n\n    protected final boolean tryAcquire(int acquires) {\n        final Thread current = Thread.currentThread();\n        int c = getState();\n        if (c == 0) {\n            //第一次获取，判断如果没有后继者，将锁操作次数修改为acquires，并且设置自己是锁的拥有者，\n            //setExclusiveOwnerThread是中的AbstractOwnableSynchronizer方法\n            if (!hasQueuedPredecessors() && compareAndSetState(0, acquires)) {\n                setExclusiveOwnerThread(current);\n                return true;\n            }\n        }\n        //第二次获取，如果还是自己，则将锁获取次数累加，并且修改状态为锁的获取次数，这里也是可重入的实现，当超过\n        //锁最大可获取次数，则抛出Error，注意Error是非受检异常\n        else if (current == getExclusiveOwnerThread()) {\n            int nextc = c + acquires;\n            if (nextc < 0)\n                throw new Error(\"Maximum lock count exceeded\");\n            setState(nextc);\n            return true;\n        }\n        return false;\n    }\n}\n\n//非公平同步器，静态final类\nstatic final class NonfairSync extends Sync {\n    private static final long serialVersionUID = 7316153563782823691L;\n\n    /**\n         * Performs lock.  Try immediate barge, backing up to normal\n         * acquire on failure.\n         */\n    final void lock() {\n        if (compareAndSetState(0, 1))\n            setExclusiveOwnerThread(Thread.currentThread());\n        else\n            acquire(1);\n    }\n\n    protected final boolean tryAcquire(int acquires) {\n        return nonfairTryAcquire(acquires);\n    }\n}\n\n//公有API\n//构造器\npublic ReentrantLock() {\n    //默认非公平\n    sync = new NonfairSync();\n}\n\npublic ReentrantLock(boolean fair) {\n    sync = fair ? new FairSync() : new NonfairSync();\n}\n\npublic void lock() {sync.lock();}\npublic void lockInterruptibly() throws InterruptedException {sync.acquireInterruptibly(1);}\npublic Condition newCondition() { return sync.newCondition();}\npublic boolean tryLock() {\n    //tryLock时候，无论公平锁还是非公平锁，都是非公平获取\n    return sync.nonfairTryAcquire(1);\n}\npublic void unlock() {\n    //减少一次锁获取次数\n    sync.release(1);\n}\n\n\n```\n\n\n\n由此我们可以看到，可重入锁的最大次数是int最大值，也就是2147483647 ，同一个线程最大可以递归获取锁21亿次。\n\n\n\n## Semaphore同步器实现\n\n1  状态是什么？当前可用许可数量\n\n2  状态切换？ 每当有一个线程获取到许可时候，就将许可减1，当许可减低为0的时候，阻塞线程，直到许可大于0\n\n3 实现细节？可共享获取\n\n```java\nabstract static class Sync extends AbstractQueuedSynchronizer {\n    private static final long serialVersionUID = 1192457210091910933L;\n\n    Sync(int permits) {\n        setState(permits);\n    }\n\n    final int getPermits() {\n        return getState();\n    }\n\n    final int nonfairTryAcquireShared(int acquires) {\n        for (;;) {\n            //可用许可\n            int available = getState();\n            //剩余许可\n            int remaining = available - acquires;\n            //剩余许可小于0或者将可用修改为剩余\n            if (remaining < 0 || compareAndSetState(available, remaining))\n                return remaining;\n        }\n    }\n\n    protected final boolean tryReleaseShared(int releases) {\n        for (;;) {\n            int current = getState();\n            int next = current + releases;\n            if (next < current) // overflow\n                throw new Error(\"Maximum permit count exceeded\");\n            if (compareAndSetState(current, next))\n                return true;\n        }\n    }\n\n    final void reducePermits(int reductions) {\n        for (;;) {\n            int current = getState();\n            int next = current - reductions;\n            if (next > current) // underflow\n                throw new Error(\"Permit count underflow\");\n            if (compareAndSetState(current, next))\n                return;\n        }\n    }\n\n    final int drainPermits() {\n        for (;;) {\n            int current = getState();\n            if (current == 0 || compareAndSetState(current, 0))\n                return current;\n        }\n    }\n}\n\n//公平同步器\nstatic final class FairSync extends Sync {\n    FairSync(int permits) {\n        super(permits);\n    }\n\n    protected int tryAcquireShared(int acquires) {\n        for (;;) {\n            //是否有前继者，如果线程有前继者，说明已有线程被阻塞，直接返回获取失败\n            if (hasQueuedPredecessors())\n                return -1;\n            int available = getState();\n            int remaining = available - acquires;\n            //剩余小于0或者可用修改为剩余，如果大于0，则获取成功，如果等于0，则独占获取，如果小于0，则获取失败\n            //所有当剩余许可小于0的时候，也就是信号量使用完的时候，线程获取锁将被阻塞\n            if (remaining < 0 || compareAndSetState(available, remaining))\n                return remaining;\n        }\n    }\n}\n\n//非公平同步器\nstatic final class NonfairSync extends Sync {\n    NonfairSync(int permits) {\n        super(permits);\n    }\n\n    protected int tryAcquireShared(int acquires) {\n        return nonfairTryAcquireShared(acquires);\n    }\n}\n\n//公共API\n//构造函数\npublic Semaphore(int permits) { sync = new NonfairSync(permits);}\n\npublic Semaphore(int permits, boolean fair) {\n    sync = fair ? new FairSync(permits) : new NonfairSync(permits);\n}\n\npublic void acquire() throws InterruptedException {\n    sync.acquireSharedInterruptibly(1);\n}\n\n public void acquire(int permits) throws InterruptedException {\n     if (permits < 0) throw new IllegalArgumentException();\n     sync.acquireSharedInterruptibly(permits);\n }\n\npublic void release() {\n    sync.releaseShared(1);\n}\n\npublic void release(int permits) {\n    if (permits < 0) throw new IllegalArgumentException();\n    sync.releaseShared(permits);\n}\n\n```\n\n\n\n我们可以看到，Semaphore是初始化N个许可，线程无需等待，然后每一个线程会消耗信号量，当消耗完时，会阻塞后面线程，而CountDownLatch是初始化N个计数器，然后线程等待，当计数器降为0的时候，唤醒初始化等待的线程，这两者有些相反的含义在里面。两种同用共享获取方式，共享释放释放。\n\n\n\n# 4  总结\n\n在实现锁或者同步器时候，需要思考以下几点：\n\n1  状态变量以及状态变量的转换\n\n2   是独占的还是共享的\n\n当想明白以上两个问题时候，就可以动手实现你要的同步器的，一般是以内部静态类的方式继承AQS的protected方法，在protected方法中，调用protected final方法，然后在你要公共API中调用你的内部同步器的public final方法既可。如下实现模板：\n\n```java\npublic MyLock implements Lock,  or MySync {\n\n   //内部同步器，继承AQS的protected方法，里面调用AQS的protected final方法修改状态\n   innerStaticSync extends AbstractQueuedSynchronizer{\n\n       //独占获取 tryAcquire，tryRelease，isHeldExclusively\n       protected boolean tryAcquire(int arg) {\n           getState/setState/compareAndSetState\n       }\n       protected boolean tryRelease(int arg) {}\n       protected boolean isHeldExclusively() {}\n       //共享获取 tryAcquireShared，tryReleaseShared\n       protected int tryAcquireShared(int arg) {}\n       protected boolean tryReleaseShared(int arg) {}\n   }\n\t//构造函数实例化\n    public MyLock or MySync {\n        innerStaticSync = new MyLock() or new MySync();\n    }\n\n    //public api 调用AQS的public final方法\n    public acquire(){innerStaticSync.acquire();}\n    public release(){innerStaticSync.release();}\n}\n```\n\n\n\nDone！","source":"_posts/AQS-api-explain.md","raw":"---\ntitle: AQS(AbstractQueuedSynchronizer) API分析\ndate: 2020-11-08 01:18:02\ntags: java.util.concurrent\ncategories:\n  - JDK源码\n  - Java并发框架\n\n---\n\n\n\n# AQS概述\n\nAbstractQueuedSynchronizer是Java用于替代 **Synchronized+内置等待通知(wait/notify)+内置条件队列**的抽象队列同步器，该同步器管理锁，条件变量(状态变量)，条件谓词三元关系，从而技术上实现了锁，条件队列，等待通知，阻塞等同步语义。在JUC中广泛使用，其中有ReentrantLock，ReentrantReadWriteLock，Semaphore，CountDownLatch，ThreadPoolExecutor#Worker，而这些基石又组成了部分并发集合，可见其重要性，该同步器比内置的伸缩性和容错性更好，并且功能比内置的更加强大，文章主要分析AQS API设计，以及如何使用该类实现自定义的锁和同步器。\n\n\n\n# AQS API一览\n\nAQS API主要分为以下几类，1 public final 方法 ，用于实现类调用以完成获取锁/释放锁的操作，2  protected final方法，用于实现类获取，原子修改状态变量， 3  protected方法，用于实现类覆写，并且协同 protected final从而真正完成等待/通知的同步语义， 4 私有方法，作为内部实现，并非API，故不分析私有方法。\n\n## public final 方法\n\n```java\npublic final void acquire(int arg) {\n    if (!tryAcquire(arg) && acquireQueued(addWaiter(Node.EXCLUSIVE), arg))\n            selfInterrupt();\n}\n\n线程以独占方式用于获取锁，如果获取到，tryAcquire(arg)将会实现状态修改，否则线程将会入队，被阻塞。\n    \n    \npublic final void acquireInterruptibly(int arg) throws InterruptedException {\n    if (Thread.interrupted())\n        throw new InterruptedException();\n    if (!tryAcquire(arg))\n        doAcquireInterruptibly(arg);\n}\n\n线程以响应中断的方式获取锁。\n\npublic final void acquireShared(int arg) {\n    if (tryAcquireShared(arg) < 0)\n        doAcquireShared(arg);\n}\n\n小于0，共享获取失败，则线程入队阻塞。\n\npublic final void acquireSharedInterruptibly(int arg) throws InterruptedException {\n    if (Thread.interrupted())\n        throw new InterruptedException();\n    if (tryAcquireShared(arg) < 0)\n        doAcquireSharedInterruptibly(arg);\n}\n\n以可响应中断的方式共享获取。\n\npublic final boolean release(int arg) {\n    if (tryRelease(arg)) {\n        Node h = head;\n        if (h != null && h.waitStatus != 0)\n            unparkSuccessor(h);\n        return true;\n    }\n    return false;\n}\n\n以独占方式释放，释放成功将unparkSuccessor.\n\npublic final boolean releaseShared(int arg) {\n    if (tryReleaseShared(arg)) {\n        doReleaseShared();\n        return true;\n    }\n    return false;\n}\n\n以共享方式释放。\n\npublic final Collection<Thread> getWaitingThreads(ConditionObject condition)\npublic final int getWaitQueueLength(ConditionObject condition) \npublic final boolean hasContended() \npublic final boolean tryAcquireNanos(int arg, long nanosTimeout)\npublic final boolean tryAcquireSharedNanos(int arg, long nanosTimeout)\n```\n\n\n\n基本获取/释放方法包含了以**tryXXX**开头的方法，这些方法都需要实现类自己来定义，通过对tryXXX方法覆写，从而实现自定义的获取释放操作。\n\n\n\n## protect方法\n\ntryAcquire, tryRelease,isHeldExclusively是实现**独占语义**需要覆写的方法，而tryAcquireShared，tryReleaseShared是实现**共享语义**需要覆写的方法，其内部实现均为throw new UnsupportedOperationException()；简单而言，就是通过状态变量的修改来决定获取锁成功，获取锁失败被阻塞，释放锁失败，释放锁成功唤醒被阻塞线程的简单语义。本质是Synchronized+wait+notify+条件队列语义的高级实现。\n\n```java\nprotected boolean tryAcquire(int arg)     true,成功获取，false，失败获取，线程将入队阻塞。\nprotected boolean tryRelease(int arg)     true，成功释放，唤醒被阻塞的线程，false，释放失败。\nprotected boolean isHeldExclusively()     true，被当前线程持有，false，非当前线程持有。\nprotected int tryAcquireShared(int arg)   负值，获取失败，线程入队被阻塞，零值，以独占方式获取，正值，以共享方式获取\nprotected boolean tryReleaseShared(int arg) true，使得所有在获取时候阻塞的线程恢复执行，false 释放失败\n```\n\n\n\n当理解了protect的语义后，就需要在protect中调用protect final来真正操作状态变量了。\n\n\n\n## protect final  方法\n\n```java\nprotected final int getState()    获取状态\nprotected final void setState(int newState)  设置状态  \nprotected final boolean compareAndSetState(int expect, int update)  原子更新状态 \n```\n\n\n\n\n\n# AQS使用实战\n\n当我们实现一个锁或者同步器时候，最重要的思考是你的状态变量是什么？条件谓词是什么？状态变量和条件谓词之间的转换关系？首先应该清晰理解你需要被AQS管理的状态，其次是这些状态之间转换。可以说，状态变量及其转换带来的同步语义是最重要的设计思考。我们先从官方API实例Mutex 和BooleanLatch说起，然后深入JDK例子CountDownLatch，ReentrantLock，Semaphore，最后总结实现AQS的模板。\n\n\n\n##  Mutex锁实现\n\n互斥锁是最经典的锁，同一时刻只能有一个线程获取锁，并且不可重入。我们可以以0为释放，1为获取作为状态，当获取锁时候，将状态从0置为1，新的线程再次获取时候，将被阻塞。当释放锁时候，将状态从1置为0，并且唤醒之前被阻塞的线程。\n\n1 状态是什么？ 是否获取锁\n\n2  状态转换？ 获取锁时候，状态从0修改为1，释放锁时候，状态从1修改为0.\n\n3  实现细节？ 实现Lock接口，内部静态final类实现Sync，用于实现AQS的protected方法 ，公共方法调用AQS的public final方法。\n\n我们来看实现：\n\n```java\npublic class Mutex implements Lock, java.io.Serializable {\n\n   // 内部助手类，桥接模式\n   private static class Sync extends AbstractQueuedSynchronizer {\n     // Reports whether in locked state\n     protected boolean isHeldExclusively() {\n         //状态为1，认为是当前线程独占\n       return getState() == 1;\n     }\n\n     // Acquires the lock if state is zero\n     public boolean tryAcquire(int acquires) {\n       assert acquires == 1; // Otherwise unused\n       if (compareAndSetState(0, 1)) {\n         //获取锁时候将状态从0原子更新到1，并且设置当前获取者是自己，获取成功返回true\n         setExclusiveOwnerThread(Thread.currentThread());\n         return true;\n       }\n       return false;\n     }\n\n     // Releases the lock by setting state to zero\n     protected boolean tryRelease(int releases) {\n       assert releases == 1; // Otherwise unused\n       //释放锁时候状态不能为0\n       if (getState() == 0) throw new IllegalMonitorStateException();\n       setExclusiveOwnerThread(null);\n       //状态更新为0\n       setState(0);\n       return true;\n     }\n       \n     // Provides a Condition\n     Condition newCondition() { return new ConditionObject(); }\n\n     // Deserializes properly\n     private void readObject(ObjectInputStream s)\n         throws IOException, ClassNotFoundException {\n       s.defaultReadObject();\n       setState(0); // reset to unlocked state\n     }\n   }\n\n   // The sync object does all the hard work. We just forward to it.\n   private final Sync sync = new Sync();\n   //实现lock接口，并且公共方法调用AQS的public final方法\n   public void lock()                { sync.acquire(1); }\n   public boolean tryLock()          { return sync.tryAcquire(1); }\n   public void unlock()              { sync.release(1); }\n   public Condition newCondition()   { return sync.newCondition(); }\n   public boolean isLocked()         { return sync.isHeldExclusively(); }\n   public boolean hasQueuedThreads() { return sync.hasQueuedThreads(); }\n   public void lockInterruptibly() throws InterruptedException {\n     sync.acquireInterruptibly(1);\n   }\n   public boolean tryLock(long timeout, TimeUnit unit)\n       throws InterruptedException {\n     return sync.tryAcquireNanos(1, unit.toNanos(timeout));\n   }\n }\n```\n\n\n\n## BooleanLatch 同步器实现\n\n布尔Latch，可以来回切换，只允许一个信号被唤醒，但是是共享获取的，所以使用tryAcquireShared，tryReleaseShared.\n\n1  状态是什么？获取成功或者失败\n\n2  状态转换？    成功1，失败-1\n\n3  实现细节？ \n\n\n\n```java\npublic class BooleanLatch {\n   private static class Sync extends AbstractQueuedSynchronizer {\n     boolean isSignalled() { return getState() != 0; }\n     protected int tryAcquireShared(int ignore) {\n       //1  共享获取成功   -1 共享获取失败，线程阻塞\n       return isSignalled() ? 1 : -1;\n     }\n     protected boolean tryReleaseShared(int ignore) {\n       //释放锁时候，将状态设置为1，并且唤醒被阻塞的线程\n       setState(1);\n       return true;\n     }\n   }\n\n   private final Sync sync = new Sync();\n   public boolean isSignalled() { return sync.isSignalled(); }\n   public void signal()         { sync.releaseShared(1); }\n   public void await() throws InterruptedException {\n     sync.acquireSharedInterruptibly(1);\n   }\n }\n```\n\n\n\n## CountDownLatch同步器实现\n\n1  状态是什么？ 当前计数值\n\n2  状态转换？每次减少一个计数值，直到0，才进行唤醒，当计数器大于0的时候，一直等待计数器降为0\n\n3  实现细节？共享获取，\n\n```java\n//构造函数初始化内部同步器的计数值\npublic CountDownLatch(int count) {\n    if (count < 0) throw new IllegalArgumentException(\"count < 0\");\n    this.sync = new Sync(count);\n}\n\n//sync的实现\nprivate static final class Sync extends AbstractQueuedSynchronizer {\n\n    Sync(int count) {\n        //初始化状态设置计数值为count\n        setState(count);\n    }\n\n    int getCount() {\n        return getState();\n    }\n\n    //共享获取，状态为0的时候，获取成功，不为0的时候，获取失败，被阻塞\n    protected int tryAcquireShared(int acquires) {\n        return (getState() == 0) ? 1 : -1;\n    }\n\t//每次countDown时候，在for循环中不断减少初始化计数值，当减少到0的时候，释放成功，将会唤醒等待线程，当已经成为0的时候\n    //将一直释放失败，所以CountDownLatch只能用一次。\n    protected boolean tryReleaseShared(int releases) {\n        // Decrement count; signal when transition to zero\n        for (;;) {\n            int c = getState();\n            if (c == 0)\n                return false;\n            int nextc = c-1;\n            if (compareAndSetState(c, nextc))\n                //降低到0的那一次，返回true，唤醒await的线程\n                return nextc == 0;\n        }\n    }\n}\n\n//公共API实现\npublic void await() throws InterruptedException {\n     sync.acquireSharedInterruptibly(1);\n}\n\npublic void countDown() {\n     sync.releaseShared(1);\n}\n```\n\n在EffectiveJava3的item17中有句话点评到：构造器应该创建完全初始化的对象，并且建立起所有约束关系。CountDownLatch是可变的，但是它的状态被刻意设计的非常小，比如创建一个实例，只能用一次，一旦定时器的计数达到0，就不能再用了。\n\n\n\n## ReentrantLock锁实现\n\n1  状态是什么？获取锁操作次数\n\n2  状态转换是什么？同一个线程多次获取锁，累加锁操作次数，对应的多次释放锁，减少锁操作次数\n\n3  实现细节？实现Lock接口，独占锁\n\n```java\n//抽象同步器，设计为静态类，作为公平同步器和非公平同步器的父类\nabstract static class Sync extends AbstractQueuedSynchronizer {\n    private static final long serialVersionUID = -5179523762034025860L;\n\n    abstract void lock();\n\n    /**\n     * Performs non-fair tryLock.  tryAcquire is implemented in\n     * subclasses, but both need nonfair try for trylock method.\n     */\n    final boolean nonfairTryAcquire(int acquires) {\n        final Thread current = Thread.currentThread();\n        int c = getState();\n        if (c == 0) {\n            if (compareAndSetState(0, acquires)) {\n                setExclusiveOwnerThread(current);\n                return true;\n            }\n        }\n        else if (current == getExclusiveOwnerThread()) {\n            int nextc = c + acquires;\n            if (nextc < 0) // overflow\n                throw new Error(\"Maximum lock count exceeded\");\n            setState(nextc);\n            return true;\n        }\n        return false;\n    }\n\n    protected final boolean tryRelease(int releases) {\n        int c = getState() - releases;\n        if (Thread.currentThread() != getExclusiveOwnerThread())\n            throw new IllegalMonitorStateException();\n        boolean free = false;\n        if (c == 0) {\n            free = true;\n            setExclusiveOwnerThread(null);\n        }\n        setState(c);\n        return free;\n    }\n\n    protected final boolean isHeldExclusively() {\n        // While we must in general read state before owner,\n        // we don't need to do so to check if current thread is owner\n        return getExclusiveOwnerThread() == Thread.currentThread();\n    }\n\n    final ConditionObject newCondition() {\n        return new ConditionObject();\n    }\n\n    final Thread getOwner() {\n        return getState() == 0 ? null : getExclusiveOwnerThread();\n    }\n\n    final int getHoldCount() {\n        return isHeldExclusively() ? getState() : 0;\n    }\n\n    final boolean isLocked() {\n        return getState() != 0;\n    }\n}\n\n//公平同步器，静态final类\nstatic final class FairSync extends Sync {\n\n    final void lock() {acquire(1);}\n\n    protected final boolean tryAcquire(int acquires) {\n        final Thread current = Thread.currentThread();\n        int c = getState();\n        if (c == 0) {\n            //第一次获取，判断如果没有后继者，将锁操作次数修改为acquires，并且设置自己是锁的拥有者，\n            //setExclusiveOwnerThread是中的AbstractOwnableSynchronizer方法\n            if (!hasQueuedPredecessors() && compareAndSetState(0, acquires)) {\n                setExclusiveOwnerThread(current);\n                return true;\n            }\n        }\n        //第二次获取，如果还是自己，则将锁获取次数累加，并且修改状态为锁的获取次数，这里也是可重入的实现，当超过\n        //锁最大可获取次数，则抛出Error，注意Error是非受检异常\n        else if (current == getExclusiveOwnerThread()) {\n            int nextc = c + acquires;\n            if (nextc < 0)\n                throw new Error(\"Maximum lock count exceeded\");\n            setState(nextc);\n            return true;\n        }\n        return false;\n    }\n}\n\n//非公平同步器，静态final类\nstatic final class NonfairSync extends Sync {\n    private static final long serialVersionUID = 7316153563782823691L;\n\n    /**\n         * Performs lock.  Try immediate barge, backing up to normal\n         * acquire on failure.\n         */\n    final void lock() {\n        if (compareAndSetState(0, 1))\n            setExclusiveOwnerThread(Thread.currentThread());\n        else\n            acquire(1);\n    }\n\n    protected final boolean tryAcquire(int acquires) {\n        return nonfairTryAcquire(acquires);\n    }\n}\n\n//公有API\n//构造器\npublic ReentrantLock() {\n    //默认非公平\n    sync = new NonfairSync();\n}\n\npublic ReentrantLock(boolean fair) {\n    sync = fair ? new FairSync() : new NonfairSync();\n}\n\npublic void lock() {sync.lock();}\npublic void lockInterruptibly() throws InterruptedException {sync.acquireInterruptibly(1);}\npublic Condition newCondition() { return sync.newCondition();}\npublic boolean tryLock() {\n    //tryLock时候，无论公平锁还是非公平锁，都是非公平获取\n    return sync.nonfairTryAcquire(1);\n}\npublic void unlock() {\n    //减少一次锁获取次数\n    sync.release(1);\n}\n\n\n```\n\n\n\n由此我们可以看到，可重入锁的最大次数是int最大值，也就是2147483647 ，同一个线程最大可以递归获取锁21亿次。\n\n\n\n## Semaphore同步器实现\n\n1  状态是什么？当前可用许可数量\n\n2  状态切换？ 每当有一个线程获取到许可时候，就将许可减1，当许可减低为0的时候，阻塞线程，直到许可大于0\n\n3 实现细节？可共享获取\n\n```java\nabstract static class Sync extends AbstractQueuedSynchronizer {\n    private static final long serialVersionUID = 1192457210091910933L;\n\n    Sync(int permits) {\n        setState(permits);\n    }\n\n    final int getPermits() {\n        return getState();\n    }\n\n    final int nonfairTryAcquireShared(int acquires) {\n        for (;;) {\n            //可用许可\n            int available = getState();\n            //剩余许可\n            int remaining = available - acquires;\n            //剩余许可小于0或者将可用修改为剩余\n            if (remaining < 0 || compareAndSetState(available, remaining))\n                return remaining;\n        }\n    }\n\n    protected final boolean tryReleaseShared(int releases) {\n        for (;;) {\n            int current = getState();\n            int next = current + releases;\n            if (next < current) // overflow\n                throw new Error(\"Maximum permit count exceeded\");\n            if (compareAndSetState(current, next))\n                return true;\n        }\n    }\n\n    final void reducePermits(int reductions) {\n        for (;;) {\n            int current = getState();\n            int next = current - reductions;\n            if (next > current) // underflow\n                throw new Error(\"Permit count underflow\");\n            if (compareAndSetState(current, next))\n                return;\n        }\n    }\n\n    final int drainPermits() {\n        for (;;) {\n            int current = getState();\n            if (current == 0 || compareAndSetState(current, 0))\n                return current;\n        }\n    }\n}\n\n//公平同步器\nstatic final class FairSync extends Sync {\n    FairSync(int permits) {\n        super(permits);\n    }\n\n    protected int tryAcquireShared(int acquires) {\n        for (;;) {\n            //是否有前继者，如果线程有前继者，说明已有线程被阻塞，直接返回获取失败\n            if (hasQueuedPredecessors())\n                return -1;\n            int available = getState();\n            int remaining = available - acquires;\n            //剩余小于0或者可用修改为剩余，如果大于0，则获取成功，如果等于0，则独占获取，如果小于0，则获取失败\n            //所有当剩余许可小于0的时候，也就是信号量使用完的时候，线程获取锁将被阻塞\n            if (remaining < 0 || compareAndSetState(available, remaining))\n                return remaining;\n        }\n    }\n}\n\n//非公平同步器\nstatic final class NonfairSync extends Sync {\n    NonfairSync(int permits) {\n        super(permits);\n    }\n\n    protected int tryAcquireShared(int acquires) {\n        return nonfairTryAcquireShared(acquires);\n    }\n}\n\n//公共API\n//构造函数\npublic Semaphore(int permits) { sync = new NonfairSync(permits);}\n\npublic Semaphore(int permits, boolean fair) {\n    sync = fair ? new FairSync(permits) : new NonfairSync(permits);\n}\n\npublic void acquire() throws InterruptedException {\n    sync.acquireSharedInterruptibly(1);\n}\n\n public void acquire(int permits) throws InterruptedException {\n     if (permits < 0) throw new IllegalArgumentException();\n     sync.acquireSharedInterruptibly(permits);\n }\n\npublic void release() {\n    sync.releaseShared(1);\n}\n\npublic void release(int permits) {\n    if (permits < 0) throw new IllegalArgumentException();\n    sync.releaseShared(permits);\n}\n\n```\n\n\n\n我们可以看到，Semaphore是初始化N个许可，线程无需等待，然后每一个线程会消耗信号量，当消耗完时，会阻塞后面线程，而CountDownLatch是初始化N个计数器，然后线程等待，当计数器降为0的时候，唤醒初始化等待的线程，这两者有些相反的含义在里面。两种同用共享获取方式，共享释放释放。\n\n\n\n# 4  总结\n\n在实现锁或者同步器时候，需要思考以下几点：\n\n1  状态变量以及状态变量的转换\n\n2   是独占的还是共享的\n\n当想明白以上两个问题时候，就可以动手实现你要的同步器的，一般是以内部静态类的方式继承AQS的protected方法，在protected方法中，调用protected final方法，然后在你要公共API中调用你的内部同步器的public final方法既可。如下实现模板：\n\n```java\npublic MyLock implements Lock,  or MySync {\n\n   //内部同步器，继承AQS的protected方法，里面调用AQS的protected final方法修改状态\n   innerStaticSync extends AbstractQueuedSynchronizer{\n\n       //独占获取 tryAcquire，tryRelease，isHeldExclusively\n       protected boolean tryAcquire(int arg) {\n           getState/setState/compareAndSetState\n       }\n       protected boolean tryRelease(int arg) {}\n       protected boolean isHeldExclusively() {}\n       //共享获取 tryAcquireShared，tryReleaseShared\n       protected int tryAcquireShared(int arg) {}\n       protected boolean tryReleaseShared(int arg) {}\n   }\n\t//构造函数实例化\n    public MyLock or MySync {\n        innerStaticSync = new MyLock() or new MySync();\n    }\n\n    //public api 调用AQS的public final方法\n    public acquire(){innerStaticSync.acquire();}\n    public release(){innerStaticSync.release();}\n}\n```\n\n\n\nDone！","slug":"AQS-api-explain","published":1,"updated":"2022-06-28T17:22:38.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clh7s5cth0006xt8jgodo3cze","content":"<h1 id=\"AQS概述\"><a href=\"#AQS概述\" class=\"headerlink\" title=\"AQS概述\"></a>AQS概述</h1><p>AbstractQueuedSynchronizer是Java用于替代 <strong>Synchronized+内置等待通知(wait/notify)+内置条件队列</strong>的抽象队列同步器，该同步器管理锁，条件变量(状态变量)，条件谓词三元关系，从而技术上实现了锁，条件队列，等待通知，阻塞等同步语义。在JUC中广泛使用，其中有ReentrantLock，ReentrantReadWriteLock，Semaphore，CountDownLatch，ThreadPoolExecutor#Worker，而这些基石又组成了部分并发集合，可见其重要性，该同步器比内置的伸缩性和容错性更好，并且功能比内置的更加强大，文章主要分析AQS API设计，以及如何使用该类实现自定义的锁和同步器。</p>\n<h1 id=\"AQS-API一览\"><a href=\"#AQS-API一览\" class=\"headerlink\" title=\"AQS API一览\"></a>AQS API一览</h1><p>AQS API主要分为以下几类，1 public final 方法 ，用于实现类调用以完成获取锁/释放锁的操作，2  protected final方法，用于实现类获取，原子修改状态变量， 3  protected方法，用于实现类覆写，并且协同 protected final从而真正完成等待/通知的同步语义， 4 私有方法，作为内部实现，并非API，故不分析私有方法。</p>\n<h2 id=\"public-final-方法\"><a href=\"#public-final-方法\" class=\"headerlink\" title=\"public final 方法\"></a>public final 方法</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">acquire</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class=\"line\">            selfInterrupt();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">线程以独占方式用于获取锁，如果获取到，tryAcquire(arg)将会实现状态修改，否则线程将会入队，被阻塞。</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">acquireInterruptibly</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Thread.interrupted())</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> InterruptedException();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!tryAcquire(arg))</span><br><span class=\"line\">        doAcquireInterruptibly(arg);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">线程以响应中断的方式获取锁。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">acquireShared</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tryAcquireShared(arg) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        doAcquireShared(arg);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">小于<span class=\"number\">0</span>，共享获取失败，则线程入队阻塞。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">acquireSharedInterruptibly</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Thread.interrupted())</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> InterruptedException();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tryAcquireShared(arg) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        doAcquireSharedInterruptibly(arg);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">以可响应中断的方式共享获取。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">release</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tryRelease(arg)) &#123;</span><br><span class=\"line\">        Node h = head;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (h != <span class=\"keyword\">null</span> &amp;&amp; h.waitStatus != <span class=\"number\">0</span>)</span><br><span class=\"line\">            unparkSuccessor(h);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">以独占方式释放，释放成功将unparkSuccessor.</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">releaseShared</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class=\"line\">        doReleaseShared();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">以共享方式释放。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Collection&lt;Thread&gt; <span class=\"title\">getWaitingThreads</span><span class=\"params\">(ConditionObject condition)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">getWaitQueueLength</span><span class=\"params\">(ConditionObject condition)</span> </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hasContended</span><span class=\"params\">()</span> </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryAcquireNanos</span><span class=\"params\">(<span class=\"keyword\">int</span> arg, <span class=\"keyword\">long</span> nanosTimeout)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryAcquireSharedNanos</span><span class=\"params\">(<span class=\"keyword\">int</span> arg, <span class=\"keyword\">long</span> nanosTimeout)</span></span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>基本获取/释放方法包含了以<strong>tryXXX</strong>开头的方法，这些方法都需要实现类自己来定义，通过对tryXXX方法覆写，从而实现自定义的获取释放操作。</p>\n<h2 id=\"protect方法\"><a href=\"#protect方法\" class=\"headerlink\" title=\"protect方法\"></a>protect方法</h2><p>tryAcquire, tryRelease,isHeldExclusively是实现<strong>独占语义</strong>需要覆写的方法，而tryAcquireShared，tryReleaseShared是实现<strong>共享语义</strong>需要覆写的方法，其内部实现均为throw new UnsupportedOperationException()；简单而言，就是通过状态变量的修改来决定获取锁成功，获取锁失败被阻塞，释放锁失败，释放锁成功唤醒被阻塞线程的简单语义。本质是Synchronized+wait+notify+条件队列语义的高级实现。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryAcquire</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span>     <span class=\"keyword\">true</span>,成功获取，<span class=\"keyword\">false</span>，失败获取，线程将入队阻塞。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryRelease</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span>     <span class=\"keyword\">true</span>，成功释放，唤醒被阻塞的线程，<span class=\"keyword\">false</span>，释放失败。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isHeldExclusively</span><span class=\"params\">()</span>     <span class=\"keyword\">true</span>，被当前线程持有，<span class=\"keyword\">false</span>，非当前线程持有。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> <span class=\"title\">tryAcquireShared</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span>   负值，获取失败，线程入队被阻塞，零值，以独占方式获取，正值，以共享方式获取</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryReleaseShared</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> <span class=\"keyword\">true</span>，使得所有在获取时候阻塞的线程恢复执行，<span class=\"keyword\">false</span> 释放失败</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>当理解了protect的语义后，就需要在protect中调用protect final来真正操作状态变量了。</p>\n<h2 id=\"protect-final-方法\"><a href=\"#protect-final-方法\" class=\"headerlink\" title=\"protect final  方法\"></a>protect final  方法</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">getState</span><span class=\"params\">()</span>    获取状态</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">setState</span><span class=\"params\">(<span class=\"keyword\">int</span> newState)</span>  设置状态  </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">compareAndSetState</span><span class=\"params\">(<span class=\"keyword\">int</span> expect, <span class=\"keyword\">int</span> update)</span>  原子更新状态</span></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h1 id=\"AQS使用实战\"><a href=\"#AQS使用实战\" class=\"headerlink\" title=\"AQS使用实战\"></a>AQS使用实战</h1><p>当我们实现一个锁或者同步器时候，最重要的思考是你的状态变量是什么？条件谓词是什么？状态变量和条件谓词之间的转换关系？首先应该清晰理解你需要被AQS管理的状态，其次是这些状态之间转换。可以说，状态变量及其转换带来的同步语义是最重要的设计思考。我们先从官方API实例Mutex 和BooleanLatch说起，然后深入JDK例子CountDownLatch，ReentrantLock，Semaphore，最后总结实现AQS的模板。</p>\n<h2 id=\"Mutex锁实现\"><a href=\"#Mutex锁实现\" class=\"headerlink\" title=\"Mutex锁实现\"></a>Mutex锁实现</h2><p>互斥锁是最经典的锁，同一时刻只能有一个线程获取锁，并且不可重入。我们可以以0为释放，1为获取作为状态，当获取锁时候，将状态从0置为1，新的线程再次获取时候，将被阻塞。当释放锁时候，将状态从1置为0，并且唤醒之前被阻塞的线程。</p>\n<p>1 状态是什么？ 是否获取锁</p>\n<p>2  状态转换？ 获取锁时候，状态从0修改为1，释放锁时候，状态从1修改为0.</p>\n<p>3  实现细节？ 实现Lock接口，内部静态final类实现Sync，用于实现AQS的protected方法 ，公共方法调用AQS的public final方法。</p>\n<p>我们来看实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Mutex</span> <span class=\"keyword\">implements</span> <span class=\"title\">Lock</span>, <span class=\"title\">java</span>.<span class=\"title\">io</span>.<span class=\"title\">Serializable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 内部助手类，桥接模式</span></span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sync</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"comment\">// Reports whether in locked state</span></span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isHeldExclusively</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">         <span class=\"comment\">//状态为1，认为是当前线程独占</span></span><br><span class=\"line\">       <span class=\"keyword\">return</span> getState() == <span class=\"number\">1</span>;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"comment\">// Acquires the lock if state is zero</span></span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryAcquire</span><span class=\"params\">(<span class=\"keyword\">int</span> acquires)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">assert</span> acquires == <span class=\"number\">1</span>; <span class=\"comment\">// Otherwise unused</span></span><br><span class=\"line\">       <span class=\"keyword\">if</span> (compareAndSetState(<span class=\"number\">0</span>, <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">         <span class=\"comment\">//获取锁时候将状态从0原子更新到1，并且设置当前获取者是自己，获取成功返回true</span></span><br><span class=\"line\">         setExclusiveOwnerThread(Thread.currentThread());</span><br><span class=\"line\">         <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"comment\">// Releases the lock by setting state to zero</span></span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryRelease</span><span class=\"params\">(<span class=\"keyword\">int</span> releases)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">assert</span> releases == <span class=\"number\">1</span>; <span class=\"comment\">// Otherwise unused</span></span><br><span class=\"line\">       <span class=\"comment\">//释放锁时候状态不能为0</span></span><br><span class=\"line\">       <span class=\"keyword\">if</span> (getState() == <span class=\"number\">0</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalMonitorStateException();</span><br><span class=\"line\">       setExclusiveOwnerThread(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">       <span class=\"comment\">//状态更新为0</span></span><br><span class=\"line\">       setState(<span class=\"number\">0</span>);</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">       </span><br><span class=\"line\">     <span class=\"comment\">// Provides a Condition</span></span><br><span class=\"line\">     <span class=\"function\">Condition <span class=\"title\">newCondition</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ConditionObject(); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"comment\">// Deserializes properly</span></span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">readObject</span><span class=\"params\">(ObjectInputStream s)</span></span></span><br><span class=\"line\"><span class=\"function\">         <span class=\"keyword\">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class=\"line\">       s.defaultReadObject();</span><br><span class=\"line\">       setState(<span class=\"number\">0</span>); <span class=\"comment\">// reset to unlocked state</span></span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// The sync object does all the hard work. We just forward to it.</span></span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Sync sync = <span class=\"keyword\">new</span> Sync();</span><br><span class=\"line\">   <span class=\"comment\">//实现lock接口，并且公共方法调用AQS的public final方法</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">lock</span><span class=\"params\">()</span>                </span>&#123; sync.acquire(<span class=\"number\">1</span>); &#125;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryLock</span><span class=\"params\">()</span>          </span>&#123; <span class=\"keyword\">return</span> sync.tryAcquire(<span class=\"number\">1</span>); &#125;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">unlock</span><span class=\"params\">()</span>              </span>&#123; sync.release(<span class=\"number\">1</span>); &#125;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> Condition <span class=\"title\">newCondition</span><span class=\"params\">()</span>   </span>&#123; <span class=\"keyword\">return</span> sync.newCondition(); &#125;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isLocked</span><span class=\"params\">()</span>         </span>&#123; <span class=\"keyword\">return</span> sync.isHeldExclusively(); &#125;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hasQueuedThreads</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> sync.hasQueuedThreads(); &#125;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">lockInterruptibly</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">     sync.acquireInterruptibly(<span class=\"number\">1</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryLock</span><span class=\"params\">(<span class=\"keyword\">long</span> timeout, TimeUnit unit)</span></span></span><br><span class=\"line\"><span class=\"function\">       <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> sync.tryAcquireNanos(<span class=\"number\">1</span>, unit.toNanos(timeout));</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"BooleanLatch-同步器实现\"><a href=\"#BooleanLatch-同步器实现\" class=\"headerlink\" title=\"BooleanLatch 同步器实现\"></a>BooleanLatch 同步器实现</h2><p>布尔Latch，可以来回切换，只允许一个信号被唤醒，但是是共享获取的，所以使用tryAcquireShared，tryReleaseShared.</p>\n<p>1  状态是什么？获取成功或者失败</p>\n<p>2  状态转换？    成功1，失败-1</p>\n<p>3  实现细节？ </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BooleanLatch</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sync</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isSignalled</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> getState() != <span class=\"number\">0</span>; &#125;</span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> <span class=\"title\">tryAcquireShared</span><span class=\"params\">(<span class=\"keyword\">int</span> ignore)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"comment\">//1  共享获取成功   -1 共享获取失败，线程阻塞</span></span><br><span class=\"line\">       <span class=\"keyword\">return</span> isSignalled() ? <span class=\"number\">1</span> : -<span class=\"number\">1</span>;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryReleaseShared</span><span class=\"params\">(<span class=\"keyword\">int</span> ignore)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"comment\">//释放锁时候，将状态设置为1，并且唤醒被阻塞的线程</span></span><br><span class=\"line\">       setState(<span class=\"number\">1</span>);</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Sync sync = <span class=\"keyword\">new</span> Sync();</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isSignalled</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> sync.isSignalled(); &#125;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">signal</span><span class=\"params\">()</span>         </span>&#123; sync.releaseShared(<span class=\"number\">1</span>); &#125;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">await</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">     sync.acquireSharedInterruptibly(<span class=\"number\">1</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"CountDownLatch同步器实现\"><a href=\"#CountDownLatch同步器实现\" class=\"headerlink\" title=\"CountDownLatch同步器实现\"></a>CountDownLatch同步器实现</h2><p>1  状态是什么？ 当前计数值</p>\n<p>2  状态转换？每次减少一个计数值，直到0，才进行唤醒，当计数器大于0的时候，一直等待计数器降为0</p>\n<p>3  实现细节？共享获取，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//构造函数初始化内部同步器的计数值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">CountDownLatch</span><span class=\"params\">(<span class=\"keyword\">int</span> count)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (count &lt; <span class=\"number\">0</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"count &lt; 0\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.sync = <span class=\"keyword\">new</span> Sync(count);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//sync的实现</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sync</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    Sync(<span class=\"keyword\">int</span> count) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//初始化状态设置计数值为count</span></span><br><span class=\"line\">        setState(count);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getCount</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> getState();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//共享获取，状态为0的时候，获取成功，不为0的时候，获取失败，被阻塞</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> <span class=\"title\">tryAcquireShared</span><span class=\"params\">(<span class=\"keyword\">int</span> acquires)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (getState() == <span class=\"number\">0</span>) ? <span class=\"number\">1</span> : -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"comment\">//每次countDown时候，在for循环中不断减少初始化计数值，当减少到0的时候，释放成功，将会唤醒等待线程，当已经成为0的时候</span></span><br><span class=\"line\">    <span class=\"comment\">//将一直释放失败，所以CountDownLatch只能用一次。</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryReleaseShared</span><span class=\"params\">(<span class=\"keyword\">int</span> releases)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// Decrement count; signal when transition to zero</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> c = getState();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (c == <span class=\"number\">0</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> nextc = c-<span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (compareAndSetState(c, nextc))</span><br><span class=\"line\">                <span class=\"comment\">//降低到0的那一次，返回true，唤醒await的线程</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> nextc == <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//公共API实现</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">await</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">     sync.acquireSharedInterruptibly(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">countDown</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">     sync.releaseShared(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在EffectiveJava3的item17中有句话点评到：构造器应该创建完全初始化的对象，并且建立起所有约束关系。CountDownLatch是可变的，但是它的状态被刻意设计的非常小，比如创建一个实例，只能用一次，一旦定时器的计数达到0，就不能再用了。</p>\n<h2 id=\"ReentrantLock锁实现\"><a href=\"#ReentrantLock锁实现\" class=\"headerlink\" title=\"ReentrantLock锁实现\"></a>ReentrantLock锁实现</h2><p>1  状态是什么？获取锁操作次数</p>\n<p>2  状态转换是什么？同一个线程多次获取锁，累加锁操作次数，对应的多次释放锁，减少锁操作次数</p>\n<p>3  实现细节？实现Lock接口，独占锁</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//抽象同步器，设计为静态类，作为公平同步器和非公平同步器的父类</span></span><br><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sync</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = -<span class=\"number\">5179523762034025860L</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">lock</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Performs non-fair tryLock.  tryAcquire is implemented in</span></span><br><span class=\"line\"><span class=\"comment\">     * subclasses, but both need nonfair try for trylock method.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">nonfairTryAcquire</span><span class=\"params\">(<span class=\"keyword\">int</span> acquires)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Thread current = Thread.currentThread();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> c = getState();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (c == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (compareAndSetState(<span class=\"number\">0</span>, acquires)) &#123;</span><br><span class=\"line\">                setExclusiveOwnerThread(current);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> nextc = c + acquires;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nextc &lt; <span class=\"number\">0</span>) <span class=\"comment\">// overflow</span></span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(<span class=\"string\">\"Maximum lock count exceeded\"</span>);</span><br><span class=\"line\">            setState(nextc);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryRelease</span><span class=\"params\">(<span class=\"keyword\">int</span> releases)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> c = getState() - releases;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalMonitorStateException();</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> free = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (c == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            free = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            setExclusiveOwnerThread(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        setState(c);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> free;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isHeldExclusively</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// While we must in general read state before owner,</span></span><br><span class=\"line\">        <span class=\"comment\">// we don't need to do so to check if current thread is owner</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> getExclusiveOwnerThread() == Thread.currentThread();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">final</span> ConditionObject <span class=\"title\">newCondition</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ConditionObject();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">final</span> Thread <span class=\"title\">getOwner</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> getState() == <span class=\"number\">0</span> ? <span class=\"keyword\">null</span> : getExclusiveOwnerThread();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">getHoldCount</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> isHeldExclusively() ? getState() : <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isLocked</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> getState() != <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//公平同步器，静态final类</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FairSync</span> <span class=\"keyword\">extends</span> <span class=\"title\">Sync</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">lock</span><span class=\"params\">()</span> </span>&#123;acquire(<span class=\"number\">1</span>);&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryAcquire</span><span class=\"params\">(<span class=\"keyword\">int</span> acquires)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Thread current = Thread.currentThread();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> c = getState();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (c == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//第一次获取，判断如果没有后继者，将锁操作次数修改为acquires，并且设置自己是锁的拥有者，</span></span><br><span class=\"line\">            <span class=\"comment\">//setExclusiveOwnerThread是中的AbstractOwnableSynchronizer方法</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(<span class=\"number\">0</span>, acquires)) &#123;</span><br><span class=\"line\">                setExclusiveOwnerThread(current);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//第二次获取，如果还是自己，则将锁获取次数累加，并且修改状态为锁的获取次数，这里也是可重入的实现，当超过</span></span><br><span class=\"line\">        <span class=\"comment\">//锁最大可获取次数，则抛出Error，注意Error是非受检异常</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> nextc = c + acquires;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nextc &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(<span class=\"string\">\"Maximum lock count exceeded\"</span>);</span><br><span class=\"line\">            setState(nextc);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//非公平同步器，静态final类</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NonfairSync</span> <span class=\"keyword\">extends</span> <span class=\"title\">Sync</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = <span class=\"number\">7316153563782823691L</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * Performs lock.  Try immediate barge, backing up to normal</span></span><br><span class=\"line\"><span class=\"comment\">         * acquire on failure.</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">lock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (compareAndSetState(<span class=\"number\">0</span>, <span class=\"number\">1</span>))</span><br><span class=\"line\">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            acquire(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryAcquire</span><span class=\"params\">(<span class=\"keyword\">int</span> acquires)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nonfairTryAcquire(acquires);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//公有API</span></span><br><span class=\"line\"><span class=\"comment\">//构造器</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ReentrantLock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//默认非公平</span></span><br><span class=\"line\">    sync = <span class=\"keyword\">new</span> NonfairSync();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ReentrantLock</span><span class=\"params\">(<span class=\"keyword\">boolean</span> fair)</span> </span>&#123;</span><br><span class=\"line\">    sync = fair ? <span class=\"keyword\">new</span> FairSync() : <span class=\"keyword\">new</span> NonfairSync();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">lock</span><span class=\"params\">()</span> </span>&#123;sync.lock();&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">lockInterruptibly</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;sync.acquireInterruptibly(<span class=\"number\">1</span>);&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Condition <span class=\"title\">newCondition</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> sync.newCondition();&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryLock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//tryLock时候，无论公平锁还是非公平锁，都是非公平获取</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> sync.nonfairTryAcquire(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">unlock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//减少一次锁获取次数</span></span><br><span class=\"line\">    sync.release(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>由此我们可以看到，可重入锁的最大次数是int最大值，也就是2147483647 ，同一个线程最大可以递归获取锁21亿次。</p>\n<h2 id=\"Semaphore同步器实现\"><a href=\"#Semaphore同步器实现\" class=\"headerlink\" title=\"Semaphore同步器实现\"></a>Semaphore同步器实现</h2><p>1  状态是什么？当前可用许可数量</p>\n<p>2  状态切换？ 每当有一个线程获取到许可时候，就将许可减1，当许可减低为0的时候，阻塞线程，直到许可大于0</p>\n<p>3 实现细节？可共享获取</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sync</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = <span class=\"number\">1192457210091910933L</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    Sync(<span class=\"keyword\">int</span> permits) &#123;</span><br><span class=\"line\">        setState(permits);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">getPermits</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> getState();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">nonfairTryAcquireShared</span><span class=\"params\">(<span class=\"keyword\">int</span> acquires)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//可用许可</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> available = getState();</span><br><span class=\"line\">            <span class=\"comment\">//剩余许可</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> remaining = available - acquires;</span><br><span class=\"line\">            <span class=\"comment\">//剩余许可小于0或者将可用修改为剩余</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (remaining &lt; <span class=\"number\">0</span> || compareAndSetState(available, remaining))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> remaining;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryReleaseShared</span><span class=\"params\">(<span class=\"keyword\">int</span> releases)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> current = getState();</span><br><span class=\"line\">            <span class=\"keyword\">int</span> next = current + releases;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (next &lt; current) <span class=\"comment\">// overflow</span></span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(<span class=\"string\">\"Maximum permit count exceeded\"</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (compareAndSetState(current, next))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">reducePermits</span><span class=\"params\">(<span class=\"keyword\">int</span> reductions)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> current = getState();</span><br><span class=\"line\">            <span class=\"keyword\">int</span> next = current - reductions;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (next &gt; current) <span class=\"comment\">// underflow</span></span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(<span class=\"string\">\"Permit count underflow\"</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (compareAndSetState(current, next))</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">drainPermits</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> current = getState();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (current == <span class=\"number\">0</span> || compareAndSetState(current, <span class=\"number\">0</span>))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> current;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//公平同步器</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FairSync</span> <span class=\"keyword\">extends</span> <span class=\"title\">Sync</span> </span>&#123;</span><br><span class=\"line\">    FairSync(<span class=\"keyword\">int</span> permits) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(permits);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> <span class=\"title\">tryAcquireShared</span><span class=\"params\">(<span class=\"keyword\">int</span> acquires)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//是否有前继者，如果线程有前继者，说明已有线程被阻塞，直接返回获取失败</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (hasQueuedPredecessors())</span><br><span class=\"line\">                <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> available = getState();</span><br><span class=\"line\">            <span class=\"keyword\">int</span> remaining = available - acquires;</span><br><span class=\"line\">            <span class=\"comment\">//剩余小于0或者可用修改为剩余，如果大于0，则获取成功，如果等于0，则独占获取，如果小于0，则获取失败</span></span><br><span class=\"line\">            <span class=\"comment\">//所有当剩余许可小于0的时候，也就是信号量使用完的时候，线程获取锁将被阻塞</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (remaining &lt; <span class=\"number\">0</span> || compareAndSetState(available, remaining))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> remaining;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//非公平同步器</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NonfairSync</span> <span class=\"keyword\">extends</span> <span class=\"title\">Sync</span> </span>&#123;</span><br><span class=\"line\">    NonfairSync(<span class=\"keyword\">int</span> permits) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(permits);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> <span class=\"title\">tryAcquireShared</span><span class=\"params\">(<span class=\"keyword\">int</span> acquires)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nonfairTryAcquireShared(acquires);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//公共API</span></span><br><span class=\"line\"><span class=\"comment\">//构造函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Semaphore</span><span class=\"params\">(<span class=\"keyword\">int</span> permits)</span> </span>&#123; sync = <span class=\"keyword\">new</span> NonfairSync(permits);&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Semaphore</span><span class=\"params\">(<span class=\"keyword\">int</span> permits, <span class=\"keyword\">boolean</span> fair)</span> </span>&#123;</span><br><span class=\"line\">    sync = fair ? <span class=\"keyword\">new</span> FairSync(permits) : <span class=\"keyword\">new</span> NonfairSync(permits);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">acquire</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    sync.acquireSharedInterruptibly(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">acquire</span><span class=\"params\">(<span class=\"keyword\">int</span> permits)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (permits &lt; <span class=\"number\">0</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException();</span><br><span class=\"line\">     sync.acquireSharedInterruptibly(permits);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">release</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    sync.releaseShared(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">release</span><span class=\"params\">(<span class=\"keyword\">int</span> permits)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (permits &lt; <span class=\"number\">0</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException();</span><br><span class=\"line\">    sync.releaseShared(permits);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>我们可以看到，Semaphore是初始化N个许可，线程无需等待，然后每一个线程会消耗信号量，当消耗完时，会阻塞后面线程，而CountDownLatch是初始化N个计数器，然后线程等待，当计数器降为0的时候，唤醒初始化等待的线程，这两者有些相反的含义在里面。两种同用共享获取方式，共享释放释放。</p>\n<h1 id=\"4-总结\"><a href=\"#4-总结\" class=\"headerlink\" title=\"4  总结\"></a>4  总结</h1><p>在实现锁或者同步器时候，需要思考以下几点：</p>\n<p>1  状态变量以及状态变量的转换</p>\n<p>2   是独占的还是共享的</p>\n<p>当想明白以上两个问题时候，就可以动手实现你要的同步器的，一般是以内部静态类的方式继承AQS的protected方法，在protected方法中，调用protected final方法，然后在你要公共API中调用你的内部同步器的public final方法既可。如下实现模板：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> MyLock implements Lock,  or MySync &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">//内部同步器，继承AQS的protected方法，里面调用AQS的protected final方法修改状态</span></span><br><span class=\"line\">   innerStaticSync extends AbstractQueuedSynchronizer&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"comment\">//独占获取 tryAcquire，tryRelease，isHeldExclusively</span></span><br><span class=\"line\">       <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryAcquire</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">           getState/setState/compareAndSetState</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryRelease</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;&#125;</span><br><span class=\"line\">       <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isHeldExclusively</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\">       <span class=\"comment\">//共享获取 tryAcquireShared，tryReleaseShared</span></span><br><span class=\"line\">       <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> <span class=\"title\">tryAcquireShared</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;&#125;</span><br><span class=\"line\">       <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryReleaseShared</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;&#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">\t<span class=\"comment\">//构造函数实例化</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> MyLock or MySync &#123;</span><br><span class=\"line\">        innerStaticSync = <span class=\"keyword\">new</span> MyLock() <span class=\"function\">or new <span class=\"title\">MySync</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//public api 调用AQS的public final方法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">acquire</span><span class=\"params\">()</span></span>&#123;innerStaticSync.acquire();&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">release</span><span class=\"params\">()</span></span>&#123;innerStaticSync.release();&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>Done！</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"AQS概述\"><a href=\"#AQS概述\" class=\"headerlink\" title=\"AQS概述\"></a>AQS概述</h1><p>AbstractQueuedSynchronizer是Java用于替代 <strong>Synchronized+内置等待通知(wait/notify)+内置条件队列</strong>的抽象队列同步器，该同步器管理锁，条件变量(状态变量)，条件谓词三元关系，从而技术上实现了锁，条件队列，等待通知，阻塞等同步语义。在JUC中广泛使用，其中有ReentrantLock，ReentrantReadWriteLock，Semaphore，CountDownLatch，ThreadPoolExecutor#Worker，而这些基石又组成了部分并发集合，可见其重要性，该同步器比内置的伸缩性和容错性更好，并且功能比内置的更加强大，文章主要分析AQS API设计，以及如何使用该类实现自定义的锁和同步器。</p>\n<h1 id=\"AQS-API一览\"><a href=\"#AQS-API一览\" class=\"headerlink\" title=\"AQS API一览\"></a>AQS API一览</h1><p>AQS API主要分为以下几类，1 public final 方法 ，用于实现类调用以完成获取锁/释放锁的操作，2  protected final方法，用于实现类获取，原子修改状态变量， 3  protected方法，用于实现类覆写，并且协同 protected final从而真正完成等待/通知的同步语义， 4 私有方法，作为内部实现，并非API，故不分析私有方法。</p>\n<h2 id=\"public-final-方法\"><a href=\"#public-final-方法\" class=\"headerlink\" title=\"public final 方法\"></a>public final 方法</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">acquire</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!tryAcquire(arg) &amp;&amp; acquireQueued(addWaiter(Node.EXCLUSIVE), arg))</span><br><span class=\"line\">            selfInterrupt();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">线程以独占方式用于获取锁，如果获取到，tryAcquire(arg)将会实现状态修改，否则线程将会入队，被阻塞。</span><br><span class=\"line\">    </span><br><span class=\"line\">    </span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">acquireInterruptibly</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Thread.interrupted())</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> InterruptedException();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!tryAcquire(arg))</span><br><span class=\"line\">        doAcquireInterruptibly(arg);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">线程以响应中断的方式获取锁。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">acquireShared</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tryAcquireShared(arg) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        doAcquireShared(arg);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">小于<span class=\"number\">0</span>，共享获取失败，则线程入队阻塞。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">acquireSharedInterruptibly</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (Thread.interrupted())</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> InterruptedException();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tryAcquireShared(arg) &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">        doAcquireSharedInterruptibly(arg);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">以可响应中断的方式共享获取。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">release</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tryRelease(arg)) &#123;</span><br><span class=\"line\">        Node h = head;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (h != <span class=\"keyword\">null</span> &amp;&amp; h.waitStatus != <span class=\"number\">0</span>)</span><br><span class=\"line\">            unparkSuccessor(h);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">以独占方式释放，释放成功将unparkSuccessor.</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">releaseShared</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tryReleaseShared(arg)) &#123;</span><br><span class=\"line\">        doReleaseShared();</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">以共享方式释放。</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> Collection&lt;Thread&gt; <span class=\"title\">getWaitingThreads</span><span class=\"params\">(ConditionObject condition)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">getWaitQueueLength</span><span class=\"params\">(ConditionObject condition)</span> </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hasContended</span><span class=\"params\">()</span> </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryAcquireNanos</span><span class=\"params\">(<span class=\"keyword\">int</span> arg, <span class=\"keyword\">long</span> nanosTimeout)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryAcquireSharedNanos</span><span class=\"params\">(<span class=\"keyword\">int</span> arg, <span class=\"keyword\">long</span> nanosTimeout)</span></span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>基本获取/释放方法包含了以<strong>tryXXX</strong>开头的方法，这些方法都需要实现类自己来定义，通过对tryXXX方法覆写，从而实现自定义的获取释放操作。</p>\n<h2 id=\"protect方法\"><a href=\"#protect方法\" class=\"headerlink\" title=\"protect方法\"></a>protect方法</h2><p>tryAcquire, tryRelease,isHeldExclusively是实现<strong>独占语义</strong>需要覆写的方法，而tryAcquireShared，tryReleaseShared是实现<strong>共享语义</strong>需要覆写的方法，其内部实现均为throw new UnsupportedOperationException()；简单而言，就是通过状态变量的修改来决定获取锁成功，获取锁失败被阻塞，释放锁失败，释放锁成功唤醒被阻塞线程的简单语义。本质是Synchronized+wait+notify+条件队列语义的高级实现。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryAcquire</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span>     <span class=\"keyword\">true</span>,成功获取，<span class=\"keyword\">false</span>，失败获取，线程将入队阻塞。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryRelease</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span>     <span class=\"keyword\">true</span>，成功释放，唤醒被阻塞的线程，<span class=\"keyword\">false</span>，释放失败。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isHeldExclusively</span><span class=\"params\">()</span>     <span class=\"keyword\">true</span>，被当前线程持有，<span class=\"keyword\">false</span>，非当前线程持有。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> <span class=\"title\">tryAcquireShared</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span>   负值，获取失败，线程入队被阻塞，零值，以独占方式获取，正值，以共享方式获取</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryReleaseShared</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> <span class=\"keyword\">true</span>，使得所有在获取时候阻塞的线程恢复执行，<span class=\"keyword\">false</span> 释放失败</span></span><br></pre></td></tr></table></figure>\n\n\n\n<p>当理解了protect的语义后，就需要在protect中调用protect final来真正操作状态变量了。</p>\n<h2 id=\"protect-final-方法\"><a href=\"#protect-final-方法\" class=\"headerlink\" title=\"protect final  方法\"></a>protect final  方法</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">getState</span><span class=\"params\">()</span>    获取状态</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">setState</span><span class=\"params\">(<span class=\"keyword\">int</span> newState)</span>  设置状态  </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">compareAndSetState</span><span class=\"params\">(<span class=\"keyword\">int</span> expect, <span class=\"keyword\">int</span> update)</span>  原子更新状态</span></span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h1 id=\"AQS使用实战\"><a href=\"#AQS使用实战\" class=\"headerlink\" title=\"AQS使用实战\"></a>AQS使用实战</h1><p>当我们实现一个锁或者同步器时候，最重要的思考是你的状态变量是什么？条件谓词是什么？状态变量和条件谓词之间的转换关系？首先应该清晰理解你需要被AQS管理的状态，其次是这些状态之间转换。可以说，状态变量及其转换带来的同步语义是最重要的设计思考。我们先从官方API实例Mutex 和BooleanLatch说起，然后深入JDK例子CountDownLatch，ReentrantLock，Semaphore，最后总结实现AQS的模板。</p>\n<h2 id=\"Mutex锁实现\"><a href=\"#Mutex锁实现\" class=\"headerlink\" title=\"Mutex锁实现\"></a>Mutex锁实现</h2><p>互斥锁是最经典的锁，同一时刻只能有一个线程获取锁，并且不可重入。我们可以以0为释放，1为获取作为状态，当获取锁时候，将状态从0置为1，新的线程再次获取时候，将被阻塞。当释放锁时候，将状态从1置为0，并且唤醒之前被阻塞的线程。</p>\n<p>1 状态是什么？ 是否获取锁</p>\n<p>2  状态转换？ 获取锁时候，状态从0修改为1，释放锁时候，状态从1修改为0.</p>\n<p>3  实现细节？ 实现Lock接口，内部静态final类实现Sync，用于实现AQS的protected方法 ，公共方法调用AQS的public final方法。</p>\n<p>我们来看实现：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Mutex</span> <span class=\"keyword\">implements</span> <span class=\"title\">Lock</span>, <span class=\"title\">java</span>.<span class=\"title\">io</span>.<span class=\"title\">Serializable</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// 内部助手类，桥接模式</span></span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sync</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"comment\">// Reports whether in locked state</span></span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isHeldExclusively</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">         <span class=\"comment\">//状态为1，认为是当前线程独占</span></span><br><span class=\"line\">       <span class=\"keyword\">return</span> getState() == <span class=\"number\">1</span>;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"comment\">// Acquires the lock if state is zero</span></span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryAcquire</span><span class=\"params\">(<span class=\"keyword\">int</span> acquires)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">assert</span> acquires == <span class=\"number\">1</span>; <span class=\"comment\">// Otherwise unused</span></span><br><span class=\"line\">       <span class=\"keyword\">if</span> (compareAndSetState(<span class=\"number\">0</span>, <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">         <span class=\"comment\">//获取锁时候将状态从0原子更新到1，并且设置当前获取者是自己，获取成功返回true</span></span><br><span class=\"line\">         setExclusiveOwnerThread(Thread.currentThread());</span><br><span class=\"line\">         <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"comment\">// Releases the lock by setting state to zero</span></span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryRelease</span><span class=\"params\">(<span class=\"keyword\">int</span> releases)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"keyword\">assert</span> releases == <span class=\"number\">1</span>; <span class=\"comment\">// Otherwise unused</span></span><br><span class=\"line\">       <span class=\"comment\">//释放锁时候状态不能为0</span></span><br><span class=\"line\">       <span class=\"keyword\">if</span> (getState() == <span class=\"number\">0</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalMonitorStateException();</span><br><span class=\"line\">       setExclusiveOwnerThread(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">       <span class=\"comment\">//状态更新为0</span></span><br><span class=\"line\">       setState(<span class=\"number\">0</span>);</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">       </span><br><span class=\"line\">     <span class=\"comment\">// Provides a Condition</span></span><br><span class=\"line\">     <span class=\"function\">Condition <span class=\"title\">newCondition</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ConditionObject(); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">     <span class=\"comment\">// Deserializes properly</span></span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">readObject</span><span class=\"params\">(ObjectInputStream s)</span></span></span><br><span class=\"line\"><span class=\"function\">         <span class=\"keyword\">throws</span> IOException, ClassNotFoundException </span>&#123;</span><br><span class=\"line\">       s.defaultReadObject();</span><br><span class=\"line\">       setState(<span class=\"number\">0</span>); <span class=\"comment\">// reset to unlocked state</span></span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">// The sync object does all the hard work. We just forward to it.</span></span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Sync sync = <span class=\"keyword\">new</span> Sync();</span><br><span class=\"line\">   <span class=\"comment\">//实现lock接口，并且公共方法调用AQS的public final方法</span></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">lock</span><span class=\"params\">()</span>                </span>&#123; sync.acquire(<span class=\"number\">1</span>); &#125;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryLock</span><span class=\"params\">()</span>          </span>&#123; <span class=\"keyword\">return</span> sync.tryAcquire(<span class=\"number\">1</span>); &#125;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">unlock</span><span class=\"params\">()</span>              </span>&#123; sync.release(<span class=\"number\">1</span>); &#125;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> Condition <span class=\"title\">newCondition</span><span class=\"params\">()</span>   </span>&#123; <span class=\"keyword\">return</span> sync.newCondition(); &#125;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isLocked</span><span class=\"params\">()</span>         </span>&#123; <span class=\"keyword\">return</span> sync.isHeldExclusively(); &#125;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hasQueuedThreads</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> sync.hasQueuedThreads(); &#125;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">lockInterruptibly</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">     sync.acquireInterruptibly(<span class=\"number\">1</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryLock</span><span class=\"params\">(<span class=\"keyword\">long</span> timeout, TimeUnit unit)</span></span></span><br><span class=\"line\"><span class=\"function\">       <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">return</span> sync.tryAcquireNanos(<span class=\"number\">1</span>, unit.toNanos(timeout));</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"BooleanLatch-同步器实现\"><a href=\"#BooleanLatch-同步器实现\" class=\"headerlink\" title=\"BooleanLatch 同步器实现\"></a>BooleanLatch 同步器实现</h2><p>布尔Latch，可以来回切换，只允许一个信号被唤醒，但是是共享获取的，所以使用tryAcquireShared，tryReleaseShared.</p>\n<p>1  状态是什么？获取成功或者失败</p>\n<p>2  状态转换？    成功1，失败-1</p>\n<p>3  实现细节？ </p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">BooleanLatch</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sync</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isSignalled</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> getState() != <span class=\"number\">0</span>; &#125;</span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> <span class=\"title\">tryAcquireShared</span><span class=\"params\">(<span class=\"keyword\">int</span> ignore)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"comment\">//1  共享获取成功   -1 共享获取失败，线程阻塞</span></span><br><span class=\"line\">       <span class=\"keyword\">return</span> isSignalled() ? <span class=\"number\">1</span> : -<span class=\"number\">1</span>;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryReleaseShared</span><span class=\"params\">(<span class=\"keyword\">int</span> ignore)</span> </span>&#123;</span><br><span class=\"line\">       <span class=\"comment\">//释放锁时候，将状态设置为1，并且唤醒被阻塞的线程</span></span><br><span class=\"line\">       setState(<span class=\"number\">1</span>);</span><br><span class=\"line\">       <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">     &#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> Sync sync = <span class=\"keyword\">new</span> Sync();</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isSignalled</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> sync.isSignalled(); &#125;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">signal</span><span class=\"params\">()</span>         </span>&#123; sync.releaseShared(<span class=\"number\">1</span>); &#125;</span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">await</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">     sync.acquireSharedInterruptibly(<span class=\"number\">1</span>);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\"> &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"CountDownLatch同步器实现\"><a href=\"#CountDownLatch同步器实现\" class=\"headerlink\" title=\"CountDownLatch同步器实现\"></a>CountDownLatch同步器实现</h2><p>1  状态是什么？ 当前计数值</p>\n<p>2  状态转换？每次减少一个计数值，直到0，才进行唤醒，当计数器大于0的时候，一直等待计数器降为0</p>\n<p>3  实现细节？共享获取，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//构造函数初始化内部同步器的计数值</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">CountDownLatch</span><span class=\"params\">(<span class=\"keyword\">int</span> count)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (count &lt; <span class=\"number\">0</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"count &lt; 0\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.sync = <span class=\"keyword\">new</span> Sync(count);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//sync的实现</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sync</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    Sync(<span class=\"keyword\">int</span> count) &#123;</span><br><span class=\"line\">        <span class=\"comment\">//初始化状态设置计数值为count</span></span><br><span class=\"line\">        setState(count);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">getCount</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> getState();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//共享获取，状态为0的时候，获取成功，不为0的时候，获取失败，被阻塞</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> <span class=\"title\">tryAcquireShared</span><span class=\"params\">(<span class=\"keyword\">int</span> acquires)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (getState() == <span class=\"number\">0</span>) ? <span class=\"number\">1</span> : -<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"comment\">//每次countDown时候，在for循环中不断减少初始化计数值，当减少到0的时候，释放成功，将会唤醒等待线程，当已经成为0的时候</span></span><br><span class=\"line\">    <span class=\"comment\">//将一直释放失败，所以CountDownLatch只能用一次。</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryReleaseShared</span><span class=\"params\">(<span class=\"keyword\">int</span> releases)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// Decrement count; signal when transition to zero</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> c = getState();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (c == <span class=\"number\">0</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> nextc = c-<span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (compareAndSetState(c, nextc))</span><br><span class=\"line\">                <span class=\"comment\">//降低到0的那一次，返回true，唤醒await的线程</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> nextc == <span class=\"number\">0</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//公共API实现</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">await</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">     sync.acquireSharedInterruptibly(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">countDown</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">     sync.releaseShared(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>在EffectiveJava3的item17中有句话点评到：构造器应该创建完全初始化的对象，并且建立起所有约束关系。CountDownLatch是可变的，但是它的状态被刻意设计的非常小，比如创建一个实例，只能用一次，一旦定时器的计数达到0，就不能再用了。</p>\n<h2 id=\"ReentrantLock锁实现\"><a href=\"#ReentrantLock锁实现\" class=\"headerlink\" title=\"ReentrantLock锁实现\"></a>ReentrantLock锁实现</h2><p>1  状态是什么？获取锁操作次数</p>\n<p>2  状态转换是什么？同一个线程多次获取锁，累加锁操作次数，对应的多次释放锁，减少锁操作次数</p>\n<p>3  实现细节？实现Lock接口，独占锁</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br><span class=\"line\">112</span><br><span class=\"line\">113</span><br><span class=\"line\">114</span><br><span class=\"line\">115</span><br><span class=\"line\">116</span><br><span class=\"line\">117</span><br><span class=\"line\">118</span><br><span class=\"line\">119</span><br><span class=\"line\">120</span><br><span class=\"line\">121</span><br><span class=\"line\">122</span><br><span class=\"line\">123</span><br><span class=\"line\">124</span><br><span class=\"line\">125</span><br><span class=\"line\">126</span><br><span class=\"line\">127</span><br><span class=\"line\">128</span><br><span class=\"line\">129</span><br><span class=\"line\">130</span><br><span class=\"line\">131</span><br><span class=\"line\">132</span><br><span class=\"line\">133</span><br><span class=\"line\">134</span><br><span class=\"line\">135</span><br><span class=\"line\">136</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//抽象同步器，设计为静态类，作为公平同步器和非公平同步器的父类</span></span><br><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sync</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = -<span class=\"number\">5179523762034025860L</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">lock</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     * Performs non-fair tryLock.  tryAcquire is implemented in</span></span><br><span class=\"line\"><span class=\"comment\">     * subclasses, but both need nonfair try for trylock method.</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">nonfairTryAcquire</span><span class=\"params\">(<span class=\"keyword\">int</span> acquires)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Thread current = Thread.currentThread();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> c = getState();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (c == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (compareAndSetState(<span class=\"number\">0</span>, acquires)) &#123;</span><br><span class=\"line\">                setExclusiveOwnerThread(current);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> nextc = c + acquires;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nextc &lt; <span class=\"number\">0</span>) <span class=\"comment\">// overflow</span></span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(<span class=\"string\">\"Maximum lock count exceeded\"</span>);</span><br><span class=\"line\">            setState(nextc);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryRelease</span><span class=\"params\">(<span class=\"keyword\">int</span> releases)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> c = getState() - releases;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (Thread.currentThread() != getExclusiveOwnerThread())</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalMonitorStateException();</span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> free = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (c == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            free = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            setExclusiveOwnerThread(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        setState(c);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> free;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isHeldExclusively</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">// While we must in general read state before owner,</span></span><br><span class=\"line\">        <span class=\"comment\">// we don't need to do so to check if current thread is owner</span></span><br><span class=\"line\">        <span class=\"keyword\">return</span> getExclusiveOwnerThread() == Thread.currentThread();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">final</span> ConditionObject <span class=\"title\">newCondition</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> ConditionObject();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">final</span> Thread <span class=\"title\">getOwner</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> getState() == <span class=\"number\">0</span> ? <span class=\"keyword\">null</span> : getExclusiveOwnerThread();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">getHoldCount</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> isHeldExclusively() ? getState() : <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isLocked</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> getState() != <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//公平同步器，静态final类</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FairSync</span> <span class=\"keyword\">extends</span> <span class=\"title\">Sync</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">lock</span><span class=\"params\">()</span> </span>&#123;acquire(<span class=\"number\">1</span>);&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryAcquire</span><span class=\"params\">(<span class=\"keyword\">int</span> acquires)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Thread current = Thread.currentThread();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> c = getState();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (c == <span class=\"number\">0</span>) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//第一次获取，判断如果没有后继者，将锁操作次数修改为acquires，并且设置自己是锁的拥有者，</span></span><br><span class=\"line\">            <span class=\"comment\">//setExclusiveOwnerThread是中的AbstractOwnableSynchronizer方法</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!hasQueuedPredecessors() &amp;&amp; compareAndSetState(<span class=\"number\">0</span>, acquires)) &#123;</span><br><span class=\"line\">                setExclusiveOwnerThread(current);</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//第二次获取，如果还是自己，则将锁获取次数累加，并且修改状态为锁的获取次数，这里也是可重入的实现，当超过</span></span><br><span class=\"line\">        <span class=\"comment\">//锁最大可获取次数，则抛出Error，注意Error是非受检异常</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (current == getExclusiveOwnerThread()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> nextc = c + acquires;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (nextc &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(<span class=\"string\">\"Maximum lock count exceeded\"</span>);</span><br><span class=\"line\">            setState(nextc);</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//非公平同步器，静态final类</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NonfairSync</span> <span class=\"keyword\">extends</span> <span class=\"title\">Sync</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = <span class=\"number\">7316153563782823691L</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">         * Performs lock.  Try immediate barge, backing up to normal</span></span><br><span class=\"line\"><span class=\"comment\">         * acquire on failure.</span></span><br><span class=\"line\"><span class=\"comment\">         */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">lock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (compareAndSetState(<span class=\"number\">0</span>, <span class=\"number\">1</span>))</span><br><span class=\"line\">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            acquire(<span class=\"number\">1</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryAcquire</span><span class=\"params\">(<span class=\"keyword\">int</span> acquires)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nonfairTryAcquire(acquires);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//公有API</span></span><br><span class=\"line\"><span class=\"comment\">//构造器</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ReentrantLock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//默认非公平</span></span><br><span class=\"line\">    sync = <span class=\"keyword\">new</span> NonfairSync();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ReentrantLock</span><span class=\"params\">(<span class=\"keyword\">boolean</span> fair)</span> </span>&#123;</span><br><span class=\"line\">    sync = fair ? <span class=\"keyword\">new</span> FairSync() : <span class=\"keyword\">new</span> NonfairSync();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">lock</span><span class=\"params\">()</span> </span>&#123;sync.lock();&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">lockInterruptibly</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;sync.acquireInterruptibly(<span class=\"number\">1</span>);&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Condition <span class=\"title\">newCondition</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> sync.newCondition();&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryLock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//tryLock时候，无论公平锁还是非公平锁，都是非公平获取</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> sync.nonfairTryAcquire(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">unlock</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//减少一次锁获取次数</span></span><br><span class=\"line\">    sync.release(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>由此我们可以看到，可重入锁的最大次数是int最大值，也就是2147483647 ，同一个线程最大可以递归获取锁21亿次。</p>\n<h2 id=\"Semaphore同步器实现\"><a href=\"#Semaphore同步器实现\" class=\"headerlink\" title=\"Semaphore同步器实现\"></a>Semaphore同步器实现</h2><p>1  状态是什么？当前可用许可数量</p>\n<p>2  状态切换？ 每当有一个线程获取到许可时候，就将许可减1，当许可减低为0的时候，阻塞线程，直到许可大于0</p>\n<p>3 实现细节？可共享获取</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br><span class=\"line\">71</span><br><span class=\"line\">72</span><br><span class=\"line\">73</span><br><span class=\"line\">74</span><br><span class=\"line\">75</span><br><span class=\"line\">76</span><br><span class=\"line\">77</span><br><span class=\"line\">78</span><br><span class=\"line\">79</span><br><span class=\"line\">80</span><br><span class=\"line\">81</span><br><span class=\"line\">82</span><br><span class=\"line\">83</span><br><span class=\"line\">84</span><br><span class=\"line\">85</span><br><span class=\"line\">86</span><br><span class=\"line\">87</span><br><span class=\"line\">88</span><br><span class=\"line\">89</span><br><span class=\"line\">90</span><br><span class=\"line\">91</span><br><span class=\"line\">92</span><br><span class=\"line\">93</span><br><span class=\"line\">94</span><br><span class=\"line\">95</span><br><span class=\"line\">96</span><br><span class=\"line\">97</span><br><span class=\"line\">98</span><br><span class=\"line\">99</span><br><span class=\"line\">100</span><br><span class=\"line\">101</span><br><span class=\"line\">102</span><br><span class=\"line\">103</span><br><span class=\"line\">104</span><br><span class=\"line\">105</span><br><span class=\"line\">106</span><br><span class=\"line\">107</span><br><span class=\"line\">108</span><br><span class=\"line\">109</span><br><span class=\"line\">110</span><br><span class=\"line\">111</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">abstract</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Sync</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractQueuedSynchronizer</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> serialVersionUID = <span class=\"number\">1192457210091910933L</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">    Sync(<span class=\"keyword\">int</span> permits) &#123;</span><br><span class=\"line\">        setState(permits);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">getPermits</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> getState();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">nonfairTryAcquireShared</span><span class=\"params\">(<span class=\"keyword\">int</span> acquires)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//可用许可</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> available = getState();</span><br><span class=\"line\">            <span class=\"comment\">//剩余许可</span></span><br><span class=\"line\">            <span class=\"keyword\">int</span> remaining = available - acquires;</span><br><span class=\"line\">            <span class=\"comment\">//剩余许可小于0或者将可用修改为剩余</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (remaining &lt; <span class=\"number\">0</span> || compareAndSetState(available, remaining))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> remaining;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryReleaseShared</span><span class=\"params\">(<span class=\"keyword\">int</span> releases)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> current = getState();</span><br><span class=\"line\">            <span class=\"keyword\">int</span> next = current + releases;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (next &lt; current) <span class=\"comment\">// overflow</span></span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(<span class=\"string\">\"Maximum permit count exceeded\"</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (compareAndSetState(current, next))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">reducePermits</span><span class=\"params\">(<span class=\"keyword\">int</span> reductions)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> current = getState();</span><br><span class=\"line\">            <span class=\"keyword\">int</span> next = current - reductions;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (next &gt; current) <span class=\"comment\">// underflow</span></span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(<span class=\"string\">\"Permit count underflow\"</span>);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (compareAndSetState(current, next))</span><br><span class=\"line\">                <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">drainPermits</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> current = getState();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (current == <span class=\"number\">0</span> || compareAndSetState(current, <span class=\"number\">0</span>))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> current;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//公平同步器</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FairSync</span> <span class=\"keyword\">extends</span> <span class=\"title\">Sync</span> </span>&#123;</span><br><span class=\"line\">    FairSync(<span class=\"keyword\">int</span> permits) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(permits);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> <span class=\"title\">tryAcquireShared</span><span class=\"params\">(<span class=\"keyword\">int</span> acquires)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//是否有前继者，如果线程有前继者，说明已有线程被阻塞，直接返回获取失败</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (hasQueuedPredecessors())</span><br><span class=\"line\">                <span class=\"keyword\">return</span> -<span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> available = getState();</span><br><span class=\"line\">            <span class=\"keyword\">int</span> remaining = available - acquires;</span><br><span class=\"line\">            <span class=\"comment\">//剩余小于0或者可用修改为剩余，如果大于0，则获取成功，如果等于0，则独占获取，如果小于0，则获取失败</span></span><br><span class=\"line\">            <span class=\"comment\">//所有当剩余许可小于0的时候，也就是信号量使用完的时候，线程获取锁将被阻塞</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (remaining &lt; <span class=\"number\">0</span> || compareAndSetState(available, remaining))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> remaining;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//非公平同步器</span></span><br><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">NonfairSync</span> <span class=\"keyword\">extends</span> <span class=\"title\">Sync</span> </span>&#123;</span><br><span class=\"line\">    NonfairSync(<span class=\"keyword\">int</span> permits) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(permits);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> <span class=\"title\">tryAcquireShared</span><span class=\"params\">(<span class=\"keyword\">int</span> acquires)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> nonfairTryAcquireShared(acquires);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//公共API</span></span><br><span class=\"line\"><span class=\"comment\">//构造函数</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Semaphore</span><span class=\"params\">(<span class=\"keyword\">int</span> permits)</span> </span>&#123; sync = <span class=\"keyword\">new</span> NonfairSync(permits);&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">Semaphore</span><span class=\"params\">(<span class=\"keyword\">int</span> permits, <span class=\"keyword\">boolean</span> fair)</span> </span>&#123;</span><br><span class=\"line\">    sync = fair ? <span class=\"keyword\">new</span> FairSync(permits) : <span class=\"keyword\">new</span> NonfairSync(permits);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">acquire</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    sync.acquireSharedInterruptibly(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"> <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">acquire</span><span class=\"params\">(<span class=\"keyword\">int</span> permits)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">     <span class=\"keyword\">if</span> (permits &lt; <span class=\"number\">0</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException();</span><br><span class=\"line\">     sync.acquireSharedInterruptibly(permits);</span><br><span class=\"line\"> &#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">release</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    sync.releaseShared(<span class=\"number\">1</span>);</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">release</span><span class=\"params\">(<span class=\"keyword\">int</span> permits)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (permits &lt; <span class=\"number\">0</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException();</span><br><span class=\"line\">    sync.releaseShared(permits);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>我们可以看到，Semaphore是初始化N个许可，线程无需等待，然后每一个线程会消耗信号量，当消耗完时，会阻塞后面线程，而CountDownLatch是初始化N个计数器，然后线程等待，当计数器降为0的时候，唤醒初始化等待的线程，这两者有些相反的含义在里面。两种同用共享获取方式，共享释放释放。</p>\n<h1 id=\"4-总结\"><a href=\"#4-总结\" class=\"headerlink\" title=\"4  总结\"></a>4  总结</h1><p>在实现锁或者同步器时候，需要思考以下几点：</p>\n<p>1  状态变量以及状态变量的转换</p>\n<p>2   是独占的还是共享的</p>\n<p>当想明白以上两个问题时候，就可以动手实现你要的同步器的，一般是以内部静态类的方式继承AQS的protected方法，在protected方法中，调用protected final方法，然后在你要公共API中调用你的内部同步器的public final方法既可。如下实现模板：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> MyLock implements Lock,  or MySync &#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"comment\">//内部同步器，继承AQS的protected方法，里面调用AQS的protected final方法修改状态</span></span><br><span class=\"line\">   innerStaticSync extends AbstractQueuedSynchronizer&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">       <span class=\"comment\">//独占获取 tryAcquire，tryRelease，isHeldExclusively</span></span><br><span class=\"line\">       <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryAcquire</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;</span><br><span class=\"line\">           getState/setState/compareAndSetState</span><br><span class=\"line\">       &#125;</span><br><span class=\"line\">       <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryRelease</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;&#125;</span><br><span class=\"line\">       <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isHeldExclusively</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br><span class=\"line\">       <span class=\"comment\">//共享获取 tryAcquireShared，tryReleaseShared</span></span><br><span class=\"line\">       <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">int</span> <span class=\"title\">tryAcquireShared</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;&#125;</span><br><span class=\"line\">       <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryReleaseShared</span><span class=\"params\">(<span class=\"keyword\">int</span> arg)</span> </span>&#123;&#125;</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">\t<span class=\"comment\">//构造函数实例化</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> MyLock or MySync &#123;</span><br><span class=\"line\">        innerStaticSync = <span class=\"keyword\">new</span> MyLock() <span class=\"function\">or new <span class=\"title\">MySync</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//public api 调用AQS的public final方法</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">acquire</span><span class=\"params\">()</span></span>&#123;innerStaticSync.acquire();&#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">release</span><span class=\"params\">()</span></span>&#123;innerStaticSync.release();&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>Done！</p>\n"},{"title":"FutureTask设计与实现","date":"2020-11-10T18:14:39.000Z","_content":"\n# 序言\n\nFutureTask是Future和Runnable的实现，ThreadPoolExecutor在执行任务的时候，执行的是FutureTask. 传统Runnable接口实现的任务只有执行方法run，并没有任务取消，执行超时等功能，并且Runnable并没有提供任务状态的抽象，其实每个任务都是有状态的。所以FutureTask其内部将任务执行过程分为一系列状态，从而使得任务有了生命周期。在JDK中，经典的实现除了FutureTask外，还有ScheduledFutureTask. \n\n\n\n# 结构\n\n![](/images/FutureTask.png)\n\n我们可以看到它对一个普通任务支持了生命周期的方法. 从而使得任务执行有了过程的概念，而不是Runnable这样只能运行或者被中断的状态，也使得客户端更加灵活的控制任务执行。\n\n\n\n# API\n\nFutureTask的API全部来自父接口，自己只定义了构造函数，\n\n```java\n//任务执行方法，继承自RunnableFuture的run,RunnableFuture又继承在Runnable\npublic void run() \n\n//run之后，获取run的结果，可能任务执行被中断，或者执行异常\npublic V get() throws InterruptedException, ExecutionException \n\n//带超时的获取run结果，可能抛出超时异常    \npublic V get(long timeout, TimeUnit unit)  throws InterruptedException, ExecutionException, TimeoutException\n    \n//取消任务\npublic boolean cancel(boolean mayInterruptIfRunning)\n    \n//任务是否被取消   \npublic boolean isCancelled()\n    \n//任务是否完成\npublic boolean isDone()\n    \n//钩子方法\nprotected void done() { }\n```\n\n# 实现\n\n## 创建\n\n```java\n//通过Callable创建FutureTask，并且任务状态设置为NEW\npublic FutureTask(Callable<V> callable) {\n    if (callable == null)\n        throw new NullPointerException();\n    this.callable = callable;\n    this.state = NEW;       // ensure visibility of callable\n}\n```\n\n\n\n```java\n//通过Runnable创建FutureTask，并且任务状态设置为NEW\npublic FutureTask(Runnable runnable, V result) {\n    this.callable = Executors.callable(runnable, result);\n    this.state = NEW;       // ensure visibility of callable\n}\n```\n\n\n\n## 等待节点WaitNode\n\n等待节点是当有多个线程获取结果的时候，会进行排队，当有一个线程get到结果时候，其他线程将被唤醒，也将拿到结果。该等待节点的实现是Treiber Stack，Treiber 是发明者名字,它是非阻塞的同步栈，详情可参考Wikipedia.  https://en.wikipedia.org/wiki/Treiber_stack\n\n```java\nstatic final class WaitNode {\n    volatile Thread thread;\n    volatile WaitNode next;\n    WaitNode() { thread = Thread.currentThread(); }\n}\n```\n\n该类的实现是静态final类，意味着这是一个全局的类，和外部实例没有关系，并且不能被继承，\n\n\n\n## 实例变量\n\n```java\n/** 运行的任务 */\nprivate Callable<V> callable;\n/** get返回的结果 */\nprivate Object outcome; // non-volatile, protected by state reads/writes\n/** 运行Callable的线程 */\nprivate volatile Thread runner;\n/** Treiber stack上的等待线程 */\nprivate volatile WaitNode waiters;\n```\n\n\n\n\n\n## 任务状态\n\n```java\nprivate volatile int state;  //任务状态，每个API都会和状态相关\nprivate static final int NEW          = 0;\nprivate static final int COMPLETING   = 1;\nprivate static final int NORMAL       = 2;\nprivate static final int EXCEPTIONAL  = 3;\nprivate static final int CANCELLED    = 4;\nprivate static final int INTERRUPTING = 5;\nprivate static final int INTERRUPTED  = 6;\n```\n\n任务的状态有7种，每种任务状态是递增且不可逆的。下面是状态流转图：\n\n<img src=\"/images/FutureTaskStatus.png\" style=\"zoom:50%;\" />\n\n任务起始状态是NEW，中间过程有COMPLETING和INTERRUPTING，终态有四种，也就是图的叶子节点。这些状态使得任务可以被控制。\n\n\n\n## 任务运行run\n\n任务运行是实现run方法，也就是客户端自定义的任务。\n\nrun方法首先判断状态，如果任务状态不NEW，则直接退出，防止任务重复执行，然后进入真正任务执行，调用Callable的call方法，\n\ncall结束，任务执行完成，将ran置为ture，正常情况调用set，如果运行中发生异常，调用setException，\n\n```java\npublic void run() {\n    //判断状态是不是NEW\n    if (state != NEW ||\n        !RUNNER.compareAndSet(this, null, Thread.currentThread()))\n        return;\n    try {\n        Callable<V> c = callable;\n        if (c != null && state == NEW) {\n            V result;\n            boolean ran;\n            try {\n                //真正任务执行\n                result = c.call();\n                //执行完成设置ran为true\n                ran = true;\n            } catch (Throwable ex) {\n                //任务执行发生异常\n                result = null;\n                ran = false;\n                //修改任务执行状态为异常\n                setException(ex);\n            }\n            if (ran)\n                //修改任务执行状态为正常结束\n                set(result);\n        }\n    } finally {\n        // runner must be non-null until state is settled to\n        // prevent concurrent calls to run()\n        runner = null;\n        // state must be re-read after nulling runner to prevent\n        // leaked interrupts\n        int s = state;\n        if (s >= INTERRUPTING)\n            handlePossibleCancellationInterrupt(s);\n    }\n}\n```\n\n\n\n如果发生异常将任务状态设置为EXCEPTIONAL\n\n```java\nprotected void setException(Throwable t) {\n    if (STATE.compareAndSet(this, NEW, COMPLETING)) {\n        outcome = t;\n        STATE.setRelease(this, EXCEPTIONAL); // final state\n        finishCompletion();\n    }\n}\n```\n\n如果正常执行完成，将任务状态设置为NORMAL\n\n```java\nprotected void set(V v) {\n    if (STATE.compareAndSet(this, NEW, COMPLETING)) {\n        outcome = v;\n        STATE.setRelease(this, NORMAL); // final state\n        finishCompletion();\n    }\n}\n```\n\n\n\n## 获取任务结果get()\n\n```java\npublic V get() throws InterruptedException, ExecutionException {\n    int s = state;\n    if (s <= COMPLETING)\n        s = awaitDone(false, 0L);\n    return report(s);\n}\n```\n\n从API可以看出，获取任务结果时候，任务可能被中断，或者发生执行异常。\n\n\n\n### awaitDone 自旋等待结果\n\n读这段代码时候，一定要想着会有多个线程来awaitDone，并且每一个线程都在自旋，等待状态变化。每个线程按照排队方式排列在waiters进行等待。\n\n假设有四个线程同时获取结果，每一个运行1s后，才启动另一个线程，那么每个线程第一次进入awaitDone时候将会创建自己的WaitNode，然后第二次进入会发现queued=false，然后将第一次进入的创建WaitNode节点next指向waiters，如Thread1 -> waiters,\n\n第三次进入时候，因为所有的分支条件只满足最后一个，调用LockSupport.park(this)，此时该线程因为一直没有获取结果而进行wait，此时线程状态变成waiting。依次类推，第二个线程进入，第三个线程进入，第四个线程进入，将会形成以下结构：\n\n<img src=\"/images/FutureTaskStack.png\" style=\"zoom:80%;\" />\n\n\n\n```java\n//timed false说明没有超时时间限制\nprivate int awaitDone(boolean timed, long nanos) throws InterruptedException {\n    long startTime = 0L;    // Special value 0L means not yet parked\n    WaitNode q = null;\n    boolean queued = false;\n    //当任务执行时候，一直在自旋等待状态变化，为了不断获取任务执行过程中的状态。\n    for (;;) {\n        int s = state;\n        if (s > COMPLETING) {\n            if (q != null)\n                //大于COMPLETING的其他状态，直接返回状态,该状态主要改变会在run方法中改变\n                q.thread = null;\n            return s;\n        }\n        else if (s == COMPLETING)\n            Thread.yield();\n        else if (Thread.interrupted()) {\n            //线程被中断时候，移除等待节点上的线程，并且告诉客户端发生了中断，\n            removeWaiter(q);\n            throw new InterruptedException();\n        }\n        //第一次进入时候，WaitNode为空，创建新的等待节点。\n        else if (q == null) {\n            if (timed && nanos <= 0L)\n                return s;\n            q = new WaitNode();\n        }\n        else if (!queued)\n            //如果\n            queued = WAITERS.weakCompareAndSet(this, q.next = waiters, q);\n        else if (timed) {\n            //如果有超时实现限制，则会不断和最终时间进行比较，超过最终时间，状态返回NEW，并且在外层抛出\n            //TimeoutException\n            final long parkNanos;\n            if (startTime == 0L) { // first time\n                startTime = System.nanoTime();\n                if (startTime == 0L)\n                    startTime = 1L;\n                parkNanos = nanos;\n            } else {\n                long elapsed = System.nanoTime() - startTime;\n                if (elapsed >= nanos) {\n                    removeWaiter(q);\n                    return state;\n                }\n                parkNanos = nanos - elapsed;\n            }\n            // nanoTime may be slow; recheck before parking\n            if (state < COMPLETING)\n                //park当前线程\n                LockSupport.parkNanos(this, parkNanos);\n        }\n        else\n            //所有排队的线程均会被park住.\n            LockSupport.park(this);\n    }\n}\n```\n\n### finishCompletion 完成任务\n\n当有任务完成时候，会将Tribie Stack等待的线程全部unpark，并且释放每个WaitNode的线程.\n\n```java\nprivate void finishCompletion() {\n    // assert state > COMPLETING;\n    for (WaitNode q; (q = waiters) != null;) {\n        if (WAITERS.weakCompareAndSet(this, q, null)) {\n            for (;;) {\n                Thread t = q.thread;\n                if (t != null) {\n                    q.thread = null;\n                    LockSupport.unpark(t);\n                }\n                WaitNode next = q.next;\n                if (next == null)\n                    break;\n                q.next = null; // unlink to help gc\n                q = next;\n            }\n            break;\n        }\n    }\n\n    done();\n\n    callable = null;        // to reduce footprint\n}\n```\n\n\n\n\n\n```java\n@SuppressWarnings(\"unchecked\")\nprivate V report(int s) throws ExecutionException {\n    Object x = outcome;\n    if (s == NORMAL)\n        return (V)x;\n    if (s >= CANCELLED)\n        throw new CancellationException();\n    throw new ExecutionException((Throwable)x);\n}\n```\n\n\n\n## 带超时的get()\n\n这块和get()其实差不多，只是会进入get的不同for(;;)分支，当超过指定时间没有返回结果时候，将会抛出TimeoutException异常。\n\n```java\npublic V get(long timeout, TimeUnit unit)\n    throws InterruptedException, ExecutionException, TimeoutException {\n    if (unit == null)\n        throw new NullPointerException();\n    int s = state;\n    if (s <= COMPLETING &&\n        (s = awaitDone(true, unit.toNanos(timeout))) <= COMPLETING)\n        throw new TimeoutException();\n    return report(s);\n}\n```\n\n\n\n## 取消任务cancel\n\n任务取消成功返回true，取消失败返回false，可以从条件判断中得知，当状态为NEW，且被原子更新为INTERRUPTING或CANCELLED，\n\n才能取消任务。当可以中断时候，任务通过中断实现的，中断之后将任务状态设置为INTERRUPTING，当不可以中断，任务取消其实并没有做什么，只是将任务状态修改为或CANCELLED，当任务状态发生变化时候，一直自旋等待线程会在get方法中获得状态变化，从而执行相关分析，最后执行finishCompletion.\n\n```java\npublic boolean cancel(boolean mayInterruptIfRunning) {\n    if (!(state == NEW && STATE.compareAndSet\n          (this, NEW, mayInterruptIfRunning ? INTERRUPTING : CANCELLED)))\n        return false;\n    try {    // in case call to interrupt throws exception\n        if (mayInterruptIfRunning) {\n            try {\n                Thread t = runner;\n                if (t != null)\n                    t.interrupt();\n            } finally { // final state\n                STATE.setRelease(this, INTERRUPTED);\n            }\n        }\n    } finally {\n        finishCompletion();\n    }\n    return true;\n}\n```\n\n\n\n## 是否取消isCancelled\n\n根据状态判断，因为状态是递增的。\n\n```java\npublic boolean isCancelled() {\n    return state >= CANCELLED;\n}\n```\n\n\n\n## 是否完成isDone\n\n同样根据状态判断。\n\n```java\npublic boolean isDone() {\n    return state != NEW;\n}\n```\n\n\n\n\n\n# 实战案例","source":"_posts/FutureTask-Design-And-Implementation.md","raw":"---\ntitle: FutureTask设计与实现\ndate: 2020-11-11 02:14:39\ntags: java.util.concurrent\ncategories:\n  - JDK源码\n  - Java并发框架\n---\n\n# 序言\n\nFutureTask是Future和Runnable的实现，ThreadPoolExecutor在执行任务的时候，执行的是FutureTask. 传统Runnable接口实现的任务只有执行方法run，并没有任务取消，执行超时等功能，并且Runnable并没有提供任务状态的抽象，其实每个任务都是有状态的。所以FutureTask其内部将任务执行过程分为一系列状态，从而使得任务有了生命周期。在JDK中，经典的实现除了FutureTask外，还有ScheduledFutureTask. \n\n\n\n# 结构\n\n![](/images/FutureTask.png)\n\n我们可以看到它对一个普通任务支持了生命周期的方法. 从而使得任务执行有了过程的概念，而不是Runnable这样只能运行或者被中断的状态，也使得客户端更加灵活的控制任务执行。\n\n\n\n# API\n\nFutureTask的API全部来自父接口，自己只定义了构造函数，\n\n```java\n//任务执行方法，继承自RunnableFuture的run,RunnableFuture又继承在Runnable\npublic void run() \n\n//run之后，获取run的结果，可能任务执行被中断，或者执行异常\npublic V get() throws InterruptedException, ExecutionException \n\n//带超时的获取run结果，可能抛出超时异常    \npublic V get(long timeout, TimeUnit unit)  throws InterruptedException, ExecutionException, TimeoutException\n    \n//取消任务\npublic boolean cancel(boolean mayInterruptIfRunning)\n    \n//任务是否被取消   \npublic boolean isCancelled()\n    \n//任务是否完成\npublic boolean isDone()\n    \n//钩子方法\nprotected void done() { }\n```\n\n# 实现\n\n## 创建\n\n```java\n//通过Callable创建FutureTask，并且任务状态设置为NEW\npublic FutureTask(Callable<V> callable) {\n    if (callable == null)\n        throw new NullPointerException();\n    this.callable = callable;\n    this.state = NEW;       // ensure visibility of callable\n}\n```\n\n\n\n```java\n//通过Runnable创建FutureTask，并且任务状态设置为NEW\npublic FutureTask(Runnable runnable, V result) {\n    this.callable = Executors.callable(runnable, result);\n    this.state = NEW;       // ensure visibility of callable\n}\n```\n\n\n\n## 等待节点WaitNode\n\n等待节点是当有多个线程获取结果的时候，会进行排队，当有一个线程get到结果时候，其他线程将被唤醒，也将拿到结果。该等待节点的实现是Treiber Stack，Treiber 是发明者名字,它是非阻塞的同步栈，详情可参考Wikipedia.  https://en.wikipedia.org/wiki/Treiber_stack\n\n```java\nstatic final class WaitNode {\n    volatile Thread thread;\n    volatile WaitNode next;\n    WaitNode() { thread = Thread.currentThread(); }\n}\n```\n\n该类的实现是静态final类，意味着这是一个全局的类，和外部实例没有关系，并且不能被继承，\n\n\n\n## 实例变量\n\n```java\n/** 运行的任务 */\nprivate Callable<V> callable;\n/** get返回的结果 */\nprivate Object outcome; // non-volatile, protected by state reads/writes\n/** 运行Callable的线程 */\nprivate volatile Thread runner;\n/** Treiber stack上的等待线程 */\nprivate volatile WaitNode waiters;\n```\n\n\n\n\n\n## 任务状态\n\n```java\nprivate volatile int state;  //任务状态，每个API都会和状态相关\nprivate static final int NEW          = 0;\nprivate static final int COMPLETING   = 1;\nprivate static final int NORMAL       = 2;\nprivate static final int EXCEPTIONAL  = 3;\nprivate static final int CANCELLED    = 4;\nprivate static final int INTERRUPTING = 5;\nprivate static final int INTERRUPTED  = 6;\n```\n\n任务的状态有7种，每种任务状态是递增且不可逆的。下面是状态流转图：\n\n<img src=\"/images/FutureTaskStatus.png\" style=\"zoom:50%;\" />\n\n任务起始状态是NEW，中间过程有COMPLETING和INTERRUPTING，终态有四种，也就是图的叶子节点。这些状态使得任务可以被控制。\n\n\n\n## 任务运行run\n\n任务运行是实现run方法，也就是客户端自定义的任务。\n\nrun方法首先判断状态，如果任务状态不NEW，则直接退出，防止任务重复执行，然后进入真正任务执行，调用Callable的call方法，\n\ncall结束，任务执行完成，将ran置为ture，正常情况调用set，如果运行中发生异常，调用setException，\n\n```java\npublic void run() {\n    //判断状态是不是NEW\n    if (state != NEW ||\n        !RUNNER.compareAndSet(this, null, Thread.currentThread()))\n        return;\n    try {\n        Callable<V> c = callable;\n        if (c != null && state == NEW) {\n            V result;\n            boolean ran;\n            try {\n                //真正任务执行\n                result = c.call();\n                //执行完成设置ran为true\n                ran = true;\n            } catch (Throwable ex) {\n                //任务执行发生异常\n                result = null;\n                ran = false;\n                //修改任务执行状态为异常\n                setException(ex);\n            }\n            if (ran)\n                //修改任务执行状态为正常结束\n                set(result);\n        }\n    } finally {\n        // runner must be non-null until state is settled to\n        // prevent concurrent calls to run()\n        runner = null;\n        // state must be re-read after nulling runner to prevent\n        // leaked interrupts\n        int s = state;\n        if (s >= INTERRUPTING)\n            handlePossibleCancellationInterrupt(s);\n    }\n}\n```\n\n\n\n如果发生异常将任务状态设置为EXCEPTIONAL\n\n```java\nprotected void setException(Throwable t) {\n    if (STATE.compareAndSet(this, NEW, COMPLETING)) {\n        outcome = t;\n        STATE.setRelease(this, EXCEPTIONAL); // final state\n        finishCompletion();\n    }\n}\n```\n\n如果正常执行完成，将任务状态设置为NORMAL\n\n```java\nprotected void set(V v) {\n    if (STATE.compareAndSet(this, NEW, COMPLETING)) {\n        outcome = v;\n        STATE.setRelease(this, NORMAL); // final state\n        finishCompletion();\n    }\n}\n```\n\n\n\n## 获取任务结果get()\n\n```java\npublic V get() throws InterruptedException, ExecutionException {\n    int s = state;\n    if (s <= COMPLETING)\n        s = awaitDone(false, 0L);\n    return report(s);\n}\n```\n\n从API可以看出，获取任务结果时候，任务可能被中断，或者发生执行异常。\n\n\n\n### awaitDone 自旋等待结果\n\n读这段代码时候，一定要想着会有多个线程来awaitDone，并且每一个线程都在自旋，等待状态变化。每个线程按照排队方式排列在waiters进行等待。\n\n假设有四个线程同时获取结果，每一个运行1s后，才启动另一个线程，那么每个线程第一次进入awaitDone时候将会创建自己的WaitNode，然后第二次进入会发现queued=false，然后将第一次进入的创建WaitNode节点next指向waiters，如Thread1 -> waiters,\n\n第三次进入时候，因为所有的分支条件只满足最后一个，调用LockSupport.park(this)，此时该线程因为一直没有获取结果而进行wait，此时线程状态变成waiting。依次类推，第二个线程进入，第三个线程进入，第四个线程进入，将会形成以下结构：\n\n<img src=\"/images/FutureTaskStack.png\" style=\"zoom:80%;\" />\n\n\n\n```java\n//timed false说明没有超时时间限制\nprivate int awaitDone(boolean timed, long nanos) throws InterruptedException {\n    long startTime = 0L;    // Special value 0L means not yet parked\n    WaitNode q = null;\n    boolean queued = false;\n    //当任务执行时候，一直在自旋等待状态变化，为了不断获取任务执行过程中的状态。\n    for (;;) {\n        int s = state;\n        if (s > COMPLETING) {\n            if (q != null)\n                //大于COMPLETING的其他状态，直接返回状态,该状态主要改变会在run方法中改变\n                q.thread = null;\n            return s;\n        }\n        else if (s == COMPLETING)\n            Thread.yield();\n        else if (Thread.interrupted()) {\n            //线程被中断时候，移除等待节点上的线程，并且告诉客户端发生了中断，\n            removeWaiter(q);\n            throw new InterruptedException();\n        }\n        //第一次进入时候，WaitNode为空，创建新的等待节点。\n        else if (q == null) {\n            if (timed && nanos <= 0L)\n                return s;\n            q = new WaitNode();\n        }\n        else if (!queued)\n            //如果\n            queued = WAITERS.weakCompareAndSet(this, q.next = waiters, q);\n        else if (timed) {\n            //如果有超时实现限制，则会不断和最终时间进行比较，超过最终时间，状态返回NEW，并且在外层抛出\n            //TimeoutException\n            final long parkNanos;\n            if (startTime == 0L) { // first time\n                startTime = System.nanoTime();\n                if (startTime == 0L)\n                    startTime = 1L;\n                parkNanos = nanos;\n            } else {\n                long elapsed = System.nanoTime() - startTime;\n                if (elapsed >= nanos) {\n                    removeWaiter(q);\n                    return state;\n                }\n                parkNanos = nanos - elapsed;\n            }\n            // nanoTime may be slow; recheck before parking\n            if (state < COMPLETING)\n                //park当前线程\n                LockSupport.parkNanos(this, parkNanos);\n        }\n        else\n            //所有排队的线程均会被park住.\n            LockSupport.park(this);\n    }\n}\n```\n\n### finishCompletion 完成任务\n\n当有任务完成时候，会将Tribie Stack等待的线程全部unpark，并且释放每个WaitNode的线程.\n\n```java\nprivate void finishCompletion() {\n    // assert state > COMPLETING;\n    for (WaitNode q; (q = waiters) != null;) {\n        if (WAITERS.weakCompareAndSet(this, q, null)) {\n            for (;;) {\n                Thread t = q.thread;\n                if (t != null) {\n                    q.thread = null;\n                    LockSupport.unpark(t);\n                }\n                WaitNode next = q.next;\n                if (next == null)\n                    break;\n                q.next = null; // unlink to help gc\n                q = next;\n            }\n            break;\n        }\n    }\n\n    done();\n\n    callable = null;        // to reduce footprint\n}\n```\n\n\n\n\n\n```java\n@SuppressWarnings(\"unchecked\")\nprivate V report(int s) throws ExecutionException {\n    Object x = outcome;\n    if (s == NORMAL)\n        return (V)x;\n    if (s >= CANCELLED)\n        throw new CancellationException();\n    throw new ExecutionException((Throwable)x);\n}\n```\n\n\n\n## 带超时的get()\n\n这块和get()其实差不多，只是会进入get的不同for(;;)分支，当超过指定时间没有返回结果时候，将会抛出TimeoutException异常。\n\n```java\npublic V get(long timeout, TimeUnit unit)\n    throws InterruptedException, ExecutionException, TimeoutException {\n    if (unit == null)\n        throw new NullPointerException();\n    int s = state;\n    if (s <= COMPLETING &&\n        (s = awaitDone(true, unit.toNanos(timeout))) <= COMPLETING)\n        throw new TimeoutException();\n    return report(s);\n}\n```\n\n\n\n## 取消任务cancel\n\n任务取消成功返回true，取消失败返回false，可以从条件判断中得知，当状态为NEW，且被原子更新为INTERRUPTING或CANCELLED，\n\n才能取消任务。当可以中断时候，任务通过中断实现的，中断之后将任务状态设置为INTERRUPTING，当不可以中断，任务取消其实并没有做什么，只是将任务状态修改为或CANCELLED，当任务状态发生变化时候，一直自旋等待线程会在get方法中获得状态变化，从而执行相关分析，最后执行finishCompletion.\n\n```java\npublic boolean cancel(boolean mayInterruptIfRunning) {\n    if (!(state == NEW && STATE.compareAndSet\n          (this, NEW, mayInterruptIfRunning ? INTERRUPTING : CANCELLED)))\n        return false;\n    try {    // in case call to interrupt throws exception\n        if (mayInterruptIfRunning) {\n            try {\n                Thread t = runner;\n                if (t != null)\n                    t.interrupt();\n            } finally { // final state\n                STATE.setRelease(this, INTERRUPTED);\n            }\n        }\n    } finally {\n        finishCompletion();\n    }\n    return true;\n}\n```\n\n\n\n## 是否取消isCancelled\n\n根据状态判断，因为状态是递增的。\n\n```java\npublic boolean isCancelled() {\n    return state >= CANCELLED;\n}\n```\n\n\n\n## 是否完成isDone\n\n同样根据状态判断。\n\n```java\npublic boolean isDone() {\n    return state != NEW;\n}\n```\n\n\n\n\n\n# 实战案例","slug":"FutureTask-Design-And-Implementation","published":1,"updated":"2022-06-28T17:22:38.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clh7s5cti0007xt8j3dg7d9ao","content":"<h1 id=\"序言\"><a href=\"#序言\" class=\"headerlink\" title=\"序言\"></a>序言</h1><p>FutureTask是Future和Runnable的实现，ThreadPoolExecutor在执行任务的时候，执行的是FutureTask. 传统Runnable接口实现的任务只有执行方法run，并没有任务取消，执行超时等功能，并且Runnable并没有提供任务状态的抽象，其实每个任务都是有状态的。所以FutureTask其内部将任务执行过程分为一系列状态，从而使得任务有了生命周期。在JDK中，经典的实现除了FutureTask外，还有ScheduledFutureTask. </p>\n<h1 id=\"结构\"><a href=\"#结构\" class=\"headerlink\" title=\"结构\"></a>结构</h1><p><img src=\"/images/FutureTask.png\" alt=\"\"></p>\n<p>我们可以看到它对一个普通任务支持了生命周期的方法. 从而使得任务执行有了过程的概念，而不是Runnable这样只能运行或者被中断的状态，也使得客户端更加灵活的控制任务执行。</p>\n<h1 id=\"API\"><a href=\"#API\" class=\"headerlink\" title=\"API\"></a>API</h1><p>FutureTask的API全部来自父接口，自己只定义了构造函数，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//任务执行方法，继承自RunnableFuture的run,RunnableFuture又继承在Runnable</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//run之后，获取run的结果，可能任务执行被中断，或者执行异常</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">get</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException, ExecutionException </span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//带超时的获取run结果，可能抛出超时异常    </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">long</span> timeout, TimeUnit unit)</span>  <span class=\"keyword\">throws</span> InterruptedException, ExecutionException, TimeoutException</span></span><br><span class=\"line\"><span class=\"function\">    </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//取消任务</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">cancel</span><span class=\"params\">(<span class=\"keyword\">boolean</span> mayInterruptIfRunning)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//任务是否被取消   </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isCancelled</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//任务是否完成</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isDone</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//钩子方法</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">done</span><span class=\"params\">()</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h1><h2 id=\"创建\"><a href=\"#创建\" class=\"headerlink\" title=\"创建\"></a>创建</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//通过Callable创建FutureTask，并且任务状态设置为NEW</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">FutureTask</span><span class=\"params\">(Callable&lt;V&gt; callable)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (callable == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.callable = callable;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = NEW;       <span class=\"comment\">// ensure visibility of callable</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//通过Runnable创建FutureTask，并且任务状态设置为NEW</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">FutureTask</span><span class=\"params\">(Runnable runnable, V result)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.callable = Executors.callable(runnable, result);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = NEW;       <span class=\"comment\">// ensure visibility of callable</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"等待节点WaitNode\"><a href=\"#等待节点WaitNode\" class=\"headerlink\" title=\"等待节点WaitNode\"></a>等待节点WaitNode</h2><p>等待节点是当有多个线程获取结果的时候，会进行排队，当有一个线程get到结果时候，其他线程将被唤醒，也将拿到结果。该等待节点的实现是Treiber Stack，Treiber 是发明者名字,它是非阻塞的同步栈，详情可参考Wikipedia.  <a href=\"https://en.wikipedia.org/wiki/Treiber_stack\" target=\"_blank\" rel=\"noopener\">https://en.wikipedia.org/wiki/Treiber_stack</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WaitNode</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">volatile</span> Thread thread;</span><br><span class=\"line\">    <span class=\"keyword\">volatile</span> WaitNode next;</span><br><span class=\"line\">    WaitNode() &#123; thread = Thread.currentThread(); &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>该类的实现是静态final类，意味着这是一个全局的类，和外部实例没有关系，并且不能被继承，</p>\n<h2 id=\"实例变量\"><a href=\"#实例变量\" class=\"headerlink\" title=\"实例变量\"></a>实例变量</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** 运行的任务 */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> Callable&lt;V&gt; callable;</span><br><span class=\"line\"><span class=\"comment\">/** get返回的结果 */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> Object outcome; <span class=\"comment\">// non-volatile, protected by state reads/writes</span></span><br><span class=\"line\"><span class=\"comment\">/** 运行Callable的线程 */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> Thread runner;</span><br><span class=\"line\"><span class=\"comment\">/** Treiber stack上的等待线程 */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> WaitNode waiters;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h2 id=\"任务状态\"><a href=\"#任务状态\" class=\"headerlink\" title=\"任务状态\"></a>任务状态</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> state;  <span class=\"comment\">//任务状态，每个API都会和状态相关</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> NEW          = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> COMPLETING   = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> NORMAL       = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> EXCEPTIONAL  = <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> CANCELLED    = <span class=\"number\">4</span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> INTERRUPTING = <span class=\"number\">5</span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> INTERRUPTED  = <span class=\"number\">6</span>;</span><br></pre></td></tr></table></figure>\n\n<p>任务的状态有7种，每种任务状态是递增且不可逆的。下面是状态流转图：</p>\n<img src=\"/images/FutureTaskStatus.png\" style=\"zoom:50%;\" />\n\n<p>任务起始状态是NEW，中间过程有COMPLETING和INTERRUPTING，终态有四种，也就是图的叶子节点。这些状态使得任务可以被控制。</p>\n<h2 id=\"任务运行run\"><a href=\"#任务运行run\" class=\"headerlink\" title=\"任务运行run\"></a>任务运行run</h2><p>任务运行是实现run方法，也就是客户端自定义的任务。</p>\n<p>run方法首先判断状态，如果任务状态不NEW，则直接退出，防止任务重复执行，然后进入真正任务执行，调用Callable的call方法，</p>\n<p>call结束，任务执行完成，将ran置为ture，正常情况调用set，如果运行中发生异常，调用setException，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//判断状态是不是NEW</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (state != NEW ||</span><br><span class=\"line\">        !RUNNER.compareAndSet(<span class=\"keyword\">this</span>, <span class=\"keyword\">null</span>, Thread.currentThread()))</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        Callable&lt;V&gt; c = callable;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (c != <span class=\"keyword\">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class=\"line\">            V result;</span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> ran;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">//真正任务执行</span></span><br><span class=\"line\">                result = c.call();</span><br><span class=\"line\">                <span class=\"comment\">//执行完成设置ran为true</span></span><br><span class=\"line\">                ran = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Throwable ex) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//任务执行发生异常</span></span><br><span class=\"line\">                result = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                ran = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                <span class=\"comment\">//修改任务执行状态为异常</span></span><br><span class=\"line\">                setException(ex);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (ran)</span><br><span class=\"line\">                <span class=\"comment\">//修改任务执行状态为正常结束</span></span><br><span class=\"line\">                set(result);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// runner must be non-null until state is settled to</span></span><br><span class=\"line\">        <span class=\"comment\">// prevent concurrent calls to run()</span></span><br><span class=\"line\">        runner = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"comment\">// state must be re-read after nulling runner to prevent</span></span><br><span class=\"line\">        <span class=\"comment\">// leaked interrupts</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> s = state;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s &gt;= INTERRUPTING)</span><br><span class=\"line\">            handlePossibleCancellationInterrupt(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>如果发生异常将任务状态设置为EXCEPTIONAL</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">setException</span><span class=\"params\">(Throwable t)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (STATE.compareAndSet(<span class=\"keyword\">this</span>, NEW, COMPLETING)) &#123;</span><br><span class=\"line\">        outcome = t;</span><br><span class=\"line\">        STATE.setRelease(<span class=\"keyword\">this</span>, EXCEPTIONAL); <span class=\"comment\">// final state</span></span><br><span class=\"line\">        finishCompletion();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果正常执行完成，将任务状态设置为NORMAL</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">set</span><span class=\"params\">(V v)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (STATE.compareAndSet(<span class=\"keyword\">this</span>, NEW, COMPLETING)) &#123;</span><br><span class=\"line\">        outcome = v;</span><br><span class=\"line\">        STATE.setRelease(<span class=\"keyword\">this</span>, NORMAL); <span class=\"comment\">// final state</span></span><br><span class=\"line\">        finishCompletion();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"获取任务结果get\"><a href=\"#获取任务结果get\" class=\"headerlink\" title=\"获取任务结果get()\"></a>获取任务结果get()</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">get</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> s = state;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s &lt;= COMPLETING)</span><br><span class=\"line\">        s = awaitDone(<span class=\"keyword\">false</span>, <span class=\"number\">0L</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> report(s);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从API可以看出，获取任务结果时候，任务可能被中断，或者发生执行异常。</p>\n<h3 id=\"awaitDone-自旋等待结果\"><a href=\"#awaitDone-自旋等待结果\" class=\"headerlink\" title=\"awaitDone 自旋等待结果\"></a>awaitDone 自旋等待结果</h3><p>读这段代码时候，一定要想着会有多个线程来awaitDone，并且每一个线程都在自旋，等待状态变化。每个线程按照排队方式排列在waiters进行等待。</p>\n<p>假设有四个线程同时获取结果，每一个运行1s后，才启动另一个线程，那么每个线程第一次进入awaitDone时候将会创建自己的WaitNode，然后第二次进入会发现queued=false，然后将第一次进入的创建WaitNode节点next指向waiters，如Thread1 -&gt; waiters,</p>\n<p>第三次进入时候，因为所有的分支条件只满足最后一个，调用LockSupport.park(this)，此时该线程因为一直没有获取结果而进行wait，此时线程状态变成waiting。依次类推，第二个线程进入，第三个线程进入，第四个线程进入，将会形成以下结构：</p>\n<img src=\"/images/FutureTaskStack.png\" style=\"zoom:80%;\" />\n\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//timed false说明没有超时时间限制</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">awaitDone</span><span class=\"params\">(<span class=\"keyword\">boolean</span> timed, <span class=\"keyword\">long</span> nanos)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> startTime = <span class=\"number\">0L</span>;    <span class=\"comment\">// Special value 0L means not yet parked</span></span><br><span class=\"line\">    WaitNode q = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> queued = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"comment\">//当任务执行时候，一直在自旋等待状态变化，为了不断获取任务执行过程中的状态。</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> s = state;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s &gt; COMPLETING) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (q != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                <span class=\"comment\">//大于COMPLETING的其他状态，直接返回状态,该状态主要改变会在run方法中改变</span></span><br><span class=\"line\">                q.thread = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (s == COMPLETING)</span><br><span class=\"line\">            Thread.yield();</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (Thread.interrupted()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//线程被中断时候，移除等待节点上的线程，并且告诉客户端发生了中断，</span></span><br><span class=\"line\">            removeWaiter(q);</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> InterruptedException();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//第一次进入时候，WaitNode为空，创建新的等待节点。</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (q == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (timed &amp;&amp; nanos &lt;= <span class=\"number\">0L</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">            q = <span class=\"keyword\">new</span> WaitNode();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!queued)</span><br><span class=\"line\">            <span class=\"comment\">//如果</span></span><br><span class=\"line\">            queued = WAITERS.weakCompareAndSet(<span class=\"keyword\">this</span>, q.next = waiters, q);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (timed) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//如果有超时实现限制，则会不断和最终时间进行比较，超过最终时间，状态返回NEW，并且在外层抛出</span></span><br><span class=\"line\">            <span class=\"comment\">//TimeoutException</span></span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> parkNanos;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (startTime == <span class=\"number\">0L</span>) &#123; <span class=\"comment\">// first time</span></span><br><span class=\"line\">                startTime = System.nanoTime();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (startTime == <span class=\"number\">0L</span>)</span><br><span class=\"line\">                    startTime = <span class=\"number\">1L</span>;</span><br><span class=\"line\">                parkNanos = nanos;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">long</span> elapsed = System.nanoTime() - startTime;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (elapsed &gt;= nanos) &#123;</span><br><span class=\"line\">                    removeWaiter(q);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> state;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                parkNanos = nanos - elapsed;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// nanoTime may be slow; recheck before parking</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (state &lt; COMPLETING)</span><br><span class=\"line\">                <span class=\"comment\">//park当前线程</span></span><br><span class=\"line\">                LockSupport.parkNanos(<span class=\"keyword\">this</span>, parkNanos);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"comment\">//所有排队的线程均会被park住.</span></span><br><span class=\"line\">            LockSupport.park(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"finishCompletion-完成任务\"><a href=\"#finishCompletion-完成任务\" class=\"headerlink\" title=\"finishCompletion 完成任务\"></a>finishCompletion 完成任务</h3><p>当有任务完成时候，会将Tribie Stack等待的线程全部unpark，并且释放每个WaitNode的线程.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">finishCompletion</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// assert state &gt; COMPLETING;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (WaitNode q; (q = waiters) != <span class=\"keyword\">null</span>;) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (WAITERS.weakCompareAndSet(<span class=\"keyword\">this</span>, q, <span class=\"keyword\">null</span>)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">                Thread t = q.thread;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (t != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    q.thread = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    LockSupport.unpark(t);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                WaitNode next = q.next;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (next == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                q.next = <span class=\"keyword\">null</span>; <span class=\"comment\">// unlink to help gc</span></span><br><span class=\"line\">                q = next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    done();</span><br><span class=\"line\"></span><br><span class=\"line\">    callable = <span class=\"keyword\">null</span>;        <span class=\"comment\">// to reduce footprint</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> V <span class=\"title\">report</span><span class=\"params\">(<span class=\"keyword\">int</span> s)</span> <span class=\"keyword\">throws</span> ExecutionException </span>&#123;</span><br><span class=\"line\">    Object x = outcome;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s == NORMAL)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (V)x;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s &gt;= CANCELLED)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> CancellationException();</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ExecutionException((Throwable)x);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"带超时的get\"><a href=\"#带超时的get\" class=\"headerlink\" title=\"带超时的get()\"></a>带超时的get()</h2><p>这块和get()其实差不多，只是会进入get的不同for(;;)分支，当超过指定时间没有返回结果时候，将会抛出TimeoutException异常。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">long</span> timeout, TimeUnit unit)</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"keyword\">throws</span> InterruptedException, ExecutionException, TimeoutException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (unit == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> s = state;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s &lt;= COMPLETING &amp;&amp;</span><br><span class=\"line\">        (s = awaitDone(<span class=\"keyword\">true</span>, unit.toNanos(timeout))) &lt;= COMPLETING)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> TimeoutException();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> report(s);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"取消任务cancel\"><a href=\"#取消任务cancel\" class=\"headerlink\" title=\"取消任务cancel\"></a>取消任务cancel</h2><p>任务取消成功返回true，取消失败返回false，可以从条件判断中得知，当状态为NEW，且被原子更新为INTERRUPTING或CANCELLED，</p>\n<p>才能取消任务。当可以中断时候，任务通过中断实现的，中断之后将任务状态设置为INTERRUPTING，当不可以中断，任务取消其实并没有做什么，只是将任务状态修改为或CANCELLED，当任务状态发生变化时候，一直自旋等待线程会在get方法中获得状态变化，从而执行相关分析，最后执行finishCompletion.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">cancel</span><span class=\"params\">(<span class=\"keyword\">boolean</span> mayInterruptIfRunning)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!(state == NEW &amp;&amp; STATE.compareAndSet</span><br><span class=\"line\">          (<span class=\"keyword\">this</span>, NEW, mayInterruptIfRunning ? INTERRUPTING : CANCELLED)))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;    <span class=\"comment\">// in case call to interrupt throws exception</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mayInterruptIfRunning) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                Thread t = runner;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (t != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    t.interrupt();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123; <span class=\"comment\">// final state</span></span><br><span class=\"line\">                STATE.setRelease(<span class=\"keyword\">this</span>, INTERRUPTED);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        finishCompletion();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"是否取消isCancelled\"><a href=\"#是否取消isCancelled\" class=\"headerlink\" title=\"是否取消isCancelled\"></a>是否取消isCancelled</h2><p>根据状态判断，因为状态是递增的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isCancelled</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> state &gt;= CANCELLED;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"是否完成isDone\"><a href=\"#是否完成isDone\" class=\"headerlink\" title=\"是否完成isDone\"></a>是否完成isDone</h2><p>同样根据状态判断。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isDone</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> state != NEW;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h1 id=\"实战案例\"><a href=\"#实战案例\" class=\"headerlink\" title=\"实战案例\"></a>实战案例</h1>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"序言\"><a href=\"#序言\" class=\"headerlink\" title=\"序言\"></a>序言</h1><p>FutureTask是Future和Runnable的实现，ThreadPoolExecutor在执行任务的时候，执行的是FutureTask. 传统Runnable接口实现的任务只有执行方法run，并没有任务取消，执行超时等功能，并且Runnable并没有提供任务状态的抽象，其实每个任务都是有状态的。所以FutureTask其内部将任务执行过程分为一系列状态，从而使得任务有了生命周期。在JDK中，经典的实现除了FutureTask外，还有ScheduledFutureTask. </p>\n<h1 id=\"结构\"><a href=\"#结构\" class=\"headerlink\" title=\"结构\"></a>结构</h1><p><img src=\"/images/FutureTask.png\" alt=\"\"></p>\n<p>我们可以看到它对一个普通任务支持了生命周期的方法. 从而使得任务执行有了过程的概念，而不是Runnable这样只能运行或者被中断的状态，也使得客户端更加灵活的控制任务执行。</p>\n<h1 id=\"API\"><a href=\"#API\" class=\"headerlink\" title=\"API\"></a>API</h1><p>FutureTask的API全部来自父接口，自己只定义了构造函数，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//任务执行方法，继承自RunnableFuture的run,RunnableFuture又继承在Runnable</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//run之后，获取run的结果，可能任务执行被中断，或者执行异常</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">get</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException, ExecutionException </span></span><br><span class=\"line\"><span class=\"function\"></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//带超时的获取run结果，可能抛出超时异常    </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">long</span> timeout, TimeUnit unit)</span>  <span class=\"keyword\">throws</span> InterruptedException, ExecutionException, TimeoutException</span></span><br><span class=\"line\"><span class=\"function\">    </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//取消任务</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">cancel</span><span class=\"params\">(<span class=\"keyword\">boolean</span> mayInterruptIfRunning)</span></span></span><br><span class=\"line\"><span class=\"function\">    </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//任务是否被取消   </span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isCancelled</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//任务是否完成</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isDone</span><span class=\"params\">()</span></span></span><br><span class=\"line\"><span class=\"function\">    </span></span><br><span class=\"line\"><span class=\"function\"><span class=\"comment\">//钩子方法</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">done</span><span class=\"params\">()</span> </span>&#123; &#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h1><h2 id=\"创建\"><a href=\"#创建\" class=\"headerlink\" title=\"创建\"></a>创建</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//通过Callable创建FutureTask，并且任务状态设置为NEW</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">FutureTask</span><span class=\"params\">(Callable&lt;V&gt; callable)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (callable == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.callable = callable;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = NEW;       <span class=\"comment\">// ensure visibility of callable</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//通过Runnable创建FutureTask，并且任务状态设置为NEW</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">FutureTask</span><span class=\"params\">(Runnable runnable, V result)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.callable = Executors.callable(runnable, result);</span><br><span class=\"line\">    <span class=\"keyword\">this</span>.state = NEW;       <span class=\"comment\">// ensure visibility of callable</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"等待节点WaitNode\"><a href=\"#等待节点WaitNode\" class=\"headerlink\" title=\"等待节点WaitNode\"></a>等待节点WaitNode</h2><p>等待节点是当有多个线程获取结果的时候，会进行排队，当有一个线程get到结果时候，其他线程将被唤醒，也将拿到结果。该等待节点的实现是Treiber Stack，Treiber 是发明者名字,它是非阻塞的同步栈，详情可参考Wikipedia.  <a href=\"https://en.wikipedia.org/wiki/Treiber_stack\" target=\"_blank\" rel=\"noopener\">https://en.wikipedia.org/wiki/Treiber_stack</a></p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">WaitNode</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">volatile</span> Thread thread;</span><br><span class=\"line\">    <span class=\"keyword\">volatile</span> WaitNode next;</span><br><span class=\"line\">    WaitNode() &#123; thread = Thread.currentThread(); &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>该类的实现是静态final类，意味着这是一个全局的类，和外部实例没有关系，并且不能被继承，</p>\n<h2 id=\"实例变量\"><a href=\"#实例变量\" class=\"headerlink\" title=\"实例变量\"></a>实例变量</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">/** 运行的任务 */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> Callable&lt;V&gt; callable;</span><br><span class=\"line\"><span class=\"comment\">/** get返回的结果 */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> Object outcome; <span class=\"comment\">// non-volatile, protected by state reads/writes</span></span><br><span class=\"line\"><span class=\"comment\">/** 运行Callable的线程 */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> Thread runner;</span><br><span class=\"line\"><span class=\"comment\">/** Treiber stack上的等待线程 */</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> WaitNode waiters;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h2 id=\"任务状态\"><a href=\"#任务状态\" class=\"headerlink\" title=\"任务状态\"></a>任务状态</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">volatile</span> <span class=\"keyword\">int</span> state;  <span class=\"comment\">//任务状态，每个API都会和状态相关</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> NEW          = <span class=\"number\">0</span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> COMPLETING   = <span class=\"number\">1</span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> NORMAL       = <span class=\"number\">2</span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> EXCEPTIONAL  = <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> CANCELLED    = <span class=\"number\">4</span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> INTERRUPTING = <span class=\"number\">5</span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> INTERRUPTED  = <span class=\"number\">6</span>;</span><br></pre></td></tr></table></figure>\n\n<p>任务的状态有7种，每种任务状态是递增且不可逆的。下面是状态流转图：</p>\n<img src=\"/images/FutureTaskStatus.png\" style=\"zoom:50%;\" />\n\n<p>任务起始状态是NEW，中间过程有COMPLETING和INTERRUPTING，终态有四种，也就是图的叶子节点。这些状态使得任务可以被控制。</p>\n<h2 id=\"任务运行run\"><a href=\"#任务运行run\" class=\"headerlink\" title=\"任务运行run\"></a>任务运行run</h2><p>任务运行是实现run方法，也就是客户端自定义的任务。</p>\n<p>run方法首先判断状态，如果任务状态不NEW，则直接退出，防止任务重复执行，然后进入真正任务执行，调用Callable的call方法，</p>\n<p>call结束，任务执行完成，将ran置为ture，正常情况调用set，如果运行中发生异常，调用setException，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//判断状态是不是NEW</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (state != NEW ||</span><br><span class=\"line\">        !RUNNER.compareAndSet(<span class=\"keyword\">this</span>, <span class=\"keyword\">null</span>, Thread.currentThread()))</span><br><span class=\"line\">        <span class=\"keyword\">return</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        Callable&lt;V&gt; c = callable;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (c != <span class=\"keyword\">null</span> &amp;&amp; state == NEW) &#123;</span><br><span class=\"line\">            V result;</span><br><span class=\"line\">            <span class=\"keyword\">boolean</span> ran;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">//真正任务执行</span></span><br><span class=\"line\">                result = c.call();</span><br><span class=\"line\">                <span class=\"comment\">//执行完成设置ran为true</span></span><br><span class=\"line\">                ran = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (Throwable ex) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//任务执行发生异常</span></span><br><span class=\"line\">                result = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                ran = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">                <span class=\"comment\">//修改任务执行状态为异常</span></span><br><span class=\"line\">                setException(ex);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (ran)</span><br><span class=\"line\">                <span class=\"comment\">//修改任务执行状态为正常结束</span></span><br><span class=\"line\">                set(result);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">// runner must be non-null until state is settled to</span></span><br><span class=\"line\">        <span class=\"comment\">// prevent concurrent calls to run()</span></span><br><span class=\"line\">        runner = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"comment\">// state must be re-read after nulling runner to prevent</span></span><br><span class=\"line\">        <span class=\"comment\">// leaked interrupts</span></span><br><span class=\"line\">        <span class=\"keyword\">int</span> s = state;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s &gt;= INTERRUPTING)</span><br><span class=\"line\">            handlePossibleCancellationInterrupt(s);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>如果发生异常将任务状态设置为EXCEPTIONAL</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">setException</span><span class=\"params\">(Throwable t)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (STATE.compareAndSet(<span class=\"keyword\">this</span>, NEW, COMPLETING)) &#123;</span><br><span class=\"line\">        outcome = t;</span><br><span class=\"line\">        STATE.setRelease(<span class=\"keyword\">this</span>, EXCEPTIONAL); <span class=\"comment\">// final state</span></span><br><span class=\"line\">        finishCompletion();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>如果正常执行完成，将任务状态设置为NORMAL</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">void</span> <span class=\"title\">set</span><span class=\"params\">(V v)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (STATE.compareAndSet(<span class=\"keyword\">this</span>, NEW, COMPLETING)) &#123;</span><br><span class=\"line\">        outcome = v;</span><br><span class=\"line\">        STATE.setRelease(<span class=\"keyword\">this</span>, NORMAL); <span class=\"comment\">// final state</span></span><br><span class=\"line\">        finishCompletion();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"获取任务结果get\"><a href=\"#获取任务结果get\" class=\"headerlink\" title=\"获取任务结果get()\"></a>获取任务结果get()</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">get</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException, ExecutionException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> s = state;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s &lt;= COMPLETING)</span><br><span class=\"line\">        s = awaitDone(<span class=\"keyword\">false</span>, <span class=\"number\">0L</span>);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> report(s);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>从API可以看出，获取任务结果时候，任务可能被中断，或者发生执行异常。</p>\n<h3 id=\"awaitDone-自旋等待结果\"><a href=\"#awaitDone-自旋等待结果\" class=\"headerlink\" title=\"awaitDone 自旋等待结果\"></a>awaitDone 自旋等待结果</h3><p>读这段代码时候，一定要想着会有多个线程来awaitDone，并且每一个线程都在自旋，等待状态变化。每个线程按照排队方式排列在waiters进行等待。</p>\n<p>假设有四个线程同时获取结果，每一个运行1s后，才启动另一个线程，那么每个线程第一次进入awaitDone时候将会创建自己的WaitNode，然后第二次进入会发现queued=false，然后将第一次进入的创建WaitNode节点next指向waiters，如Thread1 -&gt; waiters,</p>\n<p>第三次进入时候，因为所有的分支条件只满足最后一个，调用LockSupport.park(this)，此时该线程因为一直没有获取结果而进行wait，此时线程状态变成waiting。依次类推，第二个线程进入，第三个线程进入，第四个线程进入，将会形成以下结构：</p>\n<img src=\"/images/FutureTaskStack.png\" style=\"zoom:80%;\" />\n\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//timed false说明没有超时时间限制</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">int</span> <span class=\"title\">awaitDone</span><span class=\"params\">(<span class=\"keyword\">boolean</span> timed, <span class=\"keyword\">long</span> nanos)</span> <span class=\"keyword\">throws</span> InterruptedException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> startTime = <span class=\"number\">0L</span>;    <span class=\"comment\">// Special value 0L means not yet parked</span></span><br><span class=\"line\">    WaitNode q = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> queued = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"comment\">//当任务执行时候，一直在自旋等待状态变化，为了不断获取任务执行过程中的状态。</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> s = state;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (s &gt; COMPLETING) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (q != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                <span class=\"comment\">//大于COMPLETING的其他状态，直接返回状态,该状态主要改变会在run方法中改变</span></span><br><span class=\"line\">                q.thread = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (s == COMPLETING)</span><br><span class=\"line\">            Thread.yield();</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (Thread.interrupted()) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//线程被中断时候，移除等待节点上的线程，并且告诉客户端发生了中断，</span></span><br><span class=\"line\">            removeWaiter(q);</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> InterruptedException();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//第一次进入时候，WaitNode为空，创建新的等待节点。</span></span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (q == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (timed &amp;&amp; nanos &lt;= <span class=\"number\">0L</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> s;</span><br><span class=\"line\">            q = <span class=\"keyword\">new</span> WaitNode();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!queued)</span><br><span class=\"line\">            <span class=\"comment\">//如果</span></span><br><span class=\"line\">            queued = WAITERS.weakCompareAndSet(<span class=\"keyword\">this</span>, q.next = waiters, q);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (timed) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//如果有超时实现限制，则会不断和最终时间进行比较，超过最终时间，状态返回NEW，并且在外层抛出</span></span><br><span class=\"line\">            <span class=\"comment\">//TimeoutException</span></span><br><span class=\"line\">            <span class=\"keyword\">final</span> <span class=\"keyword\">long</span> parkNanos;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (startTime == <span class=\"number\">0L</span>) &#123; <span class=\"comment\">// first time</span></span><br><span class=\"line\">                startTime = System.nanoTime();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (startTime == <span class=\"number\">0L</span>)</span><br><span class=\"line\">                    startTime = <span class=\"number\">1L</span>;</span><br><span class=\"line\">                parkNanos = nanos;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">                <span class=\"keyword\">long</span> elapsed = System.nanoTime() - startTime;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (elapsed &gt;= nanos) &#123;</span><br><span class=\"line\">                    removeWaiter(q);</span><br><span class=\"line\">                    <span class=\"keyword\">return</span> state;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                parkNanos = nanos - elapsed;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"comment\">// nanoTime may be slow; recheck before parking</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (state &lt; COMPLETING)</span><br><span class=\"line\">                <span class=\"comment\">//park当前线程</span></span><br><span class=\"line\">                LockSupport.parkNanos(<span class=\"keyword\">this</span>, parkNanos);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">else</span></span><br><span class=\"line\">            <span class=\"comment\">//所有排队的线程均会被park住.</span></span><br><span class=\"line\">            LockSupport.park(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"finishCompletion-完成任务\"><a href=\"#finishCompletion-完成任务\" class=\"headerlink\" title=\"finishCompletion 完成任务\"></a>finishCompletion 完成任务</h3><p>当有任务完成时候，会将Tribie Stack等待的线程全部unpark，并且释放每个WaitNode的线程.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">finishCompletion</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">// assert state &gt; COMPLETING;</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (WaitNode q; (q = waiters) != <span class=\"keyword\">null</span>;) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (WAITERS.weakCompareAndSet(<span class=\"keyword\">this</span>, q, <span class=\"keyword\">null</span>)) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">                Thread t = q.thread;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (t != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                    q.thread = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                    LockSupport.unpark(t);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                WaitNode next = q.next;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (next == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    <span class=\"keyword\">break</span>;</span><br><span class=\"line\">                q.next = <span class=\"keyword\">null</span>; <span class=\"comment\">// unlink to help gc</span></span><br><span class=\"line\">                q = next;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    done();</span><br><span class=\"line\"></span><br><span class=\"line\">    callable = <span class=\"keyword\">null</span>;        <span class=\"comment\">// to reduce footprint</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"unchecked\"</span>)</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> V <span class=\"title\">report</span><span class=\"params\">(<span class=\"keyword\">int</span> s)</span> <span class=\"keyword\">throws</span> ExecutionException </span>&#123;</span><br><span class=\"line\">    Object x = outcome;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s == NORMAL)</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (V)x;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s &gt;= CANCELLED)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> CancellationException();</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ExecutionException((Throwable)x);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"带超时的get\"><a href=\"#带超时的get\" class=\"headerlink\" title=\"带超时的get()\"></a>带超时的get()</h2><p>这块和get()其实差不多，只是会进入get的不同for(;;)分支，当超过指定时间没有返回结果时候，将会抛出TimeoutException异常。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">long</span> timeout, TimeUnit unit)</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"keyword\">throws</span> InterruptedException, ExecutionException, TimeoutException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (unit == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> s = state;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (s &lt;= COMPLETING &amp;&amp;</span><br><span class=\"line\">        (s = awaitDone(<span class=\"keyword\">true</span>, unit.toNanos(timeout))) &lt;= COMPLETING)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> TimeoutException();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> report(s);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"取消任务cancel\"><a href=\"#取消任务cancel\" class=\"headerlink\" title=\"取消任务cancel\"></a>取消任务cancel</h2><p>任务取消成功返回true，取消失败返回false，可以从条件判断中得知，当状态为NEW，且被原子更新为INTERRUPTING或CANCELLED，</p>\n<p>才能取消任务。当可以中断时候，任务通过中断实现的，中断之后将任务状态设置为INTERRUPTING，当不可以中断，任务取消其实并没有做什么，只是将任务状态修改为或CANCELLED，当任务状态发生变化时候，一直自旋等待线程会在get方法中获得状态变化，从而执行相关分析，最后执行finishCompletion.</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">cancel</span><span class=\"params\">(<span class=\"keyword\">boolean</span> mayInterruptIfRunning)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (!(state == NEW &amp;&amp; STATE.compareAndSet</span><br><span class=\"line\">          (<span class=\"keyword\">this</span>, NEW, mayInterruptIfRunning ? INTERRUPTING : CANCELLED)))</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;    <span class=\"comment\">// in case call to interrupt throws exception</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (mayInterruptIfRunning) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                Thread t = runner;</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (t != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    t.interrupt();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123; <span class=\"comment\">// final state</span></span><br><span class=\"line\">                STATE.setRelease(<span class=\"keyword\">this</span>, INTERRUPTED);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        finishCompletion();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"是否取消isCancelled\"><a href=\"#是否取消isCancelled\" class=\"headerlink\" title=\"是否取消isCancelled\"></a>是否取消isCancelled</h2><p>根据状态判断，因为状态是递增的。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isCancelled</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> state &gt;= CANCELLED;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"是否完成isDone\"><a href=\"#是否完成isDone\" class=\"headerlink\" title=\"是否完成isDone\"></a>是否完成isDone</h2><p>同样根据状态判断。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isDone</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> state != NEW;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h1 id=\"实战案例\"><a href=\"#实战案例\" class=\"headerlink\" title=\"实战案例\"></a>实战案例</h1>"},{"title":"Java集合框架(3)-HashMap设计与实现","date":"2020-11-14T13:01:10.000Z","_content":"\n\n\n# 序言\n\n​          HashMap在面试中被频繁问到，从我入行(2015年)问到了现在，我一直思考，就一个Map的实现有什么好问的，曾经对问我HashMap的面试官忍不住吐槽：难道你们没别的问的了？但是不可避免这个问题的出现频率，因为这体现你的“Java基础”。于是为了回答好这个问题，我从网上看了很多资料，从此面试时候不在被HashMap所难倒，但是我好像除了应付面试，从HashMap并没有学到什么东西，有一天，我下定决心，真正地重新学习HashMap的实现，从此好像发现了宝藏一样，对我的代码水平提高也很有帮助，从最初的迷惑，不屑，到现在对HashMap的喜欢，也是见证自己对技术从实用主义到真正渴望理解的一个提高，也是从浮躁到沉淀的一个见证。所以这篇文章总结了自己对HashMap的设计与实现的认识。\n\n\n\n# 概述\n\n​          HashMap作为最经典的Map接口实现，内部实现细节非常复杂，但是设计本身实现却是一致的，没有脱离Map接口和整个集合框架带给我们的抽象。**Node**和**TreeNode**作为**Map.Entry**的实现类，代表了**HashMap**内部的不同类型**Entry**， **KeySet，Values，EntrySet**分别作为Map的key,value，Entry的视图. 而**HashIterator，KeyInterator，ValueIterator，EntryIterator**分别作为KeySet，Values，EntrySet的迭代器实现，用于遍历Map，而**HashMapSpliterator，KeySpliterator，ValueSpliterator，EntrySpliterator**作为HashMap支持流式编程的Spliterator的实现。虽然看着类很多，但是抽象围绕**迭代器，分割器，视图，Entry**去实现的。由此可以得知，支持HashMap的实现由这些基本抽象组成。在接下来结构中，可以体现这些细节。\n\n\n\n# 结构\n\nHashMap的内部结构较多，但是并不难以理解。\n\n![](/images/HashMap.png)\n\n\n\n\n\n\n\n\n\n# HashMap的API\n\n\n\n\n\n# HashMap的实现\n\n\n\n\n\n# 启示","source":"_posts/HashMap-Design-And-Implementation.md","raw":"---\ntitle: Java集合框架(3)-HashMap设计与实现\ndate: 2020-11-14 21:01:10\ntags: \n  - java.util.*\n  - java collection framework\ncategories:\n  - JDK源码\n  - Java集合框架\n---\n\n\n\n# 序言\n\n​          HashMap在面试中被频繁问到，从我入行(2015年)问到了现在，我一直思考，就一个Map的实现有什么好问的，曾经对问我HashMap的面试官忍不住吐槽：难道你们没别的问的了？但是不可避免这个问题的出现频率，因为这体现你的“Java基础”。于是为了回答好这个问题，我从网上看了很多资料，从此面试时候不在被HashMap所难倒，但是我好像除了应付面试，从HashMap并没有学到什么东西，有一天，我下定决心，真正地重新学习HashMap的实现，从此好像发现了宝藏一样，对我的代码水平提高也很有帮助，从最初的迷惑，不屑，到现在对HashMap的喜欢，也是见证自己对技术从实用主义到真正渴望理解的一个提高，也是从浮躁到沉淀的一个见证。所以这篇文章总结了自己对HashMap的设计与实现的认识。\n\n\n\n# 概述\n\n​          HashMap作为最经典的Map接口实现，内部实现细节非常复杂，但是设计本身实现却是一致的，没有脱离Map接口和整个集合框架带给我们的抽象。**Node**和**TreeNode**作为**Map.Entry**的实现类，代表了**HashMap**内部的不同类型**Entry**， **KeySet，Values，EntrySet**分别作为Map的key,value，Entry的视图. 而**HashIterator，KeyInterator，ValueIterator，EntryIterator**分别作为KeySet，Values，EntrySet的迭代器实现，用于遍历Map，而**HashMapSpliterator，KeySpliterator，ValueSpliterator，EntrySpliterator**作为HashMap支持流式编程的Spliterator的实现。虽然看着类很多，但是抽象围绕**迭代器，分割器，视图，Entry**去实现的。由此可以得知，支持HashMap的实现由这些基本抽象组成。在接下来结构中，可以体现这些细节。\n\n\n\n# 结构\n\nHashMap的内部结构较多，但是并不难以理解。\n\n![](/images/HashMap.png)\n\n\n\n\n\n\n\n\n\n# HashMap的API\n\n\n\n\n\n# HashMap的实现\n\n\n\n\n\n# 启示","slug":"HashMap-Design-And-Implementation","published":1,"updated":"2022-06-28T17:21:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clh7s5cti0008xt8j6m2lc7gq","content":"<h1 id=\"序言\"><a href=\"#序言\" class=\"headerlink\" title=\"序言\"></a>序言</h1><p>​          HashMap在面试中被频繁问到，从我入行(2015年)问到了现在，我一直思考，就一个Map的实现有什么好问的，曾经对问我HashMap的面试官忍不住吐槽：难道你们没别的问的了？但是不可避免这个问题的出现频率，因为这体现你的“Java基础”。于是为了回答好这个问题，我从网上看了很多资料，从此面试时候不在被HashMap所难倒，但是我好像除了应付面试，从HashMap并没有学到什么东西，有一天，我下定决心，真正地重新学习HashMap的实现，从此好像发现了宝藏一样，对我的代码水平提高也很有帮助，从最初的迷惑，不屑，到现在对HashMap的喜欢，也是见证自己对技术从实用主义到真正渴望理解的一个提高，也是从浮躁到沉淀的一个见证。所以这篇文章总结了自己对HashMap的设计与实现的认识。</p>\n<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><p>​          HashMap作为最经典的Map接口实现，内部实现细节非常复杂，但是设计本身实现却是一致的，没有脱离Map接口和整个集合框架带给我们的抽象。<strong>Node</strong>和<strong>TreeNode</strong>作为<strong>Map.Entry</strong>的实现类，代表了<strong>HashMap</strong>内部的不同类型<strong>Entry</strong>， <strong>KeySet，Values，EntrySet</strong>分别作为Map的key,value，Entry的视图. 而<strong>HashIterator，KeyInterator，ValueIterator，EntryIterator</strong>分别作为KeySet，Values，EntrySet的迭代器实现，用于遍历Map，而<strong>HashMapSpliterator，KeySpliterator，ValueSpliterator，EntrySpliterator</strong>作为HashMap支持流式编程的Spliterator的实现。虽然看着类很多，但是抽象围绕<strong>迭代器，分割器，视图，Entry</strong>去实现的。由此可以得知，支持HashMap的实现由这些基本抽象组成。在接下来结构中，可以体现这些细节。</p>\n<h1 id=\"结构\"><a href=\"#结构\" class=\"headerlink\" title=\"结构\"></a>结构</h1><p>HashMap的内部结构较多，但是并不难以理解。</p>\n<p><img src=\"/images/HashMap.png\" alt=\"\"></p>\n<h1 id=\"HashMap的API\"><a href=\"#HashMap的API\" class=\"headerlink\" title=\"HashMap的API\"></a>HashMap的API</h1><h1 id=\"HashMap的实现\"><a href=\"#HashMap的实现\" class=\"headerlink\" title=\"HashMap的实现\"></a>HashMap的实现</h1><h1 id=\"启示\"><a href=\"#启示\" class=\"headerlink\" title=\"启示\"></a>启示</h1>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"序言\"><a href=\"#序言\" class=\"headerlink\" title=\"序言\"></a>序言</h1><p>​          HashMap在面试中被频繁问到，从我入行(2015年)问到了现在，我一直思考，就一个Map的实现有什么好问的，曾经对问我HashMap的面试官忍不住吐槽：难道你们没别的问的了？但是不可避免这个问题的出现频率，因为这体现你的“Java基础”。于是为了回答好这个问题，我从网上看了很多资料，从此面试时候不在被HashMap所难倒，但是我好像除了应付面试，从HashMap并没有学到什么东西，有一天，我下定决心，真正地重新学习HashMap的实现，从此好像发现了宝藏一样，对我的代码水平提高也很有帮助，从最初的迷惑，不屑，到现在对HashMap的喜欢，也是见证自己对技术从实用主义到真正渴望理解的一个提高，也是从浮躁到沉淀的一个见证。所以这篇文章总结了自己对HashMap的设计与实现的认识。</p>\n<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><p>​          HashMap作为最经典的Map接口实现，内部实现细节非常复杂，但是设计本身实现却是一致的，没有脱离Map接口和整个集合框架带给我们的抽象。<strong>Node</strong>和<strong>TreeNode</strong>作为<strong>Map.Entry</strong>的实现类，代表了<strong>HashMap</strong>内部的不同类型<strong>Entry</strong>， <strong>KeySet，Values，EntrySet</strong>分别作为Map的key,value，Entry的视图. 而<strong>HashIterator，KeyInterator，ValueIterator，EntryIterator</strong>分别作为KeySet，Values，EntrySet的迭代器实现，用于遍历Map，而<strong>HashMapSpliterator，KeySpliterator，ValueSpliterator，EntrySpliterator</strong>作为HashMap支持流式编程的Spliterator的实现。虽然看着类很多，但是抽象围绕<strong>迭代器，分割器，视图，Entry</strong>去实现的。由此可以得知，支持HashMap的实现由这些基本抽象组成。在接下来结构中，可以体现这些细节。</p>\n<h1 id=\"结构\"><a href=\"#结构\" class=\"headerlink\" title=\"结构\"></a>结构</h1><p>HashMap的内部结构较多，但是并不难以理解。</p>\n<p><img src=\"/images/HashMap.png\" alt=\"\"></p>\n<h1 id=\"HashMap的API\"><a href=\"#HashMap的API\" class=\"headerlink\" title=\"HashMap的API\"></a>HashMap的API</h1><h1 id=\"HashMap的实现\"><a href=\"#HashMap的实现\" class=\"headerlink\" title=\"HashMap的实现\"></a>HashMap的实现</h1><h1 id=\"启示\"><a href=\"#启示\" class=\"headerlink\" title=\"启示\"></a>启示</h1>"},{"title":"2020年尾声规划","date":"2020-08-15T18:16:13.000Z","password":"password","_content":"\n\n\n2020年还有4个月就结束了，今年从疫情期间忙忙碌碌，时间过得飞快。想到了诸葛亮的诫子书一句话，年与时驰，意与日去，遂成枯落，多不接世，悲守穷庐，将复何及。觉得很惭愧，思想提高慢，能力提高慢，技术深度提高慢，希望制定以下计划来日益精进自我的技术。\n\n\n\n经过思考以下几个点需要不断提高：\n\n1. 体系化思考，深度思考能力(欠缺)\n2. 提高技术鉴赏力，品味(一般)\n3. 算法能力(严重短板)\n4. 工程，架构以及软件设计能力(一般)\n5. 项目管理能力(欠缺)\n6. 英语读写，中文读写，文档能力(欠缺)\n7. 面试能力，BQ，面试题  (不满意)\n","source":"_posts/2020-plan.md","raw":"---\ntitle: 2020年尾声规划\ndate: 2020-08-16 02:16:13\ntags:\n  - 2020尾声规划\ncategories:\n  - 规划\npassword: password\n---\n\n\n\n2020年还有4个月就结束了，今年从疫情期间忙忙碌碌，时间过得飞快。想到了诸葛亮的诫子书一句话，年与时驰，意与日去，遂成枯落，多不接世，悲守穷庐，将复何及。觉得很惭愧，思想提高慢，能力提高慢，技术深度提高慢，希望制定以下计划来日益精进自我的技术。\n\n\n\n经过思考以下几个点需要不断提高：\n\n1. 体系化思考，深度思考能力(欠缺)\n2. 提高技术鉴赏力，品味(一般)\n3. 算法能力(严重短板)\n4. 工程，架构以及软件设计能力(一般)\n5. 项目管理能力(欠缺)\n6. 英语读写，中文读写，文档能力(欠缺)\n7. 面试能力，BQ，面试题  (不满意)\n","slug":"2020-plan","published":1,"updated":"2021-12-19T15:48:56.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clh7s5ctk000cxt8j6ntw9dew","content":"<p>2020年还有4个月就结束了，今年从疫情期间忙忙碌碌，时间过得飞快。想到了诸葛亮的诫子书一句话，年与时驰，意与日去，遂成枯落，多不接世，悲守穷庐，将复何及。觉得很惭愧，思想提高慢，能力提高慢，技术深度提高慢，希望制定以下计划来日益精进自我的技术。</p>\n<p>经过思考以下几个点需要不断提高：</p>\n<ol>\n<li>体系化思考，深度思考能力(欠缺)</li>\n<li>提高技术鉴赏力，品味(一般)</li>\n<li>算法能力(严重短板)</li>\n<li>工程，架构以及软件设计能力(一般)</li>\n<li>项目管理能力(欠缺)</li>\n<li>英语读写，中文读写，文档能力(欠缺)</li>\n<li>面试能力，BQ，面试题  (不满意)</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>2020年还有4个月就结束了，今年从疫情期间忙忙碌碌，时间过得飞快。想到了诸葛亮的诫子书一句话，年与时驰，意与日去，遂成枯落，多不接世，悲守穷庐，将复何及。觉得很惭愧，思想提高慢，能力提高慢，技术深度提高慢，希望制定以下计划来日益精进自我的技术。</p>\n<p>经过思考以下几个点需要不断提高：</p>\n<ol>\n<li>体系化思考，深度思考能力(欠缺)</li>\n<li>提高技术鉴赏力，品味(一般)</li>\n<li>算法能力(严重短板)</li>\n<li>工程，架构以及软件设计能力(一般)</li>\n<li>项目管理能力(欠缺)</li>\n<li>英语读写，中文读写，文档能力(欠缺)</li>\n<li>面试能力，BQ，面试题  (不满意)</li>\n</ol>\n"},{"title":"Java集合框架(1)-接口定义类型","date":"2020-11-08T17:19:19.000Z","_content":"\n\n\n# 序言\n\n集合框架是任何语言的技术体现，是语言的综合使用的类库，大部分工作可以用集合完成，但是单独的看每一个集合实现类难以对集合框架产生一个宏观认识，所以需要从高层角度来看集合技术，本系列将分析集合框架的设计与实现。\n\n\n\n集合设计包括**接口，实现和算法**三大核心功能。接口包括类型接口和迭代器接口，类型接口是List，Set，Map，Queue等接口，而迭代器接口包括顺序迭代器和分割器，实现包括骨架实现，视图实现，数据结构实现，骨架实现就是AbstractList，AbstractSet，AbstractMap,AbstractQueue等实现，视图实现比如ArrayList的SubList，HashMap的KeySet，Values和EntrySet，而数据结构实现是特定的类型实现比如List有ArrayList和LinkedList，算法主要有排序，查找，shuffle 等，这三个功能构成了集合的设计核心。\n\n\n\n使用集合类型有非常多的好处：\n\n1\n\n2\n\n3\n\n\n\n\n\n\n\n# 结构\n\n集合中最重要的是接口，接口定义了数据类型，抽象类实现了接口，而具体集合类实现了真正的类型。接下来会分析每种数据结构类型接口方法，根本特征以及不同类型之间的真正区别。\n\n### 基本接口\n\n<img src=\"/images/JCF-Base.png\" style=\"zoom:67%;\" />\n\n集合的基本组成是元素，元素即对象。这些元素本身是普通对象，但是被集合框架管理起来就具有鲜明特点，如可以迭代，可以被分割，可以比较大小排序，而正是这些基础的能力构成了集合最核心的三大接口：**Iterator，Spliterator，Comparator**.\n\n**Iterator**提供了种不需要知道集合实现就能遍历的能力,也是经典的设计模式。\n\n**Spliterator**提供了分割集合的能力，在并行遍历中常用。\n\n**Comparator**提供了元素比较大小的能力，在排序中常用。\n\n\n\n### Collection接口\n\nCollection是JCF的顶级接口，该接口定义了集合的基本操作，其中分为查询，修改，块操作，基本对象操作。\n\n```java\n//查询\nint size();\nboolean isEmpty();\nboolean contains(Object o);\nIterator<E> iterator();\nObject[] toArray();\n<T> T[] toArray(T[] a);\n//修改，在List/Set/Queue中也会重新定义这些方法，因为这些方法在这些接口中有了新的含义，异常也和Collection\n//add接口异常也不一样，因为add对于不同接口意思不同，，如List.add只是添加元素，Set.add添加不同元素，Queue.add\n//如果超过了Queue长度，会抛出异常。\nboolean add(E e);\nboolean remove(Object o);\n//块操作\nboolean containsAll(Collection<?> c);\nboolean addAll(Collection<? extends E> c);\nboolean removeAll(Collection<?> c);\nboolean retainAll(Collection<?> c);\nvoid clear();\n//基本对象操作\nboolean equals(Object o);\nint hashCode();\n```\n\n这些操作定义了Collection基本操作，也是契约。而这些子接口Set，List，Queue有些重新定义了Collection接口方法，有些则没有，因为不同接口的含义不同。比如List，Set，Queue都重新定义了add方法，但是List，Set定义size()方法，Queue却没有定义，因为我认为size方法在List和Set(cardinality)含义不同，但是Queue的size含义和Collection一样。这种**父接口定义方法，在子接口重新定义方法**的技巧在JCF中广泛使用。\n\n\n\n### List接口\n\n<img src=\"/images/List-Impl.png\" style=\"zoom:67%;\" />\n\n\n\nList是一种Collection，但是Collection不一样，List支持index访问，所以List接口新加了关于index的方法，index是List最重要的抽象之一.同时List也把Collection中的方法重新定义了下，\n\n```java\nvoid add(int index, E element)\nboolean addAll(int index, Collection<? extends E> c);\nE get(int index);\nint indexOf(Object o);\nint lastIndexOf(Object o);\nListIterator<E> listIterator();\nListIterator<E> listIterator(int index);\nE remove(int index);\nE set(int index, E element);\nList<E> subList(int fromIndex, int toIndex);\n```\n\n\n\n### Set接口\n\n<img src=\"/images/set-impl.jpg\" style=\"zoom:67%;\" />\n\nSet接口将Collection方法几乎全部定义了遍，因为Set具有数学意义上集合的含义，所以集合操作需要新定义一套契约，用来表达Set的不同于Collection之处。\n\n\n\n### Queue接口\n\n![](/images/Queue-Impl.png )\n\nQueue也是一种Collection，但是接口中并没有新加任何方法，只是把Collection接口方法重新定义了下，因为和Collection内涵不一样。但是仅仅重新定义了add方法，其他方法并没有重新定义，因为add方法在Queue满的时候会抛出异常。这和List，Set，Collection均不一样。\n\n```java\n//入队，如果队列满抛出IllegalStateException异常\nboolean add(E e);\n//入队，如果队列满返回false\nboolean offer(E e);\n//出队队头元素，没有元素则抛出NoSuchElementException异常\nE remove();\n//出队队头元素，没有元素则返回false\nE poll();\n//查看队头元素，没有元素则抛出NoSuchElementException异常\nE element();\n//查看队头元素，没有元素则返回false\nE peek();\n```\n\n队列方法比较对称，add/remove，offer/poll，element/peek，这也是API对称设计的范例。\n\n\n\n\n\n### Deque接口\n\n![](/images/Deque-Impl.png)\n\n\n\n### Map接口\n\n<img src=\"/images/Map-Impl.png\" style=\"zoom:67%;\" />\n\n\n\nMap接口里面的Map.Entry\n\nmap接口\n\n\n\n\n\n\n\n以上便是集合框架最重要的接口和实现(不包括并发集合，并发集合将在并发中分析)了，我们接下来分析将会围绕抽象实现和具体集合类而展开\n\n\n\n# 参考\n\nhttps://docs.oracle.com/javase/tutorial/collections/\n\n\n\n","source":"_posts/JCF-HighLevel.md","raw":"---\ntitle: Java集合框架(1)-接口定义类型\ndate: 2020-11-09 01:19:19\ntags: \n  - java.util.*\n  - java collection framework\ncategories:\n  - JDK源码\n  - Java集合框架\n---\n\n\n\n# 序言\n\n集合框架是任何语言的技术体现，是语言的综合使用的类库，大部分工作可以用集合完成，但是单独的看每一个集合实现类难以对集合框架产生一个宏观认识，所以需要从高层角度来看集合技术，本系列将分析集合框架的设计与实现。\n\n\n\n集合设计包括**接口，实现和算法**三大核心功能。接口包括类型接口和迭代器接口，类型接口是List，Set，Map，Queue等接口，而迭代器接口包括顺序迭代器和分割器，实现包括骨架实现，视图实现，数据结构实现，骨架实现就是AbstractList，AbstractSet，AbstractMap,AbstractQueue等实现，视图实现比如ArrayList的SubList，HashMap的KeySet，Values和EntrySet，而数据结构实现是特定的类型实现比如List有ArrayList和LinkedList，算法主要有排序，查找，shuffle 等，这三个功能构成了集合的设计核心。\n\n\n\n使用集合类型有非常多的好处：\n\n1\n\n2\n\n3\n\n\n\n\n\n\n\n# 结构\n\n集合中最重要的是接口，接口定义了数据类型，抽象类实现了接口，而具体集合类实现了真正的类型。接下来会分析每种数据结构类型接口方法，根本特征以及不同类型之间的真正区别。\n\n### 基本接口\n\n<img src=\"/images/JCF-Base.png\" style=\"zoom:67%;\" />\n\n集合的基本组成是元素，元素即对象。这些元素本身是普通对象，但是被集合框架管理起来就具有鲜明特点，如可以迭代，可以被分割，可以比较大小排序，而正是这些基础的能力构成了集合最核心的三大接口：**Iterator，Spliterator，Comparator**.\n\n**Iterator**提供了种不需要知道集合实现就能遍历的能力,也是经典的设计模式。\n\n**Spliterator**提供了分割集合的能力，在并行遍历中常用。\n\n**Comparator**提供了元素比较大小的能力，在排序中常用。\n\n\n\n### Collection接口\n\nCollection是JCF的顶级接口，该接口定义了集合的基本操作，其中分为查询，修改，块操作，基本对象操作。\n\n```java\n//查询\nint size();\nboolean isEmpty();\nboolean contains(Object o);\nIterator<E> iterator();\nObject[] toArray();\n<T> T[] toArray(T[] a);\n//修改，在List/Set/Queue中也会重新定义这些方法，因为这些方法在这些接口中有了新的含义，异常也和Collection\n//add接口异常也不一样，因为add对于不同接口意思不同，，如List.add只是添加元素，Set.add添加不同元素，Queue.add\n//如果超过了Queue长度，会抛出异常。\nboolean add(E e);\nboolean remove(Object o);\n//块操作\nboolean containsAll(Collection<?> c);\nboolean addAll(Collection<? extends E> c);\nboolean removeAll(Collection<?> c);\nboolean retainAll(Collection<?> c);\nvoid clear();\n//基本对象操作\nboolean equals(Object o);\nint hashCode();\n```\n\n这些操作定义了Collection基本操作，也是契约。而这些子接口Set，List，Queue有些重新定义了Collection接口方法，有些则没有，因为不同接口的含义不同。比如List，Set，Queue都重新定义了add方法，但是List，Set定义size()方法，Queue却没有定义，因为我认为size方法在List和Set(cardinality)含义不同，但是Queue的size含义和Collection一样。这种**父接口定义方法，在子接口重新定义方法**的技巧在JCF中广泛使用。\n\n\n\n### List接口\n\n<img src=\"/images/List-Impl.png\" style=\"zoom:67%;\" />\n\n\n\nList是一种Collection，但是Collection不一样，List支持index访问，所以List接口新加了关于index的方法，index是List最重要的抽象之一.同时List也把Collection中的方法重新定义了下，\n\n```java\nvoid add(int index, E element)\nboolean addAll(int index, Collection<? extends E> c);\nE get(int index);\nint indexOf(Object o);\nint lastIndexOf(Object o);\nListIterator<E> listIterator();\nListIterator<E> listIterator(int index);\nE remove(int index);\nE set(int index, E element);\nList<E> subList(int fromIndex, int toIndex);\n```\n\n\n\n### Set接口\n\n<img src=\"/images/set-impl.jpg\" style=\"zoom:67%;\" />\n\nSet接口将Collection方法几乎全部定义了遍，因为Set具有数学意义上集合的含义，所以集合操作需要新定义一套契约，用来表达Set的不同于Collection之处。\n\n\n\n### Queue接口\n\n![](/images/Queue-Impl.png )\n\nQueue也是一种Collection，但是接口中并没有新加任何方法，只是把Collection接口方法重新定义了下，因为和Collection内涵不一样。但是仅仅重新定义了add方法，其他方法并没有重新定义，因为add方法在Queue满的时候会抛出异常。这和List，Set，Collection均不一样。\n\n```java\n//入队，如果队列满抛出IllegalStateException异常\nboolean add(E e);\n//入队，如果队列满返回false\nboolean offer(E e);\n//出队队头元素，没有元素则抛出NoSuchElementException异常\nE remove();\n//出队队头元素，没有元素则返回false\nE poll();\n//查看队头元素，没有元素则抛出NoSuchElementException异常\nE element();\n//查看队头元素，没有元素则返回false\nE peek();\n```\n\n队列方法比较对称，add/remove，offer/poll，element/peek，这也是API对称设计的范例。\n\n\n\n\n\n### Deque接口\n\n![](/images/Deque-Impl.png)\n\n\n\n### Map接口\n\n<img src=\"/images/Map-Impl.png\" style=\"zoom:67%;\" />\n\n\n\nMap接口里面的Map.Entry\n\nmap接口\n\n\n\n\n\n\n\n以上便是集合框架最重要的接口和实现(不包括并发集合，并发集合将在并发中分析)了，我们接下来分析将会围绕抽象实现和具体集合类而展开\n\n\n\n# 参考\n\nhttps://docs.oracle.com/javase/tutorial/collections/\n\n\n\n","slug":"JCF-HighLevel","published":1,"updated":"2022-06-28T17:21:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clh7s5ctl000ext8jalt276aa","content":"<h1 id=\"序言\"><a href=\"#序言\" class=\"headerlink\" title=\"序言\"></a>序言</h1><p>集合框架是任何语言的技术体现，是语言的综合使用的类库，大部分工作可以用集合完成，但是单独的看每一个集合实现类难以对集合框架产生一个宏观认识，所以需要从高层角度来看集合技术，本系列将分析集合框架的设计与实现。</p>\n<p>集合设计包括<strong>接口，实现和算法</strong>三大核心功能。接口包括类型接口和迭代器接口，类型接口是List，Set，Map，Queue等接口，而迭代器接口包括顺序迭代器和分割器，实现包括骨架实现，视图实现，数据结构实现，骨架实现就是AbstractList，AbstractSet，AbstractMap,AbstractQueue等实现，视图实现比如ArrayList的SubList，HashMap的KeySet，Values和EntrySet，而数据结构实现是特定的类型实现比如List有ArrayList和LinkedList，算法主要有排序，查找，shuffle 等，这三个功能构成了集合的设计核心。</p>\n<p>使用集合类型有非常多的好处：</p>\n<p>1</p>\n<p>2</p>\n<p>3</p>\n<h1 id=\"结构\"><a href=\"#结构\" class=\"headerlink\" title=\"结构\"></a>结构</h1><p>集合中最重要的是接口，接口定义了数据类型，抽象类实现了接口，而具体集合类实现了真正的类型。接下来会分析每种数据结构类型接口方法，根本特征以及不同类型之间的真正区别。</p>\n<h3 id=\"基本接口\"><a href=\"#基本接口\" class=\"headerlink\" title=\"基本接口\"></a>基本接口</h3><img src=\"/images/JCF-Base.png\" style=\"zoom:67%;\" />\n\n<p>集合的基本组成是元素，元素即对象。这些元素本身是普通对象，但是被集合框架管理起来就具有鲜明特点，如可以迭代，可以被分割，可以比较大小排序，而正是这些基础的能力构成了集合最核心的三大接口：<strong>Iterator，Spliterator，Comparator</strong>.</p>\n<p><strong>Iterator</strong>提供了种不需要知道集合实现就能遍历的能力,也是经典的设计模式。</p>\n<p><strong>Spliterator</strong>提供了分割集合的能力，在并行遍历中常用。</p>\n<p><strong>Comparator</strong>提供了元素比较大小的能力，在排序中常用。</p>\n<h3 id=\"Collection接口\"><a href=\"#Collection接口\" class=\"headerlink\" title=\"Collection接口\"></a>Collection接口</h3><p>Collection是JCF的顶级接口，该接口定义了集合的基本操作，其中分为查询，修改，块操作，基本对象操作。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//查询</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">size</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isEmpty</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">contains</span><span class=\"params\">(Object o)</span></span>;</span><br><span class=\"line\"><span class=\"function\">Iterator&lt;E&gt; <span class=\"title\">iterator</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">Object[] toArray();</span><br><span class=\"line\">&lt;T&gt; T[] toArray(T[] a);</span><br><span class=\"line\"><span class=\"comment\">//修改，在List/Set/Queue中也会重新定义这些方法，因为这些方法在这些接口中有了新的含义，异常也和Collection</span></span><br><span class=\"line\"><span class=\"comment\">//add接口异常也不一样，因为add对于不同接口意思不同，，如List.add只是添加元素，Set.add添加不同元素，Queue.add</span></span><br><span class=\"line\"><span class=\"comment\">//如果超过了Queue长度，会抛出异常。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(E e)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">remove</span><span class=\"params\">(Object o)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">//块操作</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">containsAll</span><span class=\"params\">(Collection&lt;?&gt; c)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">addAll</span><span class=\"params\">(Collection&lt;? extends E&gt; c)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">removeAll</span><span class=\"params\">(Collection&lt;?&gt; c)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">retainAll</span><span class=\"params\">(Collection&lt;?&gt; c)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">clear</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"comment\">//基本对象操作</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object o)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>这些操作定义了Collection基本操作，也是契约。而这些子接口Set，List，Queue有些重新定义了Collection接口方法，有些则没有，因为不同接口的含义不同。比如List，Set，Queue都重新定义了add方法，但是List，Set定义size()方法，Queue却没有定义，因为我认为size方法在List和Set(cardinality)含义不同，但是Queue的size含义和Collection一样。这种<strong>父接口定义方法，在子接口重新定义方法</strong>的技巧在JCF中广泛使用。</p>\n<h3 id=\"List接口\"><a href=\"#List接口\" class=\"headerlink\" title=\"List接口\"></a>List接口</h3><img src=\"/images/List-Impl.png\" style=\"zoom:67%;\" />\n\n\n\n<p>List是一种Collection，但是Collection不一样，List支持index访问，所以List接口新加了关于index的方法，index是List最重要的抽象之一.同时List也把Collection中的方法重新定义了下，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> index, E element)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">addAll</span><span class=\"params\">(<span class=\"keyword\">int</span> index, Collection&lt;? extends E&gt; c)</span></span>;</span><br><span class=\"line\"><span class=\"function\">E <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">indexOf</span><span class=\"params\">(Object o)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">lastIndexOf</span><span class=\"params\">(Object o)</span></span>;</span><br><span class=\"line\"><span class=\"function\">ListIterator&lt;E&gt; <span class=\"title\">listIterator</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"function\">ListIterator&lt;E&gt; <span class=\"title\">listIterator</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span></span>;</span><br><span class=\"line\"><span class=\"function\">E <span class=\"title\">remove</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span></span>;</span><br><span class=\"line\"><span class=\"function\">E <span class=\"title\">set</span><span class=\"params\">(<span class=\"keyword\">int</span> index, E element)</span></span>;</span><br><span class=\"line\"><span class=\"function\">List&lt;E&gt; <span class=\"title\">subList</span><span class=\"params\">(<span class=\"keyword\">int</span> fromIndex, <span class=\"keyword\">int</span> toIndex)</span></span>;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"Set接口\"><a href=\"#Set接口\" class=\"headerlink\" title=\"Set接口\"></a>Set接口</h3><img src=\"/images/set-impl.jpg\" style=\"zoom:67%;\" />\n\n<p>Set接口将Collection方法几乎全部定义了遍，因为Set具有数学意义上集合的含义，所以集合操作需要新定义一套契约，用来表达Set的不同于Collection之处。</p>\n<h3 id=\"Queue接口\"><a href=\"#Queue接口\" class=\"headerlink\" title=\"Queue接口\"></a>Queue接口</h3><p><img src=\"/images/Queue-Impl.png\" alt=\"\"></p>\n<p>Queue也是一种Collection，但是接口中并没有新加任何方法，只是把Collection接口方法重新定义了下，因为和Collection内涵不一样。但是仅仅重新定义了add方法，其他方法并没有重新定义，因为add方法在Queue满的时候会抛出异常。这和List，Set，Collection均不一样。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//入队，如果队列满抛出IllegalStateException异常</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(E e)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">//入队，如果队列满返回false</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">offer</span><span class=\"params\">(E e)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">//出队队头元素，没有元素则抛出NoSuchElementException异常</span></span><br><span class=\"line\"><span class=\"function\">E <span class=\"title\">remove</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"comment\">//出队队头元素，没有元素则返回false</span></span><br><span class=\"line\"><span class=\"function\">E <span class=\"title\">poll</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"comment\">//查看队头元素，没有元素则抛出NoSuchElementException异常</span></span><br><span class=\"line\"><span class=\"function\">E <span class=\"title\">element</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"comment\">//查看队头元素，没有元素则返回false</span></span><br><span class=\"line\"><span class=\"function\">E <span class=\"title\">peek</span><span class=\"params\">()</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>队列方法比较对称，add/remove，offer/poll，element/peek，这也是API对称设计的范例。</p>\n<h3 id=\"Deque接口\"><a href=\"#Deque接口\" class=\"headerlink\" title=\"Deque接口\"></a>Deque接口</h3><p><img src=\"/images/Deque-Impl.png\" alt=\"\"></p>\n<h3 id=\"Map接口\"><a href=\"#Map接口\" class=\"headerlink\" title=\"Map接口\"></a>Map接口</h3><img src=\"/images/Map-Impl.png\" style=\"zoom:67%;\" />\n\n\n\n<p>Map接口里面的Map.Entry</p>\n<p>map接口</p>\n<p>以上便是集合框架最重要的接口和实现(不包括并发集合，并发集合将在并发中分析)了，我们接下来分析将会围绕抽象实现和具体集合类而展开</p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"https://docs.oracle.com/javase/tutorial/collections/\" target=\"_blank\" rel=\"noopener\">https://docs.oracle.com/javase/tutorial/collections/</a></p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"序言\"><a href=\"#序言\" class=\"headerlink\" title=\"序言\"></a>序言</h1><p>集合框架是任何语言的技术体现，是语言的综合使用的类库，大部分工作可以用集合完成，但是单独的看每一个集合实现类难以对集合框架产生一个宏观认识，所以需要从高层角度来看集合技术，本系列将分析集合框架的设计与实现。</p>\n<p>集合设计包括<strong>接口，实现和算法</strong>三大核心功能。接口包括类型接口和迭代器接口，类型接口是List，Set，Map，Queue等接口，而迭代器接口包括顺序迭代器和分割器，实现包括骨架实现，视图实现，数据结构实现，骨架实现就是AbstractList，AbstractSet，AbstractMap,AbstractQueue等实现，视图实现比如ArrayList的SubList，HashMap的KeySet，Values和EntrySet，而数据结构实现是特定的类型实现比如List有ArrayList和LinkedList，算法主要有排序，查找，shuffle 等，这三个功能构成了集合的设计核心。</p>\n<p>使用集合类型有非常多的好处：</p>\n<p>1</p>\n<p>2</p>\n<p>3</p>\n<h1 id=\"结构\"><a href=\"#结构\" class=\"headerlink\" title=\"结构\"></a>结构</h1><p>集合中最重要的是接口，接口定义了数据类型，抽象类实现了接口，而具体集合类实现了真正的类型。接下来会分析每种数据结构类型接口方法，根本特征以及不同类型之间的真正区别。</p>\n<h3 id=\"基本接口\"><a href=\"#基本接口\" class=\"headerlink\" title=\"基本接口\"></a>基本接口</h3><img src=\"/images/JCF-Base.png\" style=\"zoom:67%;\" />\n\n<p>集合的基本组成是元素，元素即对象。这些元素本身是普通对象，但是被集合框架管理起来就具有鲜明特点，如可以迭代，可以被分割，可以比较大小排序，而正是这些基础的能力构成了集合最核心的三大接口：<strong>Iterator，Spliterator，Comparator</strong>.</p>\n<p><strong>Iterator</strong>提供了种不需要知道集合实现就能遍历的能力,也是经典的设计模式。</p>\n<p><strong>Spliterator</strong>提供了分割集合的能力，在并行遍历中常用。</p>\n<p><strong>Comparator</strong>提供了元素比较大小的能力，在排序中常用。</p>\n<h3 id=\"Collection接口\"><a href=\"#Collection接口\" class=\"headerlink\" title=\"Collection接口\"></a>Collection接口</h3><p>Collection是JCF的顶级接口，该接口定义了集合的基本操作，其中分为查询，修改，块操作，基本对象操作。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//查询</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">size</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isEmpty</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">contains</span><span class=\"params\">(Object o)</span></span>;</span><br><span class=\"line\"><span class=\"function\">Iterator&lt;E&gt; <span class=\"title\">iterator</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">Object[] toArray();</span><br><span class=\"line\">&lt;T&gt; T[] toArray(T[] a);</span><br><span class=\"line\"><span class=\"comment\">//修改，在List/Set/Queue中也会重新定义这些方法，因为这些方法在这些接口中有了新的含义，异常也和Collection</span></span><br><span class=\"line\"><span class=\"comment\">//add接口异常也不一样，因为add对于不同接口意思不同，，如List.add只是添加元素，Set.add添加不同元素，Queue.add</span></span><br><span class=\"line\"><span class=\"comment\">//如果超过了Queue长度，会抛出异常。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(E e)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">remove</span><span class=\"params\">(Object o)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">//块操作</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">containsAll</span><span class=\"params\">(Collection&lt;?&gt; c)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">addAll</span><span class=\"params\">(Collection&lt;? extends E&gt; c)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">removeAll</span><span class=\"params\">(Collection&lt;?&gt; c)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">retainAll</span><span class=\"params\">(Collection&lt;?&gt; c)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">clear</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"comment\">//基本对象操作</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object o)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>这些操作定义了Collection基本操作，也是契约。而这些子接口Set，List，Queue有些重新定义了Collection接口方法，有些则没有，因为不同接口的含义不同。比如List，Set，Queue都重新定义了add方法，但是List，Set定义size()方法，Queue却没有定义，因为我认为size方法在List和Set(cardinality)含义不同，但是Queue的size含义和Collection一样。这种<strong>父接口定义方法，在子接口重新定义方法</strong>的技巧在JCF中广泛使用。</p>\n<h3 id=\"List接口\"><a href=\"#List接口\" class=\"headerlink\" title=\"List接口\"></a>List接口</h3><img src=\"/images/List-Impl.png\" style=\"zoom:67%;\" />\n\n\n\n<p>List是一种Collection，但是Collection不一样，List支持index访问，所以List接口新加了关于index的方法，index是List最重要的抽象之一.同时List也把Collection中的方法重新定义了下，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(<span class=\"keyword\">int</span> index, E element)</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">addAll</span><span class=\"params\">(<span class=\"keyword\">int</span> index, Collection&lt;? extends E&gt; c)</span></span>;</span><br><span class=\"line\"><span class=\"function\">E <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">indexOf</span><span class=\"params\">(Object o)</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">lastIndexOf</span><span class=\"params\">(Object o)</span></span>;</span><br><span class=\"line\"><span class=\"function\">ListIterator&lt;E&gt; <span class=\"title\">listIterator</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"function\">ListIterator&lt;E&gt; <span class=\"title\">listIterator</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span></span>;</span><br><span class=\"line\"><span class=\"function\">E <span class=\"title\">remove</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span></span>;</span><br><span class=\"line\"><span class=\"function\">E <span class=\"title\">set</span><span class=\"params\">(<span class=\"keyword\">int</span> index, E element)</span></span>;</span><br><span class=\"line\"><span class=\"function\">List&lt;E&gt; <span class=\"title\">subList</span><span class=\"params\">(<span class=\"keyword\">int</span> fromIndex, <span class=\"keyword\">int</span> toIndex)</span></span>;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"Set接口\"><a href=\"#Set接口\" class=\"headerlink\" title=\"Set接口\"></a>Set接口</h3><img src=\"/images/set-impl.jpg\" style=\"zoom:67%;\" />\n\n<p>Set接口将Collection方法几乎全部定义了遍，因为Set具有数学意义上集合的含义，所以集合操作需要新定义一套契约，用来表达Set的不同于Collection之处。</p>\n<h3 id=\"Queue接口\"><a href=\"#Queue接口\" class=\"headerlink\" title=\"Queue接口\"></a>Queue接口</h3><p><img src=\"/images/Queue-Impl.png\" alt=\"\"></p>\n<p>Queue也是一种Collection，但是接口中并没有新加任何方法，只是把Collection接口方法重新定义了下，因为和Collection内涵不一样。但是仅仅重新定义了add方法，其他方法并没有重新定义，因为add方法在Queue满的时候会抛出异常。这和List，Set，Collection均不一样。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//入队，如果队列满抛出IllegalStateException异常</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(E e)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">//入队，如果队列满返回false</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">offer</span><span class=\"params\">(E e)</span></span>;</span><br><span class=\"line\"><span class=\"comment\">//出队队头元素，没有元素则抛出NoSuchElementException异常</span></span><br><span class=\"line\"><span class=\"function\">E <span class=\"title\">remove</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"comment\">//出队队头元素，没有元素则返回false</span></span><br><span class=\"line\"><span class=\"function\">E <span class=\"title\">poll</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"comment\">//查看队头元素，没有元素则抛出NoSuchElementException异常</span></span><br><span class=\"line\"><span class=\"function\">E <span class=\"title\">element</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"comment\">//查看队头元素，没有元素则返回false</span></span><br><span class=\"line\"><span class=\"function\">E <span class=\"title\">peek</span><span class=\"params\">()</span></span>;</span><br></pre></td></tr></table></figure>\n\n<p>队列方法比较对称，add/remove，offer/poll，element/peek，这也是API对称设计的范例。</p>\n<h3 id=\"Deque接口\"><a href=\"#Deque接口\" class=\"headerlink\" title=\"Deque接口\"></a>Deque接口</h3><p><img src=\"/images/Deque-Impl.png\" alt=\"\"></p>\n<h3 id=\"Map接口\"><a href=\"#Map接口\" class=\"headerlink\" title=\"Map接口\"></a>Map接口</h3><img src=\"/images/Map-Impl.png\" style=\"zoom:67%;\" />\n\n\n\n<p>Map接口里面的Map.Entry</p>\n<p>map接口</p>\n<p>以上便是集合框架最重要的接口和实现(不包括并发集合，并发集合将在并发中分析)了，我们接下来分析将会围绕抽象实现和具体集合类而展开</p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><p><a href=\"https://docs.oracle.com/javase/tutorial/collections/\" target=\"_blank\" rel=\"noopener\">https://docs.oracle.com/javase/tutorial/collections/</a></p>\n"},{"title":"Java集合框架(2)-抽象实现骨架","date":"2020-11-08T18:34:19.000Z","_content":"\n# 概述\n\n**接口定义类型，抽象类实现骨架**。抽象类不支持的实现方法便是细节。这种技巧在JCF中是标配。一来替客户端提供如何实现一个接口的最直接的参考。二来帮助客户端以此实现功能更强的接口。如Guava的集合也是参考这种模式。\n\n\n\n# 抽象实现\n\n抽象类的最重要分析是留下了哪些抽象方法，而留下的抽象方法是真正实现类的差异，而抽象类中的普通方法使用抽象方法来实现，而抽象方法实现由实现类实现，并且抽象类没有任何字段，所以也能从侧面体现留下的抽象方法的价值。可以认为抽象实现是模板模式的一种应用。\n\n\n\n## AbstractCollection\n\n```java\n//这是AbstractCollection最核心的两个抽象方法，其余方法实现均是调用这两者\npublic abstract Iterator<E> iterator();\npublic abstract int size();\n```\n\n\n\n### isEmpty\n\n```java\n//非常简单，size()=0\npublic boolean isEmpty() {\n    return size() == 0;\n}\n```\n\n\n\n### contains\n\n```java\n//通过遍历迭代器来查找元素，元素为空，找出Collection中第一个为空的元素，元素不为空，\n//找出第一个在集合中的元素，对象需要实现equals方法\npublic boolean contains(Object o) {\n    Iterator<E> it = iterator();\n    if (o==null) {\n        while (it.hasNext())\n            if (it.next()==null)\n                return true;\n    } else {\n        while (it.hasNext())\n            if (o.equals(it.next()))  //对象equals方法很重要\n                return true;\n    }\n    return false;\n}\n```\n\n\n\n### add\n\n```java\n//抛出异常，因为子类可以实现可变或者不可变集合\npublic boolean add(E e) {\n    throw new UnsupportedOperationException();\n}\n```\n\n### remove\n\n```java\n//通过迭代器删除，equals方法很重要\npublic boolean remove(Object o) {\n    Iterator<E> it = iterator();\n    if (o==null) {\n        while (it.hasNext()) {\n            if (it.next()==null) {\n                it.remove();\n                return true;\n            }\n        }\n    } else {\n        while (it.hasNext()) {\n            if (o.equals(it.next())) {\n                it.remove();\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```\n\n\n\n### containsAll\n\n```java\n//时间复杂度为O(n^2)\npublic boolean containsAll(Collection<?> c) {\n    for (Object e : c)\n        if (!contains(e))\n            return false;\n    return true;\n}\n```\n\n\n\n### addAll\n\n```java\n//modified来判断集合是否改变\npublic boolean addAll(Collection<? extends E> c) {\n    boolean modified = false;\n    for (E e : c)\n        if (add(e))\n            modified = true;\n    return modified;\n}\n```\n\n\n\n### removeAll\n\n```java\n//通过迭代器删除\npublic boolean removeAll(Collection<?> c) {\n    Objects.requireNonNull(c);\n    boolean modified = false;\n    Iterator<?> it = iterator();\n    while (it.hasNext()) {\n        if (c.contains(it.next())) {\n            it.remove();\n            modified = true;\n        }\n    }\n    return modified;\n}\n```\n\n\n\n### clear\n\n```java\n//遍历迭代器，删除元素\npublic void clear() {\n    Iterator<E> it = iterator();\n    while (it.hasNext()) {\n        it.next();\n        it.remove();\n    }\n}\n```\n\n\n\n我们可以看到抽象方法在实现普通方法时候是基本每个方法都会调用。\n\n\n\n## AbstractList\n\n```java\n//AbstractList抽象方法有两个，1是新定义的get 2是继承父类的size，而父类AbstractCollection中的抽象方法只实现了一个iterator()，因为对于List来说，iterator行为是确认的。但是get行为需要子类实现。\npublic abstract E get(int index);\n```\n\n\n\n在AbstractList实现中，定义了Itr, ListItr两个迭代器，以及用于实现内部视图的SubList和RandomAccessSubList.\n\n\n\n### iterator\n\n```java\npublic Iterator<E> iterator() {\n    return new Itr();\n}\n```\n\n### Itr\n\n```java\nprivate class Itr implements Iterator<E> {\n    /** 游标位置，指向当前元素**/\n    int cursor = 0;\n    /**调用next后之前的元素，-1说明刚被删除了*/\n    int lastRet = -1;\n    /**\n     *期望修复次数是不是等于实际修改次数，用户判断遍历时候是否被修改，如果不同则会抛出ConcurrentModificationException\n     * 因为这些集合不是在线程安全的，所以并发修改会报错。\n     */\n    int expectedModCount = modCount;\n\n    public boolean hasNext() {\n        return cursor != size();\n    }\n    public E next() {\n        checkForComodification();//检查是否被修改\n        try {\n            int i = cursor; //当前位置的cursor存储起来\n            E next = get(i);//抽象方法get获取元素\n            lastRet = i;//更新上一个元素位置\n            cursor = i + 1;//cursor下移一位\n            return next;//返回当前元素\n        } catch (IndexOutOfBoundsException e) {\n            checkForComodification();\n            throw new NoSuchElementException();\n        }\n    }\n\t//删除某个元素\n    public void remove() {\n        if (lastRet < 0)\n            throw new IllegalStateException();\n        checkForComodification();\n        try {\n            AbstractList.this.remove(lastRet);//调用删除方法\n            if (lastRet < cursor) //\n                cursor--;\n            lastRet = -1;//lastRet设置为-1\n            expectedModCount = modCount;//修改次数等于期望修改次数\n        } catch (IndexOutOfBoundsException e) {\n            throw new ConcurrentModificationException();\n        }\n    }\n\n    final void checkForComodification() {\n        if (modCount != expectedModCount)\n            throw new ConcurrentModificationException();\n    }\n}\n```\n\n### ListItr\n\nListItr实现了ListIterator接口，ListIterator和Iterator不同之处在于Iterator只支持向后遍历，但是ListIterator同时支持向后和向前遍历。也支持任意位置开始的遍历。\n\n```java\npublic interface ListIterator<E> extends Iterator<E> {\n\tboolean hasNext();\n    E next();\n    boolean hasPrevious();\n    E previous();\n    int nextIndex();\n    int previousIndex();\n    void remove();\n    void set(E e);\n    void add(E e);\n}\n```\n\n\n\n```java\nprivate class ListItr extends Itr implements ListIterator<E> {\n    ListItr(int index) {\n        cursor = index;\n    }\n\n    public boolean hasPrevious() {\n        return cursor != 0;\n    }\n\n    public E previous() {\n        checkForComodification();\n        try {\n            int i = cursor - 1;//前一个元素索引\n            E previous = get(i);//获取前一个元素\n            lastRet = cursor = i;//设置lastRet = cursor等于前一个元素索引\n            return previous;\n        } catch (IndexOutOfBoundsException e) {\n            checkForComodification();\n            throw new NoSuchElementException();\n        }\n    }\n\n    public int nextIndex() {\n        return cursor;\n    }\n\n    public int previousIndex() {\n        return cursor-1;\n    }\n\n    public void set(E e) {\n        if (lastRet < 0)\n            throw new IllegalStateException();\n        checkForComodification();\n\n        try {\n            AbstractList.this.set(lastRet, e);\n            expectedModCount = modCount;\n        } catch (IndexOutOfBoundsException ex) {\n            throw new ConcurrentModificationException();\n        }\n    }\n\n    public void add(E e) {\n        checkForComodification();\n\n        try {\n            int i = cursor;\n            AbstractList.this.add(i, e);\n            lastRet = -1;\n            cursor = i + 1;\n            expectedModCount = modCount;\n        } catch (IndexOutOfBoundsException ex) {\n            throw new ConcurrentModificationException();\n        }\n    }\n}\n```\n\n\n\n### SubList\n\n\n\n### RandomAccessSubList\n\n\n\n\n\n\n\n## AbstractSequentialList\n\nAbstractSequentialList新加创建List迭代器的抽象方法listIterator。\n\n```java\npublic abstract ListIterator<E> listIterator(int index);\n```\n\n\n\n## AbstractSet\n\nAbstractSet没有新加任何抽象方法，由于继承了AbstractCollection，所以它的实现是基于iterator和size的。\n\n\n\n## AbstractMap\n\nAbstractMap中的抽象方法只有entrySet，可以推断其他方法均是基于该方法实现的。因为键值对的唯一性，所以使用Set存储每一个Entry，虽然Entry好像是数据类，但是本质是有行为的类。每一个Entry代表了一个键值对，我们只能修改value，获取kv，但是不能修改key，这是Entry接口带来的契约，也是设计Entry的点，如果key可以被更新，那么这个map行为将变得不可预期。\n\n```java\npublic abstract Set<Entry<K,V>> entrySet();\n```\n\n\n\n```java\n//我们注意到Entry对KV的抽象，\ninterface Entry<K, V> {\n    K getKey();\n    V getValue();\n    V setValue(V value);\n    boolean equals(Object o);\n    int hashCode();\n}\t\t\n```\n\n\n\nAbstractMap中提供了两个Map.Entry的实现，一个可变的SimpleEntry，一个不可变的SimpleImmutableEntry.SimpleEntry的实现非常简单，没有任何难以理解的地方，我们来看下：\n\n### SimpleEntry\n\n```java\npublic static class SimpleEntry<K,V> implements Entry<K,V>, java.io.Serializable{\n    \n    @SuppressWarnings(\"serial\") // Conditionally serializable\n    private final K key;\n    @SuppressWarnings(\"serial\") // Conditionally serializable\n    private V value;\n\n    public SimpleEntry(K key, V value) {\n        this.key   = key;\n        this.value = value;\n    }\n    public SimpleEntry(Entry<? extends K, ? extends V> entry) {\n        this.key   = entry.getKey();\n        this.value = entry.getValue();\n    }\n\n    public K getKey() { return key;}\n\n    public V getValue() {return value; }\n\n    public V setValue(V value) {\n        V oldValue = this.value;\n        this.value = value;\n        return oldValue;\n    }\n\n    public boolean equals(Object o) {\n        if (!(o instanceof Map.Entry))\n            return false;\n        Map.Entry<?,?> e = (Map.Entry<?,?>)o;\n        return eq(key, e.getKey()) && eq(value, e.getValue());\n    }\n\n    public int hashCode() {\n        return (key   == null ? 0 :   key.hashCode()) ^\n               (value == null ? 0 : value.hashCode());\n    }\n\n    public String toString() {\n        return key + \"=\" + value;\n    }\n}\n```\n\n\n\n### SimpleImmutableEntry\n\n和SimpleEntry不同的地方在于setValue方法抛出UnsupportedOperationException异常。\n\n```java\npublic V setValue(V value) {\n    throw new UnsupportedOperationException();\n}\n```\n\n\n\n### 查询方法实现\n\n```java\n//查询操作\npublic int size() {\n   return entrySet().size();//调用抽象方法实现，set().size()\n}\npublic boolean isEmpty() {\n   return size() == 0;\n}\n\n//时间复杂度O(N)\npublic boolean containsKey(Object key) {\n    //取出Set的迭代器进行key的查找，\n    Iterator<Map.Entry<K,V>> i = entrySet().iterator();\n    if (key==null) {\n        while (i.hasNext()) {\n            Entry<K,V> e = i.next();\n            if (e.getKey()==null)\n                return true;\n        }\n    } else {\n        while (i.hasNext()) {\n            Entry<K,V> e = i.next();\n            if (key.equals(e.getKey()))\n                return true;\n        }\n    }\n    return false;\n}\n\n\n//时间复杂度O(N)\npublic boolean containsValue(Object value) {\n    Iterator<Entry<K,V>> i = entrySet().iterator();\n    if (value==null) {\n        while (i.hasNext()) {\n            Entry<K,V> e = i.next();\n            if (e.getValue()==null)\n                return true;\n        }\n    } else {\n        while (i.hasNext()) {\n            Entry<K,V> e = i.next();\n            if (value.equals(e.getValue()))\n                return true;\n        }\n    }\n    return false;\n}\n\n\n//这里的get方法实现复杂度是O(N),因为需要遍历整个Entry Set迭代器，这只是\n//一种实现方法，如果客户端有更加高效的实现方式，则可以覆写该方法，如HashMap\n//的高品质实现，同时因为Map只是定义了接口，并不是实现，Abstract只是定义了\n//一种简单的实现，帮助客户端减少实现难度。\npublic V get(Object key) {\n    Iterator<Entry<K,V>> i = entrySet().iterator();\n    if (key==null) {\n        while (i.hasNext()) {\n            Entry<K,V> e = i.next();\n            if (e.getKey()==null)\n                return e.getValue();\n        }\n    } else {\n        while (i.hasNext()) {\n            Entry<K,V> e = i.next();\n            if (key.equals(e.getKey()))\n                return e.getValue();\n        }\n    }\n    return null;\n}\n\n```\n\n\n\n\n\n### 修改操作方法\n\n```java\n//put方法在这里没有实现，也没有办法实现，正如add方法在AbstractCollection/List/Set中无法实现一样\n//因为你不知道放入的数据结构，真正的数据结构定义是在实现类中，如HashMap，TreeMap这里面，\n//正是因为抽象类的实现没有引入成员变量，所以放入时候才不会指定特定的存储细节，这也是\n//集合框架获得灵活性的重要机制，如果在抽象类中引入了成员变量作为存储结构，那么子类的实现将会\n//被束缚在抽象类，此时抽象类将不再抽象，而是一种实现了。\npublic V put(K key, V value) {\n    throw new UnsupportedOperationException();\n}\n\npublic void putAll(Map<? extends K, ? extends V> m) {\n        for (Map.Entry<? extends K, ? extends V> e : m.entrySet())\n            put(e.getKey(), e.getValue());\n}\n\npublic void clear() {\n    //entrySet是抽象方法\n    entrySet().clear();\n}\n\n//删除一个key，其实遍历entrySet，找到key对应的Entry，然后调用迭代器remove方法\n//删除该元素\npublic V remove(Object key) {\n        Iterator<Entry<K,V>> i = entrySet().iterator();\n        Entry<K,V> correctEntry = null;\n        if (key==null) {\n            while (correctEntry==null && i.hasNext()) {\n                Entry<K,V> e = i.next();\n                if (e.getKey()==null)\n                    correctEntry = e;\n            }\n        } else {\n            while (correctEntry==null && i.hasNext()) {\n                Entry<K,V> e = i.next();\n                if (key.equals(e.getKey()))\n                    correctEntry = e;\n            }\n        }\n\n        V oldValue = null;\n        if (correctEntry !=null) {\n            oldValue = correctEntry.getValue();\n            i.remove();\n        }\n        return oldValue;\n    }\n\n```\n\n\n\n### 视图方法\n\n```java\ntransient Set<K>        keySet;\ntransient Collection<V> values;\n```\n\n\n\n```java\n//key的视图是set，因为key不能重复，每个Map只有一个视图，每个视图通过entrySet引用了\n//真正Map的元素，可以看出视图实现了AbstractSet.第一次调用时候，keySet视图为空，创建视图。\n//第二次调用时候，使用第一次的视图。\npublic Set<K> keySet() {\n    Set<K> ks = keySet;\n    if (ks == null) {\n        ks = new AbstractSet<K>() {\n            public Iterator<K> iterator() {\n                return new Iterator<K>() {\n                    private Iterator<Entry<K,V>> i = entrySet().iterator();\n\n                    public boolean hasNext() {\n                        return i.hasNext();\n                    }\n\t\t\t\t\t//next是key\n                    public K next() {\n                        return i.next().getKey();\n                    }\n\n                    public void remove() {\n                        i.remove();\n                    }\n                };\n            }\n\n            public int size() {\n                return AbstractMap.this.size();\n            }\n\n            public boolean isEmpty() {\n                return AbstractMap.this.isEmpty();\n            }\n\n            public void clear() {\n                AbstractMap.this.clear();\n            }\n\n            public boolean contains(Object k) {\n                return AbstractMap.this.containsKey(k);\n            }\n        };\n        keySet = ks;\n    }\n    return ks;\n}\n```\n\n\n\n\n\n```java\n//因为value可以有重复的，所以使用Collection存储\npublic Collection<V> values() {\n    Collection<V> vals = values;\n    if (vals == null) {\n        vals = new AbstractCollection<V>() {\n            public Iterator<V> iterator() {\n                return new Iterator<V>() {\n                    private Iterator<Entry<K,V>> i = entrySet().iterator();\n\n                    public boolean hasNext() {\n                        return i.hasNext();\n                    }\n\n                    public V next() {\n                        return i.next().getValue();\n                    }\n\n                    public void remove() {\n                        i.remove();\n                    }\n                };\n            }\n\n            public int size() {\n                return AbstractMap.this.size();\n            }\n\n            public boolean isEmpty() {\n                return AbstractMap.this.isEmpty();\n            }\n\n            public void clear() {\n                AbstractMap.this.clear();\n            }\n\n            public boolean contains(Object v) {\n                return AbstractMap.this.containsValue(v);\n            }\n        };\n        values = vals;\n    }\n    return vals;\n}\n```","source":"_posts/JCF-AbstractInterfaceImpl.md","raw":"---\ntitle: Java集合框架(2)-抽象实现骨架\ndate: 2020-11-09 02:34:19\ntags: \n  - java.util.*\n  - java collection framework\ncategories:\n  - JDK源码\n  - Java集合框架\n---\n\n# 概述\n\n**接口定义类型，抽象类实现骨架**。抽象类不支持的实现方法便是细节。这种技巧在JCF中是标配。一来替客户端提供如何实现一个接口的最直接的参考。二来帮助客户端以此实现功能更强的接口。如Guava的集合也是参考这种模式。\n\n\n\n# 抽象实现\n\n抽象类的最重要分析是留下了哪些抽象方法，而留下的抽象方法是真正实现类的差异，而抽象类中的普通方法使用抽象方法来实现，而抽象方法实现由实现类实现，并且抽象类没有任何字段，所以也能从侧面体现留下的抽象方法的价值。可以认为抽象实现是模板模式的一种应用。\n\n\n\n## AbstractCollection\n\n```java\n//这是AbstractCollection最核心的两个抽象方法，其余方法实现均是调用这两者\npublic abstract Iterator<E> iterator();\npublic abstract int size();\n```\n\n\n\n### isEmpty\n\n```java\n//非常简单，size()=0\npublic boolean isEmpty() {\n    return size() == 0;\n}\n```\n\n\n\n### contains\n\n```java\n//通过遍历迭代器来查找元素，元素为空，找出Collection中第一个为空的元素，元素不为空，\n//找出第一个在集合中的元素，对象需要实现equals方法\npublic boolean contains(Object o) {\n    Iterator<E> it = iterator();\n    if (o==null) {\n        while (it.hasNext())\n            if (it.next()==null)\n                return true;\n    } else {\n        while (it.hasNext())\n            if (o.equals(it.next()))  //对象equals方法很重要\n                return true;\n    }\n    return false;\n}\n```\n\n\n\n### add\n\n```java\n//抛出异常，因为子类可以实现可变或者不可变集合\npublic boolean add(E e) {\n    throw new UnsupportedOperationException();\n}\n```\n\n### remove\n\n```java\n//通过迭代器删除，equals方法很重要\npublic boolean remove(Object o) {\n    Iterator<E> it = iterator();\n    if (o==null) {\n        while (it.hasNext()) {\n            if (it.next()==null) {\n                it.remove();\n                return true;\n            }\n        }\n    } else {\n        while (it.hasNext()) {\n            if (o.equals(it.next())) {\n                it.remove();\n                return true;\n            }\n        }\n    }\n    return false;\n}\n```\n\n\n\n### containsAll\n\n```java\n//时间复杂度为O(n^2)\npublic boolean containsAll(Collection<?> c) {\n    for (Object e : c)\n        if (!contains(e))\n            return false;\n    return true;\n}\n```\n\n\n\n### addAll\n\n```java\n//modified来判断集合是否改变\npublic boolean addAll(Collection<? extends E> c) {\n    boolean modified = false;\n    for (E e : c)\n        if (add(e))\n            modified = true;\n    return modified;\n}\n```\n\n\n\n### removeAll\n\n```java\n//通过迭代器删除\npublic boolean removeAll(Collection<?> c) {\n    Objects.requireNonNull(c);\n    boolean modified = false;\n    Iterator<?> it = iterator();\n    while (it.hasNext()) {\n        if (c.contains(it.next())) {\n            it.remove();\n            modified = true;\n        }\n    }\n    return modified;\n}\n```\n\n\n\n### clear\n\n```java\n//遍历迭代器，删除元素\npublic void clear() {\n    Iterator<E> it = iterator();\n    while (it.hasNext()) {\n        it.next();\n        it.remove();\n    }\n}\n```\n\n\n\n我们可以看到抽象方法在实现普通方法时候是基本每个方法都会调用。\n\n\n\n## AbstractList\n\n```java\n//AbstractList抽象方法有两个，1是新定义的get 2是继承父类的size，而父类AbstractCollection中的抽象方法只实现了一个iterator()，因为对于List来说，iterator行为是确认的。但是get行为需要子类实现。\npublic abstract E get(int index);\n```\n\n\n\n在AbstractList实现中，定义了Itr, ListItr两个迭代器，以及用于实现内部视图的SubList和RandomAccessSubList.\n\n\n\n### iterator\n\n```java\npublic Iterator<E> iterator() {\n    return new Itr();\n}\n```\n\n### Itr\n\n```java\nprivate class Itr implements Iterator<E> {\n    /** 游标位置，指向当前元素**/\n    int cursor = 0;\n    /**调用next后之前的元素，-1说明刚被删除了*/\n    int lastRet = -1;\n    /**\n     *期望修复次数是不是等于实际修改次数，用户判断遍历时候是否被修改，如果不同则会抛出ConcurrentModificationException\n     * 因为这些集合不是在线程安全的，所以并发修改会报错。\n     */\n    int expectedModCount = modCount;\n\n    public boolean hasNext() {\n        return cursor != size();\n    }\n    public E next() {\n        checkForComodification();//检查是否被修改\n        try {\n            int i = cursor; //当前位置的cursor存储起来\n            E next = get(i);//抽象方法get获取元素\n            lastRet = i;//更新上一个元素位置\n            cursor = i + 1;//cursor下移一位\n            return next;//返回当前元素\n        } catch (IndexOutOfBoundsException e) {\n            checkForComodification();\n            throw new NoSuchElementException();\n        }\n    }\n\t//删除某个元素\n    public void remove() {\n        if (lastRet < 0)\n            throw new IllegalStateException();\n        checkForComodification();\n        try {\n            AbstractList.this.remove(lastRet);//调用删除方法\n            if (lastRet < cursor) //\n                cursor--;\n            lastRet = -1;//lastRet设置为-1\n            expectedModCount = modCount;//修改次数等于期望修改次数\n        } catch (IndexOutOfBoundsException e) {\n            throw new ConcurrentModificationException();\n        }\n    }\n\n    final void checkForComodification() {\n        if (modCount != expectedModCount)\n            throw new ConcurrentModificationException();\n    }\n}\n```\n\n### ListItr\n\nListItr实现了ListIterator接口，ListIterator和Iterator不同之处在于Iterator只支持向后遍历，但是ListIterator同时支持向后和向前遍历。也支持任意位置开始的遍历。\n\n```java\npublic interface ListIterator<E> extends Iterator<E> {\n\tboolean hasNext();\n    E next();\n    boolean hasPrevious();\n    E previous();\n    int nextIndex();\n    int previousIndex();\n    void remove();\n    void set(E e);\n    void add(E e);\n}\n```\n\n\n\n```java\nprivate class ListItr extends Itr implements ListIterator<E> {\n    ListItr(int index) {\n        cursor = index;\n    }\n\n    public boolean hasPrevious() {\n        return cursor != 0;\n    }\n\n    public E previous() {\n        checkForComodification();\n        try {\n            int i = cursor - 1;//前一个元素索引\n            E previous = get(i);//获取前一个元素\n            lastRet = cursor = i;//设置lastRet = cursor等于前一个元素索引\n            return previous;\n        } catch (IndexOutOfBoundsException e) {\n            checkForComodification();\n            throw new NoSuchElementException();\n        }\n    }\n\n    public int nextIndex() {\n        return cursor;\n    }\n\n    public int previousIndex() {\n        return cursor-1;\n    }\n\n    public void set(E e) {\n        if (lastRet < 0)\n            throw new IllegalStateException();\n        checkForComodification();\n\n        try {\n            AbstractList.this.set(lastRet, e);\n            expectedModCount = modCount;\n        } catch (IndexOutOfBoundsException ex) {\n            throw new ConcurrentModificationException();\n        }\n    }\n\n    public void add(E e) {\n        checkForComodification();\n\n        try {\n            int i = cursor;\n            AbstractList.this.add(i, e);\n            lastRet = -1;\n            cursor = i + 1;\n            expectedModCount = modCount;\n        } catch (IndexOutOfBoundsException ex) {\n            throw new ConcurrentModificationException();\n        }\n    }\n}\n```\n\n\n\n### SubList\n\n\n\n### RandomAccessSubList\n\n\n\n\n\n\n\n## AbstractSequentialList\n\nAbstractSequentialList新加创建List迭代器的抽象方法listIterator。\n\n```java\npublic abstract ListIterator<E> listIterator(int index);\n```\n\n\n\n## AbstractSet\n\nAbstractSet没有新加任何抽象方法，由于继承了AbstractCollection，所以它的实现是基于iterator和size的。\n\n\n\n## AbstractMap\n\nAbstractMap中的抽象方法只有entrySet，可以推断其他方法均是基于该方法实现的。因为键值对的唯一性，所以使用Set存储每一个Entry，虽然Entry好像是数据类，但是本质是有行为的类。每一个Entry代表了一个键值对，我们只能修改value，获取kv，但是不能修改key，这是Entry接口带来的契约，也是设计Entry的点，如果key可以被更新，那么这个map行为将变得不可预期。\n\n```java\npublic abstract Set<Entry<K,V>> entrySet();\n```\n\n\n\n```java\n//我们注意到Entry对KV的抽象，\ninterface Entry<K, V> {\n    K getKey();\n    V getValue();\n    V setValue(V value);\n    boolean equals(Object o);\n    int hashCode();\n}\t\t\n```\n\n\n\nAbstractMap中提供了两个Map.Entry的实现，一个可变的SimpleEntry，一个不可变的SimpleImmutableEntry.SimpleEntry的实现非常简单，没有任何难以理解的地方，我们来看下：\n\n### SimpleEntry\n\n```java\npublic static class SimpleEntry<K,V> implements Entry<K,V>, java.io.Serializable{\n    \n    @SuppressWarnings(\"serial\") // Conditionally serializable\n    private final K key;\n    @SuppressWarnings(\"serial\") // Conditionally serializable\n    private V value;\n\n    public SimpleEntry(K key, V value) {\n        this.key   = key;\n        this.value = value;\n    }\n    public SimpleEntry(Entry<? extends K, ? extends V> entry) {\n        this.key   = entry.getKey();\n        this.value = entry.getValue();\n    }\n\n    public K getKey() { return key;}\n\n    public V getValue() {return value; }\n\n    public V setValue(V value) {\n        V oldValue = this.value;\n        this.value = value;\n        return oldValue;\n    }\n\n    public boolean equals(Object o) {\n        if (!(o instanceof Map.Entry))\n            return false;\n        Map.Entry<?,?> e = (Map.Entry<?,?>)o;\n        return eq(key, e.getKey()) && eq(value, e.getValue());\n    }\n\n    public int hashCode() {\n        return (key   == null ? 0 :   key.hashCode()) ^\n               (value == null ? 0 : value.hashCode());\n    }\n\n    public String toString() {\n        return key + \"=\" + value;\n    }\n}\n```\n\n\n\n### SimpleImmutableEntry\n\n和SimpleEntry不同的地方在于setValue方法抛出UnsupportedOperationException异常。\n\n```java\npublic V setValue(V value) {\n    throw new UnsupportedOperationException();\n}\n```\n\n\n\n### 查询方法实现\n\n```java\n//查询操作\npublic int size() {\n   return entrySet().size();//调用抽象方法实现，set().size()\n}\npublic boolean isEmpty() {\n   return size() == 0;\n}\n\n//时间复杂度O(N)\npublic boolean containsKey(Object key) {\n    //取出Set的迭代器进行key的查找，\n    Iterator<Map.Entry<K,V>> i = entrySet().iterator();\n    if (key==null) {\n        while (i.hasNext()) {\n            Entry<K,V> e = i.next();\n            if (e.getKey()==null)\n                return true;\n        }\n    } else {\n        while (i.hasNext()) {\n            Entry<K,V> e = i.next();\n            if (key.equals(e.getKey()))\n                return true;\n        }\n    }\n    return false;\n}\n\n\n//时间复杂度O(N)\npublic boolean containsValue(Object value) {\n    Iterator<Entry<K,V>> i = entrySet().iterator();\n    if (value==null) {\n        while (i.hasNext()) {\n            Entry<K,V> e = i.next();\n            if (e.getValue()==null)\n                return true;\n        }\n    } else {\n        while (i.hasNext()) {\n            Entry<K,V> e = i.next();\n            if (value.equals(e.getValue()))\n                return true;\n        }\n    }\n    return false;\n}\n\n\n//这里的get方法实现复杂度是O(N),因为需要遍历整个Entry Set迭代器，这只是\n//一种实现方法，如果客户端有更加高效的实现方式，则可以覆写该方法，如HashMap\n//的高品质实现，同时因为Map只是定义了接口，并不是实现，Abstract只是定义了\n//一种简单的实现，帮助客户端减少实现难度。\npublic V get(Object key) {\n    Iterator<Entry<K,V>> i = entrySet().iterator();\n    if (key==null) {\n        while (i.hasNext()) {\n            Entry<K,V> e = i.next();\n            if (e.getKey()==null)\n                return e.getValue();\n        }\n    } else {\n        while (i.hasNext()) {\n            Entry<K,V> e = i.next();\n            if (key.equals(e.getKey()))\n                return e.getValue();\n        }\n    }\n    return null;\n}\n\n```\n\n\n\n\n\n### 修改操作方法\n\n```java\n//put方法在这里没有实现，也没有办法实现，正如add方法在AbstractCollection/List/Set中无法实现一样\n//因为你不知道放入的数据结构，真正的数据结构定义是在实现类中，如HashMap，TreeMap这里面，\n//正是因为抽象类的实现没有引入成员变量，所以放入时候才不会指定特定的存储细节，这也是\n//集合框架获得灵活性的重要机制，如果在抽象类中引入了成员变量作为存储结构，那么子类的实现将会\n//被束缚在抽象类，此时抽象类将不再抽象，而是一种实现了。\npublic V put(K key, V value) {\n    throw new UnsupportedOperationException();\n}\n\npublic void putAll(Map<? extends K, ? extends V> m) {\n        for (Map.Entry<? extends K, ? extends V> e : m.entrySet())\n            put(e.getKey(), e.getValue());\n}\n\npublic void clear() {\n    //entrySet是抽象方法\n    entrySet().clear();\n}\n\n//删除一个key，其实遍历entrySet，找到key对应的Entry，然后调用迭代器remove方法\n//删除该元素\npublic V remove(Object key) {\n        Iterator<Entry<K,V>> i = entrySet().iterator();\n        Entry<K,V> correctEntry = null;\n        if (key==null) {\n            while (correctEntry==null && i.hasNext()) {\n                Entry<K,V> e = i.next();\n                if (e.getKey()==null)\n                    correctEntry = e;\n            }\n        } else {\n            while (correctEntry==null && i.hasNext()) {\n                Entry<K,V> e = i.next();\n                if (key.equals(e.getKey()))\n                    correctEntry = e;\n            }\n        }\n\n        V oldValue = null;\n        if (correctEntry !=null) {\n            oldValue = correctEntry.getValue();\n            i.remove();\n        }\n        return oldValue;\n    }\n\n```\n\n\n\n### 视图方法\n\n```java\ntransient Set<K>        keySet;\ntransient Collection<V> values;\n```\n\n\n\n```java\n//key的视图是set，因为key不能重复，每个Map只有一个视图，每个视图通过entrySet引用了\n//真正Map的元素，可以看出视图实现了AbstractSet.第一次调用时候，keySet视图为空，创建视图。\n//第二次调用时候，使用第一次的视图。\npublic Set<K> keySet() {\n    Set<K> ks = keySet;\n    if (ks == null) {\n        ks = new AbstractSet<K>() {\n            public Iterator<K> iterator() {\n                return new Iterator<K>() {\n                    private Iterator<Entry<K,V>> i = entrySet().iterator();\n\n                    public boolean hasNext() {\n                        return i.hasNext();\n                    }\n\t\t\t\t\t//next是key\n                    public K next() {\n                        return i.next().getKey();\n                    }\n\n                    public void remove() {\n                        i.remove();\n                    }\n                };\n            }\n\n            public int size() {\n                return AbstractMap.this.size();\n            }\n\n            public boolean isEmpty() {\n                return AbstractMap.this.isEmpty();\n            }\n\n            public void clear() {\n                AbstractMap.this.clear();\n            }\n\n            public boolean contains(Object k) {\n                return AbstractMap.this.containsKey(k);\n            }\n        };\n        keySet = ks;\n    }\n    return ks;\n}\n```\n\n\n\n\n\n```java\n//因为value可以有重复的，所以使用Collection存储\npublic Collection<V> values() {\n    Collection<V> vals = values;\n    if (vals == null) {\n        vals = new AbstractCollection<V>() {\n            public Iterator<V> iterator() {\n                return new Iterator<V>() {\n                    private Iterator<Entry<K,V>> i = entrySet().iterator();\n\n                    public boolean hasNext() {\n                        return i.hasNext();\n                    }\n\n                    public V next() {\n                        return i.next().getValue();\n                    }\n\n                    public void remove() {\n                        i.remove();\n                    }\n                };\n            }\n\n            public int size() {\n                return AbstractMap.this.size();\n            }\n\n            public boolean isEmpty() {\n                return AbstractMap.this.isEmpty();\n            }\n\n            public void clear() {\n                AbstractMap.this.clear();\n            }\n\n            public boolean contains(Object v) {\n                return AbstractMap.this.containsValue(v);\n            }\n        };\n        values = vals;\n    }\n    return vals;\n}\n```","slug":"JCF-AbstractInterfaceImpl","published":1,"updated":"2022-06-28T17:21:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clh7s5ctn000hxt8jbeqzg5dn","content":"<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><p><strong>接口定义类型，抽象类实现骨架</strong>。抽象类不支持的实现方法便是细节。这种技巧在JCF中是标配。一来替客户端提供如何实现一个接口的最直接的参考。二来帮助客户端以此实现功能更强的接口。如Guava的集合也是参考这种模式。</p>\n<h1 id=\"抽象实现\"><a href=\"#抽象实现\" class=\"headerlink\" title=\"抽象实现\"></a>抽象实现</h1><p>抽象类的最重要分析是留下了哪些抽象方法，而留下的抽象方法是真正实现类的差异，而抽象类中的普通方法使用抽象方法来实现，而抽象方法实现由实现类实现，并且抽象类没有任何字段，所以也能从侧面体现留下的抽象方法的价值。可以认为抽象实现是模板模式的一种应用。</p>\n<h2 id=\"AbstractCollection\"><a href=\"#AbstractCollection\" class=\"headerlink\" title=\"AbstractCollection\"></a>AbstractCollection</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//这是AbstractCollection最核心的两个抽象方法，其余方法实现均是调用这两者</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> Iterator&lt;E&gt; <span class=\"title\">iterator</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">int</span> <span class=\"title\">size</span><span class=\"params\">()</span></span>;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"isEmpty\"><a href=\"#isEmpty\" class=\"headerlink\" title=\"isEmpty\"></a>isEmpty</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//非常简单，size()=0</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isEmpty</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> size() == <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"contains\"><a href=\"#contains\" class=\"headerlink\" title=\"contains\"></a>contains</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//通过遍历迭代器来查找元素，元素为空，找出Collection中第一个为空的元素，元素不为空，</span></span><br><span class=\"line\"><span class=\"comment\">//找出第一个在集合中的元素，对象需要实现equals方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">contains</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">    Iterator&lt;E&gt; it = iterator();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (o==<span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (it.hasNext())</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (it.next()==<span class=\"keyword\">null</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (it.hasNext())</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (o.equals(it.next()))  <span class=\"comment\">//对象equals方法很重要</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"add\"><a href=\"#add\" class=\"headerlink\" title=\"add\"></a>add</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//抛出异常，因为子类可以实现可变或者不可变集合</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> UnsupportedOperationException();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"remove\"><a href=\"#remove\" class=\"headerlink\" title=\"remove\"></a>remove</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//通过迭代器删除，equals方法很重要</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">remove</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">    Iterator&lt;E&gt; it = iterator();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (o==<span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (it.hasNext()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (it.next()==<span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                it.remove();</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (it.hasNext()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (o.equals(it.next())) &#123;</span><br><span class=\"line\">                it.remove();</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"containsAll\"><a href=\"#containsAll\" class=\"headerlink\" title=\"containsAll\"></a>containsAll</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//时间复杂度为O(n^2)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">containsAll</span><span class=\"params\">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Object e : c)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!contains(e))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"addAll\"><a href=\"#addAll\" class=\"headerlink\" title=\"addAll\"></a>addAll</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//modified来判断集合是否改变</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">addAll</span><span class=\"params\">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> modified = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (E e : c)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (add(e))</span><br><span class=\"line\">            modified = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> modified;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"removeAll\"><a href=\"#removeAll\" class=\"headerlink\" title=\"removeAll\"></a>removeAll</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//通过迭代器删除</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">removeAll</span><span class=\"params\">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class=\"line\">    Objects.requireNonNull(c);</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> modified = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    Iterator&lt;?&gt; it = iterator();</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (it.hasNext()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (c.contains(it.next())) &#123;</span><br><span class=\"line\">            it.remove();</span><br><span class=\"line\">            modified = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> modified;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"clear\"><a href=\"#clear\" class=\"headerlink\" title=\"clear\"></a>clear</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//遍历迭代器，删除元素</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">clear</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Iterator&lt;E&gt; it = iterator();</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (it.hasNext()) &#123;</span><br><span class=\"line\">        it.next();</span><br><span class=\"line\">        it.remove();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>我们可以看到抽象方法在实现普通方法时候是基本每个方法都会调用。</p>\n<h2 id=\"AbstractList\"><a href=\"#AbstractList\" class=\"headerlink\" title=\"AbstractList\"></a>AbstractList</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//AbstractList抽象方法有两个，1是新定义的get 2是继承父类的size，而父类AbstractCollection中的抽象方法只实现了一个iterator()，因为对于List来说，iterator行为是确认的。但是get行为需要子类实现。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> E <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span></span>;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>在AbstractList实现中，定义了Itr, ListItr两个迭代器，以及用于实现内部视图的SubList和RandomAccessSubList.</p>\n<h3 id=\"iterator\"><a href=\"#iterator\" class=\"headerlink\" title=\"iterator\"></a>iterator</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Iterator&lt;E&gt; <span class=\"title\">iterator</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Itr();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Itr\"><a href=\"#Itr\" class=\"headerlink\" title=\"Itr\"></a>Itr</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Itr</span> <span class=\"keyword\">implements</span> <span class=\"title\">Iterator</span>&lt;<span class=\"title\">E</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/** 游标位置，指向当前元素**/</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> cursor = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">/**调用next后之前的元素，-1说明刚被删除了*/</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> lastRet = -<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *期望修复次数是不是等于实际修改次数，用户判断遍历时候是否被修改，如果不同则会抛出ConcurrentModificationException</span></span><br><span class=\"line\"><span class=\"comment\">     * 因为这些集合不是在线程安全的，所以并发修改会报错。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> expectedModCount = modCount;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hasNext</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cursor != size();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        checkForComodification();<span class=\"comment\">//检查是否被修改</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> i = cursor; <span class=\"comment\">//当前位置的cursor存储起来</span></span><br><span class=\"line\">            E next = get(i);<span class=\"comment\">//抽象方法get获取元素</span></span><br><span class=\"line\">            lastRet = i;<span class=\"comment\">//更新上一个元素位置</span></span><br><span class=\"line\">            cursor = i + <span class=\"number\">1</span>;<span class=\"comment\">//cursor下移一位</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> next;<span class=\"comment\">//返回当前元素</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IndexOutOfBoundsException e) &#123;</span><br><span class=\"line\">            checkForComodification();</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NoSuchElementException();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"comment\">//删除某个元素</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">remove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (lastRet &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException();</span><br><span class=\"line\">        checkForComodification();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            AbstractList.<span class=\"keyword\">this</span>.remove(lastRet);<span class=\"comment\">//调用删除方法</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (lastRet &lt; cursor) <span class=\"comment\">//</span></span><br><span class=\"line\">                cursor--;</span><br><span class=\"line\">            lastRet = -<span class=\"number\">1</span>;<span class=\"comment\">//lastRet设置为-1</span></span><br><span class=\"line\">            expectedModCount = modCount;<span class=\"comment\">//修改次数等于期望修改次数</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IndexOutOfBoundsException e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ConcurrentModificationException();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">checkForComodification</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (modCount != expectedModCount)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ConcurrentModificationException();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"ListItr\"><a href=\"#ListItr\" class=\"headerlink\" title=\"ListItr\"></a>ListItr</h3><p>ListItr实现了ListIterator接口，ListIterator和Iterator不同之处在于Iterator只支持向后遍历，但是ListIterator同时支持向后和向前遍历。也支持任意位置开始的遍历。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ListIterator</span>&lt;<span class=\"title\">E</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">Iterator</span>&lt;<span class=\"title\">E</span>&gt; </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">hasNext</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\">E <span class=\"title\">next</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">hasPrevious</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\">E <span class=\"title\">previous</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">nextIndex</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">previousIndex</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">remove</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">set</span><span class=\"params\">(E e)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(E e)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ListItr</span> <span class=\"keyword\">extends</span> <span class=\"title\">Itr</span> <span class=\"keyword\">implements</span> <span class=\"title\">ListIterator</span>&lt;<span class=\"title\">E</span>&gt; </span>&#123;</span><br><span class=\"line\">    ListItr(<span class=\"keyword\">int</span> index) &#123;</span><br><span class=\"line\">        cursor = index;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hasPrevious</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cursor != <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">previous</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        checkForComodification();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> i = cursor - <span class=\"number\">1</span>;<span class=\"comment\">//前一个元素索引</span></span><br><span class=\"line\">            E previous = get(i);<span class=\"comment\">//获取前一个元素</span></span><br><span class=\"line\">            lastRet = cursor = i;<span class=\"comment\">//设置lastRet = cursor等于前一个元素索引</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> previous;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IndexOutOfBoundsException e) &#123;</span><br><span class=\"line\">            checkForComodification();</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NoSuchElementException();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">nextIndex</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cursor;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">previousIndex</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cursor-<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">set</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (lastRet &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException();</span><br><span class=\"line\">        checkForComodification();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            AbstractList.<span class=\"keyword\">this</span>.set(lastRet, e);</span><br><span class=\"line\">            expectedModCount = modCount;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ConcurrentModificationException();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">        checkForComodification();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> i = cursor;</span><br><span class=\"line\">            AbstractList.<span class=\"keyword\">this</span>.add(i, e);</span><br><span class=\"line\">            lastRet = -<span class=\"number\">1</span>;</span><br><span class=\"line\">            cursor = i + <span class=\"number\">1</span>;</span><br><span class=\"line\">            expectedModCount = modCount;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ConcurrentModificationException();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"SubList\"><a href=\"#SubList\" class=\"headerlink\" title=\"SubList\"></a>SubList</h3><h3 id=\"RandomAccessSubList\"><a href=\"#RandomAccessSubList\" class=\"headerlink\" title=\"RandomAccessSubList\"></a>RandomAccessSubList</h3><h2 id=\"AbstractSequentialList\"><a href=\"#AbstractSequentialList\" class=\"headerlink\" title=\"AbstractSequentialList\"></a>AbstractSequentialList</h2><p>AbstractSequentialList新加创建List迭代器的抽象方法listIterator。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> ListIterator&lt;E&gt; <span class=\"title\">listIterator</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span></span>;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"AbstractSet\"><a href=\"#AbstractSet\" class=\"headerlink\" title=\"AbstractSet\"></a>AbstractSet</h2><p>AbstractSet没有新加任何抽象方法，由于继承了AbstractCollection，所以它的实现是基于iterator和size的。</p>\n<h2 id=\"AbstractMap\"><a href=\"#AbstractMap\" class=\"headerlink\" title=\"AbstractMap\"></a>AbstractMap</h2><p>AbstractMap中的抽象方法只有entrySet，可以推断其他方法均是基于该方法实现的。因为键值对的唯一性，所以使用Set存储每一个Entry，虽然Entry好像是数据类，但是本质是有行为的类。每一个Entry代表了一个键值对，我们只能修改value，获取kv，但是不能修改key，这是Entry接口带来的契约，也是设计Entry的点，如果key可以被更新，那么这个map行为将变得不可预期。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> Set&lt;Entry&lt;K,V&gt;&gt; entrySet();</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//我们注意到Entry对KV的抽象，</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Entry</span>&lt;<span class=\"title\">K</span>, <span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">K <span class=\"title\">getKey</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\">V <span class=\"title\">getValue</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\">V <span class=\"title\">setValue</span><span class=\"params\">(V value)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object o)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>AbstractMap中提供了两个Map.Entry的实现，一个可变的SimpleEntry，一个不可变的SimpleImmutableEntry.SimpleEntry的实现非常简单，没有任何难以理解的地方，我们来看下：</p>\n<h3 id=\"SimpleEntry\"><a href=\"#SimpleEntry\" class=\"headerlink\" title=\"SimpleEntry\"></a>SimpleEntry</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SimpleEntry</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Entry</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt;, <span class=\"title\">java</span>.<span class=\"title\">io</span>.<span class=\"title\">Serializable</span></span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"serial\"</span>) <span class=\"comment\">// Conditionally serializable</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> K key;</span><br><span class=\"line\">    <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"serial\"</span>) <span class=\"comment\">// Conditionally serializable</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> V value;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SimpleEntry</span><span class=\"params\">(K key, V value)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.key   = key;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.value = value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SimpleEntry</span><span class=\"params\">(Entry&lt;? extends K, ? extends V&gt; entry)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.key   = entry.getKey();</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.value = entry.getValue();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> K <span class=\"title\">getKey</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> key;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">getValue</span><span class=\"params\">()</span> </span>&#123;<span class=\"keyword\">return</span> value; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">setValue</span><span class=\"params\">(V value)</span> </span>&#123;</span><br><span class=\"line\">        V oldValue = <span class=\"keyword\">this</span>.value;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.value = value;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!(o <span class=\"keyword\">instanceof</span> Map.Entry))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> eq(key, e.getKey()) &amp;&amp; eq(value, e.getValue());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (key   == <span class=\"keyword\">null</span> ? <span class=\"number\">0</span> :   key.hashCode()) ^</span><br><span class=\"line\">               (value == <span class=\"keyword\">null</span> ? <span class=\"number\">0</span> : value.hashCode());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> key + <span class=\"string\">\"=\"</span> + value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"SimpleImmutableEntry\"><a href=\"#SimpleImmutableEntry\" class=\"headerlink\" title=\"SimpleImmutableEntry\"></a>SimpleImmutableEntry</h3><p>和SimpleEntry不同的地方在于setValue方法抛出UnsupportedOperationException异常。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">setValue</span><span class=\"params\">(V value)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> UnsupportedOperationException();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"查询方法实现\"><a href=\"#查询方法实现\" class=\"headerlink\" title=\"查询方法实现\"></a>查询方法实现</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//查询操作</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">size</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> entrySet().size();<span class=\"comment\">//调用抽象方法实现，set().size()</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isEmpty</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> size() == <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//时间复杂度O(N)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">containsKey</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//取出Set的迭代器进行key的查找，</span></span><br><span class=\"line\">    Iterator&lt;Map.Entry&lt;K,V&gt;&gt; i = entrySet().iterator();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (key==<span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i.hasNext()) &#123;</span><br><span class=\"line\">            Entry&lt;K,V&gt; e = i.next();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (e.getKey()==<span class=\"keyword\">null</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i.hasNext()) &#123;</span><br><span class=\"line\">            Entry&lt;K,V&gt; e = i.next();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (key.equals(e.getKey()))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//时间复杂度O(N)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">containsValue</span><span class=\"params\">(Object value)</span> </span>&#123;</span><br><span class=\"line\">    Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (value==<span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i.hasNext()) &#123;</span><br><span class=\"line\">            Entry&lt;K,V&gt; e = i.next();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (e.getValue()==<span class=\"keyword\">null</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i.hasNext()) &#123;</span><br><span class=\"line\">            Entry&lt;K,V&gt; e = i.next();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (value.equals(e.getValue()))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//这里的get方法实现复杂度是O(N),因为需要遍历整个Entry Set迭代器，这只是</span></span><br><span class=\"line\"><span class=\"comment\">//一种实现方法，如果客户端有更加高效的实现方式，则可以覆写该方法，如HashMap</span></span><br><span class=\"line\"><span class=\"comment\">//的高品质实现，同时因为Map只是定义了接口，并不是实现，Abstract只是定义了</span></span><br><span class=\"line\"><span class=\"comment\">//一种简单的实现，帮助客户端减少实现难度。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">get</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (key==<span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i.hasNext()) &#123;</span><br><span class=\"line\">            Entry&lt;K,V&gt; e = i.next();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (e.getKey()==<span class=\"keyword\">null</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> e.getValue();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i.hasNext()) &#123;</span><br><span class=\"line\">            Entry&lt;K,V&gt; e = i.next();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (key.equals(e.getKey()))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> e.getValue();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h3 id=\"修改操作方法\"><a href=\"#修改操作方法\" class=\"headerlink\" title=\"修改操作方法\"></a>修改操作方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//put方法在这里没有实现，也没有办法实现，正如add方法在AbstractCollection/List/Set中无法实现一样</span></span><br><span class=\"line\"><span class=\"comment\">//因为你不知道放入的数据结构，真正的数据结构定义是在实现类中，如HashMap，TreeMap这里面，</span></span><br><span class=\"line\"><span class=\"comment\">//正是因为抽象类的实现没有引入成员变量，所以放入时候才不会指定特定的存储细节，这也是</span></span><br><span class=\"line\"><span class=\"comment\">//集合框架获得灵活性的重要机制，如果在抽象类中引入了成员变量作为存储结构，那么子类的实现将会</span></span><br><span class=\"line\"><span class=\"comment\">//被束缚在抽象类，此时抽象类将不再抽象，而是一种实现了。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> UnsupportedOperationException();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">putAll</span><span class=\"params\">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet())</span><br><span class=\"line\">            put(e.getKey(), e.getValue());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">clear</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//entrySet是抽象方法</span></span><br><span class=\"line\">    entrySet().clear();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//删除一个key，其实遍历entrySet，找到key对应的Entry，然后调用迭代器remove方法</span></span><br><span class=\"line\"><span class=\"comment\">//删除该元素</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">remove</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">        Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator();</span><br><span class=\"line\">        Entry&lt;K,V&gt; correctEntry = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (key==<span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (correctEntry==<span class=\"keyword\">null</span> &amp;&amp; i.hasNext()) &#123;</span><br><span class=\"line\">                Entry&lt;K,V&gt; e = i.next();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (e.getKey()==<span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    correctEntry = e;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (correctEntry==<span class=\"keyword\">null</span> &amp;&amp; i.hasNext()) &#123;</span><br><span class=\"line\">                Entry&lt;K,V&gt; e = i.next();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (key.equals(e.getKey()))</span><br><span class=\"line\">                    correctEntry = e;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        V oldValue = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (correctEntry !=<span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            oldValue = correctEntry.getValue();</span><br><span class=\"line\">            i.remove();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"视图方法\"><a href=\"#视图方法\" class=\"headerlink\" title=\"视图方法\"></a>视图方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">transient</span> Set&lt;K&gt;        keySet;</span><br><span class=\"line\"><span class=\"keyword\">transient</span> Collection&lt;V&gt; values;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//key的视图是set，因为key不能重复，每个Map只有一个视图，每个视图通过entrySet引用了</span></span><br><span class=\"line\"><span class=\"comment\">//真正Map的元素，可以看出视图实现了AbstractSet.第一次调用时候，keySet视图为空，创建视图。</span></span><br><span class=\"line\"><span class=\"comment\">//第二次调用时候，使用第一次的视图。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Set&lt;K&gt; <span class=\"title\">keySet</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Set&lt;K&gt; ks = keySet;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ks == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        ks = <span class=\"keyword\">new</span> AbstractSet&lt;K&gt;() &#123;</span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> Iterator&lt;K&gt; <span class=\"title\">iterator</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Iterator&lt;K&gt;() &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">private</span> Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator();</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hasNext</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> i.hasNext();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">//next是key</span></span><br><span class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> K <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> i.next().getKey();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">remove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                        i.remove();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">size</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> AbstractMap.<span class=\"keyword\">this</span>.size();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isEmpty</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> AbstractMap.<span class=\"keyword\">this</span>.isEmpty();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">clear</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                AbstractMap.<span class=\"keyword\">this</span>.clear();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">contains</span><span class=\"params\">(Object k)</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> AbstractMap.<span class=\"keyword\">this</span>.containsKey(k);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        keySet = ks;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ks;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//因为value可以有重复的，所以使用Collection存储</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Collection&lt;V&gt; <span class=\"title\">values</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Collection&lt;V&gt; vals = values;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (vals == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        vals = <span class=\"keyword\">new</span> AbstractCollection&lt;V&gt;() &#123;</span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> Iterator&lt;V&gt; <span class=\"title\">iterator</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Iterator&lt;V&gt;() &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">private</span> Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator();</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hasNext</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> i.hasNext();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> i.next().getValue();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">remove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                        i.remove();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">size</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> AbstractMap.<span class=\"keyword\">this</span>.size();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isEmpty</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> AbstractMap.<span class=\"keyword\">this</span>.isEmpty();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">clear</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                AbstractMap.<span class=\"keyword\">this</span>.clear();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">contains</span><span class=\"params\">(Object v)</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> AbstractMap.<span class=\"keyword\">this</span>.containsValue(v);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        values = vals;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> vals;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><p><strong>接口定义类型，抽象类实现骨架</strong>。抽象类不支持的实现方法便是细节。这种技巧在JCF中是标配。一来替客户端提供如何实现一个接口的最直接的参考。二来帮助客户端以此实现功能更强的接口。如Guava的集合也是参考这种模式。</p>\n<h1 id=\"抽象实现\"><a href=\"#抽象实现\" class=\"headerlink\" title=\"抽象实现\"></a>抽象实现</h1><p>抽象类的最重要分析是留下了哪些抽象方法，而留下的抽象方法是真正实现类的差异，而抽象类中的普通方法使用抽象方法来实现，而抽象方法实现由实现类实现，并且抽象类没有任何字段，所以也能从侧面体现留下的抽象方法的价值。可以认为抽象实现是模板模式的一种应用。</p>\n<h2 id=\"AbstractCollection\"><a href=\"#AbstractCollection\" class=\"headerlink\" title=\"AbstractCollection\"></a>AbstractCollection</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//这是AbstractCollection最核心的两个抽象方法，其余方法实现均是调用这两者</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> Iterator&lt;E&gt; <span class=\"title\">iterator</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">int</span> <span class=\"title\">size</span><span class=\"params\">()</span></span>;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"isEmpty\"><a href=\"#isEmpty\" class=\"headerlink\" title=\"isEmpty\"></a>isEmpty</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//非常简单，size()=0</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isEmpty</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> size() == <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"contains\"><a href=\"#contains\" class=\"headerlink\" title=\"contains\"></a>contains</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//通过遍历迭代器来查找元素，元素为空，找出Collection中第一个为空的元素，元素不为空，</span></span><br><span class=\"line\"><span class=\"comment\">//找出第一个在集合中的元素，对象需要实现equals方法</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">contains</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">    Iterator&lt;E&gt; it = iterator();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (o==<span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (it.hasNext())</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (it.next()==<span class=\"keyword\">null</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (it.hasNext())</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (o.equals(it.next()))  <span class=\"comment\">//对象equals方法很重要</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"add\"><a href=\"#add\" class=\"headerlink\" title=\"add\"></a>add</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//抛出异常，因为子类可以实现可变或者不可变集合</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">add</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> UnsupportedOperationException();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"remove\"><a href=\"#remove\" class=\"headerlink\" title=\"remove\"></a>remove</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//通过迭代器删除，equals方法很重要</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">remove</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">    Iterator&lt;E&gt; it = iterator();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (o==<span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (it.hasNext()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (it.next()==<span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">                it.remove();</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (it.hasNext()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (o.equals(it.next())) &#123;</span><br><span class=\"line\">                it.remove();</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"containsAll\"><a href=\"#containsAll\" class=\"headerlink\" title=\"containsAll\"></a>containsAll</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//时间复杂度为O(n^2)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">containsAll</span><span class=\"params\">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (Object e : c)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!contains(e))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"addAll\"><a href=\"#addAll\" class=\"headerlink\" title=\"addAll\"></a>addAll</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//modified来判断集合是否改变</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">addAll</span><span class=\"params\">(Collection&lt;? extends E&gt; c)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> modified = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (E e : c)</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (add(e))</span><br><span class=\"line\">            modified = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> modified;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"removeAll\"><a href=\"#removeAll\" class=\"headerlink\" title=\"removeAll\"></a>removeAll</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//通过迭代器删除</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">removeAll</span><span class=\"params\">(Collection&lt;?&gt; c)</span> </span>&#123;</span><br><span class=\"line\">    Objects.requireNonNull(c);</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> modified = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    Iterator&lt;?&gt; it = iterator();</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (it.hasNext()) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (c.contains(it.next())) &#123;</span><br><span class=\"line\">            it.remove();</span><br><span class=\"line\">            modified = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> modified;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"clear\"><a href=\"#clear\" class=\"headerlink\" title=\"clear\"></a>clear</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//遍历迭代器，删除元素</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">clear</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Iterator&lt;E&gt; it = iterator();</span><br><span class=\"line\">    <span class=\"keyword\">while</span> (it.hasNext()) &#123;</span><br><span class=\"line\">        it.next();</span><br><span class=\"line\">        it.remove();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>我们可以看到抽象方法在实现普通方法时候是基本每个方法都会调用。</p>\n<h2 id=\"AbstractList\"><a href=\"#AbstractList\" class=\"headerlink\" title=\"AbstractList\"></a>AbstractList</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//AbstractList抽象方法有两个，1是新定义的get 2是继承父类的size，而父类AbstractCollection中的抽象方法只实现了一个iterator()，因为对于List来说，iterator行为是确认的。但是get行为需要子类实现。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> E <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span></span>;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>在AbstractList实现中，定义了Itr, ListItr两个迭代器，以及用于实现内部视图的SubList和RandomAccessSubList.</p>\n<h3 id=\"iterator\"><a href=\"#iterator\" class=\"headerlink\" title=\"iterator\"></a>iterator</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Iterator&lt;E&gt; <span class=\"title\">iterator</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Itr();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"Itr\"><a href=\"#Itr\" class=\"headerlink\" title=\"Itr\"></a>Itr</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Itr</span> <span class=\"keyword\">implements</span> <span class=\"title\">Iterator</span>&lt;<span class=\"title\">E</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/** 游标位置，指向当前元素**/</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> cursor = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">/**调用next后之前的元素，-1说明刚被删除了*/</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> lastRet = -<span class=\"number\">1</span>;</span><br><span class=\"line\">    <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">     *期望修复次数是不是等于实际修改次数，用户判断遍历时候是否被修改，如果不同则会抛出ConcurrentModificationException</span></span><br><span class=\"line\"><span class=\"comment\">     * 因为这些集合不是在线程安全的，所以并发修改会报错。</span></span><br><span class=\"line\"><span class=\"comment\">     */</span></span><br><span class=\"line\">    <span class=\"keyword\">int</span> expectedModCount = modCount;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hasNext</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cursor != size();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        checkForComodification();<span class=\"comment\">//检查是否被修改</span></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> i = cursor; <span class=\"comment\">//当前位置的cursor存储起来</span></span><br><span class=\"line\">            E next = get(i);<span class=\"comment\">//抽象方法get获取元素</span></span><br><span class=\"line\">            lastRet = i;<span class=\"comment\">//更新上一个元素位置</span></span><br><span class=\"line\">            cursor = i + <span class=\"number\">1</span>;<span class=\"comment\">//cursor下移一位</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> next;<span class=\"comment\">//返回当前元素</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IndexOutOfBoundsException e) &#123;</span><br><span class=\"line\">            checkForComodification();</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NoSuchElementException();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"comment\">//删除某个元素</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">remove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (lastRet &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException();</span><br><span class=\"line\">        checkForComodification();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            AbstractList.<span class=\"keyword\">this</span>.remove(lastRet);<span class=\"comment\">//调用删除方法</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (lastRet &lt; cursor) <span class=\"comment\">//</span></span><br><span class=\"line\">                cursor--;</span><br><span class=\"line\">            lastRet = -<span class=\"number\">1</span>;<span class=\"comment\">//lastRet设置为-1</span></span><br><span class=\"line\">            expectedModCount = modCount;<span class=\"comment\">//修改次数等于期望修改次数</span></span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IndexOutOfBoundsException e) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ConcurrentModificationException();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">checkForComodification</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (modCount != expectedModCount)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ConcurrentModificationException();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"ListItr\"><a href=\"#ListItr\" class=\"headerlink\" title=\"ListItr\"></a>ListItr</h3><p>ListItr实现了ListIterator接口，ListIterator和Iterator不同之处在于Iterator只支持向后遍历，但是ListIterator同时支持向后和向前遍历。也支持任意位置开始的遍历。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ListIterator</span>&lt;<span class=\"title\">E</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">Iterator</span>&lt;<span class=\"title\">E</span>&gt; </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">hasNext</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\">E <span class=\"title\">next</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">hasPrevious</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\">E <span class=\"title\">previous</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">nextIndex</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">previousIndex</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">remove</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">set</span><span class=\"params\">(E e)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(E e)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ListItr</span> <span class=\"keyword\">extends</span> <span class=\"title\">Itr</span> <span class=\"keyword\">implements</span> <span class=\"title\">ListIterator</span>&lt;<span class=\"title\">E</span>&gt; </span>&#123;</span><br><span class=\"line\">    ListItr(<span class=\"keyword\">int</span> index) &#123;</span><br><span class=\"line\">        cursor = index;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hasPrevious</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cursor != <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> E <span class=\"title\">previous</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        checkForComodification();</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> i = cursor - <span class=\"number\">1</span>;<span class=\"comment\">//前一个元素索引</span></span><br><span class=\"line\">            E previous = get(i);<span class=\"comment\">//获取前一个元素</span></span><br><span class=\"line\">            lastRet = cursor = i;<span class=\"comment\">//设置lastRet = cursor等于前一个元素索引</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> previous;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IndexOutOfBoundsException e) &#123;</span><br><span class=\"line\">            checkForComodification();</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NoSuchElementException();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">nextIndex</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cursor;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">previousIndex</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> cursor-<span class=\"number\">1</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">set</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (lastRet &lt; <span class=\"number\">0</span>)</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalStateException();</span><br><span class=\"line\">        checkForComodification();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            AbstractList.<span class=\"keyword\">this</span>.set(lastRet, e);</span><br><span class=\"line\">            expectedModCount = modCount;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ConcurrentModificationException();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">add</span><span class=\"params\">(E e)</span> </span>&#123;</span><br><span class=\"line\">        checkForComodification();</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> i = cursor;</span><br><span class=\"line\">            AbstractList.<span class=\"keyword\">this</span>.add(i, e);</span><br><span class=\"line\">            lastRet = -<span class=\"number\">1</span>;</span><br><span class=\"line\">            cursor = i + <span class=\"number\">1</span>;</span><br><span class=\"line\">            expectedModCount = modCount;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (IndexOutOfBoundsException ex) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> ConcurrentModificationException();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"SubList\"><a href=\"#SubList\" class=\"headerlink\" title=\"SubList\"></a>SubList</h3><h3 id=\"RandomAccessSubList\"><a href=\"#RandomAccessSubList\" class=\"headerlink\" title=\"RandomAccessSubList\"></a>RandomAccessSubList</h3><h2 id=\"AbstractSequentialList\"><a href=\"#AbstractSequentialList\" class=\"headerlink\" title=\"AbstractSequentialList\"></a>AbstractSequentialList</h2><p>AbstractSequentialList新加创建List迭代器的抽象方法listIterator。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> ListIterator&lt;E&gt; <span class=\"title\">listIterator</span><span class=\"params\">(<span class=\"keyword\">int</span> index)</span></span>;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"AbstractSet\"><a href=\"#AbstractSet\" class=\"headerlink\" title=\"AbstractSet\"></a>AbstractSet</h2><p>AbstractSet没有新加任何抽象方法，由于继承了AbstractCollection，所以它的实现是基于iterator和size的。</p>\n<h2 id=\"AbstractMap\"><a href=\"#AbstractMap\" class=\"headerlink\" title=\"AbstractMap\"></a>AbstractMap</h2><p>AbstractMap中的抽象方法只有entrySet，可以推断其他方法均是基于该方法实现的。因为键值对的唯一性，所以使用Set存储每一个Entry，虽然Entry好像是数据类，但是本质是有行为的类。每一个Entry代表了一个键值对，我们只能修改value，获取kv，但是不能修改key，这是Entry接口带来的契约，也是设计Entry的点，如果key可以被更新，那么这个map行为将变得不可预期。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> Set&lt;Entry&lt;K,V&gt;&gt; entrySet();</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//我们注意到Entry对KV的抽象，</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Entry</span>&lt;<span class=\"title\">K</span>, <span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">K <span class=\"title\">getKey</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\">V <span class=\"title\">getValue</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\">V <span class=\"title\">setValue</span><span class=\"params\">(V value)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object o)</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>AbstractMap中提供了两个Map.Entry的实现，一个可变的SimpleEntry，一个不可变的SimpleImmutableEntry.SimpleEntry的实现非常简单，没有任何难以理解的地方，我们来看下：</p>\n<h3 id=\"SimpleEntry\"><a href=\"#SimpleEntry\" class=\"headerlink\" title=\"SimpleEntry\"></a>SimpleEntry</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">SimpleEntry</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Entry</span>&lt;<span class=\"title\">K</span>,<span class=\"title\">V</span>&gt;, <span class=\"title\">java</span>.<span class=\"title\">io</span>.<span class=\"title\">Serializable</span></span>&#123;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"serial\"</span>) <span class=\"comment\">// Conditionally serializable</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">final</span> K key;</span><br><span class=\"line\">    <span class=\"meta\">@SuppressWarnings</span>(<span class=\"string\">\"serial\"</span>) <span class=\"comment\">// Conditionally serializable</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> V value;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SimpleEntry</span><span class=\"params\">(K key, V value)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.key   = key;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.value = value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">SimpleEntry</span><span class=\"params\">(Entry&lt;? extends K, ? extends V&gt; entry)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.key   = entry.getKey();</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.value = entry.getValue();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> K <span class=\"title\">getKey</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> key;&#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">getValue</span><span class=\"params\">()</span> </span>&#123;<span class=\"keyword\">return</span> value; &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">setValue</span><span class=\"params\">(V value)</span> </span>&#123;</span><br><span class=\"line\">        V oldValue = <span class=\"keyword\">this</span>.value;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.value = value;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object o)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!(o <span class=\"keyword\">instanceof</span> Map.Entry))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        Map.Entry&lt;?,?&gt; e = (Map.Entry&lt;?,?&gt;)o;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> eq(key, e.getKey()) &amp;&amp; eq(value, e.getValue());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (key   == <span class=\"keyword\">null</span> ? <span class=\"number\">0</span> :   key.hashCode()) ^</span><br><span class=\"line\">               (value == <span class=\"keyword\">null</span> ? <span class=\"number\">0</span> : value.hashCode());</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> key + <span class=\"string\">\"=\"</span> + value;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"SimpleImmutableEntry\"><a href=\"#SimpleImmutableEntry\" class=\"headerlink\" title=\"SimpleImmutableEntry\"></a>SimpleImmutableEntry</h3><p>和SimpleEntry不同的地方在于setValue方法抛出UnsupportedOperationException异常。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">setValue</span><span class=\"params\">(V value)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> UnsupportedOperationException();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"查询方法实现\"><a href=\"#查询方法实现\" class=\"headerlink\" title=\"查询方法实现\"></a>查询方法实现</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br><span class=\"line\">69</span><br><span class=\"line\">70</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//查询操作</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">size</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> entrySet().size();<span class=\"comment\">//调用抽象方法实现，set().size()</span></span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isEmpty</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">   <span class=\"keyword\">return</span> size() == <span class=\"number\">0</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//时间复杂度O(N)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">containsKey</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//取出Set的迭代器进行key的查找，</span></span><br><span class=\"line\">    Iterator&lt;Map.Entry&lt;K,V&gt;&gt; i = entrySet().iterator();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (key==<span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i.hasNext()) &#123;</span><br><span class=\"line\">            Entry&lt;K,V&gt; e = i.next();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (e.getKey()==<span class=\"keyword\">null</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i.hasNext()) &#123;</span><br><span class=\"line\">            Entry&lt;K,V&gt; e = i.next();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (key.equals(e.getKey()))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//时间复杂度O(N)</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">containsValue</span><span class=\"params\">(Object value)</span> </span>&#123;</span><br><span class=\"line\">    Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (value==<span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i.hasNext()) &#123;</span><br><span class=\"line\">            Entry&lt;K,V&gt; e = i.next();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (e.getValue()==<span class=\"keyword\">null</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i.hasNext()) &#123;</span><br><span class=\"line\">            Entry&lt;K,V&gt; e = i.next();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (value.equals(e.getValue()))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//这里的get方法实现复杂度是O(N),因为需要遍历整个Entry Set迭代器，这只是</span></span><br><span class=\"line\"><span class=\"comment\">//一种实现方法，如果客户端有更加高效的实现方式，则可以覆写该方法，如HashMap</span></span><br><span class=\"line\"><span class=\"comment\">//的高品质实现，同时因为Map只是定义了接口，并不是实现，Abstract只是定义了</span></span><br><span class=\"line\"><span class=\"comment\">//一种简单的实现，帮助客户端减少实现难度。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">get</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">    Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (key==<span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i.hasNext()) &#123;</span><br><span class=\"line\">            Entry&lt;K,V&gt; e = i.next();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (e.getKey()==<span class=\"keyword\">null</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> e.getValue();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">while</span> (i.hasNext()) &#123;</span><br><span class=\"line\">            Entry&lt;K,V&gt; e = i.next();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (key.equals(e.getKey()))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> e.getValue();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h3 id=\"修改操作方法\"><a href=\"#修改操作方法\" class=\"headerlink\" title=\"修改操作方法\"></a>修改操作方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//put方法在这里没有实现，也没有办法实现，正如add方法在AbstractCollection/List/Set中无法实现一样</span></span><br><span class=\"line\"><span class=\"comment\">//因为你不知道放入的数据结构，真正的数据结构定义是在实现类中，如HashMap，TreeMap这里面，</span></span><br><span class=\"line\"><span class=\"comment\">//正是因为抽象类的实现没有引入成员变量，所以放入时候才不会指定特定的存储细节，这也是</span></span><br><span class=\"line\"><span class=\"comment\">//集合框架获得灵活性的重要机制，如果在抽象类中引入了成员变量作为存储结构，那么子类的实现将会</span></span><br><span class=\"line\"><span class=\"comment\">//被束缚在抽象类，此时抽象类将不再抽象，而是一种实现了。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">put</span><span class=\"params\">(K key, V value)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> UnsupportedOperationException();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">putAll</span><span class=\"params\">(Map&lt;? extends K, ? extends V&gt; m)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Map.Entry&lt;? extends K, ? extends V&gt; e : m.entrySet())</span><br><span class=\"line\">            put(e.getKey(), e.getValue());</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">clear</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//entrySet是抽象方法</span></span><br><span class=\"line\">    entrySet().clear();</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//删除一个key，其实遍历entrySet，找到key对应的Entry，然后调用迭代器remove方法</span></span><br><span class=\"line\"><span class=\"comment\">//删除该元素</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">remove</span><span class=\"params\">(Object key)</span> </span>&#123;</span><br><span class=\"line\">        Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator();</span><br><span class=\"line\">        Entry&lt;K,V&gt; correctEntry = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (key==<span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (correctEntry==<span class=\"keyword\">null</span> &amp;&amp; i.hasNext()) &#123;</span><br><span class=\"line\">                Entry&lt;K,V&gt; e = i.next();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (e.getKey()==<span class=\"keyword\">null</span>)</span><br><span class=\"line\">                    correctEntry = e;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"keyword\">while</span> (correctEntry==<span class=\"keyword\">null</span> &amp;&amp; i.hasNext()) &#123;</span><br><span class=\"line\">                Entry&lt;K,V&gt; e = i.next();</span><br><span class=\"line\">                <span class=\"keyword\">if</span> (key.equals(e.getKey()))</span><br><span class=\"line\">                    correctEntry = e;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        V oldValue = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (correctEntry !=<span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            oldValue = correctEntry.getValue();</span><br><span class=\"line\">            i.remove();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> oldValue;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"视图方法\"><a href=\"#视图方法\" class=\"headerlink\" title=\"视图方法\"></a>视图方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">transient</span> Set&lt;K&gt;        keySet;</span><br><span class=\"line\"><span class=\"keyword\">transient</span> Collection&lt;V&gt; values;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//key的视图是set，因为key不能重复，每个Map只有一个视图，每个视图通过entrySet引用了</span></span><br><span class=\"line\"><span class=\"comment\">//真正Map的元素，可以看出视图实现了AbstractSet.第一次调用时候，keySet视图为空，创建视图。</span></span><br><span class=\"line\"><span class=\"comment\">//第二次调用时候，使用第一次的视图。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Set&lt;K&gt; <span class=\"title\">keySet</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Set&lt;K&gt; ks = keySet;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (ks == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        ks = <span class=\"keyword\">new</span> AbstractSet&lt;K&gt;() &#123;</span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> Iterator&lt;K&gt; <span class=\"title\">iterator</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Iterator&lt;K&gt;() &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">private</span> Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator();</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hasNext</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> i.hasNext();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">\t\t\t\t\t<span class=\"comment\">//next是key</span></span><br><span class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> K <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> i.next().getKey();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">remove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                        i.remove();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">size</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> AbstractMap.<span class=\"keyword\">this</span>.size();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isEmpty</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> AbstractMap.<span class=\"keyword\">this</span>.isEmpty();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">clear</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                AbstractMap.<span class=\"keyword\">this</span>.clear();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">contains</span><span class=\"params\">(Object k)</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> AbstractMap.<span class=\"keyword\">this</span>.containsKey(k);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        keySet = ks;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ks;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//因为value可以有重复的，所以使用Collection存储</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> Collection&lt;V&gt; <span class=\"title\">values</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    Collection&lt;V&gt; vals = values;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (vals == <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">        vals = <span class=\"keyword\">new</span> AbstractCollection&lt;V&gt;() &#123;</span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> Iterator&lt;V&gt; <span class=\"title\">iterator</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">new</span> Iterator&lt;V&gt;() &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">private</span> Iterator&lt;Entry&lt;K,V&gt;&gt; i = entrySet().iterator();</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">hasNext</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> i.hasNext();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">next</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                        <span class=\"keyword\">return</span> i.next().getValue();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">                    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">remove</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                        i.remove();</span><br><span class=\"line\">                    &#125;</span><br><span class=\"line\">                &#125;;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">size</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> AbstractMap.<span class=\"keyword\">this</span>.size();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isEmpty</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> AbstractMap.<span class=\"keyword\">this</span>.isEmpty();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">clear</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">                AbstractMap.<span class=\"keyword\">this</span>.clear();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">            <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">contains</span><span class=\"params\">(Object v)</span> </span>&#123;</span><br><span class=\"line\">                <span class=\"keyword\">return</span> AbstractMap.<span class=\"keyword\">this</span>.containsValue(v);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        values = vals;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> vals;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>"},{"title":"CRUD Boy和API Caller的怪象","date":"2021-01-01T10:40:35.000Z","_content":"\n\n\nCRUD，API Caller，Copy Paste 在业界被认为很低级工作，和low的技能(更多是自黑)。Spring作者Rod Johnson曾用一个比喻来说明问题，多瘤程序员: 学会一门技术但是留下来很多伤疤。经常认为和带着这样想法工作会降低个人生产力和对工作技术的敏感度。\n\n# CRUD Boy\n\n​        CRUD指的是对存储层的增删改查和业务层的逻辑计算。毕竟业务逻辑就是存储和计算。低级之处在于程序开发仅仅是对数据库数据的事务脚本操作，但是业务系统设计，在小型项目中CRUD可以Hold住复杂度，但是当业务系统复杂起来时候，事务脚本将带来维护性和扩展性问题，此时系统的各种业务逻辑和组件将会变得非常复杂且无趣。解决这个办法在于**良好的业务抽象**和概念**一致性的业务接口**，此时CRUD将不再是事务脚本，而更类似于OOD，而随着业务演进，可能会拆分微服务，这时候如果没有从CRUD泥潭出来，新建的微服务还是会重复事务脚本的老路。而业界有更好的业务设计方法，是**领域驱动设计**，将业务设计和技术设计结合起来，可以借鉴其思想，有句话说的比较好DDD is OOD done right.\n\n​       同时CRUD代码也不是没有技术含量的，CRUD代码也需要扩展性，维护性，可读性，文档注释，可测试性，不断重构达到整洁代码的水平，而这些任意一个工程实践，都会对既有团队带来编码习惯带来改变和编程水平的提高。所以CRUD没有技术含量，是更多把CRUD当做业务需求翻译机，产品说加你就加，而不是业务需求的解释器，用技术语言来设计业务。\n\n​       \n\n# API Caller\n\nAPI Caller是只会简单用类库和调第三方接口，没有完全理解调用方。这种透明性对业务开发进度有帮助，但是对于个人技术成长却是弊大于利。比较典型的例子是你用别人封装好的Redis接口查数据，会错以为自己会Redis，用厂商提供好的mq接口开发，发送几条消息，消费几条消息就认为自己用过mq，从而在实际工作中变成了只会调用API。在Java类库中，NIO代码冗余且复杂，学习NIO API本身就是对NIO的学习，但是写完就忘，下次还要重新学习，但是下次的学习或许没有从更深概念理解NIO，而是重新学了一遍NIO API使用代码，这样比较浪费时间。\n\n对于高质量的程序，绝大部分是注重API设计质量的，这不仅关系到API使用，还有API的理解性上，好的API本身就会抽象最核心的概念给开发者，模块间通信也会精心设计API。在JAVA世界中，集合框架和并发包可以说是对API契约和设计的经典案例，任何学习API设计的都可以从此开始研究，光看集合提供的接口，就能够收获非常多的概念和抽象。同时高质量API的文档也能够加深对技术的理解。当然API的实现也很重要，但是重要程度不如API本身。关于这方面可以参考：[集合接口](https://xiaozhiliaoo.github.io/2020/11/09/JCF-HighLevel/)\n\n我们以Guava Cache来分析从API中能获得什么？\n\n```java\n//LoadingCache的父接口Cache也包含非常多的方法，这里不做探讨。\npublic interface LoadingCache<K, V> extends Cache<K, V>, Function<K, V> { \n      V get(K key) throws ExecutionException;\n      V getUnchecked(K key);\n      ImmutableMap<K, V> getAll(Iterable<? extends K> keys) throws ExecutionException;\n        /**\n       * Loads a new value for key {@code key}, possibly asynchronously. While the new value is loading\n       * the previous value (if any) will continue to be returned by {@code get(key)} unless it is\n       * evicted. If the new value is loaded successfully it will replace the previous value in the\n       * cache; if an exception is thrown while refreshing the previous value will remain, <i>and the\n       * exception will be logged (using {@link java.util.logging.Logger}) and swallowed</i>.\n       *\n       * <p>Caches loaded by a {@link CacheLoader} will call {@link CacheLoader#reload} if the cache\n       * currently contains a value for {@code key}, and {@link CacheLoader#load} otherwise. Loading is\n       * asynchronous only if {@link CacheLoader#reload} was overridden with an asynchronous\n       * implementation.\n       *\n       * <p>Returns without doing anything if another thread is currently loading the value for {@code\n       * key}. If the cache loader associated with this cache performs refresh asynchronously then this\n       * method may return before refresh completes.\n       *\n       * @since 11.0\n       */\n      void refresh(K key);\n      /**\n       * Returns a view of the entries stored in this cache as a thread-safe map. Modifications made to\n       * the map directly affect the cache.\n       *\n       * <p>Iterators from the returned map are at least <i>weakly consistent</i>: they are safe for\n       * concurrent use, but if the cache is modified (including by eviction) after the iterator is\n       * created, it is undefined which of the changes (if any) will be reflected in that iterator.\n       */\n      ConcurrentMap<K, V> asMap();\n}\n```\n\n\n\n先看**get**方法，抛出了ExecutionException异常，这个异常定义在并发包java.util.concurrent下，所以可以猜测get时候会不会和并发，多线程执行有关.否则不可能无缘无故抛出这么个异常。事实证明猜测是对的，Guava对于[Interruption](https://github.com/google/guava/wiki/CachesExplained#interruption)的处理很多设计决策。\n\n**getUnchecked**同样是获取v方法，没有抛出任何异常，方法名是获取非受检异常，可以看出获取key的时候，一定会报错，但是提供了更加灵活的异常处理机制，而这些知识，就需要对受检异常和非受检异常有清晰的认识才能设计出这样的API，否则是不会想到这一层的。\n\n**getAll**这个接口设计很有意思，传参是Iterable，足够看到其通用和扩展性，但是返回确是不可变的Map，看到这里，是不是觉得比较有趣呢？可以质疑为什么不用List接口呢？当然使用的时候传入Key List是可以的，但是如果你不理解Iterable的接口，你这段代码很有可能需要百度demo才能写出来，下次遇到同样的问题还是没有任何进步，成为了API Caller。\n\n**refresh**从方法签名看不出什么，但是API文档注释非常详细，足够了解了。\n\n**asMap** 是缓存的视图，但是修改缓存视图会导致底层缓存被修改，并且用的是并发的Map接口，此时几乎可以得出结论，缓存大概率会并发读写的，所以benchmark时候，并发读写能力一定是一个点。此时你对ConcurrentMap操作时候就需要清晰地了解ConcurrentMap的特性，并发修改时候遍历等问题。如果你希望业务层缓存只能用来读，而缓存层做缓存更新的话，你可以将asMap包装成不可变的Map. 当转换成Map时候，疑问在于关于Cache的契约是否就会被打破了？比如get时候load数据。\n\n可以看到，还没有看LoadingCache的实现，我们就可以很多，看完核心接口，在辅以文档，可以说对Cache Design和Decision有最基本的认识了，缓存和高性能有着千丝万缕的关系，需要深入到边边角角，既能从高层知道如何设计一个Cache，也能从底层知道如何实现一个Cache，否则在工程中可能因为一个参数配置就会导致性能问题。虽然以上方法在使用起来非常简单，但是合理的理解其设计和抽象对使用产生很大帮助，对不同API也能触类旁通，也可以提高自己设计API的水平，从此脱离API Caller的窘境，成为一名API Designer. \n\nAPI Caller还有一个非常典型的例子是线程池的使用。API Caller还有特点不喜欢看API文档，甚至不知道哪里看API文档。\n\n个人比较喜欢的学习技术方法是：无论如何先看一遍官方文档，学有余力则看一遍API文档，很感兴趣则可以入手源码。\n\n\n\n# Copy Paste\n\n粘贴复制本身其实没有什么问题，可以提供编程效率，但是由于复制带来的**代码重复**问题较为严重。因为这是时空级别的重复，虽然重复的概念很简单，但是衍生带来的，维护性，可读性，耦合性，内聚性问题，牵一发而不知道影响面，会极大降低代码仓库质量和Bug数量。如果说技术债最严重的问题，我觉得是重复代码问题。通过良好的抽象和封装，以及子函数，状态聚合，行为聚合等编程手段，会减少重复问题。\n\n\n\n\n\n# 技术方案与实现的不一致性\n\n技术方案更偏向于架构，而实现更偏向于代码。有些技术方案涉及到编程(比如redis使用)，有些则无需（比如nginx负载均衡和容器化）这两者在某些程度并不是一致的。有些时候技术方案提出者并不是实现者，即使是，也有可能出现方案很牛逼，但是编码能力有限会导致的实现不好的现象。这点有一个例子，比如架构上引入缓存作为一个高层次的组件，但是缓存具体选型和实现上，则会出现分歧，用ConcurrentHashMap还是Guava Cache呢？这两者对于代码实现的复杂度不同。在实现的时候，又会面临如何封装，代码包组织，如何抽象的编程等非常细节问题，如果使用了Guava Cache，则会不会沦为API Caller的窘境呢？\n\n\n\n# 总结\n\ncrud boy，api caller，copy paste在开发业务时候会带来巨大便利，但是使用和理解不好也会造成非常多技术债和坑，这对个人成长帮助有限，会带来**我不断在学习**的假象，实际难逃轮回，凡所有相，皆是虚妄，若见诸相非相，即见如来。多花些时间研究API(包括优质和劣质)是有帮助的，要对业内“**忘记了，百度下就能知道了**”如此言论保持怀疑，他会使你真正成为API Caller的。你我都在路上！\n\n","source":"_posts/Think-CRUDBoy-APICaller.md","raw":"---\ntitle: CRUD Boy和API Caller的怪象\ndate: 2021-01-01 18:40:35\ntags:\n  - 代码设计杂谈\ncategories:\n  - 杂谈\n---\n\n\n\nCRUD，API Caller，Copy Paste 在业界被认为很低级工作，和low的技能(更多是自黑)。Spring作者Rod Johnson曾用一个比喻来说明问题，多瘤程序员: 学会一门技术但是留下来很多伤疤。经常认为和带着这样想法工作会降低个人生产力和对工作技术的敏感度。\n\n# CRUD Boy\n\n​        CRUD指的是对存储层的增删改查和业务层的逻辑计算。毕竟业务逻辑就是存储和计算。低级之处在于程序开发仅仅是对数据库数据的事务脚本操作，但是业务系统设计，在小型项目中CRUD可以Hold住复杂度，但是当业务系统复杂起来时候，事务脚本将带来维护性和扩展性问题，此时系统的各种业务逻辑和组件将会变得非常复杂且无趣。解决这个办法在于**良好的业务抽象**和概念**一致性的业务接口**，此时CRUD将不再是事务脚本，而更类似于OOD，而随着业务演进，可能会拆分微服务，这时候如果没有从CRUD泥潭出来，新建的微服务还是会重复事务脚本的老路。而业界有更好的业务设计方法，是**领域驱动设计**，将业务设计和技术设计结合起来，可以借鉴其思想，有句话说的比较好DDD is OOD done right.\n\n​       同时CRUD代码也不是没有技术含量的，CRUD代码也需要扩展性，维护性，可读性，文档注释，可测试性，不断重构达到整洁代码的水平，而这些任意一个工程实践，都会对既有团队带来编码习惯带来改变和编程水平的提高。所以CRUD没有技术含量，是更多把CRUD当做业务需求翻译机，产品说加你就加，而不是业务需求的解释器，用技术语言来设计业务。\n\n​       \n\n# API Caller\n\nAPI Caller是只会简单用类库和调第三方接口，没有完全理解调用方。这种透明性对业务开发进度有帮助，但是对于个人技术成长却是弊大于利。比较典型的例子是你用别人封装好的Redis接口查数据，会错以为自己会Redis，用厂商提供好的mq接口开发，发送几条消息，消费几条消息就认为自己用过mq，从而在实际工作中变成了只会调用API。在Java类库中，NIO代码冗余且复杂，学习NIO API本身就是对NIO的学习，但是写完就忘，下次还要重新学习，但是下次的学习或许没有从更深概念理解NIO，而是重新学了一遍NIO API使用代码，这样比较浪费时间。\n\n对于高质量的程序，绝大部分是注重API设计质量的，这不仅关系到API使用，还有API的理解性上，好的API本身就会抽象最核心的概念给开发者，模块间通信也会精心设计API。在JAVA世界中，集合框架和并发包可以说是对API契约和设计的经典案例，任何学习API设计的都可以从此开始研究，光看集合提供的接口，就能够收获非常多的概念和抽象。同时高质量API的文档也能够加深对技术的理解。当然API的实现也很重要，但是重要程度不如API本身。关于这方面可以参考：[集合接口](https://xiaozhiliaoo.github.io/2020/11/09/JCF-HighLevel/)\n\n我们以Guava Cache来分析从API中能获得什么？\n\n```java\n//LoadingCache的父接口Cache也包含非常多的方法，这里不做探讨。\npublic interface LoadingCache<K, V> extends Cache<K, V>, Function<K, V> { \n      V get(K key) throws ExecutionException;\n      V getUnchecked(K key);\n      ImmutableMap<K, V> getAll(Iterable<? extends K> keys) throws ExecutionException;\n        /**\n       * Loads a new value for key {@code key}, possibly asynchronously. While the new value is loading\n       * the previous value (if any) will continue to be returned by {@code get(key)} unless it is\n       * evicted. If the new value is loaded successfully it will replace the previous value in the\n       * cache; if an exception is thrown while refreshing the previous value will remain, <i>and the\n       * exception will be logged (using {@link java.util.logging.Logger}) and swallowed</i>.\n       *\n       * <p>Caches loaded by a {@link CacheLoader} will call {@link CacheLoader#reload} if the cache\n       * currently contains a value for {@code key}, and {@link CacheLoader#load} otherwise. Loading is\n       * asynchronous only if {@link CacheLoader#reload} was overridden with an asynchronous\n       * implementation.\n       *\n       * <p>Returns without doing anything if another thread is currently loading the value for {@code\n       * key}. If the cache loader associated with this cache performs refresh asynchronously then this\n       * method may return before refresh completes.\n       *\n       * @since 11.0\n       */\n      void refresh(K key);\n      /**\n       * Returns a view of the entries stored in this cache as a thread-safe map. Modifications made to\n       * the map directly affect the cache.\n       *\n       * <p>Iterators from the returned map are at least <i>weakly consistent</i>: they are safe for\n       * concurrent use, but if the cache is modified (including by eviction) after the iterator is\n       * created, it is undefined which of the changes (if any) will be reflected in that iterator.\n       */\n      ConcurrentMap<K, V> asMap();\n}\n```\n\n\n\n先看**get**方法，抛出了ExecutionException异常，这个异常定义在并发包java.util.concurrent下，所以可以猜测get时候会不会和并发，多线程执行有关.否则不可能无缘无故抛出这么个异常。事实证明猜测是对的，Guava对于[Interruption](https://github.com/google/guava/wiki/CachesExplained#interruption)的处理很多设计决策。\n\n**getUnchecked**同样是获取v方法，没有抛出任何异常，方法名是获取非受检异常，可以看出获取key的时候，一定会报错，但是提供了更加灵活的异常处理机制，而这些知识，就需要对受检异常和非受检异常有清晰的认识才能设计出这样的API，否则是不会想到这一层的。\n\n**getAll**这个接口设计很有意思，传参是Iterable，足够看到其通用和扩展性，但是返回确是不可变的Map，看到这里，是不是觉得比较有趣呢？可以质疑为什么不用List接口呢？当然使用的时候传入Key List是可以的，但是如果你不理解Iterable的接口，你这段代码很有可能需要百度demo才能写出来，下次遇到同样的问题还是没有任何进步，成为了API Caller。\n\n**refresh**从方法签名看不出什么，但是API文档注释非常详细，足够了解了。\n\n**asMap** 是缓存的视图，但是修改缓存视图会导致底层缓存被修改，并且用的是并发的Map接口，此时几乎可以得出结论，缓存大概率会并发读写的，所以benchmark时候，并发读写能力一定是一个点。此时你对ConcurrentMap操作时候就需要清晰地了解ConcurrentMap的特性，并发修改时候遍历等问题。如果你希望业务层缓存只能用来读，而缓存层做缓存更新的话，你可以将asMap包装成不可变的Map. 当转换成Map时候，疑问在于关于Cache的契约是否就会被打破了？比如get时候load数据。\n\n可以看到，还没有看LoadingCache的实现，我们就可以很多，看完核心接口，在辅以文档，可以说对Cache Design和Decision有最基本的认识了，缓存和高性能有着千丝万缕的关系，需要深入到边边角角，既能从高层知道如何设计一个Cache，也能从底层知道如何实现一个Cache，否则在工程中可能因为一个参数配置就会导致性能问题。虽然以上方法在使用起来非常简单，但是合理的理解其设计和抽象对使用产生很大帮助，对不同API也能触类旁通，也可以提高自己设计API的水平，从此脱离API Caller的窘境，成为一名API Designer. \n\nAPI Caller还有一个非常典型的例子是线程池的使用。API Caller还有特点不喜欢看API文档，甚至不知道哪里看API文档。\n\n个人比较喜欢的学习技术方法是：无论如何先看一遍官方文档，学有余力则看一遍API文档，很感兴趣则可以入手源码。\n\n\n\n# Copy Paste\n\n粘贴复制本身其实没有什么问题，可以提供编程效率，但是由于复制带来的**代码重复**问题较为严重。因为这是时空级别的重复，虽然重复的概念很简单，但是衍生带来的，维护性，可读性，耦合性，内聚性问题，牵一发而不知道影响面，会极大降低代码仓库质量和Bug数量。如果说技术债最严重的问题，我觉得是重复代码问题。通过良好的抽象和封装，以及子函数，状态聚合，行为聚合等编程手段，会减少重复问题。\n\n\n\n\n\n# 技术方案与实现的不一致性\n\n技术方案更偏向于架构，而实现更偏向于代码。有些技术方案涉及到编程(比如redis使用)，有些则无需（比如nginx负载均衡和容器化）这两者在某些程度并不是一致的。有些时候技术方案提出者并不是实现者，即使是，也有可能出现方案很牛逼，但是编码能力有限会导致的实现不好的现象。这点有一个例子，比如架构上引入缓存作为一个高层次的组件，但是缓存具体选型和实现上，则会出现分歧，用ConcurrentHashMap还是Guava Cache呢？这两者对于代码实现的复杂度不同。在实现的时候，又会面临如何封装，代码包组织，如何抽象的编程等非常细节问题，如果使用了Guava Cache，则会不会沦为API Caller的窘境呢？\n\n\n\n# 总结\n\ncrud boy，api caller，copy paste在开发业务时候会带来巨大便利，但是使用和理解不好也会造成非常多技术债和坑，这对个人成长帮助有限，会带来**我不断在学习**的假象，实际难逃轮回，凡所有相，皆是虚妄，若见诸相非相，即见如来。多花些时间研究API(包括优质和劣质)是有帮助的，要对业内“**忘记了，百度下就能知道了**”如此言论保持怀疑，他会使你真正成为API Caller的。你我都在路上！\n\n","slug":"Think-CRUDBoy-APICaller","published":1,"updated":"2021-01-02T05:19:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clh7s5cto000jxt8j7z3e2joi","content":"<p>CRUD，API Caller，Copy Paste 在业界被认为很低级工作，和low的技能(更多是自黑)。Spring作者Rod Johnson曾用一个比喻来说明问题，多瘤程序员: 学会一门技术但是留下来很多伤疤。经常认为和带着这样想法工作会降低个人生产力和对工作技术的敏感度。</p>\n<h1 id=\"CRUD-Boy\"><a href=\"#CRUD-Boy\" class=\"headerlink\" title=\"CRUD Boy\"></a>CRUD Boy</h1><p>​        CRUD指的是对存储层的增删改查和业务层的逻辑计算。毕竟业务逻辑就是存储和计算。低级之处在于程序开发仅仅是对数据库数据的事务脚本操作，但是业务系统设计，在小型项目中CRUD可以Hold住复杂度，但是当业务系统复杂起来时候，事务脚本将带来维护性和扩展性问题，此时系统的各种业务逻辑和组件将会变得非常复杂且无趣。解决这个办法在于<strong>良好的业务抽象</strong>和概念<strong>一致性的业务接口</strong>，此时CRUD将不再是事务脚本，而更类似于OOD，而随着业务演进，可能会拆分微服务，这时候如果没有从CRUD泥潭出来，新建的微服务还是会重复事务脚本的老路。而业界有更好的业务设计方法，是<strong>领域驱动设计</strong>，将业务设计和技术设计结合起来，可以借鉴其思想，有句话说的比较好DDD is OOD done right.</p>\n<p>​       同时CRUD代码也不是没有技术含量的，CRUD代码也需要扩展性，维护性，可读性，文档注释，可测试性，不断重构达到整洁代码的水平，而这些任意一个工程实践，都会对既有团队带来编码习惯带来改变和编程水平的提高。所以CRUD没有技术含量，是更多把CRUD当做业务需求翻译机，产品说加你就加，而不是业务需求的解释器，用技术语言来设计业务。</p>\n<p>​       </p>\n<h1 id=\"API-Caller\"><a href=\"#API-Caller\" class=\"headerlink\" title=\"API Caller\"></a>API Caller</h1><p>API Caller是只会简单用类库和调第三方接口，没有完全理解调用方。这种透明性对业务开发进度有帮助，但是对于个人技术成长却是弊大于利。比较典型的例子是你用别人封装好的Redis接口查数据，会错以为自己会Redis，用厂商提供好的mq接口开发，发送几条消息，消费几条消息就认为自己用过mq，从而在实际工作中变成了只会调用API。在Java类库中，NIO代码冗余且复杂，学习NIO API本身就是对NIO的学习，但是写完就忘，下次还要重新学习，但是下次的学习或许没有从更深概念理解NIO，而是重新学了一遍NIO API使用代码，这样比较浪费时间。</p>\n<p>对于高质量的程序，绝大部分是注重API设计质量的，这不仅关系到API使用，还有API的理解性上，好的API本身就会抽象最核心的概念给开发者，模块间通信也会精心设计API。在JAVA世界中，集合框架和并发包可以说是对API契约和设计的经典案例，任何学习API设计的都可以从此开始研究，光看集合提供的接口，就能够收获非常多的概念和抽象。同时高质量API的文档也能够加深对技术的理解。当然API的实现也很重要，但是重要程度不如API本身。关于这方面可以参考：<a href=\"https://xiaozhiliaoo.github.io/2020/11/09/JCF-HighLevel/\" target=\"_blank\" rel=\"noopener\">集合接口</a></p>\n<p>我们以Guava Cache来分析从API中能获得什么？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//LoadingCache的父接口Cache也包含非常多的方法，这里不做探讨。</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">LoadingCache</span>&lt;<span class=\"title\">K</span>, <span class=\"title\">V</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">Cache</span>&lt;<span class=\"title\">K</span>, <span class=\"title\">V</span>&gt;, <span class=\"title\">Function</span>&lt;<span class=\"title\">K</span>, <span class=\"title\">V</span>&gt; </span>&#123; </span><br><span class=\"line\">      <span class=\"function\">V <span class=\"title\">get</span><span class=\"params\">(K key)</span> <span class=\"keyword\">throws</span> ExecutionException</span>;</span><br><span class=\"line\">      <span class=\"function\">V <span class=\"title\">getUnchecked</span><span class=\"params\">(K key)</span></span>;</span><br><span class=\"line\">      <span class=\"function\">ImmutableMap&lt;K, V&gt; <span class=\"title\">getAll</span><span class=\"params\">(Iterable&lt;? extends K&gt; keys)</span> <span class=\"keyword\">throws</span> ExecutionException</span>;</span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">       * Loads a new value for key &#123;<span class=\"doctag\">@code</span> key&#125;, possibly asynchronously. While the new value is loading</span></span><br><span class=\"line\"><span class=\"comment\">       * the previous value (if any) will continue to be returned by &#123;<span class=\"doctag\">@code</span> get(key)&#125; unless it is</span></span><br><span class=\"line\"><span class=\"comment\">       * evicted. If the new value is loaded successfully it will replace the previous value in the</span></span><br><span class=\"line\"><span class=\"comment\">       * cache; if an exception is thrown while refreshing the previous value will remain, &lt;i&gt;and the</span></span><br><span class=\"line\"><span class=\"comment\">       * exception will be logged (using &#123;<span class=\"doctag\">@link</span> java.util.logging.Logger&#125;) and swallowed&lt;/i&gt;.</span></span><br><span class=\"line\"><span class=\"comment\">       *</span></span><br><span class=\"line\"><span class=\"comment\">       * &lt;p&gt;Caches loaded by a &#123;<span class=\"doctag\">@link</span> CacheLoader&#125; will call &#123;<span class=\"doctag\">@link</span> CacheLoader#reload&#125; if the cache</span></span><br><span class=\"line\"><span class=\"comment\">       * currently contains a value for &#123;<span class=\"doctag\">@code</span> key&#125;, and &#123;<span class=\"doctag\">@link</span> CacheLoader#load&#125; otherwise. Loading is</span></span><br><span class=\"line\"><span class=\"comment\">       * asynchronous only if &#123;<span class=\"doctag\">@link</span> CacheLoader#reload&#125; was overridden with an asynchronous</span></span><br><span class=\"line\"><span class=\"comment\">       * implementation.</span></span><br><span class=\"line\"><span class=\"comment\">       *</span></span><br><span class=\"line\"><span class=\"comment\">       * &lt;p&gt;Returns without doing anything if another thread is currently loading the value for &#123;<span class=\"doctag\">@code</span></span></span><br><span class=\"line\"><span class=\"comment\">       * key&#125;. If the cache loader associated with this cache performs refresh asynchronously then this</span></span><br><span class=\"line\"><span class=\"comment\">       * method may return before refresh completes.</span></span><br><span class=\"line\"><span class=\"comment\">       *</span></span><br><span class=\"line\"><span class=\"comment\">       * <span class=\"doctag\">@since</span> 11.0</span></span><br><span class=\"line\"><span class=\"comment\">       */</span></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">refresh</span><span class=\"params\">(K key)</span></span>;</span><br><span class=\"line\">      <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">       * Returns a view of the entries stored in this cache as a thread-safe map. Modifications made to</span></span><br><span class=\"line\"><span class=\"comment\">       * the map directly affect the cache.</span></span><br><span class=\"line\"><span class=\"comment\">       *</span></span><br><span class=\"line\"><span class=\"comment\">       * &lt;p&gt;Iterators from the returned map are at least &lt;i&gt;weakly consistent&lt;/i&gt;: they are safe for</span></span><br><span class=\"line\"><span class=\"comment\">       * concurrent use, but if the cache is modified (including by eviction) after the iterator is</span></span><br><span class=\"line\"><span class=\"comment\">       * created, it is undefined which of the changes (if any) will be reflected in that iterator.</span></span><br><span class=\"line\"><span class=\"comment\">       */</span></span><br><span class=\"line\">      <span class=\"function\">ConcurrentMap&lt;K, V&gt; <span class=\"title\">asMap</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>先看<strong>get</strong>方法，抛出了ExecutionException异常，这个异常定义在并发包java.util.concurrent下，所以可以猜测get时候会不会和并发，多线程执行有关.否则不可能无缘无故抛出这么个异常。事实证明猜测是对的，Guava对于<a href=\"https://github.com/google/guava/wiki/CachesExplained#interruption\" target=\"_blank\" rel=\"noopener\">Interruption</a>的处理很多设计决策。</p>\n<p><strong>getUnchecked</strong>同样是获取v方法，没有抛出任何异常，方法名是获取非受检异常，可以看出获取key的时候，一定会报错，但是提供了更加灵活的异常处理机制，而这些知识，就需要对受检异常和非受检异常有清晰的认识才能设计出这样的API，否则是不会想到这一层的。</p>\n<p><strong>getAll</strong>这个接口设计很有意思，传参是Iterable，足够看到其通用和扩展性，但是返回确是不可变的Map，看到这里，是不是觉得比较有趣呢？可以质疑为什么不用List接口呢？当然使用的时候传入Key List是可以的，但是如果你不理解Iterable的接口，你这段代码很有可能需要百度demo才能写出来，下次遇到同样的问题还是没有任何进步，成为了API Caller。</p>\n<p><strong>refresh</strong>从方法签名看不出什么，但是API文档注释非常详细，足够了解了。</p>\n<p><strong>asMap</strong> 是缓存的视图，但是修改缓存视图会导致底层缓存被修改，并且用的是并发的Map接口，此时几乎可以得出结论，缓存大概率会并发读写的，所以benchmark时候，并发读写能力一定是一个点。此时你对ConcurrentMap操作时候就需要清晰地了解ConcurrentMap的特性，并发修改时候遍历等问题。如果你希望业务层缓存只能用来读，而缓存层做缓存更新的话，你可以将asMap包装成不可变的Map. 当转换成Map时候，疑问在于关于Cache的契约是否就会被打破了？比如get时候load数据。</p>\n<p>可以看到，还没有看LoadingCache的实现，我们就可以很多，看完核心接口，在辅以文档，可以说对Cache Design和Decision有最基本的认识了，缓存和高性能有着千丝万缕的关系，需要深入到边边角角，既能从高层知道如何设计一个Cache，也能从底层知道如何实现一个Cache，否则在工程中可能因为一个参数配置就会导致性能问题。虽然以上方法在使用起来非常简单，但是合理的理解其设计和抽象对使用产生很大帮助，对不同API也能触类旁通，也可以提高自己设计API的水平，从此脱离API Caller的窘境，成为一名API Designer. </p>\n<p>API Caller还有一个非常典型的例子是线程池的使用。API Caller还有特点不喜欢看API文档，甚至不知道哪里看API文档。</p>\n<p>个人比较喜欢的学习技术方法是：无论如何先看一遍官方文档，学有余力则看一遍API文档，很感兴趣则可以入手源码。</p>\n<h1 id=\"Copy-Paste\"><a href=\"#Copy-Paste\" class=\"headerlink\" title=\"Copy Paste\"></a>Copy Paste</h1><p>粘贴复制本身其实没有什么问题，可以提供编程效率，但是由于复制带来的<strong>代码重复</strong>问题较为严重。因为这是时空级别的重复，虽然重复的概念很简单，但是衍生带来的，维护性，可读性，耦合性，内聚性问题，牵一发而不知道影响面，会极大降低代码仓库质量和Bug数量。如果说技术债最严重的问题，我觉得是重复代码问题。通过良好的抽象和封装，以及子函数，状态聚合，行为聚合等编程手段，会减少重复问题。</p>\n<h1 id=\"技术方案与实现的不一致性\"><a href=\"#技术方案与实现的不一致性\" class=\"headerlink\" title=\"技术方案与实现的不一致性\"></a>技术方案与实现的不一致性</h1><p>技术方案更偏向于架构，而实现更偏向于代码。有些技术方案涉及到编程(比如redis使用)，有些则无需（比如nginx负载均衡和容器化）这两者在某些程度并不是一致的。有些时候技术方案提出者并不是实现者，即使是，也有可能出现方案很牛逼，但是编码能力有限会导致的实现不好的现象。这点有一个例子，比如架构上引入缓存作为一个高层次的组件，但是缓存具体选型和实现上，则会出现分歧，用ConcurrentHashMap还是Guava Cache呢？这两者对于代码实现的复杂度不同。在实现的时候，又会面临如何封装，代码包组织，如何抽象的编程等非常细节问题，如果使用了Guava Cache，则会不会沦为API Caller的窘境呢？</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>crud boy，api caller，copy paste在开发业务时候会带来巨大便利，但是使用和理解不好也会造成非常多技术债和坑，这对个人成长帮助有限，会带来<strong>我不断在学习</strong>的假象，实际难逃轮回，凡所有相，皆是虚妄，若见诸相非相，即见如来。多花些时间研究API(包括优质和劣质)是有帮助的，要对业内“<strong>忘记了，百度下就能知道了</strong>”如此言论保持怀疑，他会使你真正成为API Caller的。你我都在路上！</p>\n","site":{"data":{}},"excerpt":"","more":"<p>CRUD，API Caller，Copy Paste 在业界被认为很低级工作，和low的技能(更多是自黑)。Spring作者Rod Johnson曾用一个比喻来说明问题，多瘤程序员: 学会一门技术但是留下来很多伤疤。经常认为和带着这样想法工作会降低个人生产力和对工作技术的敏感度。</p>\n<h1 id=\"CRUD-Boy\"><a href=\"#CRUD-Boy\" class=\"headerlink\" title=\"CRUD Boy\"></a>CRUD Boy</h1><p>​        CRUD指的是对存储层的增删改查和业务层的逻辑计算。毕竟业务逻辑就是存储和计算。低级之处在于程序开发仅仅是对数据库数据的事务脚本操作，但是业务系统设计，在小型项目中CRUD可以Hold住复杂度，但是当业务系统复杂起来时候，事务脚本将带来维护性和扩展性问题，此时系统的各种业务逻辑和组件将会变得非常复杂且无趣。解决这个办法在于<strong>良好的业务抽象</strong>和概念<strong>一致性的业务接口</strong>，此时CRUD将不再是事务脚本，而更类似于OOD，而随着业务演进，可能会拆分微服务，这时候如果没有从CRUD泥潭出来，新建的微服务还是会重复事务脚本的老路。而业界有更好的业务设计方法，是<strong>领域驱动设计</strong>，将业务设计和技术设计结合起来，可以借鉴其思想，有句话说的比较好DDD is OOD done right.</p>\n<p>​       同时CRUD代码也不是没有技术含量的，CRUD代码也需要扩展性，维护性，可读性，文档注释，可测试性，不断重构达到整洁代码的水平，而这些任意一个工程实践，都会对既有团队带来编码习惯带来改变和编程水平的提高。所以CRUD没有技术含量，是更多把CRUD当做业务需求翻译机，产品说加你就加，而不是业务需求的解释器，用技术语言来设计业务。</p>\n<p>​       </p>\n<h1 id=\"API-Caller\"><a href=\"#API-Caller\" class=\"headerlink\" title=\"API Caller\"></a>API Caller</h1><p>API Caller是只会简单用类库和调第三方接口，没有完全理解调用方。这种透明性对业务开发进度有帮助，但是对于个人技术成长却是弊大于利。比较典型的例子是你用别人封装好的Redis接口查数据，会错以为自己会Redis，用厂商提供好的mq接口开发，发送几条消息，消费几条消息就认为自己用过mq，从而在实际工作中变成了只会调用API。在Java类库中，NIO代码冗余且复杂，学习NIO API本身就是对NIO的学习，但是写完就忘，下次还要重新学习，但是下次的学习或许没有从更深概念理解NIO，而是重新学了一遍NIO API使用代码，这样比较浪费时间。</p>\n<p>对于高质量的程序，绝大部分是注重API设计质量的，这不仅关系到API使用，还有API的理解性上，好的API本身就会抽象最核心的概念给开发者，模块间通信也会精心设计API。在JAVA世界中，集合框架和并发包可以说是对API契约和设计的经典案例，任何学习API设计的都可以从此开始研究，光看集合提供的接口，就能够收获非常多的概念和抽象。同时高质量API的文档也能够加深对技术的理解。当然API的实现也很重要，但是重要程度不如API本身。关于这方面可以参考：<a href=\"https://xiaozhiliaoo.github.io/2020/11/09/JCF-HighLevel/\" target=\"_blank\" rel=\"noopener\">集合接口</a></p>\n<p>我们以Guava Cache来分析从API中能获得什么？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//LoadingCache的父接口Cache也包含非常多的方法，这里不做探讨。</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">LoadingCache</span>&lt;<span class=\"title\">K</span>, <span class=\"title\">V</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">Cache</span>&lt;<span class=\"title\">K</span>, <span class=\"title\">V</span>&gt;, <span class=\"title\">Function</span>&lt;<span class=\"title\">K</span>, <span class=\"title\">V</span>&gt; </span>&#123; </span><br><span class=\"line\">      <span class=\"function\">V <span class=\"title\">get</span><span class=\"params\">(K key)</span> <span class=\"keyword\">throws</span> ExecutionException</span>;</span><br><span class=\"line\">      <span class=\"function\">V <span class=\"title\">getUnchecked</span><span class=\"params\">(K key)</span></span>;</span><br><span class=\"line\">      <span class=\"function\">ImmutableMap&lt;K, V&gt; <span class=\"title\">getAll</span><span class=\"params\">(Iterable&lt;? extends K&gt; keys)</span> <span class=\"keyword\">throws</span> ExecutionException</span>;</span><br><span class=\"line\">        <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">       * Loads a new value for key &#123;<span class=\"doctag\">@code</span> key&#125;, possibly asynchronously. While the new value is loading</span></span><br><span class=\"line\"><span class=\"comment\">       * the previous value (if any) will continue to be returned by &#123;<span class=\"doctag\">@code</span> get(key)&#125; unless it is</span></span><br><span class=\"line\"><span class=\"comment\">       * evicted. If the new value is loaded successfully it will replace the previous value in the</span></span><br><span class=\"line\"><span class=\"comment\">       * cache; if an exception is thrown while refreshing the previous value will remain, &lt;i&gt;and the</span></span><br><span class=\"line\"><span class=\"comment\">       * exception will be logged (using &#123;<span class=\"doctag\">@link</span> java.util.logging.Logger&#125;) and swallowed&lt;/i&gt;.</span></span><br><span class=\"line\"><span class=\"comment\">       *</span></span><br><span class=\"line\"><span class=\"comment\">       * &lt;p&gt;Caches loaded by a &#123;<span class=\"doctag\">@link</span> CacheLoader&#125; will call &#123;<span class=\"doctag\">@link</span> CacheLoader#reload&#125; if the cache</span></span><br><span class=\"line\"><span class=\"comment\">       * currently contains a value for &#123;<span class=\"doctag\">@code</span> key&#125;, and &#123;<span class=\"doctag\">@link</span> CacheLoader#load&#125; otherwise. Loading is</span></span><br><span class=\"line\"><span class=\"comment\">       * asynchronous only if &#123;<span class=\"doctag\">@link</span> CacheLoader#reload&#125; was overridden with an asynchronous</span></span><br><span class=\"line\"><span class=\"comment\">       * implementation.</span></span><br><span class=\"line\"><span class=\"comment\">       *</span></span><br><span class=\"line\"><span class=\"comment\">       * &lt;p&gt;Returns without doing anything if another thread is currently loading the value for &#123;<span class=\"doctag\">@code</span></span></span><br><span class=\"line\"><span class=\"comment\">       * key&#125;. If the cache loader associated with this cache performs refresh asynchronously then this</span></span><br><span class=\"line\"><span class=\"comment\">       * method may return before refresh completes.</span></span><br><span class=\"line\"><span class=\"comment\">       *</span></span><br><span class=\"line\"><span class=\"comment\">       * <span class=\"doctag\">@since</span> 11.0</span></span><br><span class=\"line\"><span class=\"comment\">       */</span></span><br><span class=\"line\">      <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">refresh</span><span class=\"params\">(K key)</span></span>;</span><br><span class=\"line\">      <span class=\"comment\">/**</span></span><br><span class=\"line\"><span class=\"comment\">       * Returns a view of the entries stored in this cache as a thread-safe map. Modifications made to</span></span><br><span class=\"line\"><span class=\"comment\">       * the map directly affect the cache.</span></span><br><span class=\"line\"><span class=\"comment\">       *</span></span><br><span class=\"line\"><span class=\"comment\">       * &lt;p&gt;Iterators from the returned map are at least &lt;i&gt;weakly consistent&lt;/i&gt;: they are safe for</span></span><br><span class=\"line\"><span class=\"comment\">       * concurrent use, but if the cache is modified (including by eviction) after the iterator is</span></span><br><span class=\"line\"><span class=\"comment\">       * created, it is undefined which of the changes (if any) will be reflected in that iterator.</span></span><br><span class=\"line\"><span class=\"comment\">       */</span></span><br><span class=\"line\">      <span class=\"function\">ConcurrentMap&lt;K, V&gt; <span class=\"title\">asMap</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>先看<strong>get</strong>方法，抛出了ExecutionException异常，这个异常定义在并发包java.util.concurrent下，所以可以猜测get时候会不会和并发，多线程执行有关.否则不可能无缘无故抛出这么个异常。事实证明猜测是对的，Guava对于<a href=\"https://github.com/google/guava/wiki/CachesExplained#interruption\" target=\"_blank\" rel=\"noopener\">Interruption</a>的处理很多设计决策。</p>\n<p><strong>getUnchecked</strong>同样是获取v方法，没有抛出任何异常，方法名是获取非受检异常，可以看出获取key的时候，一定会报错，但是提供了更加灵活的异常处理机制，而这些知识，就需要对受检异常和非受检异常有清晰的认识才能设计出这样的API，否则是不会想到这一层的。</p>\n<p><strong>getAll</strong>这个接口设计很有意思，传参是Iterable，足够看到其通用和扩展性，但是返回确是不可变的Map，看到这里，是不是觉得比较有趣呢？可以质疑为什么不用List接口呢？当然使用的时候传入Key List是可以的，但是如果你不理解Iterable的接口，你这段代码很有可能需要百度demo才能写出来，下次遇到同样的问题还是没有任何进步，成为了API Caller。</p>\n<p><strong>refresh</strong>从方法签名看不出什么，但是API文档注释非常详细，足够了解了。</p>\n<p><strong>asMap</strong> 是缓存的视图，但是修改缓存视图会导致底层缓存被修改，并且用的是并发的Map接口，此时几乎可以得出结论，缓存大概率会并发读写的，所以benchmark时候，并发读写能力一定是一个点。此时你对ConcurrentMap操作时候就需要清晰地了解ConcurrentMap的特性，并发修改时候遍历等问题。如果你希望业务层缓存只能用来读，而缓存层做缓存更新的话，你可以将asMap包装成不可变的Map. 当转换成Map时候，疑问在于关于Cache的契约是否就会被打破了？比如get时候load数据。</p>\n<p>可以看到，还没有看LoadingCache的实现，我们就可以很多，看完核心接口，在辅以文档，可以说对Cache Design和Decision有最基本的认识了，缓存和高性能有着千丝万缕的关系，需要深入到边边角角，既能从高层知道如何设计一个Cache，也能从底层知道如何实现一个Cache，否则在工程中可能因为一个参数配置就会导致性能问题。虽然以上方法在使用起来非常简单，但是合理的理解其设计和抽象对使用产生很大帮助，对不同API也能触类旁通，也可以提高自己设计API的水平，从此脱离API Caller的窘境，成为一名API Designer. </p>\n<p>API Caller还有一个非常典型的例子是线程池的使用。API Caller还有特点不喜欢看API文档，甚至不知道哪里看API文档。</p>\n<p>个人比较喜欢的学习技术方法是：无论如何先看一遍官方文档，学有余力则看一遍API文档，很感兴趣则可以入手源码。</p>\n<h1 id=\"Copy-Paste\"><a href=\"#Copy-Paste\" class=\"headerlink\" title=\"Copy Paste\"></a>Copy Paste</h1><p>粘贴复制本身其实没有什么问题，可以提供编程效率，但是由于复制带来的<strong>代码重复</strong>问题较为严重。因为这是时空级别的重复，虽然重复的概念很简单，但是衍生带来的，维护性，可读性，耦合性，内聚性问题，牵一发而不知道影响面，会极大降低代码仓库质量和Bug数量。如果说技术债最严重的问题，我觉得是重复代码问题。通过良好的抽象和封装，以及子函数，状态聚合，行为聚合等编程手段，会减少重复问题。</p>\n<h1 id=\"技术方案与实现的不一致性\"><a href=\"#技术方案与实现的不一致性\" class=\"headerlink\" title=\"技术方案与实现的不一致性\"></a>技术方案与实现的不一致性</h1><p>技术方案更偏向于架构，而实现更偏向于代码。有些技术方案涉及到编程(比如redis使用)，有些则无需（比如nginx负载均衡和容器化）这两者在某些程度并不是一致的。有些时候技术方案提出者并不是实现者，即使是，也有可能出现方案很牛逼，但是编码能力有限会导致的实现不好的现象。这点有一个例子，比如架构上引入缓存作为一个高层次的组件，但是缓存具体选型和实现上，则会出现分歧，用ConcurrentHashMap还是Guava Cache呢？这两者对于代码实现的复杂度不同。在实现的时候，又会面临如何封装，代码包组织，如何抽象的编程等非常细节问题，如果使用了Guava Cache，则会不会沦为API Caller的窘境呢？</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>crud boy，api caller，copy paste在开发业务时候会带来巨大便利，但是使用和理解不好也会造成非常多技术债和坑，这对个人成长帮助有限，会带来<strong>我不断在学习</strong>的假象，实际难逃轮回，凡所有相，皆是虚妄，若见诸相非相，即见如来。多花些时间研究API(包括优质和劣质)是有帮助的，要对业内“<strong>忘记了，百度下就能知道了</strong>”如此言论保持怀疑，他会使你真正成为API Caller的。你我都在路上！</p>\n"},{"title":"ThreadLocal设计,实现,使用注意","date":"2020-11-14T19:39:59.000Z","_content":"\n\n\n# 概述\n\n线程局部变量是避免多线程读取共享变量造成竞争的一种机制，每个线程只能看到自己的私有变量，这就避免了锁竞争问题。在Java中，使用ThreadLocal可以实现该机制。\n\n\n\n# 结构\n\n在Java的ThreadLocal中，一个线程拥有多个ThreadLocal，每个ThreadLocal的变量存储在包级可见的内部静态类ThreadLocalMap中，ThreadLocalMap的Key是用WeakReference包装的ThreadLocal，Value则是强引用普通变量，每个ThreadLocal及其变量以KV形式存储在ThreadLocalMap中，而ThreadLocalMap并没有实现Map接口，而是自己实现了类似Map的功能。当前线程不在活跃的时候，垃圾收集器回自动回收ThreadLocal。即使内部细节非常多，但是ThreadLocal暴露给客户端的API确是非常简单，核心方法仅有initialValue，set，get，remove方法，这是经过多次改进后的设计。下图是结构图：\n\n单一线程：\n\n<img src=\"/images/ThreadLocalMap.png\" style=\"zoom:75%;\" />\n\n\n\n多线程：\n\n![](/images/ThreadLocalMultiThread.png)\n\n\n\n从图中得出结论：\n\n多个线程使用同一个ThreadLocal时候，每个线程会在内部创建一个自己的ThreadLocalMap. Thread:ThreadLocal:ThreadLocalMap=多:一:多\n\n一个线程使用多个ThreadLocal时候，一个线程创建了多个 ThreadLocalMap. Thread:ThreadLocal:ThreadLocalMap=一:多:一\n\n所以ThreadLocalMap数量和线程数有关。ThreadLocal是和一个领域或者业务有关。\n\n\n\n下图是类图：\n\n![](/images/ThreadLocal.png)\n\n\n\n# 实现\n\n\n\n\n\n\n\n# API演进\n\n\n\n\n\n\n\n\n\n# 实战\n\n\n\n\n\n\n\n# 使用注意\n\n1 由于每个线程的可以有多个ThreadLocal，每个ThreadLocal是唯一的，所以定义ThreadLocal时候需要定义成static final，并且初始化一个值。\n\n\n\n2 当已经给ThreadLocal设置值后，最好不需要时候主动remove，防止线程变量泄漏。\n\n\n\n3  当有父子线程需要共享传递值的时候，需要使用ThreadLocal的子类InheritableThreadLocal.\n\n\n\n4 当使用线程池更需要注意由于线程的可复用性，所以可能导致复用的线程拥有之前任务所传递的ThreadLocal局部变量，所以要在任务结束之后finallyremove该Worker的局部变量。\n\n\n\n5 内存泄漏和变量泄漏问题。","source":"_posts/ThreadLocal-Design-And-Implementation.md","raw":"---\ntitle: ThreadLocal设计,实现,使用注意\ndate: 2020-11-15 03:39:59\ntags: java.lang\ncategories:\n  - JDK源码\n  - Java核心\n---\n\n\n\n# 概述\n\n线程局部变量是避免多线程读取共享变量造成竞争的一种机制，每个线程只能看到自己的私有变量，这就避免了锁竞争问题。在Java中，使用ThreadLocal可以实现该机制。\n\n\n\n# 结构\n\n在Java的ThreadLocal中，一个线程拥有多个ThreadLocal，每个ThreadLocal的变量存储在包级可见的内部静态类ThreadLocalMap中，ThreadLocalMap的Key是用WeakReference包装的ThreadLocal，Value则是强引用普通变量，每个ThreadLocal及其变量以KV形式存储在ThreadLocalMap中，而ThreadLocalMap并没有实现Map接口，而是自己实现了类似Map的功能。当前线程不在活跃的时候，垃圾收集器回自动回收ThreadLocal。即使内部细节非常多，但是ThreadLocal暴露给客户端的API确是非常简单，核心方法仅有initialValue，set，get，remove方法，这是经过多次改进后的设计。下图是结构图：\n\n单一线程：\n\n<img src=\"/images/ThreadLocalMap.png\" style=\"zoom:75%;\" />\n\n\n\n多线程：\n\n![](/images/ThreadLocalMultiThread.png)\n\n\n\n从图中得出结论：\n\n多个线程使用同一个ThreadLocal时候，每个线程会在内部创建一个自己的ThreadLocalMap. Thread:ThreadLocal:ThreadLocalMap=多:一:多\n\n一个线程使用多个ThreadLocal时候，一个线程创建了多个 ThreadLocalMap. Thread:ThreadLocal:ThreadLocalMap=一:多:一\n\n所以ThreadLocalMap数量和线程数有关。ThreadLocal是和一个领域或者业务有关。\n\n\n\n下图是类图：\n\n![](/images/ThreadLocal.png)\n\n\n\n# 实现\n\n\n\n\n\n\n\n# API演进\n\n\n\n\n\n\n\n\n\n# 实战\n\n\n\n\n\n\n\n# 使用注意\n\n1 由于每个线程的可以有多个ThreadLocal，每个ThreadLocal是唯一的，所以定义ThreadLocal时候需要定义成static final，并且初始化一个值。\n\n\n\n2 当已经给ThreadLocal设置值后，最好不需要时候主动remove，防止线程变量泄漏。\n\n\n\n3  当有父子线程需要共享传递值的时候，需要使用ThreadLocal的子类InheritableThreadLocal.\n\n\n\n4 当使用线程池更需要注意由于线程的可复用性，所以可能导致复用的线程拥有之前任务所传递的ThreadLocal局部变量，所以要在任务结束之后finallyremove该Worker的局部变量。\n\n\n\n5 内存泄漏和变量泄漏问题。","slug":"ThreadLocal-Design-And-Implementation","published":1,"updated":"2022-06-28T17:23:40.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clh7s5ctq000mxt8j9xk488ks","content":"<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><p>线程局部变量是避免多线程读取共享变量造成竞争的一种机制，每个线程只能看到自己的私有变量，这就避免了锁竞争问题。在Java中，使用ThreadLocal可以实现该机制。</p>\n<h1 id=\"结构\"><a href=\"#结构\" class=\"headerlink\" title=\"结构\"></a>结构</h1><p>在Java的ThreadLocal中，一个线程拥有多个ThreadLocal，每个ThreadLocal的变量存储在包级可见的内部静态类ThreadLocalMap中，ThreadLocalMap的Key是用WeakReference包装的ThreadLocal，Value则是强引用普通变量，每个ThreadLocal及其变量以KV形式存储在ThreadLocalMap中，而ThreadLocalMap并没有实现Map接口，而是自己实现了类似Map的功能。当前线程不在活跃的时候，垃圾收集器回自动回收ThreadLocal。即使内部细节非常多，但是ThreadLocal暴露给客户端的API确是非常简单，核心方法仅有initialValue，set，get，remove方法，这是经过多次改进后的设计。下图是结构图：</p>\n<p>单一线程：</p>\n<img src=\"/images/ThreadLocalMap.png\" style=\"zoom:75%;\" />\n\n\n\n<p>多线程：</p>\n<p><img src=\"/images/ThreadLocalMultiThread.png\" alt=\"\"></p>\n<p>从图中得出结论：</p>\n<p>多个线程使用同一个ThreadLocal时候，每个线程会在内部创建一个自己的ThreadLocalMap. Thread:ThreadLocal:ThreadLocalMap=多:一:多</p>\n<p>一个线程使用多个ThreadLocal时候，一个线程创建了多个 ThreadLocalMap. Thread:ThreadLocal:ThreadLocalMap=一:多:一</p>\n<p>所以ThreadLocalMap数量和线程数有关。ThreadLocal是和一个领域或者业务有关。</p>\n<p>下图是类图：</p>\n<p><img src=\"/images/ThreadLocal.png\" alt=\"\"></p>\n<h1 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h1><h1 id=\"API演进\"><a href=\"#API演进\" class=\"headerlink\" title=\"API演进\"></a>API演进</h1><h1 id=\"实战\"><a href=\"#实战\" class=\"headerlink\" title=\"实战\"></a>实战</h1><h1 id=\"使用注意\"><a href=\"#使用注意\" class=\"headerlink\" title=\"使用注意\"></a>使用注意</h1><p>1 由于每个线程的可以有多个ThreadLocal，每个ThreadLocal是唯一的，所以定义ThreadLocal时候需要定义成static final，并且初始化一个值。</p>\n<p>2 当已经给ThreadLocal设置值后，最好不需要时候主动remove，防止线程变量泄漏。</p>\n<p>3  当有父子线程需要共享传递值的时候，需要使用ThreadLocal的子类InheritableThreadLocal.</p>\n<p>4 当使用线程池更需要注意由于线程的可复用性，所以可能导致复用的线程拥有之前任务所传递的ThreadLocal局部变量，所以要在任务结束之后finallyremove该Worker的局部变量。</p>\n<p>5 内存泄漏和变量泄漏问题。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><p>线程局部变量是避免多线程读取共享变量造成竞争的一种机制，每个线程只能看到自己的私有变量，这就避免了锁竞争问题。在Java中，使用ThreadLocal可以实现该机制。</p>\n<h1 id=\"结构\"><a href=\"#结构\" class=\"headerlink\" title=\"结构\"></a>结构</h1><p>在Java的ThreadLocal中，一个线程拥有多个ThreadLocal，每个ThreadLocal的变量存储在包级可见的内部静态类ThreadLocalMap中，ThreadLocalMap的Key是用WeakReference包装的ThreadLocal，Value则是强引用普通变量，每个ThreadLocal及其变量以KV形式存储在ThreadLocalMap中，而ThreadLocalMap并没有实现Map接口，而是自己实现了类似Map的功能。当前线程不在活跃的时候，垃圾收集器回自动回收ThreadLocal。即使内部细节非常多，但是ThreadLocal暴露给客户端的API确是非常简单，核心方法仅有initialValue，set，get，remove方法，这是经过多次改进后的设计。下图是结构图：</p>\n<p>单一线程：</p>\n<img src=\"/images/ThreadLocalMap.png\" style=\"zoom:75%;\" />\n\n\n\n<p>多线程：</p>\n<p><img src=\"/images/ThreadLocalMultiThread.png\" alt=\"\"></p>\n<p>从图中得出结论：</p>\n<p>多个线程使用同一个ThreadLocal时候，每个线程会在内部创建一个自己的ThreadLocalMap. Thread:ThreadLocal:ThreadLocalMap=多:一:多</p>\n<p>一个线程使用多个ThreadLocal时候，一个线程创建了多个 ThreadLocalMap. Thread:ThreadLocal:ThreadLocalMap=一:多:一</p>\n<p>所以ThreadLocalMap数量和线程数有关。ThreadLocal是和一个领域或者业务有关。</p>\n<p>下图是类图：</p>\n<p><img src=\"/images/ThreadLocal.png\" alt=\"\"></p>\n<h1 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h1><h1 id=\"API演进\"><a href=\"#API演进\" class=\"headerlink\" title=\"API演进\"></a>API演进</h1><h1 id=\"实战\"><a href=\"#实战\" class=\"headerlink\" title=\"实战\"></a>实战</h1><h1 id=\"使用注意\"><a href=\"#使用注意\" class=\"headerlink\" title=\"使用注意\"></a>使用注意</h1><p>1 由于每个线程的可以有多个ThreadLocal，每个ThreadLocal是唯一的，所以定义ThreadLocal时候需要定义成static final，并且初始化一个值。</p>\n<p>2 当已经给ThreadLocal设置值后，最好不需要时候主动remove，防止线程变量泄漏。</p>\n<p>3  当有父子线程需要共享传递值的时候，需要使用ThreadLocal的子类InheritableThreadLocal.</p>\n<p>4 当使用线程池更需要注意由于线程的可复用性，所以可能导致复用的线程拥有之前任务所传递的ThreadLocal局部变量，所以要在任务结束之后finallyremove该Worker的局部变量。</p>\n<p>5 内存泄漏和变量泄漏问题。</p>\n"},{"title":"java.lang.OutOfMemoryError内存溢出","date":"2020-08-16T13:51:03.000Z","_content":"\n\n\n对这个问题的深入理解，取决于对GC，内存本身的理解。终极问题。\n\n内存，GC，\n\n内存溢出指的是程序需要内存超出系统所有的内存，如果是正常情况调大jvm内存即可，如果是\n\nJava内存区域分为这么几个区域\n\n堆区：老年代，新生代\n\n非堆：metaspace\n\n\n\nFullGC之后空间不足，内存没有回收。\n\n\n\n\n\nJava OOM情况有以下几种，\n\n\n\n### java heap space\n\n原因：1 应用需要更多对空间  2    内存泄漏（类加载器内存泄露，ThreadLocal 不remove内存泄漏，和线程池一起使用会泄漏）\n\n举例：\n\n解决方案：\n\n这种情况属于fullgc之后，堆空间不足，内存泄漏是内存溢出的一个原因，但是内存泄漏不一定导致内存溢出。\n\n\n\n### GC Overhead limit exceeded\n\n频繁FullGC导致该错误\n\n\n\n###  Permgen space\n\nJava7 持久代空间不足\n\n\n\n###  Metaspace\n\nJava8\n\n1 应用加载类太多了\n\n2 classloader内存泄漏\n\n元空间不足，java8之后才会有\n\n\n\n### Unable to create new native thread\n\n本地线程创建数量超过操作系统的线程数\n\n\n\n### Out of swap space？\n\n交换区\n\n\n\n### Compressed class space\n\n\n\n\n\n### Requested array size exceeds VM limit\n\n\n\n\n\n### reason stack_trace_with_native_method\n\n\n\n\n\n### 参考\n\n1.  Oracle官网 [Understand the OutOfMemoryError Exception](https://docs.oracle.com/javase/8/docs/technotes/guides/troubleshoot/memleaks002.html#CIHHJDJE)\n2.  Plumbr The 8 symptoms that surface [outofmemoryerror](https://plumbr.io/outofmemoryerror)\n3.  Wikipedia [Out of memory](https://en.wikipedia.org/wiki/Out_of_memory)\n4.   Ponnam Parhar的slide  [Slides](https://www.slideshare.net/PoonamBajaj5/get-rid-of-outofmemoryerror-messages)  [Video](https://www.youtube.com/watch?v=iixQAYnBnJw)\n\n","source":"_posts/OOM.md","raw":"---\ntitle: java.lang.OutOfMemoryError内存溢出\ndate: 2020-08-16 21:51:03\ntags:\n  - 内存溢出\n  - 内存泄露\ncategories:\n  - JVM\n---\n\n\n\n对这个问题的深入理解，取决于对GC，内存本身的理解。终极问题。\n\n内存，GC，\n\n内存溢出指的是程序需要内存超出系统所有的内存，如果是正常情况调大jvm内存即可，如果是\n\nJava内存区域分为这么几个区域\n\n堆区：老年代，新生代\n\n非堆：metaspace\n\n\n\nFullGC之后空间不足，内存没有回收。\n\n\n\n\n\nJava OOM情况有以下几种，\n\n\n\n### java heap space\n\n原因：1 应用需要更多对空间  2    内存泄漏（类加载器内存泄露，ThreadLocal 不remove内存泄漏，和线程池一起使用会泄漏）\n\n举例：\n\n解决方案：\n\n这种情况属于fullgc之后，堆空间不足，内存泄漏是内存溢出的一个原因，但是内存泄漏不一定导致内存溢出。\n\n\n\n### GC Overhead limit exceeded\n\n频繁FullGC导致该错误\n\n\n\n###  Permgen space\n\nJava7 持久代空间不足\n\n\n\n###  Metaspace\n\nJava8\n\n1 应用加载类太多了\n\n2 classloader内存泄漏\n\n元空间不足，java8之后才会有\n\n\n\n### Unable to create new native thread\n\n本地线程创建数量超过操作系统的线程数\n\n\n\n### Out of swap space？\n\n交换区\n\n\n\n### Compressed class space\n\n\n\n\n\n### Requested array size exceeds VM limit\n\n\n\n\n\n### reason stack_trace_with_native_method\n\n\n\n\n\n### 参考\n\n1.  Oracle官网 [Understand the OutOfMemoryError Exception](https://docs.oracle.com/javase/8/docs/technotes/guides/troubleshoot/memleaks002.html#CIHHJDJE)\n2.  Plumbr The 8 symptoms that surface [outofmemoryerror](https://plumbr.io/outofmemoryerror)\n3.  Wikipedia [Out of memory](https://en.wikipedia.org/wiki/Out_of_memory)\n4.   Ponnam Parhar的slide  [Slides](https://www.slideshare.net/PoonamBajaj5/get-rid-of-outofmemoryerror-messages)  [Video](https://www.youtube.com/watch?v=iixQAYnBnJw)\n\n","slug":"OOM","published":1,"updated":"2021-12-19T15:41:34.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clh7s5ctq000oxt8jhrcc19ff","content":"<p>对这个问题的深入理解，取决于对GC，内存本身的理解。终极问题。</p>\n<p>内存，GC，</p>\n<p>内存溢出指的是程序需要内存超出系统所有的内存，如果是正常情况调大jvm内存即可，如果是</p>\n<p>Java内存区域分为这么几个区域</p>\n<p>堆区：老年代，新生代</p>\n<p>非堆：metaspace</p>\n<p>FullGC之后空间不足，内存没有回收。</p>\n<p>Java OOM情况有以下几种，</p>\n<h3 id=\"java-heap-space\"><a href=\"#java-heap-space\" class=\"headerlink\" title=\"java heap space\"></a>java heap space</h3><p>原因：1 应用需要更多对空间  2    内存泄漏（类加载器内存泄露，ThreadLocal 不remove内存泄漏，和线程池一起使用会泄漏）</p>\n<p>举例：</p>\n<p>解决方案：</p>\n<p>这种情况属于fullgc之后，堆空间不足，内存泄漏是内存溢出的一个原因，但是内存泄漏不一定导致内存溢出。</p>\n<h3 id=\"GC-Overhead-limit-exceeded\"><a href=\"#GC-Overhead-limit-exceeded\" class=\"headerlink\" title=\"GC Overhead limit exceeded\"></a>GC Overhead limit exceeded</h3><p>频繁FullGC导致该错误</p>\n<h3 id=\"Permgen-space\"><a href=\"#Permgen-space\" class=\"headerlink\" title=\"Permgen space\"></a>Permgen space</h3><p>Java7 持久代空间不足</p>\n<h3 id=\"Metaspace\"><a href=\"#Metaspace\" class=\"headerlink\" title=\"Metaspace\"></a>Metaspace</h3><p>Java8</p>\n<p>1 应用加载类太多了</p>\n<p>2 classloader内存泄漏</p>\n<p>元空间不足，java8之后才会有</p>\n<h3 id=\"Unable-to-create-new-native-thread\"><a href=\"#Unable-to-create-new-native-thread\" class=\"headerlink\" title=\"Unable to create new native thread\"></a>Unable to create new native thread</h3><p>本地线程创建数量超过操作系统的线程数</p>\n<h3 id=\"Out-of-swap-space？\"><a href=\"#Out-of-swap-space？\" class=\"headerlink\" title=\"Out of swap space？\"></a>Out of swap space？</h3><p>交换区</p>\n<h3 id=\"Compressed-class-space\"><a href=\"#Compressed-class-space\" class=\"headerlink\" title=\"Compressed class space\"></a>Compressed class space</h3><h3 id=\"Requested-array-size-exceeds-VM-limit\"><a href=\"#Requested-array-size-exceeds-VM-limit\" class=\"headerlink\" title=\"Requested array size exceeds VM limit\"></a>Requested array size exceeds VM limit</h3><h3 id=\"reason-stack-trace-with-native-method\"><a href=\"#reason-stack-trace-with-native-method\" class=\"headerlink\" title=\"reason stack_trace_with_native_method\"></a>reason stack_trace_with_native_method</h3><h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ol>\n<li>Oracle官网 <a href=\"https://docs.oracle.com/javase/8/docs/technotes/guides/troubleshoot/memleaks002.html#CIHHJDJE\" target=\"_blank\" rel=\"noopener\">Understand the OutOfMemoryError Exception</a></li>\n<li>Plumbr The 8 symptoms that surface <a href=\"https://plumbr.io/outofmemoryerror\" target=\"_blank\" rel=\"noopener\">outofmemoryerror</a></li>\n<li>Wikipedia <a href=\"https://en.wikipedia.org/wiki/Out_of_memory\" target=\"_blank\" rel=\"noopener\">Out of memory</a></li>\n<li>Ponnam Parhar的slide  <a href=\"https://www.slideshare.net/PoonamBajaj5/get-rid-of-outofmemoryerror-messages\" target=\"_blank\" rel=\"noopener\">Slides</a>  <a href=\"https://www.youtube.com/watch?v=iixQAYnBnJw\" target=\"_blank\" rel=\"noopener\">Video</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>对这个问题的深入理解，取决于对GC，内存本身的理解。终极问题。</p>\n<p>内存，GC，</p>\n<p>内存溢出指的是程序需要内存超出系统所有的内存，如果是正常情况调大jvm内存即可，如果是</p>\n<p>Java内存区域分为这么几个区域</p>\n<p>堆区：老年代，新生代</p>\n<p>非堆：metaspace</p>\n<p>FullGC之后空间不足，内存没有回收。</p>\n<p>Java OOM情况有以下几种，</p>\n<h3 id=\"java-heap-space\"><a href=\"#java-heap-space\" class=\"headerlink\" title=\"java heap space\"></a>java heap space</h3><p>原因：1 应用需要更多对空间  2    内存泄漏（类加载器内存泄露，ThreadLocal 不remove内存泄漏，和线程池一起使用会泄漏）</p>\n<p>举例：</p>\n<p>解决方案：</p>\n<p>这种情况属于fullgc之后，堆空间不足，内存泄漏是内存溢出的一个原因，但是内存泄漏不一定导致内存溢出。</p>\n<h3 id=\"GC-Overhead-limit-exceeded\"><a href=\"#GC-Overhead-limit-exceeded\" class=\"headerlink\" title=\"GC Overhead limit exceeded\"></a>GC Overhead limit exceeded</h3><p>频繁FullGC导致该错误</p>\n<h3 id=\"Permgen-space\"><a href=\"#Permgen-space\" class=\"headerlink\" title=\"Permgen space\"></a>Permgen space</h3><p>Java7 持久代空间不足</p>\n<h3 id=\"Metaspace\"><a href=\"#Metaspace\" class=\"headerlink\" title=\"Metaspace\"></a>Metaspace</h3><p>Java8</p>\n<p>1 应用加载类太多了</p>\n<p>2 classloader内存泄漏</p>\n<p>元空间不足，java8之后才会有</p>\n<h3 id=\"Unable-to-create-new-native-thread\"><a href=\"#Unable-to-create-new-native-thread\" class=\"headerlink\" title=\"Unable to create new native thread\"></a>Unable to create new native thread</h3><p>本地线程创建数量超过操作系统的线程数</p>\n<h3 id=\"Out-of-swap-space？\"><a href=\"#Out-of-swap-space？\" class=\"headerlink\" title=\"Out of swap space？\"></a>Out of swap space？</h3><p>交换区</p>\n<h3 id=\"Compressed-class-space\"><a href=\"#Compressed-class-space\" class=\"headerlink\" title=\"Compressed class space\"></a>Compressed class space</h3><h3 id=\"Requested-array-size-exceeds-VM-limit\"><a href=\"#Requested-array-size-exceeds-VM-limit\" class=\"headerlink\" title=\"Requested array size exceeds VM limit\"></a>Requested array size exceeds VM limit</h3><h3 id=\"reason-stack-trace-with-native-method\"><a href=\"#reason-stack-trace-with-native-method\" class=\"headerlink\" title=\"reason stack_trace_with_native_method\"></a>reason stack_trace_with_native_method</h3><h3 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h3><ol>\n<li>Oracle官网 <a href=\"https://docs.oracle.com/javase/8/docs/technotes/guides/troubleshoot/memleaks002.html#CIHHJDJE\" target=\"_blank\" rel=\"noopener\">Understand the OutOfMemoryError Exception</a></li>\n<li>Plumbr The 8 symptoms that surface <a href=\"https://plumbr.io/outofmemoryerror\" target=\"_blank\" rel=\"noopener\">outofmemoryerror</a></li>\n<li>Wikipedia <a href=\"https://en.wikipedia.org/wiki/Out_of_memory\" target=\"_blank\" rel=\"noopener\">Out of memory</a></li>\n<li>Ponnam Parhar的slide  <a href=\"https://www.slideshare.net/PoonamBajaj5/get-rid-of-outofmemoryerror-messages\" target=\"_blank\" rel=\"noopener\">Slides</a>  <a href=\"https://www.youtube.com/watch?v=iixQAYnBnJw\" target=\"_blank\" rel=\"noopener\">Video</a></li>\n</ol>\n"},{"title":"买房犯的6个错误","date":"2023-03-01T12:37:30.000Z","_content":"\n\n\n# 合同看的不够仔细\n\n工具：ipad一字一句。\n\n# 没有争取到有利于买方的合同\n\n虽然谈了很多，细节确认了很多，但是其实并没有签一个买房合同\n\n# 违约责任不明确\n\n\n\n# 价格谈的不够坚定\n\n\n\n# 中介费还可以再低\n\n开口3%，谈到2.85%，实际2.5%\n\n# 家居留什么没有仔细确认\n","source":"_posts/buy-house-mistake.md","raw":"---\ntitle: 买房犯的6个错误\ndate: 2023-03-01 20:37:30\ntags: house\ncategories:\n  - 买房\n  - 买房的坑\n---\n\n\n\n# 合同看的不够仔细\n\n工具：ipad一字一句。\n\n# 没有争取到有利于买方的合同\n\n虽然谈了很多，细节确认了很多，但是其实并没有签一个买房合同\n\n# 违约责任不明确\n\n\n\n# 价格谈的不够坚定\n\n\n\n# 中介费还可以再低\n\n开口3%，谈到2.85%，实际2.5%\n\n# 家居留什么没有仔细确认\n","slug":"buy-house-mistake","published":1,"updated":"2023-03-02T03:08:38.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clh7s5cts000rxt8jeb53ajzh","content":"<h1 id=\"合同看的不够仔细\"><a href=\"#合同看的不够仔细\" class=\"headerlink\" title=\"合同看的不够仔细\"></a>合同看的不够仔细</h1><p>工具：ipad一字一句。</p>\n<h1 id=\"没有争取到有利于买方的合同\"><a href=\"#没有争取到有利于买方的合同\" class=\"headerlink\" title=\"没有争取到有利于买方的合同\"></a>没有争取到有利于买方的合同</h1><p>虽然谈了很多，细节确认了很多，但是其实并没有签一个买房合同</p>\n<h1 id=\"违约责任不明确\"><a href=\"#违约责任不明确\" class=\"headerlink\" title=\"违约责任不明确\"></a>违约责任不明确</h1><h1 id=\"价格谈的不够坚定\"><a href=\"#价格谈的不够坚定\" class=\"headerlink\" title=\"价格谈的不够坚定\"></a>价格谈的不够坚定</h1><h1 id=\"中介费还可以再低\"><a href=\"#中介费还可以再低\" class=\"headerlink\" title=\"中介费还可以再低\"></a>中介费还可以再低</h1><p>开口3%，谈到2.85%，实际2.5%</p>\n<h1 id=\"家居留什么没有仔细确认\"><a href=\"#家居留什么没有仔细确认\" class=\"headerlink\" title=\"家居留什么没有仔细确认\"></a>家居留什么没有仔细确认</h1>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"合同看的不够仔细\"><a href=\"#合同看的不够仔细\" class=\"headerlink\" title=\"合同看的不够仔细\"></a>合同看的不够仔细</h1><p>工具：ipad一字一句。</p>\n<h1 id=\"没有争取到有利于买方的合同\"><a href=\"#没有争取到有利于买方的合同\" class=\"headerlink\" title=\"没有争取到有利于买方的合同\"></a>没有争取到有利于买方的合同</h1><p>虽然谈了很多，细节确认了很多，但是其实并没有签一个买房合同</p>\n<h1 id=\"违约责任不明确\"><a href=\"#违约责任不明确\" class=\"headerlink\" title=\"违约责任不明确\"></a>违约责任不明确</h1><h1 id=\"价格谈的不够坚定\"><a href=\"#价格谈的不够坚定\" class=\"headerlink\" title=\"价格谈的不够坚定\"></a>价格谈的不够坚定</h1><h1 id=\"中介费还可以再低\"><a href=\"#中介费还可以再低\" class=\"headerlink\" title=\"中介费还可以再低\"></a>中介费还可以再低</h1><p>开口3%，谈到2.85%，实际2.5%</p>\n<h1 id=\"家居留什么没有仔细确认\"><a href=\"#家居留什么没有仔细确认\" class=\"headerlink\" title=\"家居留什么没有仔细确认\"></a>家居留什么没有仔细确认</h1>"},{"title":"ThreadPoolExecutor设计与实现","date":"2020-11-10T06:46:47.000Z","_content":"\n\n\n​      线程池是Java并发包中的重要部分，也是高并发程序必不可少的类库，但是线程池技术本身比较复杂，不同语言对其实现提供的抽象也不一样，所以本文以Java线程池为例，分析它的设计与实现，以及它所带我们的抽象。\n\n\n\n# 序言\n\n我对线程池的认识经历了以下三个阶段\n\n1   会使用Executors的API，觉得很cool，很简单。\n\n2   到配置线程池参数，理解线程池参数，池化资源复用，减少上下文切换，参数关系构成了线程池的执行过程。\n\n3  任务，任务提交，任务执行的抽象理解，从ThreadPoolExecutor到ScheduledThreadPoolExecutor到ForkJoinPool，CompletableFuture的理解。\n\n\n\n我现在的理解是：Java并发提供了三个核心抽象概念(`任务，任务提交和取消，任务执行`)，具体来说：\n\n1 **任务**  任务的抽象从Runnable，Callable，FutureTask，到ForkJoinTask 子类RecursiveTask，RecursiveAction，以及CompletableFuture中的Completion对ForkJoinTask 的继承，对AsynchronousCompletionTask的实现。\n\n2 **任务提交和取消**  从ExecutorService到ExecutorCompletionService，实现submit，invoke方法，核心子类：AbstractExecutorService作为骨架实现 \n\n3 **任务执行**  从Executor到核心子类ThreadPoolExecutor(核心方法execute)，ForkjoinPool(因为重写了提交机制，所以核心方法submit和execute)，ScheduledThreadPoolExecutor也是种执行机制。纯接口包含了命令模式，模板模式，状态机模式等等。这就意味着你可以自定义提交和执行机制。体现了多种策略和实现分别，非常漂亮。\n\n传统的**new Thread(new Runnable).start()**  将任务，任务提交，任务执行耦合起来，也没有提供任务取消的机制，显得那么得不可用，这篇博文主要以分析ThreadPoolExecutor为主，但是站在更高的抽象层次去看，会理解更深。\n\n\n\n# 结构\n\n## 任务结构\n\n![任务结构](/images/JUC-Task-Diagram.png)\n\n每个任务都有其抽象的含义，接下来我们将分析每一个接口的类型。\n\n```java\n//代表了任务执行没有结果\npublic interface Runnable {\n\tpublic abstract void run();\n}\n```\n\n\n\n```java\n//代表了一个任务执行有结果\npublic interface Callable<V> {\n    V call() throws Exception;\n}\n```\n\n\n\n\n\n```java\n//任务不仅仅被执行，还可以取消，完成，返回结果，Future对任务的抽象比Runnable更加全面，要知道通过原生Thread API\n//去取消一个任务是件复杂的事情\npublic interface Future<V> {\n\t//任务可以被中断取消，任务取消能力在Runnable不行的\n    boolean cancel(boolean mayInterruptIfRunning);\n    //任务是否已经取消\n    boolean isCancelled();\n    //任务是否完成\n    boolean isDone();\n    //任务返回结果，获取可能中断，也可能执行异常\n    V get() throws InterruptedException, ExecutionException;\n\t//在指定时间内返回结果\n    V get(long timeout, TimeUnit unit)\n        throws InterruptedException, ExecutionException, TimeoutException;\n}\n```\n\n\n\n```java\n//接口多继承，仅仅是将Runnable和Future的能力结合起来，是一个mixin接口，但是还是强调了run的能力\npublic interface RunnableFuture<V> extends Runnable, Future<V> {\n    void run();\n}\n```\n\n\n\n```java\n//真正的任务实现是FutureTask，FutureTask的构造对Callable和Runnable进行包装,使得任务成为FutureTask\n// ThreadPoolExecutor里面的实际任务是FutureTask\npublic class FutureTask<V> implements RunnableFuture<V> {\n\tpublic FutureTask(Callable<V> callable) {//忽略}\n    public FutureTask(Runnable runnable, V result) {//忽略}\n    //FutureTask源码在另外博客中会写，这里着重分析结构\n}\n```\n\n\n\n\n\n```java\n//ForkJoinTask也是一种Future类型任务，其内部提供了AdaptedRunnable，AdaptedCallable的适配类，\n//将任务适配成ForkJoinTask\npublic abstract class ForkJoinTask<V> implements Future<V>, Serializable {}\n```\n\n\n\n从上面可以看出，在JUC中，对于任务的抽象其实和任务的执行策略有关系，ThreadPoolExecutor执行的是FutureTask任务，而ScheduledThreadPoolExecutor执行的是ScheduledFutureTask，ForkJoinPool执行的是ForkJoinTask任务，这是多么清晰且统一的设计啊！\n\n\n\n## 任务提交和执行结构\n\n<img src=\"/images/Executor-Class-Diagram.png\" alt=\"任务提交\"/>\n\n\n\n```java\n//顶级接口，定义了任务执行，每一个任务是一个Runnable\npublic interface Executor {\n    void execute(Runnable command);\n}\n```\n\n\n\n但是仅仅有执行还不行，还要管理任务的取消和生命周期，所以提供了ExecutorService接口，如果说Executor定义了任务执行，\n\n那么ExecutorService提供提交定义了任务的提交和取消，提供了更加完整的任务生命周期的概念，注意到在这层抽象上，我们其实并不知道具体任务是怎么执行的(并行？串行？定期)，怎么被提交的，以及怎么返回结果的，真正的实现是具体的实现类。\n\n```java\n//Executor提供执行机制，ExecutorService提供提交，取消，完成，等待完成，批量执行任务机制，其中最核心的抽象的提交机制。\npublic interface ExecutorService extends Executor {\n    //结束\n\tvoid shutdown();\n    //里面结束，返回没有执行完的任务\n    List<Runnable> shutdownNow();\n    boolean isShutdown();\n    boolean isTerminated();\n    boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException;\n    //提交一个Callable，返回一个加强版的任务，可以获得结果，可以取消，可以判断时候完成\n\t<T> Future<T> submit(Callable<T> task);\n    <T> Future<T> submit(Runnable task, T result);\n    Future<?> submit(Runnable task);\n    //提交一批任务，返回所有的完成结果\n    <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)\n        throws InterruptedException;\n    <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks,\n                                  long timeout, TimeUnit unit)\n        throws InterruptedException;\n    //返回任意一个结果\n    <T> T invokeAny(Collection<? extends Callable<T>> tasks)\n        throws InterruptedException, ExecutionException;\n    <T> T invokeAny(Collection<? extends Callable<T>> tasks,\n                    long timeout, TimeUnit unit)\n        throws InterruptedException, ExecutionException, TimeoutException;\n    //继承了Executor的execute方法\n     void execute(Runnable command);\n}\n```\n\n\n\n可以看出，在抽象层，通过一系列接口来完成“任务，任务执行，任务提交和取消”等机制，而接下来章节将分析一种提交和执行机制，线程池，也就是ThreadPoolExecutor.\n\n\n\n# 设计与实现\n\n## ThrealPoolExecutor整体结构\n\n<img src=\"/images/ThreadPoolExecutor.png\" style=\"zoom:70%;\" />\n\n\n\n\n\n## AbstractExecutorService实现\n\nAbstractExecutorService仅仅为任务提交提供了骨架的实现，并没有为任务执行和取消提供实现，这也是面向接口设计的一个常用技巧，该类并没有实现Executor的execute方法，因为执行机制属于子类，我们其实可以提供默认实现。但是这样抽象类存在的价值将不是很大。\n\n我们来看一下他的提交机制有哪些？\n\n```java\n//将任务包装成RunnableFuture，实际子类是FutureTask，然后子类(其实就是ThreadPoolExecutor)实现execute执行任务，最后返回执行后的任务\npublic Future<?> submit(Runnable task) {\n    if (task == null) throw new NullPointerException();\n    RunnableFuture<Void> ftask = newTaskFor(task, null);\n    execute(ftask);\n    return ftask;\n}\n```\n\n\n\n```java\n//提交一个FutureTask，子类执行任务\npublic <T> Future<T> submit(Runnable task, T result) {\n    if (task == null) throw new NullPointerException();\n    RunnableFuture<T> ftask = newTaskFor(task, result);\n    execute(ftask);\n    return ftask;\n}\n```\n\n```java\npublic <T> Future<T> submit(Callable<T> task) {\n    if (task == null) throw new NullPointerException();\n    RunnableFuture<T> ftask = newTaskFor(task);\n    execute(ftask);\n    return ftask;\n}\n```\n\n\n\n```java\n//提交一组任务，并且返回所有的任务返回值\npublic <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)\n    throws InterruptedException {\n    if (tasks == null)\n        throw new NullPointerException();\n    //存放任务返回值的列表\n    ArrayList<Future<T>> futures = new ArrayList<Future<T>>(tasks.size());\n    boolean done = false;\n    try {\n        for (Callable<T> t : tasks) {\n            RunnableFuture<T> f = newTaskFor(t);\n            futures.add(f);\n            execute(f);\n        }\n        for (int i = 0, size = futures.size(); i < size; i++) {\n            Future<T> f = futures.get(i);\n            if (!f.isDone()) {\n                try {\n                    f.get();\n                } catch (CancellationException ignore) {\n                } catch (ExecutionException ignore) {\n                }\n            }\n        }\n        //任务全部执行完成成功，返回futures\n        done = true;\n        return futures;\n    } finally {\n        //如果没有完成，那么取消所有任务\n        if (!done)\n            for (int i = 0, size = futures.size(); i < size; i++)\n                futures.get(i).cancel(true);\n    }\n}\n```\n\n\n\n\n\n## FutureTask实现\n\n### 任务执行 \n\n该方法实现RunnableFuture，而RunnableFuture接口继承Runnable的run方法，所有本质是任务执行时候的方法。\n\n```java\npublic void run() {}\n```\n\n### 获取任务结果\n\n```java\npublic V get() throws InterruptedException, ExecutionException {}\n```\n\n### 获取有限时间任务结果\n\n```java\npublic V get(long timeout, TimeUnit unit)\n    throws InterruptedException, ExecutionException, TimeoutException {}\n```\n\n### 任务取消\n\n```java\npublic boolean cancel(boolean mayInterruptIfRunning) {}\n```\n\n\n\n\n\n## ThreadPoolExecutor API\n\nThreadPoolExecutor 公共API较多，但是每一个都很实用。\n\n我们主要分析和Executor和ExecutorService相关的API\n\n```java\npublic void execute(Runnable command) {}\n```\n\n\n\n核心构造函数：\n\n```java\npublic ThreadPoolExecutor(int corePoolSize,\n                          int maximumPoolSize,\n                          long keepAliveTime,\n                          TimeUnit unit,\n                          BlockingQueue<Runnable> workQueue,\n                          ThreadFactory threadFactory,\n                          RejectedExecutionHandler handler) {\n```\n\n\n\n## ThreadPoolExecutor实现\n\nThreadPoolExecutor实现了线程池这种执行任务的机制，所以最核心的方法就是execute，如提交相关的方法，在其父类AbstractExecutorService已经实现了，所以该类其实就是实现了任务执行机制execute.\n\nexecute实现提供的抽象概念有，**Worker**和**WorkQueue** . Worker主要处理任务，每一个Worker是一个运行的线程，在runWoker方法中一直轮询WorkQueue的任务并执行，WorkQueue主要用于存储任务。\n\n### 公共API-execute\n\n```java\npublic void execute(Runnable command) {\n    if (command == null)\n        throw new NullPointerException();\n    int c = ctl.get();\n    //没有超过核心线程数，新加worker处理，此时如果添加Worker成功，直接返回，如果失败，？？？\n    if (workerCountOf(c) < corePoolSize) {\n        if (addWorker(command, true))\n            return;\n        c = ctl.get();\n    }\n    //超过核心线程数，任务入队\n    if (isRunning(c) && workQueue.offer(command)) {\n        int recheck = ctl.get();\n        if (! isRunning(recheck) && remove(command))\n            reject(command);\n        else if (workerCountOf(recheck) == 0)\n            addWorker(null, false);\n    }\n    //任务队列已满，如果添加不到workQueue里面，则拒绝任务，如果能添加，则不拒绝\n    else if (!addWorker(command, false))\n        reject(command);\n}\n```\n\n\n\n### 私有方法-addWorker\n\n添加worker，并且启动worker，开始执行任务。\n\n```java\nprivate boolean addWorker(Runnable firstTask, boolean core) {\n    retry:\n    for (;;) {\n        int c = ctl.get();\n        int rs = runStateOf(c);\n\n        // Check if queue empty only if necessary.\n        if (rs >= SHUTDOWN &&\n            ! (rs == SHUTDOWN &&\n               firstTask == null &&\n               ! workQueue.isEmpty()))\n            return false;\n\n        for (;;) {\n            int wc = workerCountOf(c);\n            if (wc >= CAPACITY ||\n                wc >= (core ? corePoolSize : maximumPoolSize))\n                return false;\n            if (compareAndIncrementWorkerCount(c))\n                break retry;\n            c = ctl.get();  // Re-read ctl\n            if (runStateOf(c) != rs)\n                continue retry;\n            // else CAS failed due to workerCount change; retry inner loop\n        }\n    }\n\n    boolean workerStarted = false;\n    boolean workerAdded = false;\n    Worker w = null;\n    try {\n        w = new Worker(firstTask);\n        final Thread t = w.thread;\n        if (t != null) {\n            final ReentrantLock mainLock = this.mainLock;\n            mainLock.lock();\n            try {\n                // Recheck while holding lock.\n                // Back out on ThreadFactory failure or if\n                // shut down before lock acquired.\n                int rs = runStateOf(ctl.get());\n\n                if (rs < SHUTDOWN ||\n                    (rs == SHUTDOWN && firstTask == null)) {\n                    if (t.isAlive()) // precheck that t is startable\n                        throw new IllegalThreadStateException();\n                    //添加worker\n                    workers.add(w);\n                    int s = workers.size();\n                    if (s > largestPoolSize)\n                        largestPoolSize = s;\n                    workerAdded = true;\n                }\n            } finally {\n                mainLock.unlock();\n            }\n            if (workerAdded) {\n                //启动worker\n                t.start();\n                workerStarted = true;\n            }\n        }\n    } finally {\n        if (! workerStarted)\n            addWorkerFailed(w);\n    }\n    return workerStarted;\n}\n```\n\n\n\n### 私有方法-addWorkerFailed\n\n```java\nprivate void addWorkerFailed(Worker w) {\n    final ReentrantLock mainLock = this.mainLock;\n    mainLock.lock();\n    try {\n        if (w != null)\n            workers.remove(w);\n        decrementWorkerCount();\n        tryTerminate();\n    } finally {\n        mainLock.unlock();\n    }\n}\n```\n\n\n\n\n\n### 私有非静态成员类-Worker\n\nWorker即是锁(extends AbstractQueuedSynchronizer)，也是一个工作者线程(implements Runnable)，\n\n```java\n//这是一个互斥锁，且不支持重入！一个只能锁定一个任务，一个任务也只能被一个Worker锁住！\nprivate final class Worker extends AbstractQueuedSynchronizer implements Runnable {\n    /** Thread this worker is running in.  Null if factory fails. */\n    final Thread thread;\n    /** Initial task to run.  Possibly null. 第一个任务，后面的任务从workQueue中拿 */\n    Runnable firstTask;\n    /** Per-thread task counter */\n    volatile long completedTasks;\n\n    Worker(Runnable firstTask) {\n        setState(-1); // inhibit interrupts until runWorker\n        this.firstTask = firstTask;\n        this.thread = getThreadFactory().newThread(this);\n    }\n\n    /** Delegates main run loop to outer runWorker  */\n    public void run() {\n        //runWokker是每个worker最核心处理方法，在该方法中，进行任务获取，任务执行\n        runWorker(this);\n    }\n    // The value 0 represents the unlocked state. The value 1 represents the locked state.\n    protected boolean isHeldExclusively() {\n        return getState() != 0;\n    }\n    protected boolean tryAcquire(int unused) {\n        if (compareAndSetState(0, 1)) {\n            setExclusiveOwnerThread(Thread.currentThread());\n            return true;\n        }\n        return false;\n    }\n\n    protected boolean tryRelease(int unused) {\n        setExclusiveOwnerThread(null);\n        setState(0);\n        return true;\n    }\n\n    public void lock()        { acquire(1); }\n    public boolean tryLock()  { return tryAcquire(1); }\n    public void unlock()      { release(1); }\n    public boolean isLocked() { return isHeldExclusively(); }\n\n    void interruptIfStarted() {\n        Thread t;\n        if (getState() >= 0 && (t = thread) != null && !t.isInterrupted()) {\n            try {\n                t.interrupt();\n            } catch (SecurityException ignore) {\n            }\n        }\n    }\n}\n```\n\n\n\n### 私有方法runWorker\n\nworker处理task的核心方法，从队列中不停地拿任务。\n\n```java\nfinal void runWorker(Worker w) {\n    Thread wt = Thread.currentThread();\n    Runnable task = w.firstTask;\n    w.firstTask = null;\n    w.unlock(); // allow interrupts\n    boolean completedAbruptly = true;\n    try {\n        //如果是prestartAllCoreThreads，将不会进入while循环，只是start一个线程，但是不处理如何任务\n        //task != null(少于核心线程数的任务)     task = getTask() 在阻塞队列中的任务\n        while (task != null || (task = getTask()) != null) {\n            w.lock();\n            // If pool is stopping, ensure thread is interrupted;\n            // if not, ensure thread is not interrupted.  This\n            // requires a recheck in second case to deal with\n            // shutdownNow race while clearing interrupt\n            if ((runStateAtLeast(ctl.get(), STOP) ||\n                 (Thread.interrupted() &&\n                  runStateAtLeast(ctl.get(), STOP))) &&\n                !wt.isInterrupted())\n                wt.interrupt();\n            try {\n                //扩展钩子方法，任务处理前的方法\n                beforeExecute(wt, task);\n                Throwable thrown = null;\n                try {\n                    //这是接口方法，客户端自定义的任务在这里执行，其实从实现来看执行的FutureTask的run方法\n                    task.run();\n                    //以下异常是任务抛出的异常,如果抛出异常，则退出Main Loop，然后设置completedAbruptly=false\n                    //此时会进入processWorkerExit方法\n                } catch (RuntimeException x) {\n                    thrown = x; throw x;\n                } catch (Error x) {\n                    thrown = x; throw x;\n                } catch (Throwable x) {\n                    thrown = x; throw new Error(x);\n                } finally {\n                    //扩展钩子方法：任务执行后的处理\n                    afterExecute(task, thrown);\n                }\n            } finally {\n                task = null;\n                w.completedTasks++;\n                w.unlock();\n            }\n        }\n        completedAbruptly = false;\n    } finally {\n        processWorkerExit(w, completedAbruptly);\n    }\n}\n```\n\n\n\n### 私有方法-processWorkerExit\n\n该方法用户处理Worker因为异常情况退出，比如任务抛出异常，或者Worker被中断了\n\n```java\nprivate void processWorkerExit(Worker w, boolean completedAbruptly) {\n    if (completedAbruptly) // If abrupt, then workerCount wasn't adjusted\n        decrementWorkerCount();\n\n    final ReentrantLock mainLock = this.mainLock;\n    mainLock.lock();\n    try {\n        completedTaskCount += w.completedTasks;\n        //删除Worker\n        workers.remove(w);\n    } finally {\n        mainLock.unlock();\n    }\n\n    tryTerminate();\n\n    int c = ctl.get();\n    if (runStateLessThan(c, STOP)) {\n        if (!completedAbruptly) {\n            int min = allowCoreThreadTimeOut ? 0 : corePoolSize;\n            if (min == 0 && ! workQueue.isEmpty())\n                min = 1;\n            if (workerCountOf(c) >= min)\n                //工作的Worker大于min，则没必要替换，直接返回\n                return; // replacement not needed\n        }\n        //启动新的Worker处理任务\n        addWorker(null, false);\n    }\n}\n```\n\n\n\n### 私有方法-getTask\n\n```java\nprivate Runnable getTask() {\n    boolean timedOut = false; // Did the last poll() time out?\n\t//不断在阻塞获取任务\n    for (;;) {\n        int c = ctl.get();\n        int rs = runStateOf(c);\n\n        // Check if queue empty only if necessary.\n        if (rs >= SHUTDOWN && (rs >= STOP || workQueue.isEmpty())) {\n            decrementWorkerCount();\n            return null;\n        }\n\n        int wc = workerCountOf(c);\n\n        // Are workers subject to culling?\n        boolean timed = allowCoreThreadTimeOut || wc > corePoolSize;\n\n        if ((wc > maximumPoolSize || (timed && timedOut))\n            && (wc > 1 || workQueue.isEmpty())) {\n            if (compareAndDecrementWorkerCount(c))\n                return null;\n            continue;\n        }\n\n        try {\n            //如果allowCoreThreadTimeOut是true，在keepAliveTime时间内，没有任务到来，\n            Runnable r = timed ?\n                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :\n                workQueue.take();\n            if (r != null)\n                return r;\n            timedOut = true;\n        } catch (InterruptedException retry) {\n            timedOut = false;\n        }\n    }\n}\n```\n\n\n\n\n\n\n\n### 私有方法-interruptIdleWorkers\n\n```java\nprivate void interruptIdleWorkers(boolean onlyOne) {\n    final ReentrantLock mainLock = this.mainLock;\n    mainLock.lock();\n    try {\n        for (Worker w : workers) {\n            Thread t = w.thread;\n            if (!t.isInterrupted() && w.tryLock()) {\n                try {\n                    t.interrupt();\n                } catch (SecurityException ignore) {\n                } finally {\n                    w.unlock();\n                }\n            }\n            if (onlyOne)\n                break;\n        }\n    } finally {\n        mainLock.unlock();\n    }\n}\n```\n\n\n\n\n\n### 公共API-shutdown\n\n```java\npublic void shutdown() {\n    final ReentrantLock mainLock = this.mainLock;\n    mainLock.lock();\n    try {\n        //检查关闭权限\n        checkShutdownAccess();\n        //线程池状态设置为SHUTDOWN\n        advanceRunState(SHUTDOWN);\n        //中断所有的空闲的Worker，此时真正执行任务的Worker不会被中断，因为获取不到锁\n        interruptIdleWorkers();\n        onShutdown(); // hook for ScheduledThreadPoolExecutor\n    } finally {\n        mainLock.unlock();\n    }\n    tryTerminate();\n}\n```\n\n\n\n### 公共API-shutdownNow\n\n```java\npublic List<Runnable> shutdownNow() {\n    List<Runnable> tasks;\n    final ReentrantLock mainLock = this.mainLock;\n    mainLock.lock();\n    try {\n        checkShutdownAccess();\n        advanceRunState(STOP);\n        interruptWorkers();\n        //workQueue中所有的任务会被取出来，然后交由客户端处理\n        tasks = drainQueue();\n    } finally {\n        mainLock.unlock();\n    }\n    tryTerminate();\n    return tasks;\n}\n```\n\n### 公共API-allowCoreThreadTimeOut\n\n```java\npublic void allowCoreThreadTimeOut(boolean value) {\n    if (value && keepAliveTime <= 0)\n        throw new IllegalArgumentException(\"Core threads must have nonzero keep alive times\");\n    if (value != allowCoreThreadTimeOut) {\n        allowCoreThreadTimeOut = value;\n        if (value)\n            interruptIdleWorkers();\n    }\n}\n```\n\n\n\n### 公共API-prestartAllCoreThreads\n\n```java\npublic int prestartAllCoreThreads() {\n    int n = 0;\n    //firstTask是null,core是true，这时候只会启动线程，但是不会执行任何任务\n    while (addWorker(null, true))\n        ++n;\n    return n;\n}\n```\n\n\n\n\n\n### 工具方法\n\n```java\nprivate static int runStateOf(int c)     { return c & ~CAPACITY; }\nprivate static int workerCountOf(int c)  { return c & CAPACITY; }\nprivate static int ctlOf(int rs, int wc) { return rs | wc; }\nprivate static boolean runStateLessThan(int c, int s) {\n\treturn c < s;\n}\nprivate static boolean runStateAtLeast(int c, int s) {\n\treturn c >= s;\n}\n\nprivate static boolean isRunning(int c) {\n\treturn c < SHUTDOWN;\n}\n\n```\n\n\n\n### 静态字段\n\n```java\nprivate final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));\nprivate static final int COUNT_BITS = Integer.SIZE - 3;\nprivate static final int CAPACITY   = (1 << COUNT_BITS) - 1;\n\n// runState is stored in the high-order bits\nprivate static final int RUNNING    = -1 << COUNT_BITS;\nprivate static final int SHUTDOWN   =  0 << COUNT_BITS;\nprivate static final int STOP       =  1 << COUNT_BITS;\nprivate static final int TIDYING    =  2 << COUNT_BITS;\nprivate static final int TERMINATED =  3 << COUNT_BITS;\n```\n\n\n\n\n\n\n\n## Executors实现\n\nExecutors是对执行者的静态工厂类，提供了常用的执行策略，并且提供了对任务的包装。\n\n\n\n# 实战案例\n\n## tomcat线程池解读\n\norg.apache.tomcat.util.threads.ThreadPoolExecutor \n\n\n\n## 扩展ThreadPoolExecutor\n\n\n\n## 多元化的拒绝策略\n\n\n\n## Apache HttpComponents Worker\n\n```\nWorkerPoolExecutor\n```\n\n\n\n## Spring的抽象\n\n\n\n\n\n\n\n\n\n# 结论和启示","source":"_posts/ThreadPoolExecutor-API-explain.md","raw":"---\ntitle: ThreadPoolExecutor设计与实现\ndate: 2020-11-10 14:46:47\ntags: java.util.concurrent\ncategories:\n  - JDK源码\n  - Java并发框架\n---\n\n\n\n​      线程池是Java并发包中的重要部分，也是高并发程序必不可少的类库，但是线程池技术本身比较复杂，不同语言对其实现提供的抽象也不一样，所以本文以Java线程池为例，分析它的设计与实现，以及它所带我们的抽象。\n\n\n\n# 序言\n\n我对线程池的认识经历了以下三个阶段\n\n1   会使用Executors的API，觉得很cool，很简单。\n\n2   到配置线程池参数，理解线程池参数，池化资源复用，减少上下文切换，参数关系构成了线程池的执行过程。\n\n3  任务，任务提交，任务执行的抽象理解，从ThreadPoolExecutor到ScheduledThreadPoolExecutor到ForkJoinPool，CompletableFuture的理解。\n\n\n\n我现在的理解是：Java并发提供了三个核心抽象概念(`任务，任务提交和取消，任务执行`)，具体来说：\n\n1 **任务**  任务的抽象从Runnable，Callable，FutureTask，到ForkJoinTask 子类RecursiveTask，RecursiveAction，以及CompletableFuture中的Completion对ForkJoinTask 的继承，对AsynchronousCompletionTask的实现。\n\n2 **任务提交和取消**  从ExecutorService到ExecutorCompletionService，实现submit，invoke方法，核心子类：AbstractExecutorService作为骨架实现 \n\n3 **任务执行**  从Executor到核心子类ThreadPoolExecutor(核心方法execute)，ForkjoinPool(因为重写了提交机制，所以核心方法submit和execute)，ScheduledThreadPoolExecutor也是种执行机制。纯接口包含了命令模式，模板模式，状态机模式等等。这就意味着你可以自定义提交和执行机制。体现了多种策略和实现分别，非常漂亮。\n\n传统的**new Thread(new Runnable).start()**  将任务，任务提交，任务执行耦合起来，也没有提供任务取消的机制，显得那么得不可用，这篇博文主要以分析ThreadPoolExecutor为主，但是站在更高的抽象层次去看，会理解更深。\n\n\n\n# 结构\n\n## 任务结构\n\n![任务结构](/images/JUC-Task-Diagram.png)\n\n每个任务都有其抽象的含义，接下来我们将分析每一个接口的类型。\n\n```java\n//代表了任务执行没有结果\npublic interface Runnable {\n\tpublic abstract void run();\n}\n```\n\n\n\n```java\n//代表了一个任务执行有结果\npublic interface Callable<V> {\n    V call() throws Exception;\n}\n```\n\n\n\n\n\n```java\n//任务不仅仅被执行，还可以取消，完成，返回结果，Future对任务的抽象比Runnable更加全面，要知道通过原生Thread API\n//去取消一个任务是件复杂的事情\npublic interface Future<V> {\n\t//任务可以被中断取消，任务取消能力在Runnable不行的\n    boolean cancel(boolean mayInterruptIfRunning);\n    //任务是否已经取消\n    boolean isCancelled();\n    //任务是否完成\n    boolean isDone();\n    //任务返回结果，获取可能中断，也可能执行异常\n    V get() throws InterruptedException, ExecutionException;\n\t//在指定时间内返回结果\n    V get(long timeout, TimeUnit unit)\n        throws InterruptedException, ExecutionException, TimeoutException;\n}\n```\n\n\n\n```java\n//接口多继承，仅仅是将Runnable和Future的能力结合起来，是一个mixin接口，但是还是强调了run的能力\npublic interface RunnableFuture<V> extends Runnable, Future<V> {\n    void run();\n}\n```\n\n\n\n```java\n//真正的任务实现是FutureTask，FutureTask的构造对Callable和Runnable进行包装,使得任务成为FutureTask\n// ThreadPoolExecutor里面的实际任务是FutureTask\npublic class FutureTask<V> implements RunnableFuture<V> {\n\tpublic FutureTask(Callable<V> callable) {//忽略}\n    public FutureTask(Runnable runnable, V result) {//忽略}\n    //FutureTask源码在另外博客中会写，这里着重分析结构\n}\n```\n\n\n\n\n\n```java\n//ForkJoinTask也是一种Future类型任务，其内部提供了AdaptedRunnable，AdaptedCallable的适配类，\n//将任务适配成ForkJoinTask\npublic abstract class ForkJoinTask<V> implements Future<V>, Serializable {}\n```\n\n\n\n从上面可以看出，在JUC中，对于任务的抽象其实和任务的执行策略有关系，ThreadPoolExecutor执行的是FutureTask任务，而ScheduledThreadPoolExecutor执行的是ScheduledFutureTask，ForkJoinPool执行的是ForkJoinTask任务，这是多么清晰且统一的设计啊！\n\n\n\n## 任务提交和执行结构\n\n<img src=\"/images/Executor-Class-Diagram.png\" alt=\"任务提交\"/>\n\n\n\n```java\n//顶级接口，定义了任务执行，每一个任务是一个Runnable\npublic interface Executor {\n    void execute(Runnable command);\n}\n```\n\n\n\n但是仅仅有执行还不行，还要管理任务的取消和生命周期，所以提供了ExecutorService接口，如果说Executor定义了任务执行，\n\n那么ExecutorService提供提交定义了任务的提交和取消，提供了更加完整的任务生命周期的概念，注意到在这层抽象上，我们其实并不知道具体任务是怎么执行的(并行？串行？定期)，怎么被提交的，以及怎么返回结果的，真正的实现是具体的实现类。\n\n```java\n//Executor提供执行机制，ExecutorService提供提交，取消，完成，等待完成，批量执行任务机制，其中最核心的抽象的提交机制。\npublic interface ExecutorService extends Executor {\n    //结束\n\tvoid shutdown();\n    //里面结束，返回没有执行完的任务\n    List<Runnable> shutdownNow();\n    boolean isShutdown();\n    boolean isTerminated();\n    boolean awaitTermination(long timeout, TimeUnit unit) throws InterruptedException;\n    //提交一个Callable，返回一个加强版的任务，可以获得结果，可以取消，可以判断时候完成\n\t<T> Future<T> submit(Callable<T> task);\n    <T> Future<T> submit(Runnable task, T result);\n    Future<?> submit(Runnable task);\n    //提交一批任务，返回所有的完成结果\n    <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)\n        throws InterruptedException;\n    <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks,\n                                  long timeout, TimeUnit unit)\n        throws InterruptedException;\n    //返回任意一个结果\n    <T> T invokeAny(Collection<? extends Callable<T>> tasks)\n        throws InterruptedException, ExecutionException;\n    <T> T invokeAny(Collection<? extends Callable<T>> tasks,\n                    long timeout, TimeUnit unit)\n        throws InterruptedException, ExecutionException, TimeoutException;\n    //继承了Executor的execute方法\n     void execute(Runnable command);\n}\n```\n\n\n\n可以看出，在抽象层，通过一系列接口来完成“任务，任务执行，任务提交和取消”等机制，而接下来章节将分析一种提交和执行机制，线程池，也就是ThreadPoolExecutor.\n\n\n\n# 设计与实现\n\n## ThrealPoolExecutor整体结构\n\n<img src=\"/images/ThreadPoolExecutor.png\" style=\"zoom:70%;\" />\n\n\n\n\n\n## AbstractExecutorService实现\n\nAbstractExecutorService仅仅为任务提交提供了骨架的实现，并没有为任务执行和取消提供实现，这也是面向接口设计的一个常用技巧，该类并没有实现Executor的execute方法，因为执行机制属于子类，我们其实可以提供默认实现。但是这样抽象类存在的价值将不是很大。\n\n我们来看一下他的提交机制有哪些？\n\n```java\n//将任务包装成RunnableFuture，实际子类是FutureTask，然后子类(其实就是ThreadPoolExecutor)实现execute执行任务，最后返回执行后的任务\npublic Future<?> submit(Runnable task) {\n    if (task == null) throw new NullPointerException();\n    RunnableFuture<Void> ftask = newTaskFor(task, null);\n    execute(ftask);\n    return ftask;\n}\n```\n\n\n\n```java\n//提交一个FutureTask，子类执行任务\npublic <T> Future<T> submit(Runnable task, T result) {\n    if (task == null) throw new NullPointerException();\n    RunnableFuture<T> ftask = newTaskFor(task, result);\n    execute(ftask);\n    return ftask;\n}\n```\n\n```java\npublic <T> Future<T> submit(Callable<T> task) {\n    if (task == null) throw new NullPointerException();\n    RunnableFuture<T> ftask = newTaskFor(task);\n    execute(ftask);\n    return ftask;\n}\n```\n\n\n\n```java\n//提交一组任务，并且返回所有的任务返回值\npublic <T> List<Future<T>> invokeAll(Collection<? extends Callable<T>> tasks)\n    throws InterruptedException {\n    if (tasks == null)\n        throw new NullPointerException();\n    //存放任务返回值的列表\n    ArrayList<Future<T>> futures = new ArrayList<Future<T>>(tasks.size());\n    boolean done = false;\n    try {\n        for (Callable<T> t : tasks) {\n            RunnableFuture<T> f = newTaskFor(t);\n            futures.add(f);\n            execute(f);\n        }\n        for (int i = 0, size = futures.size(); i < size; i++) {\n            Future<T> f = futures.get(i);\n            if (!f.isDone()) {\n                try {\n                    f.get();\n                } catch (CancellationException ignore) {\n                } catch (ExecutionException ignore) {\n                }\n            }\n        }\n        //任务全部执行完成成功，返回futures\n        done = true;\n        return futures;\n    } finally {\n        //如果没有完成，那么取消所有任务\n        if (!done)\n            for (int i = 0, size = futures.size(); i < size; i++)\n                futures.get(i).cancel(true);\n    }\n}\n```\n\n\n\n\n\n## FutureTask实现\n\n### 任务执行 \n\n该方法实现RunnableFuture，而RunnableFuture接口继承Runnable的run方法，所有本质是任务执行时候的方法。\n\n```java\npublic void run() {}\n```\n\n### 获取任务结果\n\n```java\npublic V get() throws InterruptedException, ExecutionException {}\n```\n\n### 获取有限时间任务结果\n\n```java\npublic V get(long timeout, TimeUnit unit)\n    throws InterruptedException, ExecutionException, TimeoutException {}\n```\n\n### 任务取消\n\n```java\npublic boolean cancel(boolean mayInterruptIfRunning) {}\n```\n\n\n\n\n\n## ThreadPoolExecutor API\n\nThreadPoolExecutor 公共API较多，但是每一个都很实用。\n\n我们主要分析和Executor和ExecutorService相关的API\n\n```java\npublic void execute(Runnable command) {}\n```\n\n\n\n核心构造函数：\n\n```java\npublic ThreadPoolExecutor(int corePoolSize,\n                          int maximumPoolSize,\n                          long keepAliveTime,\n                          TimeUnit unit,\n                          BlockingQueue<Runnable> workQueue,\n                          ThreadFactory threadFactory,\n                          RejectedExecutionHandler handler) {\n```\n\n\n\n## ThreadPoolExecutor实现\n\nThreadPoolExecutor实现了线程池这种执行任务的机制，所以最核心的方法就是execute，如提交相关的方法，在其父类AbstractExecutorService已经实现了，所以该类其实就是实现了任务执行机制execute.\n\nexecute实现提供的抽象概念有，**Worker**和**WorkQueue** . Worker主要处理任务，每一个Worker是一个运行的线程，在runWoker方法中一直轮询WorkQueue的任务并执行，WorkQueue主要用于存储任务。\n\n### 公共API-execute\n\n```java\npublic void execute(Runnable command) {\n    if (command == null)\n        throw new NullPointerException();\n    int c = ctl.get();\n    //没有超过核心线程数，新加worker处理，此时如果添加Worker成功，直接返回，如果失败，？？？\n    if (workerCountOf(c) < corePoolSize) {\n        if (addWorker(command, true))\n            return;\n        c = ctl.get();\n    }\n    //超过核心线程数，任务入队\n    if (isRunning(c) && workQueue.offer(command)) {\n        int recheck = ctl.get();\n        if (! isRunning(recheck) && remove(command))\n            reject(command);\n        else if (workerCountOf(recheck) == 0)\n            addWorker(null, false);\n    }\n    //任务队列已满，如果添加不到workQueue里面，则拒绝任务，如果能添加，则不拒绝\n    else if (!addWorker(command, false))\n        reject(command);\n}\n```\n\n\n\n### 私有方法-addWorker\n\n添加worker，并且启动worker，开始执行任务。\n\n```java\nprivate boolean addWorker(Runnable firstTask, boolean core) {\n    retry:\n    for (;;) {\n        int c = ctl.get();\n        int rs = runStateOf(c);\n\n        // Check if queue empty only if necessary.\n        if (rs >= SHUTDOWN &&\n            ! (rs == SHUTDOWN &&\n               firstTask == null &&\n               ! workQueue.isEmpty()))\n            return false;\n\n        for (;;) {\n            int wc = workerCountOf(c);\n            if (wc >= CAPACITY ||\n                wc >= (core ? corePoolSize : maximumPoolSize))\n                return false;\n            if (compareAndIncrementWorkerCount(c))\n                break retry;\n            c = ctl.get();  // Re-read ctl\n            if (runStateOf(c) != rs)\n                continue retry;\n            // else CAS failed due to workerCount change; retry inner loop\n        }\n    }\n\n    boolean workerStarted = false;\n    boolean workerAdded = false;\n    Worker w = null;\n    try {\n        w = new Worker(firstTask);\n        final Thread t = w.thread;\n        if (t != null) {\n            final ReentrantLock mainLock = this.mainLock;\n            mainLock.lock();\n            try {\n                // Recheck while holding lock.\n                // Back out on ThreadFactory failure or if\n                // shut down before lock acquired.\n                int rs = runStateOf(ctl.get());\n\n                if (rs < SHUTDOWN ||\n                    (rs == SHUTDOWN && firstTask == null)) {\n                    if (t.isAlive()) // precheck that t is startable\n                        throw new IllegalThreadStateException();\n                    //添加worker\n                    workers.add(w);\n                    int s = workers.size();\n                    if (s > largestPoolSize)\n                        largestPoolSize = s;\n                    workerAdded = true;\n                }\n            } finally {\n                mainLock.unlock();\n            }\n            if (workerAdded) {\n                //启动worker\n                t.start();\n                workerStarted = true;\n            }\n        }\n    } finally {\n        if (! workerStarted)\n            addWorkerFailed(w);\n    }\n    return workerStarted;\n}\n```\n\n\n\n### 私有方法-addWorkerFailed\n\n```java\nprivate void addWorkerFailed(Worker w) {\n    final ReentrantLock mainLock = this.mainLock;\n    mainLock.lock();\n    try {\n        if (w != null)\n            workers.remove(w);\n        decrementWorkerCount();\n        tryTerminate();\n    } finally {\n        mainLock.unlock();\n    }\n}\n```\n\n\n\n\n\n### 私有非静态成员类-Worker\n\nWorker即是锁(extends AbstractQueuedSynchronizer)，也是一个工作者线程(implements Runnable)，\n\n```java\n//这是一个互斥锁，且不支持重入！一个只能锁定一个任务，一个任务也只能被一个Worker锁住！\nprivate final class Worker extends AbstractQueuedSynchronizer implements Runnable {\n    /** Thread this worker is running in.  Null if factory fails. */\n    final Thread thread;\n    /** Initial task to run.  Possibly null. 第一个任务，后面的任务从workQueue中拿 */\n    Runnable firstTask;\n    /** Per-thread task counter */\n    volatile long completedTasks;\n\n    Worker(Runnable firstTask) {\n        setState(-1); // inhibit interrupts until runWorker\n        this.firstTask = firstTask;\n        this.thread = getThreadFactory().newThread(this);\n    }\n\n    /** Delegates main run loop to outer runWorker  */\n    public void run() {\n        //runWokker是每个worker最核心处理方法，在该方法中，进行任务获取，任务执行\n        runWorker(this);\n    }\n    // The value 0 represents the unlocked state. The value 1 represents the locked state.\n    protected boolean isHeldExclusively() {\n        return getState() != 0;\n    }\n    protected boolean tryAcquire(int unused) {\n        if (compareAndSetState(0, 1)) {\n            setExclusiveOwnerThread(Thread.currentThread());\n            return true;\n        }\n        return false;\n    }\n\n    protected boolean tryRelease(int unused) {\n        setExclusiveOwnerThread(null);\n        setState(0);\n        return true;\n    }\n\n    public void lock()        { acquire(1); }\n    public boolean tryLock()  { return tryAcquire(1); }\n    public void unlock()      { release(1); }\n    public boolean isLocked() { return isHeldExclusively(); }\n\n    void interruptIfStarted() {\n        Thread t;\n        if (getState() >= 0 && (t = thread) != null && !t.isInterrupted()) {\n            try {\n                t.interrupt();\n            } catch (SecurityException ignore) {\n            }\n        }\n    }\n}\n```\n\n\n\n### 私有方法runWorker\n\nworker处理task的核心方法，从队列中不停地拿任务。\n\n```java\nfinal void runWorker(Worker w) {\n    Thread wt = Thread.currentThread();\n    Runnable task = w.firstTask;\n    w.firstTask = null;\n    w.unlock(); // allow interrupts\n    boolean completedAbruptly = true;\n    try {\n        //如果是prestartAllCoreThreads，将不会进入while循环，只是start一个线程，但是不处理如何任务\n        //task != null(少于核心线程数的任务)     task = getTask() 在阻塞队列中的任务\n        while (task != null || (task = getTask()) != null) {\n            w.lock();\n            // If pool is stopping, ensure thread is interrupted;\n            // if not, ensure thread is not interrupted.  This\n            // requires a recheck in second case to deal with\n            // shutdownNow race while clearing interrupt\n            if ((runStateAtLeast(ctl.get(), STOP) ||\n                 (Thread.interrupted() &&\n                  runStateAtLeast(ctl.get(), STOP))) &&\n                !wt.isInterrupted())\n                wt.interrupt();\n            try {\n                //扩展钩子方法，任务处理前的方法\n                beforeExecute(wt, task);\n                Throwable thrown = null;\n                try {\n                    //这是接口方法，客户端自定义的任务在这里执行，其实从实现来看执行的FutureTask的run方法\n                    task.run();\n                    //以下异常是任务抛出的异常,如果抛出异常，则退出Main Loop，然后设置completedAbruptly=false\n                    //此时会进入processWorkerExit方法\n                } catch (RuntimeException x) {\n                    thrown = x; throw x;\n                } catch (Error x) {\n                    thrown = x; throw x;\n                } catch (Throwable x) {\n                    thrown = x; throw new Error(x);\n                } finally {\n                    //扩展钩子方法：任务执行后的处理\n                    afterExecute(task, thrown);\n                }\n            } finally {\n                task = null;\n                w.completedTasks++;\n                w.unlock();\n            }\n        }\n        completedAbruptly = false;\n    } finally {\n        processWorkerExit(w, completedAbruptly);\n    }\n}\n```\n\n\n\n### 私有方法-processWorkerExit\n\n该方法用户处理Worker因为异常情况退出，比如任务抛出异常，或者Worker被中断了\n\n```java\nprivate void processWorkerExit(Worker w, boolean completedAbruptly) {\n    if (completedAbruptly) // If abrupt, then workerCount wasn't adjusted\n        decrementWorkerCount();\n\n    final ReentrantLock mainLock = this.mainLock;\n    mainLock.lock();\n    try {\n        completedTaskCount += w.completedTasks;\n        //删除Worker\n        workers.remove(w);\n    } finally {\n        mainLock.unlock();\n    }\n\n    tryTerminate();\n\n    int c = ctl.get();\n    if (runStateLessThan(c, STOP)) {\n        if (!completedAbruptly) {\n            int min = allowCoreThreadTimeOut ? 0 : corePoolSize;\n            if (min == 0 && ! workQueue.isEmpty())\n                min = 1;\n            if (workerCountOf(c) >= min)\n                //工作的Worker大于min，则没必要替换，直接返回\n                return; // replacement not needed\n        }\n        //启动新的Worker处理任务\n        addWorker(null, false);\n    }\n}\n```\n\n\n\n### 私有方法-getTask\n\n```java\nprivate Runnable getTask() {\n    boolean timedOut = false; // Did the last poll() time out?\n\t//不断在阻塞获取任务\n    for (;;) {\n        int c = ctl.get();\n        int rs = runStateOf(c);\n\n        // Check if queue empty only if necessary.\n        if (rs >= SHUTDOWN && (rs >= STOP || workQueue.isEmpty())) {\n            decrementWorkerCount();\n            return null;\n        }\n\n        int wc = workerCountOf(c);\n\n        // Are workers subject to culling?\n        boolean timed = allowCoreThreadTimeOut || wc > corePoolSize;\n\n        if ((wc > maximumPoolSize || (timed && timedOut))\n            && (wc > 1 || workQueue.isEmpty())) {\n            if (compareAndDecrementWorkerCount(c))\n                return null;\n            continue;\n        }\n\n        try {\n            //如果allowCoreThreadTimeOut是true，在keepAliveTime时间内，没有任务到来，\n            Runnable r = timed ?\n                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :\n                workQueue.take();\n            if (r != null)\n                return r;\n            timedOut = true;\n        } catch (InterruptedException retry) {\n            timedOut = false;\n        }\n    }\n}\n```\n\n\n\n\n\n\n\n### 私有方法-interruptIdleWorkers\n\n```java\nprivate void interruptIdleWorkers(boolean onlyOne) {\n    final ReentrantLock mainLock = this.mainLock;\n    mainLock.lock();\n    try {\n        for (Worker w : workers) {\n            Thread t = w.thread;\n            if (!t.isInterrupted() && w.tryLock()) {\n                try {\n                    t.interrupt();\n                } catch (SecurityException ignore) {\n                } finally {\n                    w.unlock();\n                }\n            }\n            if (onlyOne)\n                break;\n        }\n    } finally {\n        mainLock.unlock();\n    }\n}\n```\n\n\n\n\n\n### 公共API-shutdown\n\n```java\npublic void shutdown() {\n    final ReentrantLock mainLock = this.mainLock;\n    mainLock.lock();\n    try {\n        //检查关闭权限\n        checkShutdownAccess();\n        //线程池状态设置为SHUTDOWN\n        advanceRunState(SHUTDOWN);\n        //中断所有的空闲的Worker，此时真正执行任务的Worker不会被中断，因为获取不到锁\n        interruptIdleWorkers();\n        onShutdown(); // hook for ScheduledThreadPoolExecutor\n    } finally {\n        mainLock.unlock();\n    }\n    tryTerminate();\n}\n```\n\n\n\n### 公共API-shutdownNow\n\n```java\npublic List<Runnable> shutdownNow() {\n    List<Runnable> tasks;\n    final ReentrantLock mainLock = this.mainLock;\n    mainLock.lock();\n    try {\n        checkShutdownAccess();\n        advanceRunState(STOP);\n        interruptWorkers();\n        //workQueue中所有的任务会被取出来，然后交由客户端处理\n        tasks = drainQueue();\n    } finally {\n        mainLock.unlock();\n    }\n    tryTerminate();\n    return tasks;\n}\n```\n\n### 公共API-allowCoreThreadTimeOut\n\n```java\npublic void allowCoreThreadTimeOut(boolean value) {\n    if (value && keepAliveTime <= 0)\n        throw new IllegalArgumentException(\"Core threads must have nonzero keep alive times\");\n    if (value != allowCoreThreadTimeOut) {\n        allowCoreThreadTimeOut = value;\n        if (value)\n            interruptIdleWorkers();\n    }\n}\n```\n\n\n\n### 公共API-prestartAllCoreThreads\n\n```java\npublic int prestartAllCoreThreads() {\n    int n = 0;\n    //firstTask是null,core是true，这时候只会启动线程，但是不会执行任何任务\n    while (addWorker(null, true))\n        ++n;\n    return n;\n}\n```\n\n\n\n\n\n### 工具方法\n\n```java\nprivate static int runStateOf(int c)     { return c & ~CAPACITY; }\nprivate static int workerCountOf(int c)  { return c & CAPACITY; }\nprivate static int ctlOf(int rs, int wc) { return rs | wc; }\nprivate static boolean runStateLessThan(int c, int s) {\n\treturn c < s;\n}\nprivate static boolean runStateAtLeast(int c, int s) {\n\treturn c >= s;\n}\n\nprivate static boolean isRunning(int c) {\n\treturn c < SHUTDOWN;\n}\n\n```\n\n\n\n### 静态字段\n\n```java\nprivate final AtomicInteger ctl = new AtomicInteger(ctlOf(RUNNING, 0));\nprivate static final int COUNT_BITS = Integer.SIZE - 3;\nprivate static final int CAPACITY   = (1 << COUNT_BITS) - 1;\n\n// runState is stored in the high-order bits\nprivate static final int RUNNING    = -1 << COUNT_BITS;\nprivate static final int SHUTDOWN   =  0 << COUNT_BITS;\nprivate static final int STOP       =  1 << COUNT_BITS;\nprivate static final int TIDYING    =  2 << COUNT_BITS;\nprivate static final int TERMINATED =  3 << COUNT_BITS;\n```\n\n\n\n\n\n\n\n## Executors实现\n\nExecutors是对执行者的静态工厂类，提供了常用的执行策略，并且提供了对任务的包装。\n\n\n\n# 实战案例\n\n## tomcat线程池解读\n\norg.apache.tomcat.util.threads.ThreadPoolExecutor \n\n\n\n## 扩展ThreadPoolExecutor\n\n\n\n## 多元化的拒绝策略\n\n\n\n## Apache HttpComponents Worker\n\n```\nWorkerPoolExecutor\n```\n\n\n\n## Spring的抽象\n\n\n\n\n\n\n\n\n\n# 结论和启示","slug":"ThreadPoolExecutor-API-explain","published":1,"updated":"2022-06-28T17:24:04.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clh7s5ctt000sxt8j0fn4eyva","content":"<p>​      线程池是Java并发包中的重要部分，也是高并发程序必不可少的类库，但是线程池技术本身比较复杂，不同语言对其实现提供的抽象也不一样，所以本文以Java线程池为例，分析它的设计与实现，以及它所带我们的抽象。</p>\n<h1 id=\"序言\"><a href=\"#序言\" class=\"headerlink\" title=\"序言\"></a>序言</h1><p>我对线程池的认识经历了以下三个阶段</p>\n<p>1   会使用Executors的API，觉得很cool，很简单。</p>\n<p>2   到配置线程池参数，理解线程池参数，池化资源复用，减少上下文切换，参数关系构成了线程池的执行过程。</p>\n<p>3  任务，任务提交，任务执行的抽象理解，从ThreadPoolExecutor到ScheduledThreadPoolExecutor到ForkJoinPool，CompletableFuture的理解。</p>\n<p>我现在的理解是：Java并发提供了三个核心抽象概念(<code>任务，任务提交和取消，任务执行</code>)，具体来说：</p>\n<p>1 <strong>任务</strong>  任务的抽象从Runnable，Callable，FutureTask，到ForkJoinTask 子类RecursiveTask，RecursiveAction，以及CompletableFuture中的Completion对ForkJoinTask 的继承，对AsynchronousCompletionTask的实现。</p>\n<p>2 <strong>任务提交和取消</strong>  从ExecutorService到ExecutorCompletionService，实现submit，invoke方法，核心子类：AbstractExecutorService作为骨架实现 </p>\n<p>3 <strong>任务执行</strong>  从Executor到核心子类ThreadPoolExecutor(核心方法execute)，ForkjoinPool(因为重写了提交机制，所以核心方法submit和execute)，ScheduledThreadPoolExecutor也是种执行机制。纯接口包含了命令模式，模板模式，状态机模式等等。这就意味着你可以自定义提交和执行机制。体现了多种策略和实现分别，非常漂亮。</p>\n<p>传统的<strong>new Thread(new Runnable).start()</strong>  将任务，任务提交，任务执行耦合起来，也没有提供任务取消的机制，显得那么得不可用，这篇博文主要以分析ThreadPoolExecutor为主，但是站在更高的抽象层次去看，会理解更深。</p>\n<h1 id=\"结构\"><a href=\"#结构\" class=\"headerlink\" title=\"结构\"></a>结构</h1><h2 id=\"任务结构\"><a href=\"#任务结构\" class=\"headerlink\" title=\"任务结构\"></a>任务结构</h2><p><img src=\"/images/JUC-Task-Diagram.png\" alt=\"任务结构\"></p>\n<p>每个任务都有其抽象的含义，接下来我们将分析每一个接口的类型。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//代表了任务执行没有结果</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//代表了一个任务执行有结果</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Callable</span>&lt;<span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">V <span class=\"title\">call</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//任务不仅仅被执行，还可以取消，完成，返回结果，Future对任务的抽象比Runnable更加全面，要知道通过原生Thread API</span></span><br><span class=\"line\"><span class=\"comment\">//去取消一个任务是件复杂的事情</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Future</span>&lt;<span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//任务可以被中断取消，任务取消能力在Runnable不行的</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">cancel</span><span class=\"params\">(<span class=\"keyword\">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">//任务是否已经取消</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isCancelled</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">//任务是否完成</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isDone</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">//任务返回结果，获取可能中断，也可能执行异常</span></span><br><span class=\"line\">    <span class=\"function\">V <span class=\"title\">get</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class=\"line\">\t<span class=\"comment\">//在指定时间内返回结果</span></span><br><span class=\"line\">    <span class=\"function\">V <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">long</span> timeout, TimeUnit unit)</span></span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"keyword\">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//接口多继承，仅仅是将Runnable和Future的能力结合起来，是一个mixin接口，但是还是强调了run的能力</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">RunnableFuture</span>&lt;<span class=\"title\">V</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">Runnable</span>, <span class=\"title\">Future</span>&lt;<span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//真正的任务实现是FutureTask，FutureTask的构造对Callable和Runnable进行包装,使得任务成为FutureTask</span></span><br><span class=\"line\"><span class=\"comment\">// ThreadPoolExecutor里面的实际任务是FutureTask</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FutureTask</span>&lt;<span class=\"title\">V</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">RunnableFuture</span>&lt;<span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">FutureTask</span><span class=\"params\">(Callable&lt;V&gt; callable)</span> </span>&#123;<span class=\"comment\">//忽略&#125;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">FutureTask</span><span class=\"params\">(Runnable runnable, V result)</span> </span>&#123;<span class=\"comment\">//忽略&#125;</span></span><br><span class=\"line\">    <span class=\"comment\">//FutureTask源码在另外博客中会写，这里着重分析结构</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//ForkJoinTask也是一种Future类型任务，其内部提供了AdaptedRunnable，AdaptedCallable的适配类，</span></span><br><span class=\"line\"><span class=\"comment\">//将任务适配成ForkJoinTask</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ForkJoinTask</span>&lt;<span class=\"title\">V</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Future</span>&lt;<span class=\"title\">V</span>&gt;, <span class=\"title\">Serializable</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>从上面可以看出，在JUC中，对于任务的抽象其实和任务的执行策略有关系，ThreadPoolExecutor执行的是FutureTask任务，而ScheduledThreadPoolExecutor执行的是ScheduledFutureTask，ForkJoinPool执行的是ForkJoinTask任务，这是多么清晰且统一的设计啊！</p>\n<h2 id=\"任务提交和执行结构\"><a href=\"#任务提交和执行结构\" class=\"headerlink\" title=\"任务提交和执行结构\"></a>任务提交和执行结构</h2><img src=\"/images/Executor-Class-Diagram.png\" alt=\"任务提交\"/>\n\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//顶级接口，定义了任务执行，每一个任务是一个Runnable</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Executor</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(Runnable command)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>但是仅仅有执行还不行，还要管理任务的取消和生命周期，所以提供了ExecutorService接口，如果说Executor定义了任务执行，</p>\n<p>那么ExecutorService提供提交定义了任务的提交和取消，提供了更加完整的任务生命周期的概念，注意到在这层抽象上，我们其实并不知道具体任务是怎么执行的(并行？串行？定期)，怎么被提交的，以及怎么返回结果的，真正的实现是具体的实现类。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Executor提供执行机制，ExecutorService提供提交，取消，完成，等待完成，批量执行任务机制，其中最核心的抽象的提交机制。</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ExecutorService</span> <span class=\"keyword\">extends</span> <span class=\"title\">Executor</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//结束</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">shutdown</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">//里面结束，返回没有执行完的任务</span></span><br><span class=\"line\">    <span class=\"function\">List&lt;Runnable&gt; <span class=\"title\">shutdownNow</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isShutdown</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isTerminated</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">awaitTermination</span><span class=\"params\">(<span class=\"keyword\">long</span> timeout, TimeUnit unit)</span> <span class=\"keyword\">throws</span> InterruptedException</span>;</span><br><span class=\"line\">    <span class=\"comment\">//提交一个Callable，返回一个加强版的任务，可以获得结果，可以取消，可以判断时候完成</span></span><br><span class=\"line\">\t&lt;T&gt; <span class=\"function\">Future&lt;T&gt; <span class=\"title\">submit</span><span class=\"params\">(Callable&lt;T&gt; task)</span></span>;</span><br><span class=\"line\">    &lt;T&gt; <span class=\"function\">Future&lt;T&gt; <span class=\"title\">submit</span><span class=\"params\">(Runnable task, T result)</span></span>;</span><br><span class=\"line\">    Future&lt;?&gt; submit(Runnable task);</span><br><span class=\"line\">    <span class=\"comment\">//提交一批任务，返回所有的完成结果</span></span><br><span class=\"line\">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br><span class=\"line\">        <span class=\"keyword\">throws</span> InterruptedException;</span><br><span class=\"line\">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class=\"line\">                                  <span class=\"keyword\">long</span> timeout, TimeUnit unit)</span><br><span class=\"line\">        <span class=\"keyword\">throws</span> InterruptedException;</span><br><span class=\"line\">    <span class=\"comment\">//返回任意一个结果</span></span><br><span class=\"line\">    &lt;T&gt; <span class=\"function\">T <span class=\"title\">invokeAny</span><span class=\"params\">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"keyword\">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class=\"line\">    &lt;T&gt; <span class=\"function\">T <span class=\"title\">invokeAny</span><span class=\"params\">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                    <span class=\"keyword\">long</span> timeout, TimeUnit unit)</span></span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"keyword\">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class=\"line\">    <span class=\"comment\">//继承了Executor的execute方法</span></span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(Runnable command)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>可以看出，在抽象层，通过一系列接口来完成“任务，任务执行，任务提交和取消”等机制，而接下来章节将分析一种提交和执行机制，线程池，也就是ThreadPoolExecutor.</p>\n<h1 id=\"设计与实现\"><a href=\"#设计与实现\" class=\"headerlink\" title=\"设计与实现\"></a>设计与实现</h1><h2 id=\"ThrealPoolExecutor整体结构\"><a href=\"#ThrealPoolExecutor整体结构\" class=\"headerlink\" title=\"ThrealPoolExecutor整体结构\"></a>ThrealPoolExecutor整体结构</h2><img src=\"/images/ThreadPoolExecutor.png\" style=\"zoom:70%;\" />\n\n\n\n\n\n<h2 id=\"AbstractExecutorService实现\"><a href=\"#AbstractExecutorService实现\" class=\"headerlink\" title=\"AbstractExecutorService实现\"></a>AbstractExecutorService实现</h2><p>AbstractExecutorService仅仅为任务提交提供了骨架的实现，并没有为任务执行和取消提供实现，这也是面向接口设计的一个常用技巧，该类并没有实现Executor的execute方法，因为执行机制属于子类，我们其实可以提供默认实现。但是这样抽象类存在的价值将不是很大。</p>\n<p>我们来看一下他的提交机制有哪些？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//将任务包装成RunnableFuture，实际子类是FutureTask，然后子类(其实就是ThreadPoolExecutor)实现execute执行任务，最后返回执行后的任务</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (task == <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    execute(ftask);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ftask;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//提交一个FutureTask，子类执行任务</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\">Future&lt;T&gt; <span class=\"title\">submit</span><span class=\"params\">(Runnable task, T result)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (task == <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);</span><br><span class=\"line\">    execute(ftask);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ftask;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\">Future&lt;T&gt; <span class=\"title\">submit</span><span class=\"params\">(Callable&lt;T&gt; task)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (task == <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task);</span><br><span class=\"line\">    execute(ftask);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ftask;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//提交一组任务，并且返回所有的任务返回值</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br><span class=\"line\">    <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tasks == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">    <span class=\"comment\">//存放任务返回值的列表</span></span><br><span class=\"line\">    ArrayList&lt;Future&lt;T&gt;&gt; futures = <span class=\"keyword\">new</span> ArrayList&lt;Future&lt;T&gt;&gt;(tasks.size());</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> done = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Callable&lt;T&gt; t : tasks) &#123;</span><br><span class=\"line\">            RunnableFuture&lt;T&gt; f = newTaskFor(t);</span><br><span class=\"line\">            futures.add(f);</span><br><span class=\"line\">            execute(f);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, size = futures.size(); i &lt; size; i++) &#123;</span><br><span class=\"line\">            Future&lt;T&gt; f = futures.get(i);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!f.isDone()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    f.get();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (CancellationException ignore) &#123;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (ExecutionException ignore) &#123;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//任务全部执行完成成功，返回futures</span></span><br><span class=\"line\">        done = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> futures;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//如果没有完成，那么取消所有任务</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!done)</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, size = futures.size(); i &lt; size; i++)</span><br><span class=\"line\">                futures.get(i).cancel(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h2 id=\"FutureTask实现\"><a href=\"#FutureTask实现\" class=\"headerlink\" title=\"FutureTask实现\"></a>FutureTask实现</h2><h3 id=\"任务执行\"><a href=\"#任务执行\" class=\"headerlink\" title=\"任务执行\"></a>任务执行</h3><p>该方法实现RunnableFuture，而RunnableFuture接口继承Runnable的run方法，所有本质是任务执行时候的方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"获取任务结果\"><a href=\"#获取任务结果\" class=\"headerlink\" title=\"获取任务结果\"></a>获取任务结果</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">get</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException, ExecutionException </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"获取有限时间任务结果\"><a href=\"#获取有限时间任务结果\" class=\"headerlink\" title=\"获取有限时间任务结果\"></a>获取有限时间任务结果</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">long</span> timeout, TimeUnit unit)</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"keyword\">throws</span> InterruptedException, ExecutionException, TimeoutException </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"任务取消\"><a href=\"#任务取消\" class=\"headerlink\" title=\"任务取消\"></a>任务取消</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">cancel</span><span class=\"params\">(<span class=\"keyword\">boolean</span> mayInterruptIfRunning)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h2 id=\"ThreadPoolExecutor-API\"><a href=\"#ThreadPoolExecutor-API\" class=\"headerlink\" title=\"ThreadPoolExecutor API\"></a>ThreadPoolExecutor API</h2><p>ThreadPoolExecutor 公共API较多，但是每一个都很实用。</p>\n<p>我们主要分析和Executor和ExecutorService相关的API</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(Runnable command)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>核心构造函数：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ThreadPoolExecutor</span><span class=\"params\">(<span class=\"keyword\">int</span> corePoolSize,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          <span class=\"keyword\">int</span> maximumPoolSize,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          <span class=\"keyword\">long</span> keepAliveTime,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          TimeUnit unit,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          ThreadFactory threadFactory,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"ThreadPoolExecutor实现\"><a href=\"#ThreadPoolExecutor实现\" class=\"headerlink\" title=\"ThreadPoolExecutor实现\"></a>ThreadPoolExecutor实现</h2><p>ThreadPoolExecutor实现了线程池这种执行任务的机制，所以最核心的方法就是execute，如提交相关的方法，在其父类AbstractExecutorService已经实现了，所以该类其实就是实现了任务执行机制execute.</p>\n<p>execute实现提供的抽象概念有，<strong>Worker</strong>和<strong>WorkQueue</strong> . Worker主要处理任务，每一个Worker是一个运行的线程，在runWoker方法中一直轮询WorkQueue的任务并执行，WorkQueue主要用于存储任务。</p>\n<h3 id=\"公共API-execute\"><a href=\"#公共API-execute\" class=\"headerlink\" title=\"公共API-execute\"></a>公共API-execute</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(Runnable command)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (command == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> c = ctl.get();</span><br><span class=\"line\">    <span class=\"comment\">//没有超过核心线程数，新加worker处理，此时如果添加Worker成功，直接返回，如果失败，？？？</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (addWorker(command, <span class=\"keyword\">true</span>))</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        c = ctl.get();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//超过核心线程数，任务入队</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> recheck = ctl.get();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class=\"line\">            reject(command);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (workerCountOf(recheck) == <span class=\"number\">0</span>)</span><br><span class=\"line\">            addWorker(<span class=\"keyword\">null</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//任务队列已满，如果添加不到workQueue里面，则拒绝任务，如果能添加，则不拒绝</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!addWorker(command, <span class=\"keyword\">false</span>))</span><br><span class=\"line\">        reject(command);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"私有方法-addWorker\"><a href=\"#私有方法-addWorker\" class=\"headerlink\" title=\"私有方法-addWorker\"></a>私有方法-addWorker</h3><p>添加worker，并且启动worker，开始执行任务。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">addWorker</span><span class=\"params\">(Runnable firstTask, <span class=\"keyword\">boolean</span> core)</span> </span>&#123;</span><br><span class=\"line\">    retry:</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> c = ctl.get();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> rs = runStateOf(c);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Check if queue empty only if necessary.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class=\"line\">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class=\"line\">               firstTask == <span class=\"keyword\">null</span> &amp;&amp;</span><br><span class=\"line\">               ! workQueue.isEmpty()))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> wc = workerCountOf(c);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (wc &gt;= CAPACITY ||</span><br><span class=\"line\">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class=\"line\">                <span class=\"keyword\">break</span> retry;</span><br><span class=\"line\">            c = ctl.get();  <span class=\"comment\">// Re-read ctl</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (runStateOf(c) != rs)</span><br><span class=\"line\">                <span class=\"keyword\">continue</span> retry;</span><br><span class=\"line\">            <span class=\"comment\">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> workerStarted = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> workerAdded = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    Worker w = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        w = <span class=\"keyword\">new</span> Worker(firstTask);</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Thread t = w.thread;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (t != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> ReentrantLock mainLock = <span class=\"keyword\">this</span>.mainLock;</span><br><span class=\"line\">            mainLock.lock();</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// Recheck while holding lock.</span></span><br><span class=\"line\">                <span class=\"comment\">// Back out on ThreadFactory failure or if</span></span><br><span class=\"line\">                <span class=\"comment\">// shut down before lock acquired.</span></span><br><span class=\"line\">                <span class=\"keyword\">int</span> rs = runStateOf(ctl.get());</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (rs &lt; SHUTDOWN ||</span><br><span class=\"line\">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class=\"keyword\">null</span>)) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (t.isAlive()) <span class=\"comment\">// precheck that t is startable</span></span><br><span class=\"line\">                        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalThreadStateException();</span><br><span class=\"line\">                    <span class=\"comment\">//添加worker</span></span><br><span class=\"line\">                    workers.add(w);</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> s = workers.size();</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (s &gt; largestPoolSize)</span><br><span class=\"line\">                        largestPoolSize = s;</span><br><span class=\"line\">                    workerAdded = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                mainLock.unlock();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (workerAdded) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//启动worker</span></span><br><span class=\"line\">                t.start();</span><br><span class=\"line\">                workerStarted = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (! workerStarted)</span><br><span class=\"line\">            addWorkerFailed(w);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> workerStarted;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"私有方法-addWorkerFailed\"><a href=\"#私有方法-addWorkerFailed\" class=\"headerlink\" title=\"私有方法-addWorkerFailed\"></a>私有方法-addWorkerFailed</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">addWorkerFailed</span><span class=\"params\">(Worker w)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ReentrantLock mainLock = <span class=\"keyword\">this</span>.mainLock;</span><br><span class=\"line\">    mainLock.lock();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (w != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            workers.remove(w);</span><br><span class=\"line\">        decrementWorkerCount();</span><br><span class=\"line\">        tryTerminate();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        mainLock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h3 id=\"私有非静态成员类-Worker\"><a href=\"#私有非静态成员类-Worker\" class=\"headerlink\" title=\"私有非静态成员类-Worker\"></a>私有非静态成员类-Worker</h3><p>Worker即是锁(extends AbstractQueuedSynchronizer)，也是一个工作者线程(implements Runnable)，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//这是一个互斥锁，且不支持重入！一个只能锁定一个任务，一个任务也只能被一个Worker锁住！</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Worker</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractQueuedSynchronizer</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/** Thread this worker is running in.  Null if factory fails. */</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> Thread thread;</span><br><span class=\"line\">    <span class=\"comment\">/** Initial task to run.  Possibly null. 第一个任务，后面的任务从workQueue中拿 */</span></span><br><span class=\"line\">    Runnable firstTask;</span><br><span class=\"line\">    <span class=\"comment\">/** Per-thread task counter */</span></span><br><span class=\"line\">    <span class=\"keyword\">volatile</span> <span class=\"keyword\">long</span> completedTasks;</span><br><span class=\"line\"></span><br><span class=\"line\">    Worker(Runnable firstTask) &#123;</span><br><span class=\"line\">        setState(-<span class=\"number\">1</span>); <span class=\"comment\">// inhibit interrupts until runWorker</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.firstTask = firstTask;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.thread = getThreadFactory().newThread(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** Delegates main run loop to outer runWorker  */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//runWokker是每个worker最核心处理方法，在该方法中，进行任务获取，任务执行</span></span><br><span class=\"line\">        runWorker(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// The value 0 represents the unlocked state. The value 1 represents the locked state.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isHeldExclusively</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> getState() != <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryAcquire</span><span class=\"params\">(<span class=\"keyword\">int</span> unused)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (compareAndSetState(<span class=\"number\">0</span>, <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryRelease</span><span class=\"params\">(<span class=\"keyword\">int</span> unused)</span> </span>&#123;</span><br><span class=\"line\">        setExclusiveOwnerThread(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">        setState(<span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">lock</span><span class=\"params\">()</span>        </span>&#123; acquire(<span class=\"number\">1</span>); &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryLock</span><span class=\"params\">()</span>  </span>&#123; <span class=\"keyword\">return</span> tryAcquire(<span class=\"number\">1</span>); &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">unlock</span><span class=\"params\">()</span>      </span>&#123; release(<span class=\"number\">1</span>); &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isLocked</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> isHeldExclusively(); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">interruptIfStarted</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Thread t;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (getState() &gt;= <span class=\"number\">0</span> &amp;&amp; (t = thread) != <span class=\"keyword\">null</span> &amp;&amp; !t.isInterrupted()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                t.interrupt();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (SecurityException ignore) &#123;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"私有方法runWorker\"><a href=\"#私有方法runWorker\" class=\"headerlink\" title=\"私有方法runWorker\"></a>私有方法runWorker</h3><p>worker处理task的核心方法，从队列中不停地拿任务。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">runWorker</span><span class=\"params\">(Worker w)</span> </span>&#123;</span><br><span class=\"line\">    Thread wt = Thread.currentThread();</span><br><span class=\"line\">    Runnable task = w.firstTask;</span><br><span class=\"line\">    w.firstTask = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    w.unlock(); <span class=\"comment\">// allow interrupts</span></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> completedAbruptly = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//如果是prestartAllCoreThreads，将不会进入while循环，只是start一个线程，但是不处理如何任务</span></span><br><span class=\"line\">        <span class=\"comment\">//task != null(少于核心线程数的任务)     task = getTask() 在阻塞队列中的任务</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (task != <span class=\"keyword\">null</span> || (task = getTask()) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            w.lock();</span><br><span class=\"line\">            <span class=\"comment\">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class=\"line\">            <span class=\"comment\">// if not, ensure thread is not interrupted.  This</span></span><br><span class=\"line\">            <span class=\"comment\">// requires a recheck in second case to deal with</span></span><br><span class=\"line\">            <span class=\"comment\">// shutdownNow race while clearing interrupt</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class=\"line\">                 (Thread.interrupted() &amp;&amp;</span><br><span class=\"line\">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class=\"line\">                !wt.isInterrupted())</span><br><span class=\"line\">                wt.interrupt();</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">//扩展钩子方法，任务处理前的方法</span></span><br><span class=\"line\">                beforeExecute(wt, task);</span><br><span class=\"line\">                Throwable thrown = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//这是接口方法，客户端自定义的任务在这里执行，其实从实现来看执行的FutureTask的run方法</span></span><br><span class=\"line\">                    task.run();</span><br><span class=\"line\">                    <span class=\"comment\">//以下异常是任务抛出的异常,如果抛出异常，则退出Main Loop，然后设置completedAbruptly=false</span></span><br><span class=\"line\">                    <span class=\"comment\">//此时会进入processWorkerExit方法</span></span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (RuntimeException x) &#123;</span><br><span class=\"line\">                    thrown = x; <span class=\"keyword\">throw</span> x;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Error x) &#123;</span><br><span class=\"line\">                    thrown = x; <span class=\"keyword\">throw</span> x;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Throwable x) &#123;</span><br><span class=\"line\">                    thrown = x; <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(x);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//扩展钩子方法：任务执行后的处理</span></span><br><span class=\"line\">                    afterExecute(task, thrown);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                task = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                w.completedTasks++;</span><br><span class=\"line\">                w.unlock();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        completedAbruptly = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        processWorkerExit(w, completedAbruptly);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"私有方法-processWorkerExit\"><a href=\"#私有方法-processWorkerExit\" class=\"headerlink\" title=\"私有方法-processWorkerExit\"></a>私有方法-processWorkerExit</h3><p>该方法用户处理Worker因为异常情况退出，比如任务抛出异常，或者Worker被中断了</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">processWorkerExit</span><span class=\"params\">(Worker w, <span class=\"keyword\">boolean</span> completedAbruptly)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (completedAbruptly) <span class=\"comment\">// If abrupt, then workerCount wasn't adjusted</span></span><br><span class=\"line\">        decrementWorkerCount();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> ReentrantLock mainLock = <span class=\"keyword\">this</span>.mainLock;</span><br><span class=\"line\">    mainLock.lock();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        completedTaskCount += w.completedTasks;</span><br><span class=\"line\">        <span class=\"comment\">//删除Worker</span></span><br><span class=\"line\">        workers.remove(w);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        mainLock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    tryTerminate();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> c = ctl.get();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (runStateLessThan(c, STOP)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!completedAbruptly) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> min = allowCoreThreadTimeOut ? <span class=\"number\">0</span> : corePoolSize;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (min == <span class=\"number\">0</span> &amp;&amp; ! workQueue.isEmpty())</span><br><span class=\"line\">                min = <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (workerCountOf(c) &gt;= min)</span><br><span class=\"line\">                <span class=\"comment\">//工作的Worker大于min，则没必要替换，直接返回</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span>; <span class=\"comment\">// replacement not needed</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//启动新的Worker处理任务</span></span><br><span class=\"line\">        addWorker(<span class=\"keyword\">null</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"私有方法-getTask\"><a href=\"#私有方法-getTask\" class=\"headerlink\" title=\"私有方法-getTask\"></a>私有方法-getTask</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Runnable <span class=\"title\">getTask</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> timedOut = <span class=\"keyword\">false</span>; <span class=\"comment\">// Did the last poll() time out?</span></span><br><span class=\"line\">\t<span class=\"comment\">//不断在阻塞获取任务</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> c = ctl.get();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> rs = runStateOf(c);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Check if queue empty only if necessary.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class=\"line\">            decrementWorkerCount();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> wc = workerCountOf(c);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Are workers subject to culling?</span></span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class=\"line\">            &amp;&amp; (wc &gt; <span class=\"number\">1</span> || workQueue.isEmpty())) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//如果allowCoreThreadTimeOut是true，在keepAliveTime时间内，没有任务到来，</span></span><br><span class=\"line\">            Runnable r = timed ?</span><br><span class=\"line\">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class=\"line\">                workQueue.take();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (r != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">            timedOut = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException retry) &#123;</span><br><span class=\"line\">            timedOut = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n<h3 id=\"私有方法-interruptIdleWorkers\"><a href=\"#私有方法-interruptIdleWorkers\" class=\"headerlink\" title=\"私有方法-interruptIdleWorkers\"></a>私有方法-interruptIdleWorkers</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">interruptIdleWorkers</span><span class=\"params\">(<span class=\"keyword\">boolean</span> onlyOne)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ReentrantLock mainLock = <span class=\"keyword\">this</span>.mainLock;</span><br><span class=\"line\">    mainLock.lock();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Worker w : workers) &#123;</span><br><span class=\"line\">            Thread t = w.thread;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    t.interrupt();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (SecurityException ignore) &#123;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                    w.unlock();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (onlyOne)</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        mainLock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h3 id=\"公共API-shutdown\"><a href=\"#公共API-shutdown\" class=\"headerlink\" title=\"公共API-shutdown\"></a>公共API-shutdown</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">shutdown</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ReentrantLock mainLock = <span class=\"keyword\">this</span>.mainLock;</span><br><span class=\"line\">    mainLock.lock();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//检查关闭权限</span></span><br><span class=\"line\">        checkShutdownAccess();</span><br><span class=\"line\">        <span class=\"comment\">//线程池状态设置为SHUTDOWN</span></span><br><span class=\"line\">        advanceRunState(SHUTDOWN);</span><br><span class=\"line\">        <span class=\"comment\">//中断所有的空闲的Worker，此时真正执行任务的Worker不会被中断，因为获取不到锁</span></span><br><span class=\"line\">        interruptIdleWorkers();</span><br><span class=\"line\">        onShutdown(); <span class=\"comment\">// hook for ScheduledThreadPoolExecutor</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        mainLock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    tryTerminate();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"公共API-shutdownNow\"><a href=\"#公共API-shutdownNow\" class=\"headerlink\" title=\"公共API-shutdownNow\"></a>公共API-shutdownNow</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> List&lt;Runnable&gt; <span class=\"title\">shutdownNow</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    List&lt;Runnable&gt; tasks;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ReentrantLock mainLock = <span class=\"keyword\">this</span>.mainLock;</span><br><span class=\"line\">    mainLock.lock();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        checkShutdownAccess();</span><br><span class=\"line\">        advanceRunState(STOP);</span><br><span class=\"line\">        interruptWorkers();</span><br><span class=\"line\">        <span class=\"comment\">//workQueue中所有的任务会被取出来，然后交由客户端处理</span></span><br><span class=\"line\">        tasks = drainQueue();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        mainLock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    tryTerminate();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> tasks;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"公共API-allowCoreThreadTimeOut\"><a href=\"#公共API-allowCoreThreadTimeOut\" class=\"headerlink\" title=\"公共API-allowCoreThreadTimeOut\"></a>公共API-allowCoreThreadTimeOut</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">allowCoreThreadTimeOut</span><span class=\"params\">(<span class=\"keyword\">boolean</span> value)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (value &amp;&amp; keepAliveTime &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Core threads must have nonzero keep alive times\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (value != allowCoreThreadTimeOut) &#123;</span><br><span class=\"line\">        allowCoreThreadTimeOut = value;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (value)</span><br><span class=\"line\">            interruptIdleWorkers();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"公共API-prestartAllCoreThreads\"><a href=\"#公共API-prestartAllCoreThreads\" class=\"headerlink\" title=\"公共API-prestartAllCoreThreads\"></a>公共API-prestartAllCoreThreads</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">prestartAllCoreThreads</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">//firstTask是null,core是true，这时候只会启动线程，但是不会执行任何任务</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (addWorker(<span class=\"keyword\">null</span>, <span class=\"keyword\">true</span>))</span><br><span class=\"line\">        ++n;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> n;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h3 id=\"工具方法\"><a href=\"#工具方法\" class=\"headerlink\" title=\"工具方法\"></a>工具方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">runStateOf</span><span class=\"params\">(<span class=\"keyword\">int</span> c)</span>     </span>&#123; <span class=\"keyword\">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">workerCountOf</span><span class=\"params\">(<span class=\"keyword\">int</span> c)</span>  </span>&#123; <span class=\"keyword\">return</span> c &amp; CAPACITY; &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">ctlOf</span><span class=\"params\">(<span class=\"keyword\">int</span> rs, <span class=\"keyword\">int</span> wc)</span> </span>&#123; <span class=\"keyword\">return</span> rs | wc; &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">runStateLessThan</span><span class=\"params\">(<span class=\"keyword\">int</span> c, <span class=\"keyword\">int</span> s)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> c &lt; s;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">runStateAtLeast</span><span class=\"params\">(<span class=\"keyword\">int</span> c, <span class=\"keyword\">int</span> s)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> c &gt;= s;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isRunning</span><span class=\"params\">(<span class=\"keyword\">int</span> c)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> c &lt; SHUTDOWN;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"静态字段\"><a href=\"#静态字段\" class=\"headerlink\" title=\"静态字段\"></a>静态字段</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> AtomicInteger ctl = <span class=\"keyword\">new</span> AtomicInteger(ctlOf(RUNNING, <span class=\"number\">0</span>));</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> COUNT_BITS = Integer.SIZE - <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> CAPACITY   = (<span class=\"number\">1</span> &lt;&lt; COUNT_BITS) - <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// runState is stored in the high-order bits</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> RUNNING    = -<span class=\"number\">1</span> &lt;&lt; COUNT_BITS;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> SHUTDOWN   =  <span class=\"number\">0</span> &lt;&lt; COUNT_BITS;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> STOP       =  <span class=\"number\">1</span> &lt;&lt; COUNT_BITS;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> TIDYING    =  <span class=\"number\">2</span> &lt;&lt; COUNT_BITS;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> TERMINATED =  <span class=\"number\">3</span> &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n<h2 id=\"Executors实现\"><a href=\"#Executors实现\" class=\"headerlink\" title=\"Executors实现\"></a>Executors实现</h2><p>Executors是对执行者的静态工厂类，提供了常用的执行策略，并且提供了对任务的包装。</p>\n<h1 id=\"实战案例\"><a href=\"#实战案例\" class=\"headerlink\" title=\"实战案例\"></a>实战案例</h1><h2 id=\"tomcat线程池解读\"><a href=\"#tomcat线程池解读\" class=\"headerlink\" title=\"tomcat线程池解读\"></a>tomcat线程池解读</h2><p>org.apache.tomcat.util.threads.ThreadPoolExecutor </p>\n<h2 id=\"扩展ThreadPoolExecutor\"><a href=\"#扩展ThreadPoolExecutor\" class=\"headerlink\" title=\"扩展ThreadPoolExecutor\"></a>扩展ThreadPoolExecutor</h2><h2 id=\"多元化的拒绝策略\"><a href=\"#多元化的拒绝策略\" class=\"headerlink\" title=\"多元化的拒绝策略\"></a>多元化的拒绝策略</h2><h2 id=\"Apache-HttpComponents-Worker\"><a href=\"#Apache-HttpComponents-Worker\" class=\"headerlink\" title=\"Apache HttpComponents Worker\"></a>Apache HttpComponents Worker</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WorkerPoolExecutor</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"Spring的抽象\"><a href=\"#Spring的抽象\" class=\"headerlink\" title=\"Spring的抽象\"></a>Spring的抽象</h2><h1 id=\"结论和启示\"><a href=\"#结论和启示\" class=\"headerlink\" title=\"结论和启示\"></a>结论和启示</h1>","site":{"data":{}},"excerpt":"","more":"<p>​      线程池是Java并发包中的重要部分，也是高并发程序必不可少的类库，但是线程池技术本身比较复杂，不同语言对其实现提供的抽象也不一样，所以本文以Java线程池为例，分析它的设计与实现，以及它所带我们的抽象。</p>\n<h1 id=\"序言\"><a href=\"#序言\" class=\"headerlink\" title=\"序言\"></a>序言</h1><p>我对线程池的认识经历了以下三个阶段</p>\n<p>1   会使用Executors的API，觉得很cool，很简单。</p>\n<p>2   到配置线程池参数，理解线程池参数，池化资源复用，减少上下文切换，参数关系构成了线程池的执行过程。</p>\n<p>3  任务，任务提交，任务执行的抽象理解，从ThreadPoolExecutor到ScheduledThreadPoolExecutor到ForkJoinPool，CompletableFuture的理解。</p>\n<p>我现在的理解是：Java并发提供了三个核心抽象概念(<code>任务，任务提交和取消，任务执行</code>)，具体来说：</p>\n<p>1 <strong>任务</strong>  任务的抽象从Runnable，Callable，FutureTask，到ForkJoinTask 子类RecursiveTask，RecursiveAction，以及CompletableFuture中的Completion对ForkJoinTask 的继承，对AsynchronousCompletionTask的实现。</p>\n<p>2 <strong>任务提交和取消</strong>  从ExecutorService到ExecutorCompletionService，实现submit，invoke方法，核心子类：AbstractExecutorService作为骨架实现 </p>\n<p>3 <strong>任务执行</strong>  从Executor到核心子类ThreadPoolExecutor(核心方法execute)，ForkjoinPool(因为重写了提交机制，所以核心方法submit和execute)，ScheduledThreadPoolExecutor也是种执行机制。纯接口包含了命令模式，模板模式，状态机模式等等。这就意味着你可以自定义提交和执行机制。体现了多种策略和实现分别，非常漂亮。</p>\n<p>传统的<strong>new Thread(new Runnable).start()</strong>  将任务，任务提交，任务执行耦合起来，也没有提供任务取消的机制，显得那么得不可用，这篇博文主要以分析ThreadPoolExecutor为主，但是站在更高的抽象层次去看，会理解更深。</p>\n<h1 id=\"结构\"><a href=\"#结构\" class=\"headerlink\" title=\"结构\"></a>结构</h1><h2 id=\"任务结构\"><a href=\"#任务结构\" class=\"headerlink\" title=\"任务结构\"></a>任务结构</h2><p><img src=\"/images/JUC-Task-Diagram.png\" alt=\"任务结构\"></p>\n<p>每个任务都有其抽象的含义，接下来我们将分析每一个接口的类型。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//代表了任务执行没有结果</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//代表了一个任务执行有结果</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Callable</span>&lt;<span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">V <span class=\"title\">call</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> Exception</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//任务不仅仅被执行，还可以取消，完成，返回结果，Future对任务的抽象比Runnable更加全面，要知道通过原生Thread API</span></span><br><span class=\"line\"><span class=\"comment\">//去取消一个任务是件复杂的事情</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Future</span>&lt;<span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">\t<span class=\"comment\">//任务可以被中断取消，任务取消能力在Runnable不行的</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">cancel</span><span class=\"params\">(<span class=\"keyword\">boolean</span> mayInterruptIfRunning)</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">//任务是否已经取消</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isCancelled</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">//任务是否完成</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isDone</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">//任务返回结果，获取可能中断，也可能执行异常</span></span><br><span class=\"line\">    <span class=\"function\">V <span class=\"title\">get</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class=\"line\">\t<span class=\"comment\">//在指定时间内返回结果</span></span><br><span class=\"line\">    <span class=\"function\">V <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">long</span> timeout, TimeUnit unit)</span></span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"keyword\">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//接口多继承，仅仅是将Runnable和Future的能力结合起来，是一个mixin接口，但是还是强调了run的能力</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">RunnableFuture</span>&lt;<span class=\"title\">V</span>&gt; <span class=\"keyword\">extends</span> <span class=\"title\">Runnable</span>, <span class=\"title\">Future</span>&lt;<span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//真正的任务实现是FutureTask，FutureTask的构造对Callable和Runnable进行包装,使得任务成为FutureTask</span></span><br><span class=\"line\"><span class=\"comment\">// ThreadPoolExecutor里面的实际任务是FutureTask</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">FutureTask</span>&lt;<span class=\"title\">V</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">RunnableFuture</span>&lt;<span class=\"title\">V</span>&gt; </span>&#123;</span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">FutureTask</span><span class=\"params\">(Callable&lt;V&gt; callable)</span> </span>&#123;<span class=\"comment\">//忽略&#125;</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">FutureTask</span><span class=\"params\">(Runnable runnable, V result)</span> </span>&#123;<span class=\"comment\">//忽略&#125;</span></span><br><span class=\"line\">    <span class=\"comment\">//FutureTask源码在另外博客中会写，这里着重分析结构</span></span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//ForkJoinTask也是一种Future类型任务，其内部提供了AdaptedRunnable，AdaptedCallable的适配类，</span></span><br><span class=\"line\"><span class=\"comment\">//将任务适配成ForkJoinTask</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">abstract</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">ForkJoinTask</span>&lt;<span class=\"title\">V</span>&gt; <span class=\"keyword\">implements</span> <span class=\"title\">Future</span>&lt;<span class=\"title\">V</span>&gt;, <span class=\"title\">Serializable</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>从上面可以看出，在JUC中，对于任务的抽象其实和任务的执行策略有关系，ThreadPoolExecutor执行的是FutureTask任务，而ScheduledThreadPoolExecutor执行的是ScheduledFutureTask，ForkJoinPool执行的是ForkJoinTask任务，这是多么清晰且统一的设计啊！</p>\n<h2 id=\"任务提交和执行结构\"><a href=\"#任务提交和执行结构\" class=\"headerlink\" title=\"任务提交和执行结构\"></a>任务提交和执行结构</h2><img src=\"/images/Executor-Class-Diagram.png\" alt=\"任务提交\"/>\n\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//顶级接口，定义了任务执行，每一个任务是一个Runnable</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Executor</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(Runnable command)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>但是仅仅有执行还不行，还要管理任务的取消和生命周期，所以提供了ExecutorService接口，如果说Executor定义了任务执行，</p>\n<p>那么ExecutorService提供提交定义了任务的提交和取消，提供了更加完整的任务生命周期的概念，注意到在这层抽象上，我们其实并不知道具体任务是怎么执行的(并行？串行？定期)，怎么被提交的，以及怎么返回结果的，真正的实现是具体的实现类。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Executor提供执行机制，ExecutorService提供提交，取消，完成，等待完成，批量执行任务机制，其中最核心的抽象的提交机制。</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">ExecutorService</span> <span class=\"keyword\">extends</span> <span class=\"title\">Executor</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//结束</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">shutdown</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"comment\">//里面结束，返回没有执行完的任务</span></span><br><span class=\"line\">    <span class=\"function\">List&lt;Runnable&gt; <span class=\"title\">shutdownNow</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isShutdown</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">isTerminated</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">boolean</span> <span class=\"title\">awaitTermination</span><span class=\"params\">(<span class=\"keyword\">long</span> timeout, TimeUnit unit)</span> <span class=\"keyword\">throws</span> InterruptedException</span>;</span><br><span class=\"line\">    <span class=\"comment\">//提交一个Callable，返回一个加强版的任务，可以获得结果，可以取消，可以判断时候完成</span></span><br><span class=\"line\">\t&lt;T&gt; <span class=\"function\">Future&lt;T&gt; <span class=\"title\">submit</span><span class=\"params\">(Callable&lt;T&gt; task)</span></span>;</span><br><span class=\"line\">    &lt;T&gt; <span class=\"function\">Future&lt;T&gt; <span class=\"title\">submit</span><span class=\"params\">(Runnable task, T result)</span></span>;</span><br><span class=\"line\">    Future&lt;?&gt; submit(Runnable task);</span><br><span class=\"line\">    <span class=\"comment\">//提交一批任务，返回所有的完成结果</span></span><br><span class=\"line\">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br><span class=\"line\">        <span class=\"keyword\">throws</span> InterruptedException;</span><br><span class=\"line\">    &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span><br><span class=\"line\">                                  <span class=\"keyword\">long</span> timeout, TimeUnit unit)</span><br><span class=\"line\">        <span class=\"keyword\">throws</span> InterruptedException;</span><br><span class=\"line\">    <span class=\"comment\">//返回任意一个结果</span></span><br><span class=\"line\">    &lt;T&gt; <span class=\"function\">T <span class=\"title\">invokeAny</span><span class=\"params\">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span></span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"keyword\">throws</span> InterruptedException, ExecutionException</span>;</span><br><span class=\"line\">    &lt;T&gt; <span class=\"function\">T <span class=\"title\">invokeAny</span><span class=\"params\">(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                    <span class=\"keyword\">long</span> timeout, TimeUnit unit)</span></span></span><br><span class=\"line\"><span class=\"function\">        <span class=\"keyword\">throws</span> InterruptedException, ExecutionException, TimeoutException</span>;</span><br><span class=\"line\">    <span class=\"comment\">//继承了Executor的execute方法</span></span><br><span class=\"line\">     <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(Runnable command)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>可以看出，在抽象层，通过一系列接口来完成“任务，任务执行，任务提交和取消”等机制，而接下来章节将分析一种提交和执行机制，线程池，也就是ThreadPoolExecutor.</p>\n<h1 id=\"设计与实现\"><a href=\"#设计与实现\" class=\"headerlink\" title=\"设计与实现\"></a>设计与实现</h1><h2 id=\"ThrealPoolExecutor整体结构\"><a href=\"#ThrealPoolExecutor整体结构\" class=\"headerlink\" title=\"ThrealPoolExecutor整体结构\"></a>ThrealPoolExecutor整体结构</h2><img src=\"/images/ThreadPoolExecutor.png\" style=\"zoom:70%;\" />\n\n\n\n\n\n<h2 id=\"AbstractExecutorService实现\"><a href=\"#AbstractExecutorService实现\" class=\"headerlink\" title=\"AbstractExecutorService实现\"></a>AbstractExecutorService实现</h2><p>AbstractExecutorService仅仅为任务提交提供了骨架的实现，并没有为任务执行和取消提供实现，这也是面向接口设计的一个常用技巧，该类并没有实现Executor的execute方法，因为执行机制属于子类，我们其实可以提供默认实现。但是这样抽象类存在的价值将不是很大。</p>\n<p>我们来看一下他的提交机制有哪些？</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//将任务包装成RunnableFuture，实际子类是FutureTask，然后子类(其实就是ThreadPoolExecutor)实现execute执行任务，最后返回执行后的任务</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> Future&lt;?&gt; submit(Runnable task) &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (task == <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">    RunnableFuture&lt;Void&gt; ftask = newTaskFor(task, <span class=\"keyword\">null</span>);</span><br><span class=\"line\">    execute(ftask);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ftask;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//提交一个FutureTask，子类执行任务</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\">Future&lt;T&gt; <span class=\"title\">submit</span><span class=\"params\">(Runnable task, T result)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (task == <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task, result);</span><br><span class=\"line\">    execute(ftask);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ftask;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; <span class=\"function\">Future&lt;T&gt; <span class=\"title\">submit</span><span class=\"params\">(Callable&lt;T&gt; task)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (task == <span class=\"keyword\">null</span>) <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">    RunnableFuture&lt;T&gt; ftask = newTaskFor(task);</span><br><span class=\"line\">    execute(ftask);</span><br><span class=\"line\">    <span class=\"keyword\">return</span> ftask;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//提交一组任务，并且返回所有的任务返回值</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> &lt;T&gt; List&lt;Future&lt;T&gt;&gt; invokeAll(Collection&lt;? extends Callable&lt;T&gt;&gt; tasks)</span><br><span class=\"line\">    <span class=\"keyword\">throws</span> InterruptedException &#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (tasks == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">    <span class=\"comment\">//存放任务返回值的列表</span></span><br><span class=\"line\">    ArrayList&lt;Future&lt;T&gt;&gt; futures = <span class=\"keyword\">new</span> ArrayList&lt;Future&lt;T&gt;&gt;(tasks.size());</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> done = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Callable&lt;T&gt; t : tasks) &#123;</span><br><span class=\"line\">            RunnableFuture&lt;T&gt; f = newTaskFor(t);</span><br><span class=\"line\">            futures.add(f);</span><br><span class=\"line\">            execute(f);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, size = futures.size(); i &lt; size; i++) &#123;</span><br><span class=\"line\">            Future&lt;T&gt; f = futures.get(i);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!f.isDone()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    f.get();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (CancellationException ignore) &#123;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (ExecutionException ignore) &#123;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//任务全部执行完成成功，返回futures</span></span><br><span class=\"line\">        done = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> futures;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//如果没有完成，那么取消所有任务</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!done)</span><br><span class=\"line\">            <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> i = <span class=\"number\">0</span>, size = futures.size(); i &lt; size; i++)</span><br><span class=\"line\">                futures.get(i).cancel(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h2 id=\"FutureTask实现\"><a href=\"#FutureTask实现\" class=\"headerlink\" title=\"FutureTask实现\"></a>FutureTask实现</h2><h3 id=\"任务执行\"><a href=\"#任务执行\" class=\"headerlink\" title=\"任务执行\"></a>任务执行</h3><p>该方法实现RunnableFuture，而RunnableFuture接口继承Runnable的run方法，所有本质是任务执行时候的方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"获取任务结果\"><a href=\"#获取任务结果\" class=\"headerlink\" title=\"获取任务结果\"></a>获取任务结果</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">get</span><span class=\"params\">()</span> <span class=\"keyword\">throws</span> InterruptedException, ExecutionException </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"获取有限时间任务结果\"><a href=\"#获取有限时间任务结果\" class=\"headerlink\" title=\"获取有限时间任务结果\"></a>获取有限时间任务结果</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">get</span><span class=\"params\">(<span class=\"keyword\">long</span> timeout, TimeUnit unit)</span></span></span><br><span class=\"line\"><span class=\"function\">    <span class=\"keyword\">throws</span> InterruptedException, ExecutionException, TimeoutException </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"任务取消\"><a href=\"#任务取消\" class=\"headerlink\" title=\"任务取消\"></a>任务取消</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">cancel</span><span class=\"params\">(<span class=\"keyword\">boolean</span> mayInterruptIfRunning)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h2 id=\"ThreadPoolExecutor-API\"><a href=\"#ThreadPoolExecutor-API\" class=\"headerlink\" title=\"ThreadPoolExecutor API\"></a>ThreadPoolExecutor API</h2><p>ThreadPoolExecutor 公共API较多，但是每一个都很实用。</p>\n<p>我们主要分析和Executor和ExecutorService相关的API</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(Runnable command)</span> </span>&#123;&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>核心构造函数：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">ThreadPoolExecutor</span><span class=\"params\">(<span class=\"keyword\">int</span> corePoolSize,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          <span class=\"keyword\">int</span> maximumPoolSize,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          <span class=\"keyword\">long</span> keepAliveTime,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          TimeUnit unit,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          BlockingQueue&lt;Runnable&gt; workQueue,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          ThreadFactory threadFactory,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                          RejectedExecutionHandler handler)</span> </span>&#123;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"ThreadPoolExecutor实现\"><a href=\"#ThreadPoolExecutor实现\" class=\"headerlink\" title=\"ThreadPoolExecutor实现\"></a>ThreadPoolExecutor实现</h2><p>ThreadPoolExecutor实现了线程池这种执行任务的机制，所以最核心的方法就是execute，如提交相关的方法，在其父类AbstractExecutorService已经实现了，所以该类其实就是实现了任务执行机制execute.</p>\n<p>execute实现提供的抽象概念有，<strong>Worker</strong>和<strong>WorkQueue</strong> . Worker主要处理任务，每一个Worker是一个运行的线程，在runWoker方法中一直轮询WorkQueue的任务并执行，WorkQueue主要用于存储任务。</p>\n<h3 id=\"公共API-execute\"><a href=\"#公共API-execute\" class=\"headerlink\" title=\"公共API-execute\"></a>公共API-execute</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">execute</span><span class=\"params\">(Runnable command)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (command == <span class=\"keyword\">null</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> NullPointerException();</span><br><span class=\"line\">    <span class=\"keyword\">int</span> c = ctl.get();</span><br><span class=\"line\">    <span class=\"comment\">//没有超过核心线程数，新加worker处理，此时如果添加Worker成功，直接返回，如果失败，？？？</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (workerCountOf(c) &lt; corePoolSize) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (addWorker(command, <span class=\"keyword\">true</span>))</span><br><span class=\"line\">            <span class=\"keyword\">return</span>;</span><br><span class=\"line\">        c = ctl.get();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//超过核心线程数，任务入队</span></span><br><span class=\"line\">    <span class=\"keyword\">if</span> (isRunning(c) &amp;&amp; workQueue.offer(command)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> recheck = ctl.get();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (! isRunning(recheck) &amp;&amp; remove(command))</span><br><span class=\"line\">            reject(command);</span><br><span class=\"line\">        <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (workerCountOf(recheck) == <span class=\"number\">0</span>)</span><br><span class=\"line\">            addWorker(<span class=\"keyword\">null</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">//任务队列已满，如果添加不到workQueue里面，则拒绝任务，如果能添加，则不拒绝</span></span><br><span class=\"line\">    <span class=\"keyword\">else</span> <span class=\"keyword\">if</span> (!addWorker(command, <span class=\"keyword\">false</span>))</span><br><span class=\"line\">        reject(command);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"私有方法-addWorker\"><a href=\"#私有方法-addWorker\" class=\"headerlink\" title=\"私有方法-addWorker\"></a>私有方法-addWorker</h3><p>添加worker，并且启动worker，开始执行任务。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br><span class=\"line\">54</span><br><span class=\"line\">55</span><br><span class=\"line\">56</span><br><span class=\"line\">57</span><br><span class=\"line\">58</span><br><span class=\"line\">59</span><br><span class=\"line\">60</span><br><span class=\"line\">61</span><br><span class=\"line\">62</span><br><span class=\"line\">63</span><br><span class=\"line\">64</span><br><span class=\"line\">65</span><br><span class=\"line\">66</span><br><span class=\"line\">67</span><br><span class=\"line\">68</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">boolean</span> <span class=\"title\">addWorker</span><span class=\"params\">(Runnable firstTask, <span class=\"keyword\">boolean</span> core)</span> </span>&#123;</span><br><span class=\"line\">    retry:</span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> c = ctl.get();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> rs = runStateOf(c);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Check if queue empty only if necessary.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (rs &gt;= SHUTDOWN &amp;&amp;</span><br><span class=\"line\">            ! (rs == SHUTDOWN &amp;&amp;</span><br><span class=\"line\">               firstTask == <span class=\"keyword\">null</span> &amp;&amp;</span><br><span class=\"line\">               ! workQueue.isEmpty()))</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> wc = workerCountOf(c);</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (wc &gt;= CAPACITY ||</span><br><span class=\"line\">                wc &gt;= (core ? corePoolSize : maximumPoolSize))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (compareAndIncrementWorkerCount(c))</span><br><span class=\"line\">                <span class=\"keyword\">break</span> retry;</span><br><span class=\"line\">            c = ctl.get();  <span class=\"comment\">// Re-read ctl</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> (runStateOf(c) != rs)</span><br><span class=\"line\">                <span class=\"keyword\">continue</span> retry;</span><br><span class=\"line\">            <span class=\"comment\">// else CAS failed due to workerCount change; retry inner loop</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> workerStarted = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> workerAdded = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    Worker w = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        w = <span class=\"keyword\">new</span> Worker(firstTask);</span><br><span class=\"line\">        <span class=\"keyword\">final</span> Thread t = w.thread;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (t != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">final</span> ReentrantLock mainLock = <span class=\"keyword\">this</span>.mainLock;</span><br><span class=\"line\">            mainLock.lock();</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">// Recheck while holding lock.</span></span><br><span class=\"line\">                <span class=\"comment\">// Back out on ThreadFactory failure or if</span></span><br><span class=\"line\">                <span class=\"comment\">// shut down before lock acquired.</span></span><br><span class=\"line\">                <span class=\"keyword\">int</span> rs = runStateOf(ctl.get());</span><br><span class=\"line\"></span><br><span class=\"line\">                <span class=\"keyword\">if</span> (rs &lt; SHUTDOWN ||</span><br><span class=\"line\">                    (rs == SHUTDOWN &amp;&amp; firstTask == <span class=\"keyword\">null</span>)) &#123;</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (t.isAlive()) <span class=\"comment\">// precheck that t is startable</span></span><br><span class=\"line\">                        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalThreadStateException();</span><br><span class=\"line\">                    <span class=\"comment\">//添加worker</span></span><br><span class=\"line\">                    workers.add(w);</span><br><span class=\"line\">                    <span class=\"keyword\">int</span> s = workers.size();</span><br><span class=\"line\">                    <span class=\"keyword\">if</span> (s &gt; largestPoolSize)</span><br><span class=\"line\">                        largestPoolSize = s;</span><br><span class=\"line\">                    workerAdded = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                mainLock.unlock();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (workerAdded) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//启动worker</span></span><br><span class=\"line\">                t.start();</span><br><span class=\"line\">                workerStarted = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (! workerStarted)</span><br><span class=\"line\">            addWorkerFailed(w);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> workerStarted;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"私有方法-addWorkerFailed\"><a href=\"#私有方法-addWorkerFailed\" class=\"headerlink\" title=\"私有方法-addWorkerFailed\"></a>私有方法-addWorkerFailed</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">addWorkerFailed</span><span class=\"params\">(Worker w)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ReentrantLock mainLock = <span class=\"keyword\">this</span>.mainLock;</span><br><span class=\"line\">    mainLock.lock();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (w != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">            workers.remove(w);</span><br><span class=\"line\">        decrementWorkerCount();</span><br><span class=\"line\">        tryTerminate();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        mainLock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h3 id=\"私有非静态成员类-Worker\"><a href=\"#私有非静态成员类-Worker\" class=\"headerlink\" title=\"私有非静态成员类-Worker\"></a>私有非静态成员类-Worker</h3><p>Worker即是锁(extends AbstractQueuedSynchronizer)，也是一个工作者线程(implements Runnable)，</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br><span class=\"line\">51</span><br><span class=\"line\">52</span><br><span class=\"line\">53</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//这是一个互斥锁，且不支持重入！一个只能锁定一个任务，一个任务也只能被一个Worker锁住！</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">Worker</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractQueuedSynchronizer</span> <span class=\"keyword\">implements</span> <span class=\"title\">Runnable</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">/** Thread this worker is running in.  Null if factory fails. */</span></span><br><span class=\"line\">    <span class=\"keyword\">final</span> Thread thread;</span><br><span class=\"line\">    <span class=\"comment\">/** Initial task to run.  Possibly null. 第一个任务，后面的任务从workQueue中拿 */</span></span><br><span class=\"line\">    Runnable firstTask;</span><br><span class=\"line\">    <span class=\"comment\">/** Per-thread task counter */</span></span><br><span class=\"line\">    <span class=\"keyword\">volatile</span> <span class=\"keyword\">long</span> completedTasks;</span><br><span class=\"line\"></span><br><span class=\"line\">    Worker(Runnable firstTask) &#123;</span><br><span class=\"line\">        setState(-<span class=\"number\">1</span>); <span class=\"comment\">// inhibit interrupts until runWorker</span></span><br><span class=\"line\">        <span class=\"keyword\">this</span>.firstTask = firstTask;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.thread = getThreadFactory().newThread(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">/** Delegates main run loop to outer runWorker  */</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">run</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//runWokker是每个worker最核心处理方法，在该方法中，进行任务获取，任务执行</span></span><br><span class=\"line\">        runWorker(<span class=\"keyword\">this</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"comment\">// The value 0 represents the unlocked state. The value 1 represents the locked state.</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isHeldExclusively</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> getState() != <span class=\"number\">0</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryAcquire</span><span class=\"params\">(<span class=\"keyword\">int</span> unused)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (compareAndSetState(<span class=\"number\">0</span>, <span class=\"number\">1</span>)) &#123;</span><br><span class=\"line\">            setExclusiveOwnerThread(Thread.currentThread());</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">protected</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryRelease</span><span class=\"params\">(<span class=\"keyword\">int</span> unused)</span> </span>&#123;</span><br><span class=\"line\">        setExclusiveOwnerThread(<span class=\"keyword\">null</span>);</span><br><span class=\"line\">        setState(<span class=\"number\">0</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">lock</span><span class=\"params\">()</span>        </span>&#123; acquire(<span class=\"number\">1</span>); &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">tryLock</span><span class=\"params\">()</span>  </span>&#123; <span class=\"keyword\">return</span> tryAcquire(<span class=\"number\">1</span>); &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">unlock</span><span class=\"params\">()</span>      </span>&#123; release(<span class=\"number\">1</span>); &#125;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isLocked</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> isHeldExclusively(); &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">interruptIfStarted</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        Thread t;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (getState() &gt;= <span class=\"number\">0</span> &amp;&amp; (t = thread) != <span class=\"keyword\">null</span> &amp;&amp; !t.isInterrupted()) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                t.interrupt();</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (SecurityException ignore) &#123;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"私有方法runWorker\"><a href=\"#私有方法runWorker\" class=\"headerlink\" title=\"私有方法runWorker\"></a>私有方法runWorker</h3><p>worker处理task的核心方法，从队列中不停地拿任务。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br><span class=\"line\">44</span><br><span class=\"line\">45</span><br><span class=\"line\">46</span><br><span class=\"line\">47</span><br><span class=\"line\">48</span><br><span class=\"line\">49</span><br><span class=\"line\">50</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">runWorker</span><span class=\"params\">(Worker w)</span> </span>&#123;</span><br><span class=\"line\">    Thread wt = Thread.currentThread();</span><br><span class=\"line\">    Runnable task = w.firstTask;</span><br><span class=\"line\">    w.firstTask = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">    w.unlock(); <span class=\"comment\">// allow interrupts</span></span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> completedAbruptly = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//如果是prestartAllCoreThreads，将不会进入while循环，只是start一个线程，但是不处理如何任务</span></span><br><span class=\"line\">        <span class=\"comment\">//task != null(少于核心线程数的任务)     task = getTask() 在阻塞队列中的任务</span></span><br><span class=\"line\">        <span class=\"keyword\">while</span> (task != <span class=\"keyword\">null</span> || (task = getTask()) != <span class=\"keyword\">null</span>) &#123;</span><br><span class=\"line\">            w.lock();</span><br><span class=\"line\">            <span class=\"comment\">// If pool is stopping, ensure thread is interrupted;</span></span><br><span class=\"line\">            <span class=\"comment\">// if not, ensure thread is not interrupted.  This</span></span><br><span class=\"line\">            <span class=\"comment\">// requires a recheck in second case to deal with</span></span><br><span class=\"line\">            <span class=\"comment\">// shutdownNow race while clearing interrupt</span></span><br><span class=\"line\">            <span class=\"keyword\">if</span> ((runStateAtLeast(ctl.get(), STOP) ||</span><br><span class=\"line\">                 (Thread.interrupted() &amp;&amp;</span><br><span class=\"line\">                  runStateAtLeast(ctl.get(), STOP))) &amp;&amp;</span><br><span class=\"line\">                !wt.isInterrupted())</span><br><span class=\"line\">                wt.interrupt();</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">//扩展钩子方法，任务处理前的方法</span></span><br><span class=\"line\">                beforeExecute(wt, task);</span><br><span class=\"line\">                Throwable thrown = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//这是接口方法，客户端自定义的任务在这里执行，其实从实现来看执行的FutureTask的run方法</span></span><br><span class=\"line\">                    task.run();</span><br><span class=\"line\">                    <span class=\"comment\">//以下异常是任务抛出的异常,如果抛出异常，则退出Main Loop，然后设置completedAbruptly=false</span></span><br><span class=\"line\">                    <span class=\"comment\">//此时会进入processWorkerExit方法</span></span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (RuntimeException x) &#123;</span><br><span class=\"line\">                    thrown = x; <span class=\"keyword\">throw</span> x;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Error x) &#123;</span><br><span class=\"line\">                    thrown = x; <span class=\"keyword\">throw</span> x;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Throwable x) &#123;</span><br><span class=\"line\">                    thrown = x; <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> Error(x);</span><br><span class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                    <span class=\"comment\">//扩展钩子方法：任务执行后的处理</span></span><br><span class=\"line\">                    afterExecute(task, thrown);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                task = <span class=\"keyword\">null</span>;</span><br><span class=\"line\">                w.completedTasks++;</span><br><span class=\"line\">                w.unlock();</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        completedAbruptly = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        processWorkerExit(w, completedAbruptly);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"私有方法-processWorkerExit\"><a href=\"#私有方法-processWorkerExit\" class=\"headerlink\" title=\"私有方法-processWorkerExit\"></a>私有方法-processWorkerExit</h3><p>该方法用户处理Worker因为异常情况退出，比如任务抛出异常，或者Worker被中断了</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">processWorkerExit</span><span class=\"params\">(Worker w, <span class=\"keyword\">boolean</span> completedAbruptly)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (completedAbruptly) <span class=\"comment\">// If abrupt, then workerCount wasn't adjusted</span></span><br><span class=\"line\">        decrementWorkerCount();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">final</span> ReentrantLock mainLock = <span class=\"keyword\">this</span>.mainLock;</span><br><span class=\"line\">    mainLock.lock();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        completedTaskCount += w.completedTasks;</span><br><span class=\"line\">        <span class=\"comment\">//删除Worker</span></span><br><span class=\"line\">        workers.remove(w);</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        mainLock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    tryTerminate();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">int</span> c = ctl.get();</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (runStateLessThan(c, STOP)) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!completedAbruptly) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">int</span> min = allowCoreThreadTimeOut ? <span class=\"number\">0</span> : corePoolSize;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (min == <span class=\"number\">0</span> &amp;&amp; ! workQueue.isEmpty())</span><br><span class=\"line\">                min = <span class=\"number\">1</span>;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (workerCountOf(c) &gt;= min)</span><br><span class=\"line\">                <span class=\"comment\">//工作的Worker大于min，则没必要替换，直接返回</span></span><br><span class=\"line\">                <span class=\"keyword\">return</span>; <span class=\"comment\">// replacement not needed</span></span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//启动新的Worker处理任务</span></span><br><span class=\"line\">        addWorker(<span class=\"keyword\">null</span>, <span class=\"keyword\">false</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"私有方法-getTask\"><a href=\"#私有方法-getTask\" class=\"headerlink\" title=\"私有方法-getTask\"></a>私有方法-getTask</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> Runnable <span class=\"title\">getTask</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">boolean</span> timedOut = <span class=\"keyword\">false</span>; <span class=\"comment\">// Did the last poll() time out?</span></span><br><span class=\"line\">\t<span class=\"comment\">//不断在阻塞获取任务</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (;;) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">int</span> c = ctl.get();</span><br><span class=\"line\">        <span class=\"keyword\">int</span> rs = runStateOf(c);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Check if queue empty only if necessary.</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (rs &gt;= SHUTDOWN &amp;&amp; (rs &gt;= STOP || workQueue.isEmpty())) &#123;</span><br><span class=\"line\">            decrementWorkerCount();</span><br><span class=\"line\">            <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">int</span> wc = workerCountOf(c);</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"comment\">// Are workers subject to culling?</span></span><br><span class=\"line\">        <span class=\"keyword\">boolean</span> timed = allowCoreThreadTimeOut || wc &gt; corePoolSize;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">if</span> ((wc &gt; maximumPoolSize || (timed &amp;&amp; timedOut))</span><br><span class=\"line\">            &amp;&amp; (wc &gt; <span class=\"number\">1</span> || workQueue.isEmpty())) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (compareAndDecrementWorkerCount(c))</span><br><span class=\"line\">                <span class=\"keyword\">return</span> <span class=\"keyword\">null</span>;</span><br><span class=\"line\">            <span class=\"keyword\">continue</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//如果allowCoreThreadTimeOut是true，在keepAliveTime时间内，没有任务到来，</span></span><br><span class=\"line\">            Runnable r = timed ?</span><br><span class=\"line\">                workQueue.poll(keepAliveTime, TimeUnit.NANOSECONDS) :</span><br><span class=\"line\">                workQueue.take();</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (r != <span class=\"keyword\">null</span>)</span><br><span class=\"line\">                <span class=\"keyword\">return</span> r;</span><br><span class=\"line\">            timedOut = <span class=\"keyword\">true</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (InterruptedException retry) &#123;</span><br><span class=\"line\">            timedOut = <span class=\"keyword\">false</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n<h3 id=\"私有方法-interruptIdleWorkers\"><a href=\"#私有方法-interruptIdleWorkers\" class=\"headerlink\" title=\"私有方法-interruptIdleWorkers\"></a>私有方法-interruptIdleWorkers</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">void</span> <span class=\"title\">interruptIdleWorkers</span><span class=\"params\">(<span class=\"keyword\">boolean</span> onlyOne)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ReentrantLock mainLock = <span class=\"keyword\">this</span>.mainLock;</span><br><span class=\"line\">    mainLock.lock();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"keyword\">for</span> (Worker w : workers) &#123;</span><br><span class=\"line\">            Thread t = w.thread;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (!t.isInterrupted() &amp;&amp; w.tryLock()) &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    t.interrupt();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (SecurityException ignore) &#123;</span><br><span class=\"line\">                &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">                    w.unlock();</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">            <span class=\"keyword\">if</span> (onlyOne)</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        mainLock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h3 id=\"公共API-shutdown\"><a href=\"#公共API-shutdown\" class=\"headerlink\" title=\"公共API-shutdown\"></a>公共API-shutdown</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">shutdown</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ReentrantLock mainLock = <span class=\"keyword\">this</span>.mainLock;</span><br><span class=\"line\">    mainLock.lock();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        <span class=\"comment\">//检查关闭权限</span></span><br><span class=\"line\">        checkShutdownAccess();</span><br><span class=\"line\">        <span class=\"comment\">//线程池状态设置为SHUTDOWN</span></span><br><span class=\"line\">        advanceRunState(SHUTDOWN);</span><br><span class=\"line\">        <span class=\"comment\">//中断所有的空闲的Worker，此时真正执行任务的Worker不会被中断，因为获取不到锁</span></span><br><span class=\"line\">        interruptIdleWorkers();</span><br><span class=\"line\">        onShutdown(); <span class=\"comment\">// hook for ScheduledThreadPoolExecutor</span></span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        mainLock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    tryTerminate();</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"公共API-shutdownNow\"><a href=\"#公共API-shutdownNow\" class=\"headerlink\" title=\"公共API-shutdownNow\"></a>公共API-shutdownNow</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> List&lt;Runnable&gt; <span class=\"title\">shutdownNow</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    List&lt;Runnable&gt; tasks;</span><br><span class=\"line\">    <span class=\"keyword\">final</span> ReentrantLock mainLock = <span class=\"keyword\">this</span>.mainLock;</span><br><span class=\"line\">    mainLock.lock();</span><br><span class=\"line\">    <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">        checkShutdownAccess();</span><br><span class=\"line\">        advanceRunState(STOP);</span><br><span class=\"line\">        interruptWorkers();</span><br><span class=\"line\">        <span class=\"comment\">//workQueue中所有的任务会被取出来，然后交由客户端处理</span></span><br><span class=\"line\">        tasks = drainQueue();</span><br><span class=\"line\">    &#125; <span class=\"keyword\">finally</span> &#123;</span><br><span class=\"line\">        mainLock.unlock();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    tryTerminate();</span><br><span class=\"line\">    <span class=\"keyword\">return</span> tasks;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h3 id=\"公共API-allowCoreThreadTimeOut\"><a href=\"#公共API-allowCoreThreadTimeOut\" class=\"headerlink\" title=\"公共API-allowCoreThreadTimeOut\"></a>公共API-allowCoreThreadTimeOut</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">allowCoreThreadTimeOut</span><span class=\"params\">(<span class=\"keyword\">boolean</span> value)</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (value &amp;&amp; keepAliveTime &lt;= <span class=\"number\">0</span>)</span><br><span class=\"line\">        <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> IllegalArgumentException(<span class=\"string\">\"Core threads must have nonzero keep alive times\"</span>);</span><br><span class=\"line\">    <span class=\"keyword\">if</span> (value != allowCoreThreadTimeOut) &#123;</span><br><span class=\"line\">        allowCoreThreadTimeOut = value;</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (value)</span><br><span class=\"line\">            interruptIdleWorkers();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"公共API-prestartAllCoreThreads\"><a href=\"#公共API-prestartAllCoreThreads\" class=\"headerlink\" title=\"公共API-prestartAllCoreThreads\"></a>公共API-prestartAllCoreThreads</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">int</span> <span class=\"title\">prestartAllCoreThreads</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">int</span> n = <span class=\"number\">0</span>;</span><br><span class=\"line\">    <span class=\"comment\">//firstTask是null,core是true，这时候只会启动线程，但是不会执行任何任务</span></span><br><span class=\"line\">    <span class=\"keyword\">while</span> (addWorker(<span class=\"keyword\">null</span>, <span class=\"keyword\">true</span>))</span><br><span class=\"line\">        ++n;</span><br><span class=\"line\">    <span class=\"keyword\">return</span> n;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n<h3 id=\"工具方法\"><a href=\"#工具方法\" class=\"headerlink\" title=\"工具方法\"></a>工具方法</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">runStateOf</span><span class=\"params\">(<span class=\"keyword\">int</span> c)</span>     </span>&#123; <span class=\"keyword\">return</span> c &amp; ~CAPACITY; &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">workerCountOf</span><span class=\"params\">(<span class=\"keyword\">int</span> c)</span>  </span>&#123; <span class=\"keyword\">return</span> c &amp; CAPACITY; &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">int</span> <span class=\"title\">ctlOf</span><span class=\"params\">(<span class=\"keyword\">int</span> rs, <span class=\"keyword\">int</span> wc)</span> </span>&#123; <span class=\"keyword\">return</span> rs | wc; &#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">runStateLessThan</span><span class=\"params\">(<span class=\"keyword\">int</span> c, <span class=\"keyword\">int</span> s)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> c &lt; s;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">runStateAtLeast</span><span class=\"params\">(<span class=\"keyword\">int</span> c, <span class=\"keyword\">int</span> s)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> c &gt;= s;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isRunning</span><span class=\"params\">(<span class=\"keyword\">int</span> c)</span> </span>&#123;</span><br><span class=\"line\">\t<span class=\"keyword\">return</span> c &lt; SHUTDOWN;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"静态字段\"><a href=\"#静态字段\" class=\"headerlink\" title=\"静态字段\"></a>静态字段</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">final</span> AtomicInteger ctl = <span class=\"keyword\">new</span> AtomicInteger(ctlOf(RUNNING, <span class=\"number\">0</span>));</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> COUNT_BITS = Integer.SIZE - <span class=\"number\">3</span>;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> CAPACITY   = (<span class=\"number\">1</span> &lt;&lt; COUNT_BITS) - <span class=\"number\">1</span>;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">// runState is stored in the high-order bits</span></span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> RUNNING    = -<span class=\"number\">1</span> &lt;&lt; COUNT_BITS;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> SHUTDOWN   =  <span class=\"number\">0</span> &lt;&lt; COUNT_BITS;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> STOP       =  <span class=\"number\">1</span> &lt;&lt; COUNT_BITS;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> TIDYING    =  <span class=\"number\">2</span> &lt;&lt; COUNT_BITS;</span><br><span class=\"line\"><span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> TERMINATED =  <span class=\"number\">3</span> &lt;&lt; COUNT_BITS;</span><br></pre></td></tr></table></figure>\n\n\n\n\n\n\n\n<h2 id=\"Executors实现\"><a href=\"#Executors实现\" class=\"headerlink\" title=\"Executors实现\"></a>Executors实现</h2><p>Executors是对执行者的静态工厂类，提供了常用的执行策略，并且提供了对任务的包装。</p>\n<h1 id=\"实战案例\"><a href=\"#实战案例\" class=\"headerlink\" title=\"实战案例\"></a>实战案例</h1><h2 id=\"tomcat线程池解读\"><a href=\"#tomcat线程池解读\" class=\"headerlink\" title=\"tomcat线程池解读\"></a>tomcat线程池解读</h2><p>org.apache.tomcat.util.threads.ThreadPoolExecutor </p>\n<h2 id=\"扩展ThreadPoolExecutor\"><a href=\"#扩展ThreadPoolExecutor\" class=\"headerlink\" title=\"扩展ThreadPoolExecutor\"></a>扩展ThreadPoolExecutor</h2><h2 id=\"多元化的拒绝策略\"><a href=\"#多元化的拒绝策略\" class=\"headerlink\" title=\"多元化的拒绝策略\"></a>多元化的拒绝策略</h2><h2 id=\"Apache-HttpComponents-Worker\"><a href=\"#Apache-HttpComponents-Worker\" class=\"headerlink\" title=\"Apache HttpComponents Worker\"></a>Apache HttpComponents Worker</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">WorkerPoolExecutor</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"Spring的抽象\"><a href=\"#Spring的抽象\" class=\"headerlink\" title=\"Spring的抽象\"></a>Spring的抽象</h2><h1 id=\"结论和启示\"><a href=\"#结论和启示\" class=\"headerlink\" title=\"结论和启示\"></a>结论和启示</h1>"},{"title":"聊聊数据同步(Redis和MySQL数据同步)","date":"2022-09-24T12:51:41.000Z","_content":"\n数据同步问题是应用层非常值得研究的一个设计问题，也是为数不多值得研究的数据问题。虽然在实践中各种方案会运行的很好，但是这些方案背后有哪些假设，以及问题的模型是什么，这个点并没有得到充分理解，所以本文以经验之谈分析了下数据同步的设计问题，案例分析以及结论。\n\n# 数据同步的设计问题\n\n数据同步问题是将一个地方数据，经过计算/不计算挪动到另外一个地方，在这个过程中，会面临三个问题：\n\n1. **如何同步？**机器是否跨网络，是否单机，策略是双写或者是异步写？同步的是指令还是数据？双写中并发写问题如何解决？\n2. **数据形态是什么？**副本，缓存（缓存是一种特殊的副本），副本形态可能高写入，缓存形态一般高读取。\n3. **谁来解决这个问题？**应用层，还是中间件层。发起同步的进程还是后台进程？\n\n这些问题抽象为：多节点(同构或异构)数据复制带来的一致性问题。而这样问题也会受到CAP或者Jepsen中一致性的等级所制约。\n\n我们来依次看看这些问题。如何同步的问题抽象是写入保证一致性，而跨网络抽象成复制问题，单机会抽象成单进程/线程读写问题，一个地方移动到另外一个地方，复制有主动/被动，有异步和同步，地点可以是内存到磁盘，可以是Redis到MySQL，可以是内存到Redis，数据的形态有副本，有缓存，不同的形态数据使用场景不同，带来的复制更新问题也不同，如缓存会有一系列缓存淘汰算法或者缓存更新策略(通读，通写，后写)，这个过程相对主动，谁来解决这个问题，影响了系统的实现。\n\n如果在单机情况下，那么要保证操作同时成功，或者同时失败，数据能保证一致性，那么单机系统中最完美的抽象是事务。事务的ACID特性完美解决了一系列问题，如并发控制和恢复系统。\n\n在分布式场景下，由于CAP/PACELC的限制，会导致数据同步（复制策略）不同，导致了不同的一致性级别。\n\n但是面对异构系统，且跨网络的模型，原子广播协议或者分布式事务可以解决此类问题，但是谁来解决跨系统分布式事务呢？据我所知，暂时没有这样机制。即使XA模型很早提出了，Java领域也有JTA模型，但是实际系统中很少使用，因为性能或者易用性的问题。所以双写问题带来的固然局限性，因为处理异常情况非常复杂，业内也没有非常成熟的实践。\n\n\n\n# 案例分析\n\n案例有同构和异构系统的一致性总结。以及谁来解决这个问题来进行总结。\n\n| 系统                 | 如何同步     | 数据形态 | 解决层     | CAP                |\n| -------------------- | ------------ | -------- | ---------- | ------------------ |\n| Redis 主从           | 异步复制     | 副本     | Redis      | AP                 |\n| Redis和应用内存      | 双写，异步写 | 缓存     | 应用层     | 可选               |\n| 操作系统的内存和磁盘 | 双写         | 缓存     | 操作系统层 | CA                 |\n| Redis和MySQL         | 双写，异步写 | 缓存     | 应用层     | 可选               |\n| MySQL主从            | 异步复制     | 副本     | MySQL      | 异步AP<br />同步CP |\n| Zookeeper            | ZAB协议      | 副本     | Zookeeper  | CP                 |\n| Etcd                 | Raft协议     | 副本     | Etcd       | CP                 |\n| MySQL 内存和磁盘     | 事务         | 缓存     | MySQL      | CA                 |\n\n## Redis和MySQL同步分析\n\n同步为什么很困难？1 网络的引入导致成功，失败，不可知状态。  2  谁来解决问题，还是返回给操作方？如果没有操作方是进程呢？ 3 在同构系统同步已经很复杂但成熟，异构系统更加复杂且不成熟。4 更新操作的顺序考虑。\n\n如何简化问题？忽略网络，操作方解决。\n\n虽然问题分析比较有意思，但是方案来说有：\n\n> 1. 同步：cache-aside（缓存驻留），read through(通读)，write through（通写）等。\n> 2. 异步：单机内存队列（Sticky Available），消息中间件（请求定序），write behind（后写），Refresh ahead（预加载）等。\n\n这里重点看看cache-aside模式（方案1是缓存驻留模式，其他都是对比方案）的写入方案，也是理解同步问题的起点，下面有四种模式（假设没有发生网络异常）：\n\n```java\n//方案1\nupdateDB();\ndeteleCache();\n\n//方案2\ndeleteCache();\nupdateDB();\n\n//方案3\nupdateDB();\nupdateCache();\n\n//方案4\nupdateCache();\nupdateDB();\n```\n\n**方案1，先更新数据库，后删除缓存**。这个方案是常用的方案。但是会有极小概率出现这种情况：读操作没有命中缓存，会去数据库取数据，此时写请求进入，写完数据库，然后缓存失效，之前的读请求再把老数据放进去，会导致脏数据问题。这个情况理论上会出现，但是概率非常小，需要满足条件有：发生在读缓存时失效，且有并发写入，数据库写比读慢很多，所以读操作必须在写操作前进去数据库，而晚于写操作更新缓存。\n\n**方案2，先删除缓存，后更新数据库。**可能很短时间内，新的请求会读数据，然后发现缓存没有数据，就会设置缓存，导致缓存有脏数据。缓存宁愿没数据，也不要脏数据。这个概率发生要比1高很多。因为缓存模式就是读多血少。\n\n**方案3，先更新数据库，后更新缓存。**由于缓存构建可能很慢，不是简单从数据库中读取出来，更新缓存可能会非常慢，不如直接删除缓存，在下次加载时候重新计算，更是因为并发写会导致脏数据问题。因为第二个写入可能会被第一个写入覆盖了。\n\n**方案4，先更新缓存，后更新数据库。**理由同方案3。从效果上看该方案和通写一样，数据更新没有命中缓存，那么直接更新数据，如果命中缓存，那么更更新缓存，然后Cache自己更新数据库。\n\n\n\n以上四种方案本质是同步方案，而没有考虑网络异常，如果网络异常导致某一个节点不可用，就会导致同步失败（为了一致性而牺牲了可用性），此时应用层有感知，虽然处理这种失败可以重试，但是如果节点是宕机呢？数据可以暂时存在本地内存队列中，等节点启动后进行同步，而要保证下次请求读到上次写入的数据，那么需要满足Jepsen中[Read Your Writes](https://jepsen.io/consistency/models/read-your-writes)的一致性，但是这种一致性下可用性是Sticky Available，也就是会话一致性，需要将请求定位到同一台机器，但是如果该机器宕机了，那么内存数据会丢失。完美的方案是引入事务模型来解决同时成功或者同时失败从而使得开发者忽略一切底层细节，但是代价很高且缺少分布式事务方案可以直接来用，所以引入异步方案也是一种方式，异步更新时效性没有同步那么及时，但是需要解决的问题较少，可以进行后台定时同步（类似于反熵过程），或者消息队列进行CDC或者定序（分布式提交日志）等操作进行同步，较为复杂场景是MySQL主从和Redis主从进行同步，如果是读MySQL从，而后写入Redis主，那么数据也会不一样，但是需要理解Redis对于MySQL数据形态是什么？如果Redis当做缓存，那么会有一些列缓存更新问题出现，但是缓存使用必然会带来不一致性，只是能够接受多久的不一致性时间窗口。\n\n每一个种选择都会带来对应的问题，而需要仔细衡量解决问题的成本。**没有完美的方案，只有削足适履的选择！**\n\n# 结论\n\n本文将数据同步问题抽象成多节点数据复制带来的一致性问题。\n\n所以上表可以得出结论：\n\n1. **同构的系统的同步**，采用共识协议或者健壮的复制，且由系统自己解决的方案占据大多数，\n2. **异构系统的同步**，同步或者异步写都有可能，但是需要解决各自方案带来的问题，如同步需要保证同时成功，同时失败问题，而异步写需要解决系统间一致性延时问题。双写会在不同数据形态会展示不同的策略，如果数据形态是缓存，那么双写策略有通写，或者后写等缓存更新策略，还会有缓存淘汰算法等策略。一般由应用层解决较多。\n2. **实际工程中**：同步的cache-aside，通读，异步Kafka方案，或者广播消息方式，定时任务刷新是解决这类问题的有效方案。\n\n# 参考\n\n1. 耗子叔 极客时间-性能设计篇之-缓存\n2. 微软：云计算架构设计模式 [Cache aside](https://github.com/iambowen/cloud-design-patterns/blob/master/patterns/cache-aside.md)\n3. [https://docs.aws.amazon.com/whitepapers/latest/database-caching-strategies-using-redis/caching-patterns.html](https://docs.aws.amazon.com/whitepapers/latest/database-caching-strategies-using-redis/caching-patterns.html)\n4. Ehcache：[https://www.ehcache.org/documentation/3.3/caching-patterns.html](https://www.ehcache.org/documentation/3.3/caching-patterns.html)\n5. 耗子叔-缓存更新的套路 [https://coolshell.cn/articles/17416.html](https://coolshell.cn/articles/17416.html)\n6. DDIA第十一章：流处理 [https://github.com/Vonng/ddia/blob/master/ch11.md](https://github.com/Vonng/ddia/blob/master/ch11.md)\n6. Hazelcast Caching Patterns：[https://hazelcast.com/blog/a-hitchhikers-guide-to-caching-patterns/](https://hazelcast.com/blog/a-hitchhikers-guide-to-caching-patterns/)\n6. Cache：[https://en.wikipedia.org/wiki/Cache_(computing)](https://en.wikipedia.org/wiki/Cache_(computing))\n6. Cache stampede：[https://en.wikipedia.org/wiki/Cache_stampede](https://en.wikipedia.org/wiki/Cache_stampede)\n","source":"_posts/data-synchronization-thinking.md","raw":"---\ntitle: 聊聊数据同步(Redis和MySQL数据同步)\ndate: 2022-09-24 20:51:41\ntags:\n  - 数据同步\n  - MySQL和Redis\ncategories:\n  - system design\n---\n\n数据同步问题是应用层非常值得研究的一个设计问题，也是为数不多值得研究的数据问题。虽然在实践中各种方案会运行的很好，但是这些方案背后有哪些假设，以及问题的模型是什么，这个点并没有得到充分理解，所以本文以经验之谈分析了下数据同步的设计问题，案例分析以及结论。\n\n# 数据同步的设计问题\n\n数据同步问题是将一个地方数据，经过计算/不计算挪动到另外一个地方，在这个过程中，会面临三个问题：\n\n1. **如何同步？**机器是否跨网络，是否单机，策略是双写或者是异步写？同步的是指令还是数据？双写中并发写问题如何解决？\n2. **数据形态是什么？**副本，缓存（缓存是一种特殊的副本），副本形态可能高写入，缓存形态一般高读取。\n3. **谁来解决这个问题？**应用层，还是中间件层。发起同步的进程还是后台进程？\n\n这些问题抽象为：多节点(同构或异构)数据复制带来的一致性问题。而这样问题也会受到CAP或者Jepsen中一致性的等级所制约。\n\n我们来依次看看这些问题。如何同步的问题抽象是写入保证一致性，而跨网络抽象成复制问题，单机会抽象成单进程/线程读写问题，一个地方移动到另外一个地方，复制有主动/被动，有异步和同步，地点可以是内存到磁盘，可以是Redis到MySQL，可以是内存到Redis，数据的形态有副本，有缓存，不同的形态数据使用场景不同，带来的复制更新问题也不同，如缓存会有一系列缓存淘汰算法或者缓存更新策略(通读，通写，后写)，这个过程相对主动，谁来解决这个问题，影响了系统的实现。\n\n如果在单机情况下，那么要保证操作同时成功，或者同时失败，数据能保证一致性，那么单机系统中最完美的抽象是事务。事务的ACID特性完美解决了一系列问题，如并发控制和恢复系统。\n\n在分布式场景下，由于CAP/PACELC的限制，会导致数据同步（复制策略）不同，导致了不同的一致性级别。\n\n但是面对异构系统，且跨网络的模型，原子广播协议或者分布式事务可以解决此类问题，但是谁来解决跨系统分布式事务呢？据我所知，暂时没有这样机制。即使XA模型很早提出了，Java领域也有JTA模型，但是实际系统中很少使用，因为性能或者易用性的问题。所以双写问题带来的固然局限性，因为处理异常情况非常复杂，业内也没有非常成熟的实践。\n\n\n\n# 案例分析\n\n案例有同构和异构系统的一致性总结。以及谁来解决这个问题来进行总结。\n\n| 系统                 | 如何同步     | 数据形态 | 解决层     | CAP                |\n| -------------------- | ------------ | -------- | ---------- | ------------------ |\n| Redis 主从           | 异步复制     | 副本     | Redis      | AP                 |\n| Redis和应用内存      | 双写，异步写 | 缓存     | 应用层     | 可选               |\n| 操作系统的内存和磁盘 | 双写         | 缓存     | 操作系统层 | CA                 |\n| Redis和MySQL         | 双写，异步写 | 缓存     | 应用层     | 可选               |\n| MySQL主从            | 异步复制     | 副本     | MySQL      | 异步AP<br />同步CP |\n| Zookeeper            | ZAB协议      | 副本     | Zookeeper  | CP                 |\n| Etcd                 | Raft协议     | 副本     | Etcd       | CP                 |\n| MySQL 内存和磁盘     | 事务         | 缓存     | MySQL      | CA                 |\n\n## Redis和MySQL同步分析\n\n同步为什么很困难？1 网络的引入导致成功，失败，不可知状态。  2  谁来解决问题，还是返回给操作方？如果没有操作方是进程呢？ 3 在同构系统同步已经很复杂但成熟，异构系统更加复杂且不成熟。4 更新操作的顺序考虑。\n\n如何简化问题？忽略网络，操作方解决。\n\n虽然问题分析比较有意思，但是方案来说有：\n\n> 1. 同步：cache-aside（缓存驻留），read through(通读)，write through（通写）等。\n> 2. 异步：单机内存队列（Sticky Available），消息中间件（请求定序），write behind（后写），Refresh ahead（预加载）等。\n\n这里重点看看cache-aside模式（方案1是缓存驻留模式，其他都是对比方案）的写入方案，也是理解同步问题的起点，下面有四种模式（假设没有发生网络异常）：\n\n```java\n//方案1\nupdateDB();\ndeteleCache();\n\n//方案2\ndeleteCache();\nupdateDB();\n\n//方案3\nupdateDB();\nupdateCache();\n\n//方案4\nupdateCache();\nupdateDB();\n```\n\n**方案1，先更新数据库，后删除缓存**。这个方案是常用的方案。但是会有极小概率出现这种情况：读操作没有命中缓存，会去数据库取数据，此时写请求进入，写完数据库，然后缓存失效，之前的读请求再把老数据放进去，会导致脏数据问题。这个情况理论上会出现，但是概率非常小，需要满足条件有：发生在读缓存时失效，且有并发写入，数据库写比读慢很多，所以读操作必须在写操作前进去数据库，而晚于写操作更新缓存。\n\n**方案2，先删除缓存，后更新数据库。**可能很短时间内，新的请求会读数据，然后发现缓存没有数据，就会设置缓存，导致缓存有脏数据。缓存宁愿没数据，也不要脏数据。这个概率发生要比1高很多。因为缓存模式就是读多血少。\n\n**方案3，先更新数据库，后更新缓存。**由于缓存构建可能很慢，不是简单从数据库中读取出来，更新缓存可能会非常慢，不如直接删除缓存，在下次加载时候重新计算，更是因为并发写会导致脏数据问题。因为第二个写入可能会被第一个写入覆盖了。\n\n**方案4，先更新缓存，后更新数据库。**理由同方案3。从效果上看该方案和通写一样，数据更新没有命中缓存，那么直接更新数据，如果命中缓存，那么更更新缓存，然后Cache自己更新数据库。\n\n\n\n以上四种方案本质是同步方案，而没有考虑网络异常，如果网络异常导致某一个节点不可用，就会导致同步失败（为了一致性而牺牲了可用性），此时应用层有感知，虽然处理这种失败可以重试，但是如果节点是宕机呢？数据可以暂时存在本地内存队列中，等节点启动后进行同步，而要保证下次请求读到上次写入的数据，那么需要满足Jepsen中[Read Your Writes](https://jepsen.io/consistency/models/read-your-writes)的一致性，但是这种一致性下可用性是Sticky Available，也就是会话一致性，需要将请求定位到同一台机器，但是如果该机器宕机了，那么内存数据会丢失。完美的方案是引入事务模型来解决同时成功或者同时失败从而使得开发者忽略一切底层细节，但是代价很高且缺少分布式事务方案可以直接来用，所以引入异步方案也是一种方式，异步更新时效性没有同步那么及时，但是需要解决的问题较少，可以进行后台定时同步（类似于反熵过程），或者消息队列进行CDC或者定序（分布式提交日志）等操作进行同步，较为复杂场景是MySQL主从和Redis主从进行同步，如果是读MySQL从，而后写入Redis主，那么数据也会不一样，但是需要理解Redis对于MySQL数据形态是什么？如果Redis当做缓存，那么会有一些列缓存更新问题出现，但是缓存使用必然会带来不一致性，只是能够接受多久的不一致性时间窗口。\n\n每一个种选择都会带来对应的问题，而需要仔细衡量解决问题的成本。**没有完美的方案，只有削足适履的选择！**\n\n# 结论\n\n本文将数据同步问题抽象成多节点数据复制带来的一致性问题。\n\n所以上表可以得出结论：\n\n1. **同构的系统的同步**，采用共识协议或者健壮的复制，且由系统自己解决的方案占据大多数，\n2. **异构系统的同步**，同步或者异步写都有可能，但是需要解决各自方案带来的问题，如同步需要保证同时成功，同时失败问题，而异步写需要解决系统间一致性延时问题。双写会在不同数据形态会展示不同的策略，如果数据形态是缓存，那么双写策略有通写，或者后写等缓存更新策略，还会有缓存淘汰算法等策略。一般由应用层解决较多。\n2. **实际工程中**：同步的cache-aside，通读，异步Kafka方案，或者广播消息方式，定时任务刷新是解决这类问题的有效方案。\n\n# 参考\n\n1. 耗子叔 极客时间-性能设计篇之-缓存\n2. 微软：云计算架构设计模式 [Cache aside](https://github.com/iambowen/cloud-design-patterns/blob/master/patterns/cache-aside.md)\n3. [https://docs.aws.amazon.com/whitepapers/latest/database-caching-strategies-using-redis/caching-patterns.html](https://docs.aws.amazon.com/whitepapers/latest/database-caching-strategies-using-redis/caching-patterns.html)\n4. Ehcache：[https://www.ehcache.org/documentation/3.3/caching-patterns.html](https://www.ehcache.org/documentation/3.3/caching-patterns.html)\n5. 耗子叔-缓存更新的套路 [https://coolshell.cn/articles/17416.html](https://coolshell.cn/articles/17416.html)\n6. DDIA第十一章：流处理 [https://github.com/Vonng/ddia/blob/master/ch11.md](https://github.com/Vonng/ddia/blob/master/ch11.md)\n6. Hazelcast Caching Patterns：[https://hazelcast.com/blog/a-hitchhikers-guide-to-caching-patterns/](https://hazelcast.com/blog/a-hitchhikers-guide-to-caching-patterns/)\n6. Cache：[https://en.wikipedia.org/wiki/Cache_(computing)](https://en.wikipedia.org/wiki/Cache_(computing))\n6. Cache stampede：[https://en.wikipedia.org/wiki/Cache_stampede](https://en.wikipedia.org/wiki/Cache_stampede)\n","slug":"data-synchronization-thinking","published":1,"updated":"2022-12-09T06:22:30.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clh7s5ctu000wxt8jbj1mcu9b","content":"<p>数据同步问题是应用层非常值得研究的一个设计问题，也是为数不多值得研究的数据问题。虽然在实践中各种方案会运行的很好，但是这些方案背后有哪些假设，以及问题的模型是什么，这个点并没有得到充分理解，所以本文以经验之谈分析了下数据同步的设计问题，案例分析以及结论。</p>\n<h1 id=\"数据同步的设计问题\"><a href=\"#数据同步的设计问题\" class=\"headerlink\" title=\"数据同步的设计问题\"></a>数据同步的设计问题</h1><p>数据同步问题是将一个地方数据，经过计算/不计算挪动到另外一个地方，在这个过程中，会面临三个问题：</p>\n<ol>\n<li><strong>如何同步？</strong>机器是否跨网络，是否单机，策略是双写或者是异步写？同步的是指令还是数据？双写中并发写问题如何解决？</li>\n<li><strong>数据形态是什么？</strong>副本，缓存（缓存是一种特殊的副本），副本形态可能高写入，缓存形态一般高读取。</li>\n<li><strong>谁来解决这个问题？</strong>应用层，还是中间件层。发起同步的进程还是后台进程？</li>\n</ol>\n<p>这些问题抽象为：多节点(同构或异构)数据复制带来的一致性问题。而这样问题也会受到CAP或者Jepsen中一致性的等级所制约。</p>\n<p>我们来依次看看这些问题。如何同步的问题抽象是写入保证一致性，而跨网络抽象成复制问题，单机会抽象成单进程/线程读写问题，一个地方移动到另外一个地方，复制有主动/被动，有异步和同步，地点可以是内存到磁盘，可以是Redis到MySQL，可以是内存到Redis，数据的形态有副本，有缓存，不同的形态数据使用场景不同，带来的复制更新问题也不同，如缓存会有一系列缓存淘汰算法或者缓存更新策略(通读，通写，后写)，这个过程相对主动，谁来解决这个问题，影响了系统的实现。</p>\n<p>如果在单机情况下，那么要保证操作同时成功，或者同时失败，数据能保证一致性，那么单机系统中最完美的抽象是事务。事务的ACID特性完美解决了一系列问题，如并发控制和恢复系统。</p>\n<p>在分布式场景下，由于CAP/PACELC的限制，会导致数据同步（复制策略）不同，导致了不同的一致性级别。</p>\n<p>但是面对异构系统，且跨网络的模型，原子广播协议或者分布式事务可以解决此类问题，但是谁来解决跨系统分布式事务呢？据我所知，暂时没有这样机制。即使XA模型很早提出了，Java领域也有JTA模型，但是实际系统中很少使用，因为性能或者易用性的问题。所以双写问题带来的固然局限性，因为处理异常情况非常复杂，业内也没有非常成熟的实践。</p>\n<h1 id=\"案例分析\"><a href=\"#案例分析\" class=\"headerlink\" title=\"案例分析\"></a>案例分析</h1><p>案例有同构和异构系统的一致性总结。以及谁来解决这个问题来进行总结。</p>\n<table>\n<thead>\n<tr>\n<th>系统</th>\n<th>如何同步</th>\n<th>数据形态</th>\n<th>解决层</th>\n<th>CAP</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Redis 主从</td>\n<td>异步复制</td>\n<td>副本</td>\n<td>Redis</td>\n<td>AP</td>\n</tr>\n<tr>\n<td>Redis和应用内存</td>\n<td>双写，异步写</td>\n<td>缓存</td>\n<td>应用层</td>\n<td>可选</td>\n</tr>\n<tr>\n<td>操作系统的内存和磁盘</td>\n<td>双写</td>\n<td>缓存</td>\n<td>操作系统层</td>\n<td>CA</td>\n</tr>\n<tr>\n<td>Redis和MySQL</td>\n<td>双写，异步写</td>\n<td>缓存</td>\n<td>应用层</td>\n<td>可选</td>\n</tr>\n<tr>\n<td>MySQL主从</td>\n<td>异步复制</td>\n<td>副本</td>\n<td>MySQL</td>\n<td>异步AP<br />同步CP</td>\n</tr>\n<tr>\n<td>Zookeeper</td>\n<td>ZAB协议</td>\n<td>副本</td>\n<td>Zookeeper</td>\n<td>CP</td>\n</tr>\n<tr>\n<td>Etcd</td>\n<td>Raft协议</td>\n<td>副本</td>\n<td>Etcd</td>\n<td>CP</td>\n</tr>\n<tr>\n<td>MySQL 内存和磁盘</td>\n<td>事务</td>\n<td>缓存</td>\n<td>MySQL</td>\n<td>CA</td>\n</tr>\n</tbody></table>\n<h2 id=\"Redis和MySQL同步分析\"><a href=\"#Redis和MySQL同步分析\" class=\"headerlink\" title=\"Redis和MySQL同步分析\"></a>Redis和MySQL同步分析</h2><p>同步为什么很困难？1 网络的引入导致成功，失败，不可知状态。  2  谁来解决问题，还是返回给操作方？如果没有操作方是进程呢？ 3 在同构系统同步已经很复杂但成熟，异构系统更加复杂且不成熟。4 更新操作的顺序考虑。</p>\n<p>如何简化问题？忽略网络，操作方解决。</p>\n<p>虽然问题分析比较有意思，但是方案来说有：</p>\n<blockquote>\n<ol>\n<li>同步：cache-aside（缓存驻留），read through(通读)，write through（通写）等。</li>\n<li>异步：单机内存队列（Sticky Available），消息中间件（请求定序），write behind（后写），Refresh ahead（预加载）等。</li>\n</ol>\n</blockquote>\n<p>这里重点看看cache-aside模式（方案1是缓存驻留模式，其他都是对比方案）的写入方案，也是理解同步问题的起点，下面有四种模式（假设没有发生网络异常）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//方案1</span></span><br><span class=\"line\">updateDB();</span><br><span class=\"line\">deteleCache();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//方案2</span></span><br><span class=\"line\">deleteCache();</span><br><span class=\"line\">updateDB();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//方案3</span></span><br><span class=\"line\">updateDB();</span><br><span class=\"line\">updateCache();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//方案4</span></span><br><span class=\"line\">updateCache();</span><br><span class=\"line\">updateDB();</span><br></pre></td></tr></table></figure>\n\n<p><strong>方案1，先更新数据库，后删除缓存</strong>。这个方案是常用的方案。但是会有极小概率出现这种情况：读操作没有命中缓存，会去数据库取数据，此时写请求进入，写完数据库，然后缓存失效，之前的读请求再把老数据放进去，会导致脏数据问题。这个情况理论上会出现，但是概率非常小，需要满足条件有：发生在读缓存时失效，且有并发写入，数据库写比读慢很多，所以读操作必须在写操作前进去数据库，而晚于写操作更新缓存。</p>\n<p><strong>方案2，先删除缓存，后更新数据库。</strong>可能很短时间内，新的请求会读数据，然后发现缓存没有数据，就会设置缓存，导致缓存有脏数据。缓存宁愿没数据，也不要脏数据。这个概率发生要比1高很多。因为缓存模式就是读多血少。</p>\n<p><strong>方案3，先更新数据库，后更新缓存。</strong>由于缓存构建可能很慢，不是简单从数据库中读取出来，更新缓存可能会非常慢，不如直接删除缓存，在下次加载时候重新计算，更是因为并发写会导致脏数据问题。因为第二个写入可能会被第一个写入覆盖了。</p>\n<p><strong>方案4，先更新缓存，后更新数据库。</strong>理由同方案3。从效果上看该方案和通写一样，数据更新没有命中缓存，那么直接更新数据，如果命中缓存，那么更更新缓存，然后Cache自己更新数据库。</p>\n<p>以上四种方案本质是同步方案，而没有考虑网络异常，如果网络异常导致某一个节点不可用，就会导致同步失败（为了一致性而牺牲了可用性），此时应用层有感知，虽然处理这种失败可以重试，但是如果节点是宕机呢？数据可以暂时存在本地内存队列中，等节点启动后进行同步，而要保证下次请求读到上次写入的数据，那么需要满足Jepsen中<a href=\"https://jepsen.io/consistency/models/read-your-writes\" target=\"_blank\" rel=\"noopener\">Read Your Writes</a>的一致性，但是这种一致性下可用性是Sticky Available，也就是会话一致性，需要将请求定位到同一台机器，但是如果该机器宕机了，那么内存数据会丢失。完美的方案是引入事务模型来解决同时成功或者同时失败从而使得开发者忽略一切底层细节，但是代价很高且缺少分布式事务方案可以直接来用，所以引入异步方案也是一种方式，异步更新时效性没有同步那么及时，但是需要解决的问题较少，可以进行后台定时同步（类似于反熵过程），或者消息队列进行CDC或者定序（分布式提交日志）等操作进行同步，较为复杂场景是MySQL主从和Redis主从进行同步，如果是读MySQL从，而后写入Redis主，那么数据也会不一样，但是需要理解Redis对于MySQL数据形态是什么？如果Redis当做缓存，那么会有一些列缓存更新问题出现，但是缓存使用必然会带来不一致性，只是能够接受多久的不一致性时间窗口。</p>\n<p>每一个种选择都会带来对应的问题，而需要仔细衡量解决问题的成本。<strong>没有完美的方案，只有削足适履的选择！</strong></p>\n<h1 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h1><p>本文将数据同步问题抽象成多节点数据复制带来的一致性问题。</p>\n<p>所以上表可以得出结论：</p>\n<ol>\n<li><strong>同构的系统的同步</strong>，采用共识协议或者健壮的复制，且由系统自己解决的方案占据大多数，</li>\n<li><strong>异构系统的同步</strong>，同步或者异步写都有可能，但是需要解决各自方案带来的问题，如同步需要保证同时成功，同时失败问题，而异步写需要解决系统间一致性延时问题。双写会在不同数据形态会展示不同的策略，如果数据形态是缓存，那么双写策略有通写，或者后写等缓存更新策略，还会有缓存淘汰算法等策略。一般由应用层解决较多。</li>\n<li><strong>实际工程中</strong>：同步的cache-aside，通读，异步Kafka方案，或者广播消息方式，定时任务刷新是解决这类问题的有效方案。</li>\n</ol>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><ol>\n<li>耗子叔 极客时间-性能设计篇之-缓存</li>\n<li>微软：云计算架构设计模式 <a href=\"https://github.com/iambowen/cloud-design-patterns/blob/master/patterns/cache-aside.md\" target=\"_blank\" rel=\"noopener\">Cache aside</a></li>\n<li><a href=\"https://docs.aws.amazon.com/whitepapers/latest/database-caching-strategies-using-redis/caching-patterns.html\" target=\"_blank\" rel=\"noopener\">https://docs.aws.amazon.com/whitepapers/latest/database-caching-strategies-using-redis/caching-patterns.html</a></li>\n<li>Ehcache：<a href=\"https://www.ehcache.org/documentation/3.3/caching-patterns.html\" target=\"_blank\" rel=\"noopener\">https://www.ehcache.org/documentation/3.3/caching-patterns.html</a></li>\n<li>耗子叔-缓存更新的套路 <a href=\"https://coolshell.cn/articles/17416.html\" target=\"_blank\" rel=\"noopener\">https://coolshell.cn/articles/17416.html</a></li>\n<li>DDIA第十一章：流处理 <a href=\"https://github.com/Vonng/ddia/blob/master/ch11.md\" target=\"_blank\" rel=\"noopener\">https://github.com/Vonng/ddia/blob/master/ch11.md</a></li>\n<li>Hazelcast Caching Patterns：<a href=\"https://hazelcast.com/blog/a-hitchhikers-guide-to-caching-patterns/\" target=\"_blank\" rel=\"noopener\">https://hazelcast.com/blog/a-hitchhikers-guide-to-caching-patterns/</a></li>\n<li>Cache：<a href=\"https://en.wikipedia.org/wiki/Cache_(computing)\" target=\"_blank\" rel=\"noopener\">https://en.wikipedia.org/wiki/Cache_(computing)</a></li>\n<li>Cache stampede：<a href=\"https://en.wikipedia.org/wiki/Cache_stampede\" target=\"_blank\" rel=\"noopener\">https://en.wikipedia.org/wiki/Cache_stampede</a></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>数据同步问题是应用层非常值得研究的一个设计问题，也是为数不多值得研究的数据问题。虽然在实践中各种方案会运行的很好，但是这些方案背后有哪些假设，以及问题的模型是什么，这个点并没有得到充分理解，所以本文以经验之谈分析了下数据同步的设计问题，案例分析以及结论。</p>\n<h1 id=\"数据同步的设计问题\"><a href=\"#数据同步的设计问题\" class=\"headerlink\" title=\"数据同步的设计问题\"></a>数据同步的设计问题</h1><p>数据同步问题是将一个地方数据，经过计算/不计算挪动到另外一个地方，在这个过程中，会面临三个问题：</p>\n<ol>\n<li><strong>如何同步？</strong>机器是否跨网络，是否单机，策略是双写或者是异步写？同步的是指令还是数据？双写中并发写问题如何解决？</li>\n<li><strong>数据形态是什么？</strong>副本，缓存（缓存是一种特殊的副本），副本形态可能高写入，缓存形态一般高读取。</li>\n<li><strong>谁来解决这个问题？</strong>应用层，还是中间件层。发起同步的进程还是后台进程？</li>\n</ol>\n<p>这些问题抽象为：多节点(同构或异构)数据复制带来的一致性问题。而这样问题也会受到CAP或者Jepsen中一致性的等级所制约。</p>\n<p>我们来依次看看这些问题。如何同步的问题抽象是写入保证一致性，而跨网络抽象成复制问题，单机会抽象成单进程/线程读写问题，一个地方移动到另外一个地方，复制有主动/被动，有异步和同步，地点可以是内存到磁盘，可以是Redis到MySQL，可以是内存到Redis，数据的形态有副本，有缓存，不同的形态数据使用场景不同，带来的复制更新问题也不同，如缓存会有一系列缓存淘汰算法或者缓存更新策略(通读，通写，后写)，这个过程相对主动，谁来解决这个问题，影响了系统的实现。</p>\n<p>如果在单机情况下，那么要保证操作同时成功，或者同时失败，数据能保证一致性，那么单机系统中最完美的抽象是事务。事务的ACID特性完美解决了一系列问题，如并发控制和恢复系统。</p>\n<p>在分布式场景下，由于CAP/PACELC的限制，会导致数据同步（复制策略）不同，导致了不同的一致性级别。</p>\n<p>但是面对异构系统，且跨网络的模型，原子广播协议或者分布式事务可以解决此类问题，但是谁来解决跨系统分布式事务呢？据我所知，暂时没有这样机制。即使XA模型很早提出了，Java领域也有JTA模型，但是实际系统中很少使用，因为性能或者易用性的问题。所以双写问题带来的固然局限性，因为处理异常情况非常复杂，业内也没有非常成熟的实践。</p>\n<h1 id=\"案例分析\"><a href=\"#案例分析\" class=\"headerlink\" title=\"案例分析\"></a>案例分析</h1><p>案例有同构和异构系统的一致性总结。以及谁来解决这个问题来进行总结。</p>\n<table>\n<thead>\n<tr>\n<th>系统</th>\n<th>如何同步</th>\n<th>数据形态</th>\n<th>解决层</th>\n<th>CAP</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>Redis 主从</td>\n<td>异步复制</td>\n<td>副本</td>\n<td>Redis</td>\n<td>AP</td>\n</tr>\n<tr>\n<td>Redis和应用内存</td>\n<td>双写，异步写</td>\n<td>缓存</td>\n<td>应用层</td>\n<td>可选</td>\n</tr>\n<tr>\n<td>操作系统的内存和磁盘</td>\n<td>双写</td>\n<td>缓存</td>\n<td>操作系统层</td>\n<td>CA</td>\n</tr>\n<tr>\n<td>Redis和MySQL</td>\n<td>双写，异步写</td>\n<td>缓存</td>\n<td>应用层</td>\n<td>可选</td>\n</tr>\n<tr>\n<td>MySQL主从</td>\n<td>异步复制</td>\n<td>副本</td>\n<td>MySQL</td>\n<td>异步AP<br />同步CP</td>\n</tr>\n<tr>\n<td>Zookeeper</td>\n<td>ZAB协议</td>\n<td>副本</td>\n<td>Zookeeper</td>\n<td>CP</td>\n</tr>\n<tr>\n<td>Etcd</td>\n<td>Raft协议</td>\n<td>副本</td>\n<td>Etcd</td>\n<td>CP</td>\n</tr>\n<tr>\n<td>MySQL 内存和磁盘</td>\n<td>事务</td>\n<td>缓存</td>\n<td>MySQL</td>\n<td>CA</td>\n</tr>\n</tbody></table>\n<h2 id=\"Redis和MySQL同步分析\"><a href=\"#Redis和MySQL同步分析\" class=\"headerlink\" title=\"Redis和MySQL同步分析\"></a>Redis和MySQL同步分析</h2><p>同步为什么很困难？1 网络的引入导致成功，失败，不可知状态。  2  谁来解决问题，还是返回给操作方？如果没有操作方是进程呢？ 3 在同构系统同步已经很复杂但成熟，异构系统更加复杂且不成熟。4 更新操作的顺序考虑。</p>\n<p>如何简化问题？忽略网络，操作方解决。</p>\n<p>虽然问题分析比较有意思，但是方案来说有：</p>\n<blockquote>\n<ol>\n<li>同步：cache-aside（缓存驻留），read through(通读)，write through（通写）等。</li>\n<li>异步：单机内存队列（Sticky Available），消息中间件（请求定序），write behind（后写），Refresh ahead（预加载）等。</li>\n</ol>\n</blockquote>\n<p>这里重点看看cache-aside模式（方案1是缓存驻留模式，其他都是对比方案）的写入方案，也是理解同步问题的起点，下面有四种模式（假设没有发生网络异常）：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//方案1</span></span><br><span class=\"line\">updateDB();</span><br><span class=\"line\">deteleCache();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//方案2</span></span><br><span class=\"line\">deleteCache();</span><br><span class=\"line\">updateDB();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//方案3</span></span><br><span class=\"line\">updateDB();</span><br><span class=\"line\">updateCache();</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"comment\">//方案4</span></span><br><span class=\"line\">updateCache();</span><br><span class=\"line\">updateDB();</span><br></pre></td></tr></table></figure>\n\n<p><strong>方案1，先更新数据库，后删除缓存</strong>。这个方案是常用的方案。但是会有极小概率出现这种情况：读操作没有命中缓存，会去数据库取数据，此时写请求进入，写完数据库，然后缓存失效，之前的读请求再把老数据放进去，会导致脏数据问题。这个情况理论上会出现，但是概率非常小，需要满足条件有：发生在读缓存时失效，且有并发写入，数据库写比读慢很多，所以读操作必须在写操作前进去数据库，而晚于写操作更新缓存。</p>\n<p><strong>方案2，先删除缓存，后更新数据库。</strong>可能很短时间内，新的请求会读数据，然后发现缓存没有数据，就会设置缓存，导致缓存有脏数据。缓存宁愿没数据，也不要脏数据。这个概率发生要比1高很多。因为缓存模式就是读多血少。</p>\n<p><strong>方案3，先更新数据库，后更新缓存。</strong>由于缓存构建可能很慢，不是简单从数据库中读取出来，更新缓存可能会非常慢，不如直接删除缓存，在下次加载时候重新计算，更是因为并发写会导致脏数据问题。因为第二个写入可能会被第一个写入覆盖了。</p>\n<p><strong>方案4，先更新缓存，后更新数据库。</strong>理由同方案3。从效果上看该方案和通写一样，数据更新没有命中缓存，那么直接更新数据，如果命中缓存，那么更更新缓存，然后Cache自己更新数据库。</p>\n<p>以上四种方案本质是同步方案，而没有考虑网络异常，如果网络异常导致某一个节点不可用，就会导致同步失败（为了一致性而牺牲了可用性），此时应用层有感知，虽然处理这种失败可以重试，但是如果节点是宕机呢？数据可以暂时存在本地内存队列中，等节点启动后进行同步，而要保证下次请求读到上次写入的数据，那么需要满足Jepsen中<a href=\"https://jepsen.io/consistency/models/read-your-writes\" target=\"_blank\" rel=\"noopener\">Read Your Writes</a>的一致性，但是这种一致性下可用性是Sticky Available，也就是会话一致性，需要将请求定位到同一台机器，但是如果该机器宕机了，那么内存数据会丢失。完美的方案是引入事务模型来解决同时成功或者同时失败从而使得开发者忽略一切底层细节，但是代价很高且缺少分布式事务方案可以直接来用，所以引入异步方案也是一种方式，异步更新时效性没有同步那么及时，但是需要解决的问题较少，可以进行后台定时同步（类似于反熵过程），或者消息队列进行CDC或者定序（分布式提交日志）等操作进行同步，较为复杂场景是MySQL主从和Redis主从进行同步，如果是读MySQL从，而后写入Redis主，那么数据也会不一样，但是需要理解Redis对于MySQL数据形态是什么？如果Redis当做缓存，那么会有一些列缓存更新问题出现，但是缓存使用必然会带来不一致性，只是能够接受多久的不一致性时间窗口。</p>\n<p>每一个种选择都会带来对应的问题，而需要仔细衡量解决问题的成本。<strong>没有完美的方案，只有削足适履的选择！</strong></p>\n<h1 id=\"结论\"><a href=\"#结论\" class=\"headerlink\" title=\"结论\"></a>结论</h1><p>本文将数据同步问题抽象成多节点数据复制带来的一致性问题。</p>\n<p>所以上表可以得出结论：</p>\n<ol>\n<li><strong>同构的系统的同步</strong>，采用共识协议或者健壮的复制，且由系统自己解决的方案占据大多数，</li>\n<li><strong>异构系统的同步</strong>，同步或者异步写都有可能，但是需要解决各自方案带来的问题，如同步需要保证同时成功，同时失败问题，而异步写需要解决系统间一致性延时问题。双写会在不同数据形态会展示不同的策略，如果数据形态是缓存，那么双写策略有通写，或者后写等缓存更新策略，还会有缓存淘汰算法等策略。一般由应用层解决较多。</li>\n<li><strong>实际工程中</strong>：同步的cache-aside，通读，异步Kafka方案，或者广播消息方式，定时任务刷新是解决这类问题的有效方案。</li>\n</ol>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><ol>\n<li>耗子叔 极客时间-性能设计篇之-缓存</li>\n<li>微软：云计算架构设计模式 <a href=\"https://github.com/iambowen/cloud-design-patterns/blob/master/patterns/cache-aside.md\" target=\"_blank\" rel=\"noopener\">Cache aside</a></li>\n<li><a href=\"https://docs.aws.amazon.com/whitepapers/latest/database-caching-strategies-using-redis/caching-patterns.html\" target=\"_blank\" rel=\"noopener\">https://docs.aws.amazon.com/whitepapers/latest/database-caching-strategies-using-redis/caching-patterns.html</a></li>\n<li>Ehcache：<a href=\"https://www.ehcache.org/documentation/3.3/caching-patterns.html\" target=\"_blank\" rel=\"noopener\">https://www.ehcache.org/documentation/3.3/caching-patterns.html</a></li>\n<li>耗子叔-缓存更新的套路 <a href=\"https://coolshell.cn/articles/17416.html\" target=\"_blank\" rel=\"noopener\">https://coolshell.cn/articles/17416.html</a></li>\n<li>DDIA第十一章：流处理 <a href=\"https://github.com/Vonng/ddia/blob/master/ch11.md\" target=\"_blank\" rel=\"noopener\">https://github.com/Vonng/ddia/blob/master/ch11.md</a></li>\n<li>Hazelcast Caching Patterns：<a href=\"https://hazelcast.com/blog/a-hitchhikers-guide-to-caching-patterns/\" target=\"_blank\" rel=\"noopener\">https://hazelcast.com/blog/a-hitchhikers-guide-to-caching-patterns/</a></li>\n<li>Cache：<a href=\"https://en.wikipedia.org/wiki/Cache_(computing)\" target=\"_blank\" rel=\"noopener\">https://en.wikipedia.org/wiki/Cache_(computing)</a></li>\n<li>Cache stampede：<a href=\"https://en.wikipedia.org/wiki/Cache_stampede\" target=\"_blank\" rel=\"noopener\">https://en.wikipedia.org/wiki/Cache_stampede</a></li>\n</ol>\n"},{"title":"SQL-DML练习","date":"2021-01-31T09:58:46.000Z","_content":"\n\n\n1. 找出所有教师名字\n\n   ```sql\n   select name from instructor;\n   ```\n\n   \n\n2. 找出所有教师系名\n\n   ```\n   select dept_name from instructor;\n   ```\n\n   \n\n3. 找出所有不重复的系名\n\n   ```\n   select distinct dept_name from instructor;\n   ```\n\n   \n\n4. 找出CS系并且工资超过7000的教师名字\n\n   ```sql\n   select name from instructor where dept_name='CS' and salary>7000;\n   ```\n\n   \n\n5. 找出所有教师名字，以及他们所在系的建筑名字\n\n   ```mysql\n   select name,instructor.dept_name,building from instructor,department where instructor.dept_name=department.dept_name;\n   \n   ```\n\n   \n\n6. 找出CS系的教师名和课程ID\n\n   ```mysql\n   select name,course_id from instructor,teaches where instructor.ID = teaches.ID and instructor.dept_name='CS';\n   \n   ```\n\n   \n\n7. 找出教师的名字和他们所教课的ID\n\n   ```mysql\n   select name,course_id from instructor natural join teaches;\n   ```\n\n   \n\n8. 找出教师名字和他们所教课的名字\n\n   ```\n   select name,title from instructor natural join teaches,course where teaches.course_id=course.course_id;\n   ```\n\n   \n\n9. 找出 “工资至少比Biology系某一个教师工资要高” 的所有教师名字\n\n   ```mysql\n   select distinct T.name from instructor as T, instructor as S where T.salary > S.salary and S.dept_name='Biology';\n   ```\n\n   ```mysql\n   select name from instructor where salary > some(select salary from instructor where dept_name='Biology');\n   ```\n\n   \n\n10. 找出按字母排序在Biology的所有老师\n\n    ```mysql\n    select name from instructor where dept_name='Biology' order by name;\n    ```\n\n    \n\n11. 找出工资降序，如果工资相同姓名升序的教师\n\n    ```\n    select name from instructor order by salary desc,name asc;\n    ```\n\n    \n\n12. 找出工资在9000到10000的教师\n\n    ```\n    select name from instructor where salary between 9000 and 10000;\n    select name from instructor where salary >= 9000 and salary <= 10000;\n    ```\n\n    \n\n13. 找出Biology系授课的所有教师名字和他们所教授的课程\n\n    ```\n    select name,course_id from instructor, teaches where instructor.ID=teaches.ID and dept_name='Biology';\n    ```\n\n    \n\n14. 找出2009年秋季和2010年春季的所有的课程\n\n    ```mysql\n    (select course_id from section where semester='Fall' and year=2009) union (select course_id from section where semester='Spring' and year=2010) ;\n    ```\n\n    ```mysql\n    \n    ```\n\n15. 找出2009年秋季和2010年春季的同时开课的课程\n\n    ```mysql\n    select distinct course_id from section where semester='Spring' and year=2009 and course_id in(select course_id from section where semester='Spring' and year=2010);\n    ```\n\n    ```java\n    select course_id from section as S where semester='Fall' and year=2009 and exists(select * from section as T where  semester='Spring' and year=2010 and S.course_id=T.course_id);\n    ```\n\n    \n\n16. 找出在2009年秋季开课和不在2010年春季开课的课程\n\n    ```mysql\n    select distinct course_id from section where semester='Spring' and year=2009 and course_id not in(select course_id from section where semester='Spring' and year=2010);\n    ```\n\n    \n\n17. 找出CS系教师平均工资\n\n    ```\n    select avg(salary) from instructor where dept_name='CS';\n    ```\n\n    \n\n18. 找出2010春季讲授课程的教师总数\n\n    ```\n    select count(distinct ID) from teaches where semester='Spring' and year=2010;\n    ```\n\n    \n\n19. 找出每个系的平均工资\n\n    ```\n    select dept_name,avg(salary) from instructor group by dept_name;\n    ```\n\n    \n\n20. 找出所有老师的平均工资\n\n    ```\n    select avg(salary) from instructor;\n    ```\n\n    \n\n21. 找出每个系在2010年春季讲授一门课程的教师人数\n\n    ```mysql\n    SELECT \n        dept_name, COUNT(DISTINCT ID)\n    FROM\n        instructor\n            NATURAL JOIN\n        teaches\n    WHERE\n        semester = 'Spring' AND year = 2010\n    GROUP BY dept_name;\n    ```\n\n    \n\n22. 找出教师平均工资超过42000美元的系\n\n    ```\n    SELECT \n        dept_name, AVG(salary)\n    FROM\n        instructor\n    GROUP BY dept_name\n    HAVING AVG(salary) > 42000;\n    ```\n\n    \n\n23. 找出2009年讲授的每个课程段，如果该课程段至少两名学生选课，找出选修该课程段的所有学生总学分的平均值\n\n    ```mysql\n    SELECT \n        course_id, semester, year, sec_id, AVG(tot_cred)\n    FROM\n        takes\n            NATURAL JOIN\n        student\n    WHERE\n        year = 2009\n    GROUP BY course_id , semester , year , sec_id\n    HAVING COUNT(ID) >= 2;\n    ```\n\n    \n\n24. 找出既不叫Bob也不叫Ali的教师名字\n\n    ```\n    select distinct name from instructor where name not in('Bob','Ali') \n    ```\n\n    \n\n25. 找出不同的学生总数，选修ID为10101教师所教授的课程段\n\n    ```mysql\n    SELECT \n        COUNT(DISTINCT ID)\n    FROM\n        takes\n    WHERE\n        (course_id , sec_id, year) IN (SELECT \n                course_id, sec_id, year\n            FROM\n                teaches\n            WHERE\n                teaches.ID = 10101);\n    ```\n\n    \n\n26. 找出 “工资比Biology系所有教师工资要高” 的所有教师名字\n\n    ```\n    select name from instructor where salary > all(select salary from instructor where dept_name='Biology');\n    ```\n\n27. 找出平均工资大于所有系平均工资的系\n\n    ```mysql\n    select dept_name from instructor group by dept_name having avg(salary) >= all(select avg(salary) from instructor group by dept_name);\n    ```\n\n    \n\n28. 找出选修了Biology系所开设的所有课程的学生\n    \n29. 找出所有在2009年最多开设一次的课程\n    \n30. 找出所有在2009年最少开设两次的课程\n    \n31. 找出系平均工资超过42000美元的那些系中的教师平均工资\n    \n32. 所有系工资总额最大系\n    \n33. 所有系和他们拥有的教师数\n    \n34. 删除工作在Watson大楼系工作的教师\n    \n35. 删除平均工资低于大学平均工资的教师\n    \n36. 让CS系修满144学分的学生成为CS系的老师，并且其平均工资为8000\n    \n37. 工资低于1000教师工资增加5%\n    \n38. 工资低于平均数的教师工资增加5%\n    \n39. 工资超过1000教师涨5%，其余增长8%\n    \n40. 一个学生在某门课成绩既不是F，也不是空，认为修完了该课程\n    \n41. 找出所有课程一门也没选修的学生\n    \n42. 找出CS系所有学生以及他们在2009年春季选修的所有课程\n\n\n\n其他联系平台\n\nhttps://www.nowcoder.com/ta/sql\n\n\n\n\n\n","source":"_posts/db-sql-practice.md","raw":"---\ntitle: SQL-DML练习\ndate: 2021-01-31 17:58:46\ntags: SQL\ncategories:\n  - 数据库\n  - SQL\n---\n\n\n\n1. 找出所有教师名字\n\n   ```sql\n   select name from instructor;\n   ```\n\n   \n\n2. 找出所有教师系名\n\n   ```\n   select dept_name from instructor;\n   ```\n\n   \n\n3. 找出所有不重复的系名\n\n   ```\n   select distinct dept_name from instructor;\n   ```\n\n   \n\n4. 找出CS系并且工资超过7000的教师名字\n\n   ```sql\n   select name from instructor where dept_name='CS' and salary>7000;\n   ```\n\n   \n\n5. 找出所有教师名字，以及他们所在系的建筑名字\n\n   ```mysql\n   select name,instructor.dept_name,building from instructor,department where instructor.dept_name=department.dept_name;\n   \n   ```\n\n   \n\n6. 找出CS系的教师名和课程ID\n\n   ```mysql\n   select name,course_id from instructor,teaches where instructor.ID = teaches.ID and instructor.dept_name='CS';\n   \n   ```\n\n   \n\n7. 找出教师的名字和他们所教课的ID\n\n   ```mysql\n   select name,course_id from instructor natural join teaches;\n   ```\n\n   \n\n8. 找出教师名字和他们所教课的名字\n\n   ```\n   select name,title from instructor natural join teaches,course where teaches.course_id=course.course_id;\n   ```\n\n   \n\n9. 找出 “工资至少比Biology系某一个教师工资要高” 的所有教师名字\n\n   ```mysql\n   select distinct T.name from instructor as T, instructor as S where T.salary > S.salary and S.dept_name='Biology';\n   ```\n\n   ```mysql\n   select name from instructor where salary > some(select salary from instructor where dept_name='Biology');\n   ```\n\n   \n\n10. 找出按字母排序在Biology的所有老师\n\n    ```mysql\n    select name from instructor where dept_name='Biology' order by name;\n    ```\n\n    \n\n11. 找出工资降序，如果工资相同姓名升序的教师\n\n    ```\n    select name from instructor order by salary desc,name asc;\n    ```\n\n    \n\n12. 找出工资在9000到10000的教师\n\n    ```\n    select name from instructor where salary between 9000 and 10000;\n    select name from instructor where salary >= 9000 and salary <= 10000;\n    ```\n\n    \n\n13. 找出Biology系授课的所有教师名字和他们所教授的课程\n\n    ```\n    select name,course_id from instructor, teaches where instructor.ID=teaches.ID and dept_name='Biology';\n    ```\n\n    \n\n14. 找出2009年秋季和2010年春季的所有的课程\n\n    ```mysql\n    (select course_id from section where semester='Fall' and year=2009) union (select course_id from section where semester='Spring' and year=2010) ;\n    ```\n\n    ```mysql\n    \n    ```\n\n15. 找出2009年秋季和2010年春季的同时开课的课程\n\n    ```mysql\n    select distinct course_id from section where semester='Spring' and year=2009 and course_id in(select course_id from section where semester='Spring' and year=2010);\n    ```\n\n    ```java\n    select course_id from section as S where semester='Fall' and year=2009 and exists(select * from section as T where  semester='Spring' and year=2010 and S.course_id=T.course_id);\n    ```\n\n    \n\n16. 找出在2009年秋季开课和不在2010年春季开课的课程\n\n    ```mysql\n    select distinct course_id from section where semester='Spring' and year=2009 and course_id not in(select course_id from section where semester='Spring' and year=2010);\n    ```\n\n    \n\n17. 找出CS系教师平均工资\n\n    ```\n    select avg(salary) from instructor where dept_name='CS';\n    ```\n\n    \n\n18. 找出2010春季讲授课程的教师总数\n\n    ```\n    select count(distinct ID) from teaches where semester='Spring' and year=2010;\n    ```\n\n    \n\n19. 找出每个系的平均工资\n\n    ```\n    select dept_name,avg(salary) from instructor group by dept_name;\n    ```\n\n    \n\n20. 找出所有老师的平均工资\n\n    ```\n    select avg(salary) from instructor;\n    ```\n\n    \n\n21. 找出每个系在2010年春季讲授一门课程的教师人数\n\n    ```mysql\n    SELECT \n        dept_name, COUNT(DISTINCT ID)\n    FROM\n        instructor\n            NATURAL JOIN\n        teaches\n    WHERE\n        semester = 'Spring' AND year = 2010\n    GROUP BY dept_name;\n    ```\n\n    \n\n22. 找出教师平均工资超过42000美元的系\n\n    ```\n    SELECT \n        dept_name, AVG(salary)\n    FROM\n        instructor\n    GROUP BY dept_name\n    HAVING AVG(salary) > 42000;\n    ```\n\n    \n\n23. 找出2009年讲授的每个课程段，如果该课程段至少两名学生选课，找出选修该课程段的所有学生总学分的平均值\n\n    ```mysql\n    SELECT \n        course_id, semester, year, sec_id, AVG(tot_cred)\n    FROM\n        takes\n            NATURAL JOIN\n        student\n    WHERE\n        year = 2009\n    GROUP BY course_id , semester , year , sec_id\n    HAVING COUNT(ID) >= 2;\n    ```\n\n    \n\n24. 找出既不叫Bob也不叫Ali的教师名字\n\n    ```\n    select distinct name from instructor where name not in('Bob','Ali') \n    ```\n\n    \n\n25. 找出不同的学生总数，选修ID为10101教师所教授的课程段\n\n    ```mysql\n    SELECT \n        COUNT(DISTINCT ID)\n    FROM\n        takes\n    WHERE\n        (course_id , sec_id, year) IN (SELECT \n                course_id, sec_id, year\n            FROM\n                teaches\n            WHERE\n                teaches.ID = 10101);\n    ```\n\n    \n\n26. 找出 “工资比Biology系所有教师工资要高” 的所有教师名字\n\n    ```\n    select name from instructor where salary > all(select salary from instructor where dept_name='Biology');\n    ```\n\n27. 找出平均工资大于所有系平均工资的系\n\n    ```mysql\n    select dept_name from instructor group by dept_name having avg(salary) >= all(select avg(salary) from instructor group by dept_name);\n    ```\n\n    \n\n28. 找出选修了Biology系所开设的所有课程的学生\n    \n29. 找出所有在2009年最多开设一次的课程\n    \n30. 找出所有在2009年最少开设两次的课程\n    \n31. 找出系平均工资超过42000美元的那些系中的教师平均工资\n    \n32. 所有系工资总额最大系\n    \n33. 所有系和他们拥有的教师数\n    \n34. 删除工作在Watson大楼系工作的教师\n    \n35. 删除平均工资低于大学平均工资的教师\n    \n36. 让CS系修满144学分的学生成为CS系的老师，并且其平均工资为8000\n    \n37. 工资低于1000教师工资增加5%\n    \n38. 工资低于平均数的教师工资增加5%\n    \n39. 工资超过1000教师涨5%，其余增长8%\n    \n40. 一个学生在某门课成绩既不是F，也不是空，认为修完了该课程\n    \n41. 找出所有课程一门也没选修的学生\n    \n42. 找出CS系所有学生以及他们在2009年春季选修的所有课程\n\n\n\n其他联系平台\n\nhttps://www.nowcoder.com/ta/sql\n\n\n\n\n\n","slug":"db-sql-practice","published":1,"updated":"2022-06-28T17:25:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clh7s5ctv000zxt8j28pf5tx2","content":"<ol>\n<li><p>找出所有教师名字</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"keyword\">name</span> <span class=\"keyword\">from</span> instructor;</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ol>\n<ol start=\"2\">\n<li><p>找出所有教师系名</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select dept_name from instructor;</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ol>\n<ol start=\"3\">\n<li><p>找出所有不重复的系名</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select distinct dept_name from instructor;</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ol>\n<ol start=\"4\">\n<li><p>找出CS系并且工资超过7000的教师名字</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"keyword\">name</span> <span class=\"keyword\">from</span> instructor <span class=\"keyword\">where</span> dept_name=<span class=\"string\">'CS'</span> <span class=\"keyword\">and</span> salary&gt;<span class=\"number\">7000</span>;</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ol>\n<ol start=\"5\">\n<li><p>找出所有教师名字，以及他们所在系的建筑名字</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select name,instructor.dept_name,building from instructor,department where instructor.dept_name&#x3D;department.dept_name;</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ol>\n<ol start=\"6\">\n<li><p>找出CS系的教师名和课程ID</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select name,course_id from instructor,teaches where instructor.ID &#x3D; teaches.ID and instructor.dept_name&#x3D;&#39;CS&#39;;</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ol>\n<ol start=\"7\">\n<li><p>找出教师的名字和他们所教课的ID</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select name,course_id from instructor natural join teaches;</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ol>\n<ol start=\"8\">\n<li><p>找出教师名字和他们所教课的名字</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select name,title from instructor natural join teaches,course where teaches.course_id&#x3D;course.course_id;</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ol>\n<ol start=\"9\">\n<li><p>找出 “工资至少比Biology系某一个教师工资要高” 的所有教师名字</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select distinct T.name from instructor as T, instructor as S where T.salary &gt; S.salary and S.dept_name&#x3D;&#39;Biology&#39;;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select name from instructor where salary &gt; some(select salary from instructor where dept_name&#x3D;&#39;Biology&#39;);</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ol>\n<ol start=\"10\">\n<li><p>找出按字母排序在Biology的所有老师</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select name from instructor where dept_name&#x3D;&#39;Biology&#39; order by name;</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ol>\n<ol start=\"11\">\n<li><p>找出工资降序，如果工资相同姓名升序的教师</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select name from instructor order by salary desc,name asc;</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ol>\n<ol start=\"12\">\n<li><p>找出工资在9000到10000的教师</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select name from instructor where salary between 9000 and 10000;</span><br><span class=\"line\">select name from instructor where salary &gt;&#x3D; 9000 and salary &lt;&#x3D; 10000;</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ol>\n<ol start=\"13\">\n<li><p>找出Biology系授课的所有教师名字和他们所教授的课程</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select name,course_id from instructor, teaches where instructor.ID&#x3D;teaches.ID and dept_name&#x3D;&#39;Biology&#39;;</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ol>\n<ol start=\"14\">\n<li><p>找出2009年秋季和2010年春季的所有的课程</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(select course_id from section where semester&#x3D;&#39;Fall&#39; and year&#x3D;2009) union (select course_id from section where semester&#x3D;&#39;Spring&#39; and year&#x3D;2010) ;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> </span><br></pre></td></tr></table></figure>\n</li>\n<li><p>找出2009年秋季和2010年春季的同时开课的课程</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select distinct course_id from section where semester&#x3D;&#39;Spring&#39; and year&#x3D;2009 and course_id in(select course_id from section where semester&#x3D;&#39;Spring&#39; and year&#x3D;2010);</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select course_id from section as S where semester=<span class=\"string\">'Fall'</span> and year=<span class=\"number\">2009</span> <span class=\"function\">and <span class=\"title\">exists</span><span class=\"params\">(select * from section as T where  semester=<span class=\"string\">'Spring'</span> and year=<span class=\"number\">2010</span> and S.course_id=T.course_id)</span></span>;</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ol>\n<ol start=\"16\">\n<li><p>找出在2009年秋季开课和不在2010年春季开课的课程</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select distinct course_id from section where semester&#x3D;&#39;Spring&#39; and year&#x3D;2009 and course_id not in(select course_id from section where semester&#x3D;&#39;Spring&#39; and year&#x3D;2010);</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ol>\n<ol start=\"17\">\n<li><p>找出CS系教师平均工资</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select avg(salary) from instructor where dept_name&#x3D;&#39;CS&#39;;</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ol>\n<ol start=\"18\">\n<li><p>找出2010春季讲授课程的教师总数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select count(distinct ID) from teaches where semester&#x3D;&#39;Spring&#39; and year&#x3D;2010;</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ol>\n<ol start=\"19\">\n<li><p>找出每个系的平均工资</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select dept_name,avg(salary) from instructor group by dept_name;</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ol>\n<ol start=\"20\">\n<li><p>找出所有老师的平均工资</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select avg(salary) from instructor;</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ol>\n<ol start=\"21\">\n<li><p>找出每个系在2010年春季讲授一门课程的教师人数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT </span><br><span class=\"line\">    dept_name, COUNT(DISTINCT ID)</span><br><span class=\"line\">FROM</span><br><span class=\"line\">    instructor</span><br><span class=\"line\">        NATURAL JOIN</span><br><span class=\"line\">    teaches</span><br><span class=\"line\">WHERE</span><br><span class=\"line\">    semester &#x3D; &#39;Spring&#39; AND year &#x3D; 2010</span><br><span class=\"line\">GROUP BY dept_name;</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ol>\n<ol start=\"22\">\n<li><p>找出教师平均工资超过42000美元的系</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT </span><br><span class=\"line\">    dept_name, AVG(salary)</span><br><span class=\"line\">FROM</span><br><span class=\"line\">    instructor</span><br><span class=\"line\">GROUP BY dept_name</span><br><span class=\"line\">HAVING AVG(salary) &gt; 42000;</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ol>\n<ol start=\"23\">\n<li><p>找出2009年讲授的每个课程段，如果该课程段至少两名学生选课，找出选修该课程段的所有学生总学分的平均值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT </span><br><span class=\"line\">    course_id, semester, year, sec_id, AVG(tot_cred)</span><br><span class=\"line\">FROM</span><br><span class=\"line\">    takes</span><br><span class=\"line\">        NATURAL JOIN</span><br><span class=\"line\">    student</span><br><span class=\"line\">WHERE</span><br><span class=\"line\">    year &#x3D; 2009</span><br><span class=\"line\">GROUP BY course_id , semester , year , sec_id</span><br><span class=\"line\">HAVING COUNT(ID) &gt;&#x3D; 2;</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ol>\n<ol start=\"24\">\n<li><p>找出既不叫Bob也不叫Ali的教师名字</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select distinct name from instructor where name not in(&#39;Bob&#39;,&#39;Ali&#39;)</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ol>\n<ol start=\"25\">\n<li><p>找出不同的学生总数，选修ID为10101教师所教授的课程段</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT </span><br><span class=\"line\">    COUNT(DISTINCT ID)</span><br><span class=\"line\">FROM</span><br><span class=\"line\">    takes</span><br><span class=\"line\">WHERE</span><br><span class=\"line\">    (course_id , sec_id, year) IN (SELECT </span><br><span class=\"line\">            course_id, sec_id, year</span><br><span class=\"line\">        FROM</span><br><span class=\"line\">            teaches</span><br><span class=\"line\">        WHERE</span><br><span class=\"line\">            teaches.ID &#x3D; 10101);</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ol>\n<ol start=\"26\">\n<li><p>找出 “工资比Biology系所有教师工资要高” 的所有教师名字</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select name from instructor where salary &gt; all(select salary from instructor where dept_name&#x3D;&#39;Biology&#39;);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>找出平均工资大于所有系平均工资的系</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select dept_name from instructor group by dept_name having avg(salary) &gt;&#x3D; all(select avg(salary) from instructor group by dept_name);</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ol>\n<ol start=\"28\">\n<li><p>找出选修了Biology系所开设的所有课程的学生</p>\n</li>\n<li><p>找出所有在2009年最多开设一次的课程</p>\n</li>\n<li><p>找出所有在2009年最少开设两次的课程</p>\n</li>\n<li><p>找出系平均工资超过42000美元的那些系中的教师平均工资</p>\n</li>\n<li><p>所有系工资总额最大系</p>\n</li>\n<li><p>所有系和他们拥有的教师数</p>\n</li>\n<li><p>删除工作在Watson大楼系工作的教师</p>\n</li>\n<li><p>删除平均工资低于大学平均工资的教师</p>\n</li>\n<li><p>让CS系修满144学分的学生成为CS系的老师，并且其平均工资为8000</p>\n</li>\n<li><p>工资低于1000教师工资增加5%</p>\n</li>\n<li><p>工资低于平均数的教师工资增加5%</p>\n</li>\n<li><p>工资超过1000教师涨5%，其余增长8%</p>\n</li>\n<li><p>一个学生在某门课成绩既不是F，也不是空，认为修完了该课程</p>\n</li>\n<li><p>找出所有课程一门也没选修的学生</p>\n</li>\n<li><p>找出CS系所有学生以及他们在2009年春季选修的所有课程</p>\n</li>\n</ol>\n<p>其他联系平台</p>\n<p><a href=\"https://www.nowcoder.com/ta/sql\" target=\"_blank\" rel=\"noopener\">https://www.nowcoder.com/ta/sql</a></p>\n","site":{"data":{}},"excerpt":"","more":"<ol>\n<li><p>找出所有教师名字</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"keyword\">name</span> <span class=\"keyword\">from</span> instructor;</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ol>\n<ol start=\"2\">\n<li><p>找出所有教师系名</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select dept_name from instructor;</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ol>\n<ol start=\"3\">\n<li><p>找出所有不重复的系名</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select distinct dept_name from instructor;</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ol>\n<ol start=\"4\">\n<li><p>找出CS系并且工资超过7000的教师名字</p>\n<figure class=\"highlight sql\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">select</span> <span class=\"keyword\">name</span> <span class=\"keyword\">from</span> instructor <span class=\"keyword\">where</span> dept_name=<span class=\"string\">'CS'</span> <span class=\"keyword\">and</span> salary&gt;<span class=\"number\">7000</span>;</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ol>\n<ol start=\"5\">\n<li><p>找出所有教师名字，以及他们所在系的建筑名字</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select name,instructor.dept_name,building from instructor,department where instructor.dept_name&#x3D;department.dept_name;</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ol>\n<ol start=\"6\">\n<li><p>找出CS系的教师名和课程ID</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select name,course_id from instructor,teaches where instructor.ID &#x3D; teaches.ID and instructor.dept_name&#x3D;&#39;CS&#39;;</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ol>\n<ol start=\"7\">\n<li><p>找出教师的名字和他们所教课的ID</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select name,course_id from instructor natural join teaches;</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ol>\n<ol start=\"8\">\n<li><p>找出教师名字和他们所教课的名字</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select name,title from instructor natural join teaches,course where teaches.course_id&#x3D;course.course_id;</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ol>\n<ol start=\"9\">\n<li><p>找出 “工资至少比Biology系某一个教师工资要高” 的所有教师名字</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select distinct T.name from instructor as T, instructor as S where T.salary &gt; S.salary and S.dept_name&#x3D;&#39;Biology&#39;;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select name from instructor where salary &gt; some(select salary from instructor where dept_name&#x3D;&#39;Biology&#39;);</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ol>\n<ol start=\"10\">\n<li><p>找出按字母排序在Biology的所有老师</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select name from instructor where dept_name&#x3D;&#39;Biology&#39; order by name;</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ol>\n<ol start=\"11\">\n<li><p>找出工资降序，如果工资相同姓名升序的教师</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select name from instructor order by salary desc,name asc;</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ol>\n<ol start=\"12\">\n<li><p>找出工资在9000到10000的教师</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select name from instructor where salary between 9000 and 10000;</span><br><span class=\"line\">select name from instructor where salary &gt;&#x3D; 9000 and salary &lt;&#x3D; 10000;</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ol>\n<ol start=\"13\">\n<li><p>找出Biology系授课的所有教师名字和他们所教授的课程</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select name,course_id from instructor, teaches where instructor.ID&#x3D;teaches.ID and dept_name&#x3D;&#39;Biology&#39;;</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ol>\n<ol start=\"14\">\n<li><p>找出2009年秋季和2010年春季的所有的课程</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">(select course_id from section where semester&#x3D;&#39;Fall&#39; and year&#x3D;2009) union (select course_id from section where semester&#x3D;&#39;Spring&#39; and year&#x3D;2010) ;</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"> </span><br></pre></td></tr></table></figure>\n</li>\n<li><p>找出2009年秋季和2010年春季的同时开课的课程</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select distinct course_id from section where semester&#x3D;&#39;Spring&#39; and year&#x3D;2009 and course_id in(select course_id from section where semester&#x3D;&#39;Spring&#39; and year&#x3D;2010);</span><br></pre></td></tr></table></figure>\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select course_id from section as S where semester=<span class=\"string\">'Fall'</span> and year=<span class=\"number\">2009</span> <span class=\"function\">and <span class=\"title\">exists</span><span class=\"params\">(select * from section as T where  semester=<span class=\"string\">'Spring'</span> and year=<span class=\"number\">2010</span> and S.course_id=T.course_id)</span></span>;</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ol>\n<ol start=\"16\">\n<li><p>找出在2009年秋季开课和不在2010年春季开课的课程</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select distinct course_id from section where semester&#x3D;&#39;Spring&#39; and year&#x3D;2009 and course_id not in(select course_id from section where semester&#x3D;&#39;Spring&#39; and year&#x3D;2010);</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ol>\n<ol start=\"17\">\n<li><p>找出CS系教师平均工资</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select avg(salary) from instructor where dept_name&#x3D;&#39;CS&#39;;</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ol>\n<ol start=\"18\">\n<li><p>找出2010春季讲授课程的教师总数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select count(distinct ID) from teaches where semester&#x3D;&#39;Spring&#39; and year&#x3D;2010;</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ol>\n<ol start=\"19\">\n<li><p>找出每个系的平均工资</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select dept_name,avg(salary) from instructor group by dept_name;</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ol>\n<ol start=\"20\">\n<li><p>找出所有老师的平均工资</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select avg(salary) from instructor;</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ol>\n<ol start=\"21\">\n<li><p>找出每个系在2010年春季讲授一门课程的教师人数</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT </span><br><span class=\"line\">    dept_name, COUNT(DISTINCT ID)</span><br><span class=\"line\">FROM</span><br><span class=\"line\">    instructor</span><br><span class=\"line\">        NATURAL JOIN</span><br><span class=\"line\">    teaches</span><br><span class=\"line\">WHERE</span><br><span class=\"line\">    semester &#x3D; &#39;Spring&#39; AND year &#x3D; 2010</span><br><span class=\"line\">GROUP BY dept_name;</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ol>\n<ol start=\"22\">\n<li><p>找出教师平均工资超过42000美元的系</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT </span><br><span class=\"line\">    dept_name, AVG(salary)</span><br><span class=\"line\">FROM</span><br><span class=\"line\">    instructor</span><br><span class=\"line\">GROUP BY dept_name</span><br><span class=\"line\">HAVING AVG(salary) &gt; 42000;</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ol>\n<ol start=\"23\">\n<li><p>找出2009年讲授的每个课程段，如果该课程段至少两名学生选课，找出选修该课程段的所有学生总学分的平均值</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT </span><br><span class=\"line\">    course_id, semester, year, sec_id, AVG(tot_cred)</span><br><span class=\"line\">FROM</span><br><span class=\"line\">    takes</span><br><span class=\"line\">        NATURAL JOIN</span><br><span class=\"line\">    student</span><br><span class=\"line\">WHERE</span><br><span class=\"line\">    year &#x3D; 2009</span><br><span class=\"line\">GROUP BY course_id , semester , year , sec_id</span><br><span class=\"line\">HAVING COUNT(ID) &gt;&#x3D; 2;</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ol>\n<ol start=\"24\">\n<li><p>找出既不叫Bob也不叫Ali的教师名字</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select distinct name from instructor where name not in(&#39;Bob&#39;,&#39;Ali&#39;)</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ol>\n<ol start=\"25\">\n<li><p>找出不同的学生总数，选修ID为10101教师所教授的课程段</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">SELECT </span><br><span class=\"line\">    COUNT(DISTINCT ID)</span><br><span class=\"line\">FROM</span><br><span class=\"line\">    takes</span><br><span class=\"line\">WHERE</span><br><span class=\"line\">    (course_id , sec_id, year) IN (SELECT </span><br><span class=\"line\">            course_id, sec_id, year</span><br><span class=\"line\">        FROM</span><br><span class=\"line\">            teaches</span><br><span class=\"line\">        WHERE</span><br><span class=\"line\">            teaches.ID &#x3D; 10101);</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ol>\n<ol start=\"26\">\n<li><p>找出 “工资比Biology系所有教师工资要高” 的所有教师名字</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select name from instructor where salary &gt; all(select salary from instructor where dept_name&#x3D;&#39;Biology&#39;);</span><br></pre></td></tr></table></figure>\n</li>\n<li><p>找出平均工资大于所有系平均工资的系</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">select dept_name from instructor group by dept_name having avg(salary) &gt;&#x3D; all(select avg(salary) from instructor group by dept_name);</span><br></pre></td></tr></table></figure>\n\n\n\n</li>\n</ol>\n<ol start=\"28\">\n<li><p>找出选修了Biology系所开设的所有课程的学生</p>\n</li>\n<li><p>找出所有在2009年最多开设一次的课程</p>\n</li>\n<li><p>找出所有在2009年最少开设两次的课程</p>\n</li>\n<li><p>找出系平均工资超过42000美元的那些系中的教师平均工资</p>\n</li>\n<li><p>所有系工资总额最大系</p>\n</li>\n<li><p>所有系和他们拥有的教师数</p>\n</li>\n<li><p>删除工作在Watson大楼系工作的教师</p>\n</li>\n<li><p>删除平均工资低于大学平均工资的教师</p>\n</li>\n<li><p>让CS系修满144学分的学生成为CS系的老师，并且其平均工资为8000</p>\n</li>\n<li><p>工资低于1000教师工资增加5%</p>\n</li>\n<li><p>工资低于平均数的教师工资增加5%</p>\n</li>\n<li><p>工资超过1000教师涨5%，其余增长8%</p>\n</li>\n<li><p>一个学生在某门课成绩既不是F，也不是空，认为修完了该课程</p>\n</li>\n<li><p>找出所有课程一门也没选修的学生</p>\n</li>\n<li><p>找出CS系所有学生以及他们在2009年春季选修的所有课程</p>\n</li>\n</ol>\n<p>其他联系平台</p>\n<p><a href=\"https://www.nowcoder.com/ta/sql\" target=\"_blank\" rel=\"noopener\">https://www.nowcoder.com/ta/sql</a></p>\n"},{"title":"分布式系统研究泛型模板","date":"2021-04-23T19:19:51.000Z","_content":"\n\n\n# 概述\n\n世界上很多种分布式系统，如分布式文件系统，分布式KV，Google三驾马车，dynamo，newsql，分布式应用系统(微服务与SOA)，WWW等等，每种分布式系统种类不同，但是面临的问题类似，这里总结研究这些系统面临的共同话题，以便于研究新系统时候能够举一反三。泛型出自《分布式系统原理与泛型》这本书。当我们面临一个新的分布式系统时候，通过这些角度思考，能对系统有更深理解。\n\n\n\n# 总览\n\n| 分布式系统的抽象 | 问题                                                         |\n| ---------------- | ------------------------------------------------------------ |\n| 系统体系结构     | 系统体系结构是什么？<br />静态和动态视图是什么？<br />系统接口是什么？ |\n| 进程             | 进程模型是什么？<br />有哪些核心进程？<br />系统参与者有哪些？<br />进程可能奔溃？<br />进程如何工作完成系统功能？ |\n| 通信             | 系统间如何通信？<br />系统对外如何通信？<br />同步还是异步？<br />传递保证是什么？ |\n| 命名             | 如何找到资源？                                               |\n| 协调             | 进程间如何同步和协作？<br />如何互斥？<br />如何达成共识？<br /> |\n| 一致性和复制     | 一致性级别是什么？<br />复制过程是什么？(写入，副本更新，读取过程是什么？) <br />数据分区过程是什么？ |\n| 容错性           | 如何检查故障？<br />故障恢复过程是什么？<br />网络分区怎么处理？<br />系统成员变动如何处理？<br />分布式提交过程是什么？ |\n| 安全             | 系统间通信安全如何保证？<br />系统安全如何保证？             |\n\n\n\n\n\n## 系统体系结构(Architecture)\n\n系统结构：集中式，非集中式，混合式\n\n系统风格：分层架构，面向对象和SOA架构，面向资源架构，发布订阅架构\n\n## 进程(Process)\n\n进程模型有多线程，单线程进程，有限状态机等内容\n\n\n\n## 通信(Communication)\n\nrpc\n\n面向消息：AMQP\n\n面向流\n\n多播通信（应用层基于树的多播，flooding 多播，gossip data dissemination（传播））\n\n\n\n## 命名(Naming)\n\n名称，标识，地址，找到资源的方法\n\n无层次命名：DHT，home-base，等级划分\n\n结构化命名：NFS\n\n基于属性命名：LDAP\n\n## 协调(Coordination)\n\n时钟同步：物理时钟\n\n逻辑时钟：Lamport逻辑时钟，向量时钟\n\n互斥：集中，非集中，分布式，令牌环\n\n选举\n\n## 一致性和复制(Consistency and Replication)\n\n一致性协议，最终一致性，单调读，单调写，读写一致性，写读一致性，强最终一致性，线性一致性，顺序一致性，因果一致性等内容\n\n复制：主从复制，多主复制，无主复制\n\n\n\n## 容错性(Fault tolerance)\n\n故障类型，进程恢复，可靠通信，组通信（原子多播），分布式提交，恢复，故障检测\n\n\n\n## 安全\n\n安全通道，访问控制，安全管理\n\n\n\n# 推荐书籍\n\n《分布式系统原理与泛型》第二版和第三版\n\n《分布式系统概念与设计》\n\n《数据库系统内幕》\n\n《数据密集型应用系统设计》","source":"_posts/distributed-systems-research-paradigm.md","raw":"---\ntitle: 分布式系统研究泛型模板\ndate: 2021-04-24 03:19:51\ntags: \n  - 分布式系统泛型\ncategories:\n  - 分布式系统\n---\n\n\n\n# 概述\n\n世界上很多种分布式系统，如分布式文件系统，分布式KV，Google三驾马车，dynamo，newsql，分布式应用系统(微服务与SOA)，WWW等等，每种分布式系统种类不同，但是面临的问题类似，这里总结研究这些系统面临的共同话题，以便于研究新系统时候能够举一反三。泛型出自《分布式系统原理与泛型》这本书。当我们面临一个新的分布式系统时候，通过这些角度思考，能对系统有更深理解。\n\n\n\n# 总览\n\n| 分布式系统的抽象 | 问题                                                         |\n| ---------------- | ------------------------------------------------------------ |\n| 系统体系结构     | 系统体系结构是什么？<br />静态和动态视图是什么？<br />系统接口是什么？ |\n| 进程             | 进程模型是什么？<br />有哪些核心进程？<br />系统参与者有哪些？<br />进程可能奔溃？<br />进程如何工作完成系统功能？ |\n| 通信             | 系统间如何通信？<br />系统对外如何通信？<br />同步还是异步？<br />传递保证是什么？ |\n| 命名             | 如何找到资源？                                               |\n| 协调             | 进程间如何同步和协作？<br />如何互斥？<br />如何达成共识？<br /> |\n| 一致性和复制     | 一致性级别是什么？<br />复制过程是什么？(写入，副本更新，读取过程是什么？) <br />数据分区过程是什么？ |\n| 容错性           | 如何检查故障？<br />故障恢复过程是什么？<br />网络分区怎么处理？<br />系统成员变动如何处理？<br />分布式提交过程是什么？ |\n| 安全             | 系统间通信安全如何保证？<br />系统安全如何保证？             |\n\n\n\n\n\n## 系统体系结构(Architecture)\n\n系统结构：集中式，非集中式，混合式\n\n系统风格：分层架构，面向对象和SOA架构，面向资源架构，发布订阅架构\n\n## 进程(Process)\n\n进程模型有多线程，单线程进程，有限状态机等内容\n\n\n\n## 通信(Communication)\n\nrpc\n\n面向消息：AMQP\n\n面向流\n\n多播通信（应用层基于树的多播，flooding 多播，gossip data dissemination（传播））\n\n\n\n## 命名(Naming)\n\n名称，标识，地址，找到资源的方法\n\n无层次命名：DHT，home-base，等级划分\n\n结构化命名：NFS\n\n基于属性命名：LDAP\n\n## 协调(Coordination)\n\n时钟同步：物理时钟\n\n逻辑时钟：Lamport逻辑时钟，向量时钟\n\n互斥：集中，非集中，分布式，令牌环\n\n选举\n\n## 一致性和复制(Consistency and Replication)\n\n一致性协议，最终一致性，单调读，单调写，读写一致性，写读一致性，强最终一致性，线性一致性，顺序一致性，因果一致性等内容\n\n复制：主从复制，多主复制，无主复制\n\n\n\n## 容错性(Fault tolerance)\n\n故障类型，进程恢复，可靠通信，组通信（原子多播），分布式提交，恢复，故障检测\n\n\n\n## 安全\n\n安全通道，访问控制，安全管理\n\n\n\n# 推荐书籍\n\n《分布式系统原理与泛型》第二版和第三版\n\n《分布式系统概念与设计》\n\n《数据库系统内幕》\n\n《数据密集型应用系统设计》","slug":"distributed-systems-research-paradigm","published":1,"updated":"2022-11-19T04:32:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clh7s5ctw0013xt8j2r8cfnv3","content":"<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><p>世界上很多种分布式系统，如分布式文件系统，分布式KV，Google三驾马车，dynamo，newsql，分布式应用系统(微服务与SOA)，WWW等等，每种分布式系统种类不同，但是面临的问题类似，这里总结研究这些系统面临的共同话题，以便于研究新系统时候能够举一反三。泛型出自《分布式系统原理与泛型》这本书。当我们面临一个新的分布式系统时候，通过这些角度思考，能对系统有更深理解。</p>\n<h1 id=\"总览\"><a href=\"#总览\" class=\"headerlink\" title=\"总览\"></a>总览</h1><table>\n<thead>\n<tr>\n<th>分布式系统的抽象</th>\n<th>问题</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>系统体系结构</td>\n<td>系统体系结构是什么？<br />静态和动态视图是什么？<br />系统接口是什么？</td>\n</tr>\n<tr>\n<td>进程</td>\n<td>进程模型是什么？<br />有哪些核心进程？<br />系统参与者有哪些？<br />进程可能奔溃？<br />进程如何工作完成系统功能？</td>\n</tr>\n<tr>\n<td>通信</td>\n<td>系统间如何通信？<br />系统对外如何通信？<br />同步还是异步？<br />传递保证是什么？</td>\n</tr>\n<tr>\n<td>命名</td>\n<td>如何找到资源？</td>\n</tr>\n<tr>\n<td>协调</td>\n<td>进程间如何同步和协作？<br />如何互斥？<br />如何达成共识？<br /></td>\n</tr>\n<tr>\n<td>一致性和复制</td>\n<td>一致性级别是什么？<br />复制过程是什么？(写入，副本更新，读取过程是什么？) <br />数据分区过程是什么？</td>\n</tr>\n<tr>\n<td>容错性</td>\n<td>如何检查故障？<br />故障恢复过程是什么？<br />网络分区怎么处理？<br />系统成员变动如何处理？<br />分布式提交过程是什么？</td>\n</tr>\n<tr>\n<td>安全</td>\n<td>系统间通信安全如何保证？<br />系统安全如何保证？</td>\n</tr>\n</tbody></table>\n<h2 id=\"系统体系结构-Architecture\"><a href=\"#系统体系结构-Architecture\" class=\"headerlink\" title=\"系统体系结构(Architecture)\"></a>系统体系结构(Architecture)</h2><p>系统结构：集中式，非集中式，混合式</p>\n<p>系统风格：分层架构，面向对象和SOA架构，面向资源架构，发布订阅架构</p>\n<h2 id=\"进程-Process\"><a href=\"#进程-Process\" class=\"headerlink\" title=\"进程(Process)\"></a>进程(Process)</h2><p>进程模型有多线程，单线程进程，有限状态机等内容</p>\n<h2 id=\"通信-Communication\"><a href=\"#通信-Communication\" class=\"headerlink\" title=\"通信(Communication)\"></a>通信(Communication)</h2><p>rpc</p>\n<p>面向消息：AMQP</p>\n<p>面向流</p>\n<p>多播通信（应用层基于树的多播，flooding 多播，gossip data dissemination（传播））</p>\n<h2 id=\"命名-Naming\"><a href=\"#命名-Naming\" class=\"headerlink\" title=\"命名(Naming)\"></a>命名(Naming)</h2><p>名称，标识，地址，找到资源的方法</p>\n<p>无层次命名：DHT，home-base，等级划分</p>\n<p>结构化命名：NFS</p>\n<p>基于属性命名：LDAP</p>\n<h2 id=\"协调-Coordination\"><a href=\"#协调-Coordination\" class=\"headerlink\" title=\"协调(Coordination)\"></a>协调(Coordination)</h2><p>时钟同步：物理时钟</p>\n<p>逻辑时钟：Lamport逻辑时钟，向量时钟</p>\n<p>互斥：集中，非集中，分布式，令牌环</p>\n<p>选举</p>\n<h2 id=\"一致性和复制-Consistency-and-Replication\"><a href=\"#一致性和复制-Consistency-and-Replication\" class=\"headerlink\" title=\"一致性和复制(Consistency and Replication)\"></a>一致性和复制(Consistency and Replication)</h2><p>一致性协议，最终一致性，单调读，单调写，读写一致性，写读一致性，强最终一致性，线性一致性，顺序一致性，因果一致性等内容</p>\n<p>复制：主从复制，多主复制，无主复制</p>\n<h2 id=\"容错性-Fault-tolerance\"><a href=\"#容错性-Fault-tolerance\" class=\"headerlink\" title=\"容错性(Fault tolerance)\"></a>容错性(Fault tolerance)</h2><p>故障类型，进程恢复，可靠通信，组通信（原子多播），分布式提交，恢复，故障检测</p>\n<h2 id=\"安全\"><a href=\"#安全\" class=\"headerlink\" title=\"安全\"></a>安全</h2><p>安全通道，访问控制，安全管理</p>\n<h1 id=\"推荐书籍\"><a href=\"#推荐书籍\" class=\"headerlink\" title=\"推荐书籍\"></a>推荐书籍</h1><p>《分布式系统原理与泛型》第二版和第三版</p>\n<p>《分布式系统概念与设计》</p>\n<p>《数据库系统内幕》</p>\n<p>《数据密集型应用系统设计》</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><p>世界上很多种分布式系统，如分布式文件系统，分布式KV，Google三驾马车，dynamo，newsql，分布式应用系统(微服务与SOA)，WWW等等，每种分布式系统种类不同，但是面临的问题类似，这里总结研究这些系统面临的共同话题，以便于研究新系统时候能够举一反三。泛型出自《分布式系统原理与泛型》这本书。当我们面临一个新的分布式系统时候，通过这些角度思考，能对系统有更深理解。</p>\n<h1 id=\"总览\"><a href=\"#总览\" class=\"headerlink\" title=\"总览\"></a>总览</h1><table>\n<thead>\n<tr>\n<th>分布式系统的抽象</th>\n<th>问题</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>系统体系结构</td>\n<td>系统体系结构是什么？<br />静态和动态视图是什么？<br />系统接口是什么？</td>\n</tr>\n<tr>\n<td>进程</td>\n<td>进程模型是什么？<br />有哪些核心进程？<br />系统参与者有哪些？<br />进程可能奔溃？<br />进程如何工作完成系统功能？</td>\n</tr>\n<tr>\n<td>通信</td>\n<td>系统间如何通信？<br />系统对外如何通信？<br />同步还是异步？<br />传递保证是什么？</td>\n</tr>\n<tr>\n<td>命名</td>\n<td>如何找到资源？</td>\n</tr>\n<tr>\n<td>协调</td>\n<td>进程间如何同步和协作？<br />如何互斥？<br />如何达成共识？<br /></td>\n</tr>\n<tr>\n<td>一致性和复制</td>\n<td>一致性级别是什么？<br />复制过程是什么？(写入，副本更新，读取过程是什么？) <br />数据分区过程是什么？</td>\n</tr>\n<tr>\n<td>容错性</td>\n<td>如何检查故障？<br />故障恢复过程是什么？<br />网络分区怎么处理？<br />系统成员变动如何处理？<br />分布式提交过程是什么？</td>\n</tr>\n<tr>\n<td>安全</td>\n<td>系统间通信安全如何保证？<br />系统安全如何保证？</td>\n</tr>\n</tbody></table>\n<h2 id=\"系统体系结构-Architecture\"><a href=\"#系统体系结构-Architecture\" class=\"headerlink\" title=\"系统体系结构(Architecture)\"></a>系统体系结构(Architecture)</h2><p>系统结构：集中式，非集中式，混合式</p>\n<p>系统风格：分层架构，面向对象和SOA架构，面向资源架构，发布订阅架构</p>\n<h2 id=\"进程-Process\"><a href=\"#进程-Process\" class=\"headerlink\" title=\"进程(Process)\"></a>进程(Process)</h2><p>进程模型有多线程，单线程进程，有限状态机等内容</p>\n<h2 id=\"通信-Communication\"><a href=\"#通信-Communication\" class=\"headerlink\" title=\"通信(Communication)\"></a>通信(Communication)</h2><p>rpc</p>\n<p>面向消息：AMQP</p>\n<p>面向流</p>\n<p>多播通信（应用层基于树的多播，flooding 多播，gossip data dissemination（传播））</p>\n<h2 id=\"命名-Naming\"><a href=\"#命名-Naming\" class=\"headerlink\" title=\"命名(Naming)\"></a>命名(Naming)</h2><p>名称，标识，地址，找到资源的方法</p>\n<p>无层次命名：DHT，home-base，等级划分</p>\n<p>结构化命名：NFS</p>\n<p>基于属性命名：LDAP</p>\n<h2 id=\"协调-Coordination\"><a href=\"#协调-Coordination\" class=\"headerlink\" title=\"协调(Coordination)\"></a>协调(Coordination)</h2><p>时钟同步：物理时钟</p>\n<p>逻辑时钟：Lamport逻辑时钟，向量时钟</p>\n<p>互斥：集中，非集中，分布式，令牌环</p>\n<p>选举</p>\n<h2 id=\"一致性和复制-Consistency-and-Replication\"><a href=\"#一致性和复制-Consistency-and-Replication\" class=\"headerlink\" title=\"一致性和复制(Consistency and Replication)\"></a>一致性和复制(Consistency and Replication)</h2><p>一致性协议，最终一致性，单调读，单调写，读写一致性，写读一致性，强最终一致性，线性一致性，顺序一致性，因果一致性等内容</p>\n<p>复制：主从复制，多主复制，无主复制</p>\n<h2 id=\"容错性-Fault-tolerance\"><a href=\"#容错性-Fault-tolerance\" class=\"headerlink\" title=\"容错性(Fault tolerance)\"></a>容错性(Fault tolerance)</h2><p>故障类型，进程恢复，可靠通信，组通信（原子多播），分布式提交，恢复，故障检测</p>\n<h2 id=\"安全\"><a href=\"#安全\" class=\"headerlink\" title=\"安全\"></a>安全</h2><p>安全通道，访问控制，安全管理</p>\n<h1 id=\"推荐书籍\"><a href=\"#推荐书籍\" class=\"headerlink\" title=\"推荐书籍\"></a>推荐书籍</h1><p>《分布式系统原理与泛型》第二版和第三版</p>\n<p>《分布式系统概念与设计》</p>\n<p>《数据库系统内幕》</p>\n<p>《数据密集型应用系统设计》</p>\n"},{"title":"guava-retry源码分析","date":"2020-08-15T06:50:19.000Z","_content":"\n\n\nguava-retry是扩展guava的一个重试库。\n\n\n\n### 一  问题(Question)\n\n在系统设计的时候，重试作为系统容错方法，被广泛使用在云化系统，微服务系统，并以模式形式记录在 [azure cloud design pattern](https://docs.microsoft.com/en-us/azure/architecture/patterns/retry )从而使得系统变得更加健壮和弹性(resilient)，同时和熔断，限流等策略结合起来，充分保证系统可靠性。但是如何设计一个可复用，可扩展的重试库，需要先了解重试的设计问题。业界给出的答案有：[guava-retry](https://github.com/rholder/guava-retrying)，[Spring Retry](https://mvnrepository.com/artifact/org.springframework.retry/spring-retry) ，[Resilience4j](https://mvnrepository.com/artifact/io.github.resilience4j/resilience4j-retry) ，本文主要对guava-retry进行分析。\n\n\n\n### 二  设计(Design)\n\n重试的设计问题有以下几个方面：\n\n- 1   什么时候开始重试？ 异常和错误或不满足预期值。\n\n- 2   重试策略是什么？ 重试策略可以具体划分一下三个方面：\n\n  ​          2.1 基于次数(空间)还是基于时间，还是两者结合起来\n\n  ​          2.2 重试间隔策略是什么？是等待指定时间后重试，还是无限重试，还是指数回退呢\n\n-  3   什么时候停止重试？\n\n\n\n### 三 抽象和分解(Abstract and Decomposing)\n\n通过对问题的理解，可以抽象出核心概念和隐喻解决这个问题。来看看guava-retry的抽象和解决之道。\n\n1. 执行过程抽象成Callable对象，执行时间控制通过TimeLimiter来管理。\n\n2. 将通过对返回结果封装成Attempt对象，来表达结果是否有异常，获取该结果已经重试次数，距离第一次重试耗费多久。\n\n3. 将重试条件组合成Predicate对象。\n\n4. 等待策略WaitStrategy获取等待时间，阻塞策略BlockStrategy用于重试间隔的阻塞，停止策略StopStrategy。以及提供了默认策略实现的WaitStrategies工厂，BlockStrategys工厂，StopStrategys工厂。\n\n5. RetryListener监听器，监听每次重试时候的动作。\n\n6. RetryerBuilder用于构造Retryer，Retryer将条件，过程，策略通过call(Callable<V> callable)方法组合起来，来完成整个重试机制的实现。\n\n   \n\n### 四 类图(Class Diagram)\n\n![类图](/images/guava-retry.png)\n\n\n\n### 五 核心流程(Core process)\n\n\n\n```java\n//Retryer类的核心流程call方法中，将RetryerBuilder中的等待条件，执行过程(指定时间执行完成)，等待策略，阻塞策略，\n//停止策略整合起来完成重试机制的设计。\npublic V call(Callable<V> callable) throws ExecutionException, RetryException {\n    long startTime = System.nanoTime();\n    //for循环中不断重试，并通过attemptNumber来记录重试次数\n    for (int attemptNumber = 1; ; attemptNumber++) {\n        Attempt<V> attempt;\n        try {\n            //指定时间内返回结果\n            V result = attemptTimeLimiter.call(callable);\n            //正常返回结果封装成ResultAttempt对象，并且记录真实结果，重试吃啥，距离第一次返回结果的时间间隔\n            attempt = new ResultAttempt<V>(result, attemptNumber, TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startTime));\n        } catch (Throwable t) {\n            //异常返回结果封装成ExceptionAttempt对象\n            attempt = new ExceptionAttempt<V>(t, attemptNumber, TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startTime));\n        }\n        //监听器回调Attempt结果\n        for (RetryListener listener : listeners) {\n            listener.onRetry(attempt);\n        }\n        //各种重试条件(结果预期，抛出异常，状态码非200等判断)组合Predicate判断，是否需要重试\n        if (!rejectionPredicate.apply(attempt)) {\n            //不需要重试直接返回真实结果\n            return attempt.get();\n        }\n        //需要重试时候判断此次是否停止重试\n        if (stopStrategy.shouldStop(attempt)) {\n            //停止重试时候，说明正确返回值还没有获取，即认为重试失败，抛出重试异常，交由客户端处理\n            throw new RetryException(attemptNumber, attempt);\n        } else {\n            //等待策略获取等待时间\n            long sleepTime = waitStrategy.computeSleepTime(attempt);\n            try {\n                //开始等待\n                blockStrategy.block(sleepTime);\n            } catch (InterruptedException e) {\n                //线程等待中被中断，抛出重试异常\n                Thread.currentThread().interrupt();\n                throw new RetryException(attemptNumber, attempt);\n            }\n        }\n    }\n}\n```\n\n\n\n### 六 总结(Summary)\n\n#### 优点:\n\n设计上：\n\n1. 整个源码总共13个类，6个接口,  7个类中4个工厂类，1个异常类，2个核心类，1个监听类。抽象度比较平衡，类的层次最多两层。\n2. 整个源码非常简洁，容易理解，代码重复很少，对外API也很简单容易使用。\n3. guava-retry使用Builder，Template，Strategy，Factory，Facade等模式将整个流程组合起来，并且提供了扩展点以自定义策略。体现了面向接口编程原则。\n\n实现上：\n\n1. 使用Guava的SimpleTimeLimiter，Preconditions，Predicates。\n2. 引入findbugs:jsr305注解，@Immutable，@Nonnull注解，提高可读性和设计意图。\n\n\n\n#### 缺点：\n\n1. 官方issue较多，回复不及时，不是很活跃。\n2.  SimpleTimeLimiter类在Guava中已经没有公开构造方法了，所以使用时候会报运行时错误。\n3. 虽然叫guava-retry，但是实际不是google维护的代码。\n4. 单元测试不全面，有些类没有测试。\n5. 代码检测不如apache标准项目多，比如pmd，checkstyle等检测。\n6. 由于是个人项目，工程规范方面可借鉴的较少。","source":"_posts/guava-retry-code-analysis.md","raw":"---\ntitle: guava-retry源码分析\ndate: 2020-08-15 14:50:19\ntags:\n  - guava-retry\ncategories:\n  - 源码分析\n---\n\n\n\nguava-retry是扩展guava的一个重试库。\n\n\n\n### 一  问题(Question)\n\n在系统设计的时候，重试作为系统容错方法，被广泛使用在云化系统，微服务系统，并以模式形式记录在 [azure cloud design pattern](https://docs.microsoft.com/en-us/azure/architecture/patterns/retry )从而使得系统变得更加健壮和弹性(resilient)，同时和熔断，限流等策略结合起来，充分保证系统可靠性。但是如何设计一个可复用，可扩展的重试库，需要先了解重试的设计问题。业界给出的答案有：[guava-retry](https://github.com/rholder/guava-retrying)，[Spring Retry](https://mvnrepository.com/artifact/org.springframework.retry/spring-retry) ，[Resilience4j](https://mvnrepository.com/artifact/io.github.resilience4j/resilience4j-retry) ，本文主要对guava-retry进行分析。\n\n\n\n### 二  设计(Design)\n\n重试的设计问题有以下几个方面：\n\n- 1   什么时候开始重试？ 异常和错误或不满足预期值。\n\n- 2   重试策略是什么？ 重试策略可以具体划分一下三个方面：\n\n  ​          2.1 基于次数(空间)还是基于时间，还是两者结合起来\n\n  ​          2.2 重试间隔策略是什么？是等待指定时间后重试，还是无限重试，还是指数回退呢\n\n-  3   什么时候停止重试？\n\n\n\n### 三 抽象和分解(Abstract and Decomposing)\n\n通过对问题的理解，可以抽象出核心概念和隐喻解决这个问题。来看看guava-retry的抽象和解决之道。\n\n1. 执行过程抽象成Callable对象，执行时间控制通过TimeLimiter来管理。\n\n2. 将通过对返回结果封装成Attempt对象，来表达结果是否有异常，获取该结果已经重试次数，距离第一次重试耗费多久。\n\n3. 将重试条件组合成Predicate对象。\n\n4. 等待策略WaitStrategy获取等待时间，阻塞策略BlockStrategy用于重试间隔的阻塞，停止策略StopStrategy。以及提供了默认策略实现的WaitStrategies工厂，BlockStrategys工厂，StopStrategys工厂。\n\n5. RetryListener监听器，监听每次重试时候的动作。\n\n6. RetryerBuilder用于构造Retryer，Retryer将条件，过程，策略通过call(Callable<V> callable)方法组合起来，来完成整个重试机制的实现。\n\n   \n\n### 四 类图(Class Diagram)\n\n![类图](/images/guava-retry.png)\n\n\n\n### 五 核心流程(Core process)\n\n\n\n```java\n//Retryer类的核心流程call方法中，将RetryerBuilder中的等待条件，执行过程(指定时间执行完成)，等待策略，阻塞策略，\n//停止策略整合起来完成重试机制的设计。\npublic V call(Callable<V> callable) throws ExecutionException, RetryException {\n    long startTime = System.nanoTime();\n    //for循环中不断重试，并通过attemptNumber来记录重试次数\n    for (int attemptNumber = 1; ; attemptNumber++) {\n        Attempt<V> attempt;\n        try {\n            //指定时间内返回结果\n            V result = attemptTimeLimiter.call(callable);\n            //正常返回结果封装成ResultAttempt对象，并且记录真实结果，重试吃啥，距离第一次返回结果的时间间隔\n            attempt = new ResultAttempt<V>(result, attemptNumber, TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startTime));\n        } catch (Throwable t) {\n            //异常返回结果封装成ExceptionAttempt对象\n            attempt = new ExceptionAttempt<V>(t, attemptNumber, TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startTime));\n        }\n        //监听器回调Attempt结果\n        for (RetryListener listener : listeners) {\n            listener.onRetry(attempt);\n        }\n        //各种重试条件(结果预期，抛出异常，状态码非200等判断)组合Predicate判断，是否需要重试\n        if (!rejectionPredicate.apply(attempt)) {\n            //不需要重试直接返回真实结果\n            return attempt.get();\n        }\n        //需要重试时候判断此次是否停止重试\n        if (stopStrategy.shouldStop(attempt)) {\n            //停止重试时候，说明正确返回值还没有获取，即认为重试失败，抛出重试异常，交由客户端处理\n            throw new RetryException(attemptNumber, attempt);\n        } else {\n            //等待策略获取等待时间\n            long sleepTime = waitStrategy.computeSleepTime(attempt);\n            try {\n                //开始等待\n                blockStrategy.block(sleepTime);\n            } catch (InterruptedException e) {\n                //线程等待中被中断，抛出重试异常\n                Thread.currentThread().interrupt();\n                throw new RetryException(attemptNumber, attempt);\n            }\n        }\n    }\n}\n```\n\n\n\n### 六 总结(Summary)\n\n#### 优点:\n\n设计上：\n\n1. 整个源码总共13个类，6个接口,  7个类中4个工厂类，1个异常类，2个核心类，1个监听类。抽象度比较平衡，类的层次最多两层。\n2. 整个源码非常简洁，容易理解，代码重复很少，对外API也很简单容易使用。\n3. guava-retry使用Builder，Template，Strategy，Factory，Facade等模式将整个流程组合起来，并且提供了扩展点以自定义策略。体现了面向接口编程原则。\n\n实现上：\n\n1. 使用Guava的SimpleTimeLimiter，Preconditions，Predicates。\n2. 引入findbugs:jsr305注解，@Immutable，@Nonnull注解，提高可读性和设计意图。\n\n\n\n#### 缺点：\n\n1. 官方issue较多，回复不及时，不是很活跃。\n2.  SimpleTimeLimiter类在Guava中已经没有公开构造方法了，所以使用时候会报运行时错误。\n3. 虽然叫guava-retry，但是实际不是google维护的代码。\n4. 单元测试不全面，有些类没有测试。\n5. 代码检测不如apache标准项目多，比如pmd，checkstyle等检测。\n6. 由于是个人项目，工程规范方面可借鉴的较少。","slug":"guava-retry-code-analysis","published":1,"updated":"2020-08-15T10:59:02.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clh7s5ctx0017xt8jc7kza6x7","content":"<p>guava-retry是扩展guava的一个重试库。</p>\n<h3 id=\"一-问题-Question\"><a href=\"#一-问题-Question\" class=\"headerlink\" title=\"一  问题(Question)\"></a>一  问题(Question)</h3><p>在系统设计的时候，重试作为系统容错方法，被广泛使用在云化系统，微服务系统，并以模式形式记录在 <a href=\"https://docs.microsoft.com/en-us/azure/architecture/patterns/retry\" target=\"_blank\" rel=\"noopener\">azure cloud design pattern</a>从而使得系统变得更加健壮和弹性(resilient)，同时和熔断，限流等策略结合起来，充分保证系统可靠性。但是如何设计一个可复用，可扩展的重试库，需要先了解重试的设计问题。业界给出的答案有：<a href=\"https://github.com/rholder/guava-retrying\" target=\"_blank\" rel=\"noopener\">guava-retry</a>，<a href=\"https://mvnrepository.com/artifact/org.springframework.retry/spring-retry\" target=\"_blank\" rel=\"noopener\">Spring Retry</a> ，<a href=\"https://mvnrepository.com/artifact/io.github.resilience4j/resilience4j-retry\" target=\"_blank\" rel=\"noopener\">Resilience4j</a> ，本文主要对guava-retry进行分析。</p>\n<h3 id=\"二-设计-Design\"><a href=\"#二-设计-Design\" class=\"headerlink\" title=\"二  设计(Design)\"></a>二  设计(Design)</h3><p>重试的设计问题有以下几个方面：</p>\n<ul>\n<li><p>1   什么时候开始重试？ 异常和错误或不满足预期值。</p>\n</li>\n<li><p>2   重试策略是什么？ 重试策略可以具体划分一下三个方面：</p>\n<p>​          2.1 基于次数(空间)还是基于时间，还是两者结合起来</p>\n<p>​          2.2 重试间隔策略是什么？是等待指定时间后重试，还是无限重试，还是指数回退呢</p>\n</li>\n<li><p>3   什么时候停止重试？</p>\n</li>\n</ul>\n<h3 id=\"三-抽象和分解-Abstract-and-Decomposing\"><a href=\"#三-抽象和分解-Abstract-and-Decomposing\" class=\"headerlink\" title=\"三 抽象和分解(Abstract and Decomposing)\"></a>三 抽象和分解(Abstract and Decomposing)</h3><p>通过对问题的理解，可以抽象出核心概念和隐喻解决这个问题。来看看guava-retry的抽象和解决之道。</p>\n<ol>\n<li><p>执行过程抽象成Callable对象，执行时间控制通过TimeLimiter来管理。</p>\n</li>\n<li><p>将通过对返回结果封装成Attempt对象，来表达结果是否有异常，获取该结果已经重试次数，距离第一次重试耗费多久。</p>\n</li>\n<li><p>将重试条件组合成Predicate对象。</p>\n</li>\n<li><p>等待策略WaitStrategy获取等待时间，阻塞策略BlockStrategy用于重试间隔的阻塞，停止策略StopStrategy。以及提供了默认策略实现的WaitStrategies工厂，BlockStrategys工厂，StopStrategys工厂。</p>\n</li>\n<li><p>RetryListener监听器，监听每次重试时候的动作。</p>\n</li>\n<li><p>RetryerBuilder用于构造Retryer，Retryer将条件，过程，策略通过call(Callable<V> callable)方法组合起来，来完成整个重试机制的实现。</p>\n</li>\n</ol>\n<h3 id=\"四-类图-Class-Diagram\"><a href=\"#四-类图-Class-Diagram\" class=\"headerlink\" title=\"四 类图(Class Diagram)\"></a>四 类图(Class Diagram)</h3><p><img src=\"/images/guava-retry.png\" alt=\"类图\"></p>\n<h3 id=\"五-核心流程-Core-process\"><a href=\"#五-核心流程-Core-process\" class=\"headerlink\" title=\"五 核心流程(Core process)\"></a>五 核心流程(Core process)</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Retryer类的核心流程call方法中，将RetryerBuilder中的等待条件，执行过程(指定时间执行完成)，等待策略，阻塞策略，</span></span><br><span class=\"line\"><span class=\"comment\">//停止策略整合起来完成重试机制的设计。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">call</span><span class=\"params\">(Callable&lt;V&gt; callable)</span> <span class=\"keyword\">throws</span> ExecutionException, RetryException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> startTime = System.nanoTime();</span><br><span class=\"line\">    <span class=\"comment\">//for循环中不断重试，并通过attemptNumber来记录重试次数</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> attemptNumber = <span class=\"number\">1</span>; ; attemptNumber++) &#123;</span><br><span class=\"line\">        Attempt&lt;V&gt; attempt;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//指定时间内返回结果</span></span><br><span class=\"line\">            V result = attemptTimeLimiter.call(callable);</span><br><span class=\"line\">            <span class=\"comment\">//正常返回结果封装成ResultAttempt对象，并且记录真实结果，重试吃啥，距离第一次返回结果的时间间隔</span></span><br><span class=\"line\">            attempt = <span class=\"keyword\">new</span> ResultAttempt&lt;V&gt;(result, attemptNumber, TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startTime));</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//异常返回结果封装成ExceptionAttempt对象</span></span><br><span class=\"line\">            attempt = <span class=\"keyword\">new</span> ExceptionAttempt&lt;V&gt;(t, attemptNumber, TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startTime));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//监听器回调Attempt结果</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (RetryListener listener : listeners) &#123;</span><br><span class=\"line\">            listener.onRetry(attempt);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//各种重试条件(结果预期，抛出异常，状态码非200等判断)组合Predicate判断，是否需要重试</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!rejectionPredicate.apply(attempt)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//不需要重试直接返回真实结果</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> attempt.get();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//需要重试时候判断此次是否停止重试</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (stopStrategy.shouldStop(attempt)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//停止重试时候，说明正确返回值还没有获取，即认为重试失败，抛出重试异常，交由客户端处理</span></span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RetryException(attemptNumber, attempt);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//等待策略获取等待时间</span></span><br><span class=\"line\">            <span class=\"keyword\">long</span> sleepTime = waitStrategy.computeSleepTime(attempt);</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">//开始等待</span></span><br><span class=\"line\">                blockStrategy.block(sleepTime);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//线程等待中被中断，抛出重试异常</span></span><br><span class=\"line\">                Thread.currentThread().interrupt();</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RetryException(attemptNumber, attempt);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"六-总结-Summary\"><a href=\"#六-总结-Summary\" class=\"headerlink\" title=\"六 总结(Summary)\"></a>六 总结(Summary)</h3><h4 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点:\"></a>优点:</h4><p>设计上：</p>\n<ol>\n<li>整个源码总共13个类，6个接口,  7个类中4个工厂类，1个异常类，2个核心类，1个监听类。抽象度比较平衡，类的层次最多两层。</li>\n<li>整个源码非常简洁，容易理解，代码重复很少，对外API也很简单容易使用。</li>\n<li>guava-retry使用Builder，Template，Strategy，Factory，Facade等模式将整个流程组合起来，并且提供了扩展点以自定义策略。体现了面向接口编程原则。</li>\n</ol>\n<p>实现上：</p>\n<ol>\n<li>使用Guava的SimpleTimeLimiter，Preconditions，Predicates。</li>\n<li>引入findbugs:jsr305注解，@Immutable，@Nonnull注解，提高可读性和设计意图。</li>\n</ol>\n<h4 id=\"缺点：\"><a href=\"#缺点：\" class=\"headerlink\" title=\"缺点：\"></a>缺点：</h4><ol>\n<li>官方issue较多，回复不及时，不是很活跃。</li>\n<li>SimpleTimeLimiter类在Guava中已经没有公开构造方法了，所以使用时候会报运行时错误。</li>\n<li>虽然叫guava-retry，但是实际不是google维护的代码。</li>\n<li>单元测试不全面，有些类没有测试。</li>\n<li>代码检测不如apache标准项目多，比如pmd，checkstyle等检测。</li>\n<li>由于是个人项目，工程规范方面可借鉴的较少。</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>guava-retry是扩展guava的一个重试库。</p>\n<h3 id=\"一-问题-Question\"><a href=\"#一-问题-Question\" class=\"headerlink\" title=\"一  问题(Question)\"></a>一  问题(Question)</h3><p>在系统设计的时候，重试作为系统容错方法，被广泛使用在云化系统，微服务系统，并以模式形式记录在 <a href=\"https://docs.microsoft.com/en-us/azure/architecture/patterns/retry\" target=\"_blank\" rel=\"noopener\">azure cloud design pattern</a>从而使得系统变得更加健壮和弹性(resilient)，同时和熔断，限流等策略结合起来，充分保证系统可靠性。但是如何设计一个可复用，可扩展的重试库，需要先了解重试的设计问题。业界给出的答案有：<a href=\"https://github.com/rholder/guava-retrying\" target=\"_blank\" rel=\"noopener\">guava-retry</a>，<a href=\"https://mvnrepository.com/artifact/org.springframework.retry/spring-retry\" target=\"_blank\" rel=\"noopener\">Spring Retry</a> ，<a href=\"https://mvnrepository.com/artifact/io.github.resilience4j/resilience4j-retry\" target=\"_blank\" rel=\"noopener\">Resilience4j</a> ，本文主要对guava-retry进行分析。</p>\n<h3 id=\"二-设计-Design\"><a href=\"#二-设计-Design\" class=\"headerlink\" title=\"二  设计(Design)\"></a>二  设计(Design)</h3><p>重试的设计问题有以下几个方面：</p>\n<ul>\n<li><p>1   什么时候开始重试？ 异常和错误或不满足预期值。</p>\n</li>\n<li><p>2   重试策略是什么？ 重试策略可以具体划分一下三个方面：</p>\n<p>​          2.1 基于次数(空间)还是基于时间，还是两者结合起来</p>\n<p>​          2.2 重试间隔策略是什么？是等待指定时间后重试，还是无限重试，还是指数回退呢</p>\n</li>\n<li><p>3   什么时候停止重试？</p>\n</li>\n</ul>\n<h3 id=\"三-抽象和分解-Abstract-and-Decomposing\"><a href=\"#三-抽象和分解-Abstract-and-Decomposing\" class=\"headerlink\" title=\"三 抽象和分解(Abstract and Decomposing)\"></a>三 抽象和分解(Abstract and Decomposing)</h3><p>通过对问题的理解，可以抽象出核心概念和隐喻解决这个问题。来看看guava-retry的抽象和解决之道。</p>\n<ol>\n<li><p>执行过程抽象成Callable对象，执行时间控制通过TimeLimiter来管理。</p>\n</li>\n<li><p>将通过对返回结果封装成Attempt对象，来表达结果是否有异常，获取该结果已经重试次数，距离第一次重试耗费多久。</p>\n</li>\n<li><p>将重试条件组合成Predicate对象。</p>\n</li>\n<li><p>等待策略WaitStrategy获取等待时间，阻塞策略BlockStrategy用于重试间隔的阻塞，停止策略StopStrategy。以及提供了默认策略实现的WaitStrategies工厂，BlockStrategys工厂，StopStrategys工厂。</p>\n</li>\n<li><p>RetryListener监听器，监听每次重试时候的动作。</p>\n</li>\n<li><p>RetryerBuilder用于构造Retryer，Retryer将条件，过程，策略通过call(Callable<V> callable)方法组合起来，来完成整个重试机制的实现。</p>\n</li>\n</ol>\n<h3 id=\"四-类图-Class-Diagram\"><a href=\"#四-类图-Class-Diagram\" class=\"headerlink\" title=\"四 类图(Class Diagram)\"></a>四 类图(Class Diagram)</h3><p><img src=\"/images/guava-retry.png\" alt=\"类图\"></p>\n<h3 id=\"五-核心流程-Core-process\"><a href=\"#五-核心流程-Core-process\" class=\"headerlink\" title=\"五 核心流程(Core process)\"></a>五 核心流程(Core process)</h3><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br><span class=\"line\">42</span><br><span class=\"line\">43</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//Retryer类的核心流程call方法中，将RetryerBuilder中的等待条件，执行过程(指定时间执行完成)，等待策略，阻塞策略，</span></span><br><span class=\"line\"><span class=\"comment\">//停止策略整合起来完成重试机制的设计。</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> V <span class=\"title\">call</span><span class=\"params\">(Callable&lt;V&gt; callable)</span> <span class=\"keyword\">throws</span> ExecutionException, RetryException </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">long</span> startTime = System.nanoTime();</span><br><span class=\"line\">    <span class=\"comment\">//for循环中不断重试，并通过attemptNumber来记录重试次数</span></span><br><span class=\"line\">    <span class=\"keyword\">for</span> (<span class=\"keyword\">int</span> attemptNumber = <span class=\"number\">1</span>; ; attemptNumber++) &#123;</span><br><span class=\"line\">        Attempt&lt;V&gt; attempt;</span><br><span class=\"line\">        <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//指定时间内返回结果</span></span><br><span class=\"line\">            V result = attemptTimeLimiter.call(callable);</span><br><span class=\"line\">            <span class=\"comment\">//正常返回结果封装成ResultAttempt对象，并且记录真实结果，重试吃啥，距离第一次返回结果的时间间隔</span></span><br><span class=\"line\">            attempt = <span class=\"keyword\">new</span> ResultAttempt&lt;V&gt;(result, attemptNumber, TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startTime));</span><br><span class=\"line\">        &#125; <span class=\"keyword\">catch</span> (Throwable t) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//异常返回结果封装成ExceptionAttempt对象</span></span><br><span class=\"line\">            attempt = <span class=\"keyword\">new</span> ExceptionAttempt&lt;V&gt;(t, attemptNumber, TimeUnit.NANOSECONDS.toMillis(System.nanoTime() - startTime));</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//监听器回调Attempt结果</span></span><br><span class=\"line\">        <span class=\"keyword\">for</span> (RetryListener listener : listeners) &#123;</span><br><span class=\"line\">            listener.onRetry(attempt);</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//各种重试条件(结果预期，抛出异常，状态码非200等判断)组合Predicate判断，是否需要重试</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!rejectionPredicate.apply(attempt)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//不需要重试直接返回真实结果</span></span><br><span class=\"line\">            <span class=\"keyword\">return</span> attempt.get();</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">        <span class=\"comment\">//需要重试时候判断此次是否停止重试</span></span><br><span class=\"line\">        <span class=\"keyword\">if</span> (stopStrategy.shouldStop(attempt)) &#123;</span><br><span class=\"line\">            <span class=\"comment\">//停止重试时候，说明正确返回值还没有获取，即认为重试失败，抛出重试异常，交由客户端处理</span></span><br><span class=\"line\">            <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RetryException(attemptNumber, attempt);</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            <span class=\"comment\">//等待策略获取等待时间</span></span><br><span class=\"line\">            <span class=\"keyword\">long</span> sleepTime = waitStrategy.computeSleepTime(attempt);</span><br><span class=\"line\">            <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                <span class=\"comment\">//开始等待</span></span><br><span class=\"line\">                blockStrategy.block(sleepTime);</span><br><span class=\"line\">            &#125; <span class=\"keyword\">catch</span> (InterruptedException e) &#123;</span><br><span class=\"line\">                <span class=\"comment\">//线程等待中被中断，抛出重试异常</span></span><br><span class=\"line\">                Thread.currentThread().interrupt();</span><br><span class=\"line\">                <span class=\"keyword\">throw</span> <span class=\"keyword\">new</span> RetryException(attemptNumber, attempt);</span><br><span class=\"line\">            &#125;</span><br><span class=\"line\">        &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"六-总结-Summary\"><a href=\"#六-总结-Summary\" class=\"headerlink\" title=\"六 总结(Summary)\"></a>六 总结(Summary)</h3><h4 id=\"优点\"><a href=\"#优点\" class=\"headerlink\" title=\"优点:\"></a>优点:</h4><p>设计上：</p>\n<ol>\n<li>整个源码总共13个类，6个接口,  7个类中4个工厂类，1个异常类，2个核心类，1个监听类。抽象度比较平衡，类的层次最多两层。</li>\n<li>整个源码非常简洁，容易理解，代码重复很少，对外API也很简单容易使用。</li>\n<li>guava-retry使用Builder，Template，Strategy，Factory，Facade等模式将整个流程组合起来，并且提供了扩展点以自定义策略。体现了面向接口编程原则。</li>\n</ol>\n<p>实现上：</p>\n<ol>\n<li>使用Guava的SimpleTimeLimiter，Preconditions，Predicates。</li>\n<li>引入findbugs:jsr305注解，@Immutable，@Nonnull注解，提高可读性和设计意图。</li>\n</ol>\n<h4 id=\"缺点：\"><a href=\"#缺点：\" class=\"headerlink\" title=\"缺点：\"></a>缺点：</h4><ol>\n<li>官方issue较多，回复不及时，不是很活跃。</li>\n<li>SimpleTimeLimiter类在Guava中已经没有公开构造方法了，所以使用时候会报运行时错误。</li>\n<li>虽然叫guava-retry，但是实际不是google维护的代码。</li>\n<li>单元测试不全面，有些类没有测试。</li>\n<li>代码检测不如apache标准项目多，比如pmd，checkstyle等检测。</li>\n<li>由于是个人项目，工程规范方面可借鉴的较少。</li>\n</ol>\n"},{"title":"动态代理Proxy的设计与实现","date":"2020-11-21T13:59:46.000Z","_content":"\n\n\n# 序言\n\nJava动态代理实现是基于反射和动态生成Class文件的技术，Proxy，InvocationHandler，Method是三个核心类，Proxy是代理类的入口，用来获取代理类，创建代理实例，获取InvocationHandler，判断某个类是否是代理类，InvocationHandler是方法调用的拦截，invoke方法是接口唯一方法，Method是反射的方法，用来完成方法调用。\n\n\n\n# 案例看行为\n\n我们先通过一个Person案例来看动态代理生成的代理类的模样。\n\n```java\n//公共接口\ninterface Person {\n    String getName();\n    void setName(String name);\n}\n//公共接口实现\nclass PersonImpl implements Person {\n    private String name;\n    @Override\n    public String getName() { return name; }\n    @Override\n    public void setName(String name) { this.name = name; }\n}\n//调用处理器\nclass MyInvocationHandler implements InvocationHandler {\n    private Person person;\n    public MyInvocationHandler(Person person) {\n        this.person = person;\n    }\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        System.out.println(\"before invoke\");\n        Object invoke = method.invoke(person, args);\n        System.out.println(\"after invoke\");\n        return invoke;\n    }\n}\npublic class PersonProxy {\n    public static void main(String[] args) {\n        //生成动态代理类文件\n        System.getProperties().put(\"jdk.proxy.ProxyGenerator.saveGeneratedFiles\", \"true\");\n        //通过Proxy.newProxyInstance创建动态代理类，并且转型成Person。Person本质是$Proxy0代理类。\n        Person person = (Person) Proxy.newProxyInstance(\n                Person.class.getClassLoader(), //类加载器\n                new Class[]{Person.class},  //接口\n                new MyInvocationHandler(new PersonImpl())  //调用处理器\n        );\n        person.setName(\"lili\");//动态代理类调用setName\n        System.out.println(person.getName());//动态代理类调用getName\n    }\n}\n```\n\n\n\n我们可以看下生成的$Proxy0类，该类是真正的代理类。分析可知：该类是final说明不可被子类化，并且继承Proxy的构造函数，这也就是Proxy构造函数为什么是protect的原因，同时实现了Person接口，说明代理类可以转型为Person，从而可以调用Person方法产生代理行为，在方法层面，所有的方法都是final方法。在$Proxy0 m0，m1，m2始终为hashCode，equals，toString方法，而m3，m4 ...... 为目标接口的方法，我们可以看到当$Proxy0调用setName时候，实质调用了h.invoke(this, m4, new Object[]{var1})方法，也就是我们自定义的MyInvocationHandler#invoke方法，从而产生代理行为。\n\n```java\npublic final class $Proxy0 extends Proxy implements Person {\n    private static Method m0;//hashCode\n    private static Method m1;//equals\n    private static Method m2;//toString\n    private static Method m3;//getName\n    private static Method m4;//setName\n    //继承Proxy构造方法\n    public $Proxy0(InvocationHandler param1) {\n        super(var1);\n    }\n\n    public final int hashCode() {\n         return (Integer)super.h.invoke(this, m0, (Object[])null);\n    }\n\n    public final boolean equals(Object var1) {\n        return (Boolean)super.h.invoke(this, m1, new Object[]{var1});\n    }\n\n    public final String toString() {\n        return (String)super.h.invoke(this, m2, (Object[])null);\n    }\n\n    public final String getName() {\n        return (String)super.h.invoke(this, m3, (Object[])null);\n    }\n\n    public final void setName(String var1) {\n         super.h.invoke(this, m4, new Object[]{var1});\n    }\n\t//获取到method对象\n    static {      \n        m0 = Class.forName(\"java.lang.Object\").getMethod(\"hashCode\");\n        m1 = Class.forName(\"java.lang.Object\").getMethod(\"equals\", Class.forName(\"java.lang.Object\"));\n        m2 = Class.forName(\"java.lang.Object\").getMethod(\"toString\");\n        m3 = Class.forName(\"org.lili.jdk.lang.reflect.Person\").getMethod(\"getName\");\n        m4 = Class.forName(\"org.lili.jdk.lang.reflect.Person\").getMethod(\"setName\", Class.forName(\"java.lang.String\"));\n    }\n}\n```\n\n\n\n# 结构\n\n通过案例，我们可以勾画出动态代理的结构\n\n![](/images/Proxy.png)\n\n$Proxy0作为Proxy，Person作为Subject，而PersonImpl作为RealSubject是和设计模式代理模式一模一样。\n\n![](/images/GOF-Proxy.png)\n\n\n\n# 实现\n\n","source":"_posts/Dynamic-Proxy.md","raw":"---\ntitle: 动态代理Proxy的设计与实现\ndate: 2020-11-21 21:59:46\ntags: \n  - java.lang.reflect\n  - Java-Core\ncategories:\n  - JDK源码\n  - Java核心\n---\n\n\n\n# 序言\n\nJava动态代理实现是基于反射和动态生成Class文件的技术，Proxy，InvocationHandler，Method是三个核心类，Proxy是代理类的入口，用来获取代理类，创建代理实例，获取InvocationHandler，判断某个类是否是代理类，InvocationHandler是方法调用的拦截，invoke方法是接口唯一方法，Method是反射的方法，用来完成方法调用。\n\n\n\n# 案例看行为\n\n我们先通过一个Person案例来看动态代理生成的代理类的模样。\n\n```java\n//公共接口\ninterface Person {\n    String getName();\n    void setName(String name);\n}\n//公共接口实现\nclass PersonImpl implements Person {\n    private String name;\n    @Override\n    public String getName() { return name; }\n    @Override\n    public void setName(String name) { this.name = name; }\n}\n//调用处理器\nclass MyInvocationHandler implements InvocationHandler {\n    private Person person;\n    public MyInvocationHandler(Person person) {\n        this.person = person;\n    }\n    @Override\n    public Object invoke(Object proxy, Method method, Object[] args) throws Throwable {\n        System.out.println(\"before invoke\");\n        Object invoke = method.invoke(person, args);\n        System.out.println(\"after invoke\");\n        return invoke;\n    }\n}\npublic class PersonProxy {\n    public static void main(String[] args) {\n        //生成动态代理类文件\n        System.getProperties().put(\"jdk.proxy.ProxyGenerator.saveGeneratedFiles\", \"true\");\n        //通过Proxy.newProxyInstance创建动态代理类，并且转型成Person。Person本质是$Proxy0代理类。\n        Person person = (Person) Proxy.newProxyInstance(\n                Person.class.getClassLoader(), //类加载器\n                new Class[]{Person.class},  //接口\n                new MyInvocationHandler(new PersonImpl())  //调用处理器\n        );\n        person.setName(\"lili\");//动态代理类调用setName\n        System.out.println(person.getName());//动态代理类调用getName\n    }\n}\n```\n\n\n\n我们可以看下生成的$Proxy0类，该类是真正的代理类。分析可知：该类是final说明不可被子类化，并且继承Proxy的构造函数，这也就是Proxy构造函数为什么是protect的原因，同时实现了Person接口，说明代理类可以转型为Person，从而可以调用Person方法产生代理行为，在方法层面，所有的方法都是final方法。在$Proxy0 m0，m1，m2始终为hashCode，equals，toString方法，而m3，m4 ...... 为目标接口的方法，我们可以看到当$Proxy0调用setName时候，实质调用了h.invoke(this, m4, new Object[]{var1})方法，也就是我们自定义的MyInvocationHandler#invoke方法，从而产生代理行为。\n\n```java\npublic final class $Proxy0 extends Proxy implements Person {\n    private static Method m0;//hashCode\n    private static Method m1;//equals\n    private static Method m2;//toString\n    private static Method m3;//getName\n    private static Method m4;//setName\n    //继承Proxy构造方法\n    public $Proxy0(InvocationHandler param1) {\n        super(var1);\n    }\n\n    public final int hashCode() {\n         return (Integer)super.h.invoke(this, m0, (Object[])null);\n    }\n\n    public final boolean equals(Object var1) {\n        return (Boolean)super.h.invoke(this, m1, new Object[]{var1});\n    }\n\n    public final String toString() {\n        return (String)super.h.invoke(this, m2, (Object[])null);\n    }\n\n    public final String getName() {\n        return (String)super.h.invoke(this, m3, (Object[])null);\n    }\n\n    public final void setName(String var1) {\n         super.h.invoke(this, m4, new Object[]{var1});\n    }\n\t//获取到method对象\n    static {      \n        m0 = Class.forName(\"java.lang.Object\").getMethod(\"hashCode\");\n        m1 = Class.forName(\"java.lang.Object\").getMethod(\"equals\", Class.forName(\"java.lang.Object\"));\n        m2 = Class.forName(\"java.lang.Object\").getMethod(\"toString\");\n        m3 = Class.forName(\"org.lili.jdk.lang.reflect.Person\").getMethod(\"getName\");\n        m4 = Class.forName(\"org.lili.jdk.lang.reflect.Person\").getMethod(\"setName\", Class.forName(\"java.lang.String\"));\n    }\n}\n```\n\n\n\n# 结构\n\n通过案例，我们可以勾画出动态代理的结构\n\n![](/images/Proxy.png)\n\n$Proxy0作为Proxy，Person作为Subject，而PersonImpl作为RealSubject是和设计模式代理模式一模一样。\n\n![](/images/GOF-Proxy.png)\n\n\n\n# 实现\n\n","slug":"Dynamic-Proxy","published":1,"updated":"2022-06-28T17:23:20.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clh7s5ctx001axt8jhx4ic87y","content":"<h1 id=\"序言\"><a href=\"#序言\" class=\"headerlink\" title=\"序言\"></a>序言</h1><p>Java动态代理实现是基于反射和动态生成Class文件的技术，Proxy，InvocationHandler，Method是三个核心类，Proxy是代理类的入口，用来获取代理类，创建代理实例，获取InvocationHandler，判断某个类是否是代理类，InvocationHandler是方法调用的拦截，invoke方法是接口唯一方法，Method是反射的方法，用来完成方法调用。</p>\n<h1 id=\"案例看行为\"><a href=\"#案例看行为\" class=\"headerlink\" title=\"案例看行为\"></a>案例看行为</h1><p>我们先通过一个Person案例来看动态代理生成的代理类的模样。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//公共接口</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">getName</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//公共接口实现</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PersonImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> name; &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123; <span class=\"keyword\">this</span>.name = name; &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//调用处理器</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyInvocationHandler</span> <span class=\"keyword\">implements</span> <span class=\"title\">InvocationHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Person person;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyInvocationHandler</span><span class=\"params\">(Person person)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.person = person;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"before invoke\"</span>);</span><br><span class=\"line\">        Object invoke = method.invoke(person, args);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"after invoke\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> invoke;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PersonProxy</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//生成动态代理类文件</span></span><br><span class=\"line\">        System.getProperties().put(<span class=\"string\">\"jdk.proxy.ProxyGenerator.saveGeneratedFiles\"</span>, <span class=\"string\">\"true\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">//通过Proxy.newProxyInstance创建动态代理类，并且转型成Person。Person本质是$Proxy0代理类。</span></span><br><span class=\"line\">        Person person = (Person) Proxy.newProxyInstance(</span><br><span class=\"line\">                Person<span class=\"class\">.<span class=\"keyword\">class</span>.<span class=\"title\">getClassLoader</span>(), //类加载器</span></span><br><span class=\"line\">                new Class[]&#123;Person.class&#125;,  //接口</span><br><span class=\"line\">                <span class=\"keyword\">new</span> MyInvocationHandler(<span class=\"keyword\">new</span> PersonImpl())  <span class=\"comment\">//调用处理器</span></span><br><span class=\"line\">        );</span><br><span class=\"line\">        person.setName(<span class=\"string\">\"lili\"</span>);<span class=\"comment\">//动态代理类调用setName</span></span><br><span class=\"line\">        System.out.println(person.getName());<span class=\"comment\">//动态代理类调用getName</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>我们可以看下生成的$Proxy0类，该类是真正的代理类。分析可知：该类是final说明不可被子类化，并且继承Proxy的构造函数，这也就是Proxy构造函数为什么是protect的原因，同时实现了Person接口，说明代理类可以转型为Person，从而可以调用Person方法产生代理行为，在方法层面，所有的方法都是final方法。在$Proxy0 m0，m1，m2始终为hashCode，equals，toString方法，而m3，m4 …… 为目标接口的方法，我们可以看到当$Proxy0调用setName时候，实质调用了h.invoke(this, m4, new Object[]{var1})方法，也就是我们自定义的MyInvocationHandler#invoke方法，从而产生代理行为。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> $<span class=\"title\">Proxy0</span> <span class=\"keyword\">extends</span> <span class=\"title\">Proxy</span> <span class=\"keyword\">implements</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Method m0;<span class=\"comment\">//hashCode</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Method m1;<span class=\"comment\">//equals</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Method m2;<span class=\"comment\">//toString</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Method m3;<span class=\"comment\">//getName</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Method m4;<span class=\"comment\">//setName</span></span><br><span class=\"line\">    <span class=\"comment\">//继承Proxy构造方法</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> $Proxy0(InvocationHandler param1) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(var1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> (Integer)<span class=\"keyword\">super</span>.h.invoke(<span class=\"keyword\">this</span>, m0, (Object[])<span class=\"keyword\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object var1)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (Boolean)<span class=\"keyword\">super</span>.h.invoke(<span class=\"keyword\">this</span>, m1, <span class=\"keyword\">new</span> Object[]&#123;var1&#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (String)<span class=\"keyword\">super</span>.h.invoke(<span class=\"keyword\">this</span>, m2, (Object[])<span class=\"keyword\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (String)<span class=\"keyword\">super</span>.h.invoke(<span class=\"keyword\">this</span>, m3, (Object[])<span class=\"keyword\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String var1)</span> </span>&#123;</span><br><span class=\"line\">         <span class=\"keyword\">super</span>.h.invoke(<span class=\"keyword\">this</span>, m4, <span class=\"keyword\">new</span> Object[]&#123;var1&#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"comment\">//获取到method对象</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;      </span><br><span class=\"line\">        m0 = Class.forName(<span class=\"string\">\"java.lang.Object\"</span>).getMethod(<span class=\"string\">\"hashCode\"</span>);</span><br><span class=\"line\">        m1 = Class.forName(<span class=\"string\">\"java.lang.Object\"</span>).getMethod(<span class=\"string\">\"equals\"</span>, Class.forName(<span class=\"string\">\"java.lang.Object\"</span>));</span><br><span class=\"line\">        m2 = Class.forName(<span class=\"string\">\"java.lang.Object\"</span>).getMethod(<span class=\"string\">\"toString\"</span>);</span><br><span class=\"line\">        m3 = Class.forName(<span class=\"string\">\"org.lili.jdk.lang.reflect.Person\"</span>).getMethod(<span class=\"string\">\"getName\"</span>);</span><br><span class=\"line\">        m4 = Class.forName(<span class=\"string\">\"org.lili.jdk.lang.reflect.Person\"</span>).getMethod(<span class=\"string\">\"setName\"</span>, Class.forName(<span class=\"string\">\"java.lang.String\"</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"结构\"><a href=\"#结构\" class=\"headerlink\" title=\"结构\"></a>结构</h1><p>通过案例，我们可以勾画出动态代理的结构</p>\n<p><img src=\"/images/Proxy.png\" alt=\"\"></p>\n<p>$Proxy0作为Proxy，Person作为Subject，而PersonImpl作为RealSubject是和设计模式代理模式一模一样。</p>\n<p><img src=\"/images/GOF-Proxy.png\" alt=\"\"></p>\n<h1 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h1>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"序言\"><a href=\"#序言\" class=\"headerlink\" title=\"序言\"></a>序言</h1><p>Java动态代理实现是基于反射和动态生成Class文件的技术，Proxy，InvocationHandler，Method是三个核心类，Proxy是代理类的入口，用来获取代理类，创建代理实例，获取InvocationHandler，判断某个类是否是代理类，InvocationHandler是方法调用的拦截，invoke方法是接口唯一方法，Method是反射的方法，用来完成方法调用。</p>\n<h1 id=\"案例看行为\"><a href=\"#案例看行为\" class=\"headerlink\" title=\"案例看行为\"></a>案例看行为</h1><p>我们先通过一个Person案例来看动态代理生成的代理类的模样。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br><span class=\"line\">41</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//公共接口</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">String <span class=\"title\">getName</span><span class=\"params\">()</span></span>;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span></span>;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//公共接口实现</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PersonImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> String name;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123; <span class=\"keyword\">return</span> name; &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String name)</span> </span>&#123; <span class=\"keyword\">this</span>.name = name; &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"comment\">//调用处理器</span></span><br><span class=\"line\"><span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">MyInvocationHandler</span> <span class=\"keyword\">implements</span> <span class=\"title\">InvocationHandler</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Person person;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"title\">MyInvocationHandler</span><span class=\"params\">(Person person)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.person = person;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    <span class=\"meta\">@Override</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> Object <span class=\"title\">invoke</span><span class=\"params\">(Object proxy, Method method, Object[] args)</span> <span class=\"keyword\">throws</span> Throwable </span>&#123;</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"before invoke\"</span>);</span><br><span class=\"line\">        Object invoke = method.invoke(person, args);</span><br><span class=\"line\">        System.out.println(<span class=\"string\">\"after invoke\"</span>);</span><br><span class=\"line\">        <span class=\"keyword\">return</span> invoke;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">PersonProxy</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">main</span><span class=\"params\">(String[] args)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//生成动态代理类文件</span></span><br><span class=\"line\">        System.getProperties().put(<span class=\"string\">\"jdk.proxy.ProxyGenerator.saveGeneratedFiles\"</span>, <span class=\"string\">\"true\"</span>);</span><br><span class=\"line\">        <span class=\"comment\">//通过Proxy.newProxyInstance创建动态代理类，并且转型成Person。Person本质是$Proxy0代理类。</span></span><br><span class=\"line\">        Person person = (Person) Proxy.newProxyInstance(</span><br><span class=\"line\">                Person<span class=\"class\">.<span class=\"keyword\">class</span>.<span class=\"title\">getClassLoader</span>(), //类加载器</span></span><br><span class=\"line\">                new Class[]&#123;Person.class&#125;,  //接口</span><br><span class=\"line\">                <span class=\"keyword\">new</span> MyInvocationHandler(<span class=\"keyword\">new</span> PersonImpl())  <span class=\"comment\">//调用处理器</span></span><br><span class=\"line\">        );</span><br><span class=\"line\">        person.setName(<span class=\"string\">\"lili\"</span>);<span class=\"comment\">//动态代理类调用setName</span></span><br><span class=\"line\">        System.out.println(person.getName());<span class=\"comment\">//动态代理类调用getName</span></span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>我们可以看下生成的$Proxy0类，该类是真正的代理类。分析可知：该类是final说明不可被子类化，并且继承Proxy的构造函数，这也就是Proxy构造函数为什么是protect的原因，同时实现了Person接口，说明代理类可以转型为Person，从而可以调用Person方法产生代理行为，在方法层面，所有的方法都是final方法。在$Proxy0 m0，m1，m2始终为hashCode，equals，toString方法，而m3，m4 …… 为目标接口的方法，我们可以看到当$Proxy0调用setName时候，实质调用了h.invoke(this, m4, new Object[]{var1})方法，也就是我们自定义的MyInvocationHandler#invoke方法，从而产生代理行为。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"class\"><span class=\"keyword\">class</span> $<span class=\"title\">Proxy0</span> <span class=\"keyword\">extends</span> <span class=\"title\">Proxy</span> <span class=\"keyword\">implements</span> <span class=\"title\">Person</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Method m0;<span class=\"comment\">//hashCode</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Method m1;<span class=\"comment\">//equals</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Method m2;<span class=\"comment\">//toString</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Method m3;<span class=\"comment\">//getName</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> Method m4;<span class=\"comment\">//setName</span></span><br><span class=\"line\">    <span class=\"comment\">//继承Proxy构造方法</span></span><br><span class=\"line\">    <span class=\"keyword\">public</span> $Proxy0(InvocationHandler param1) &#123;</span><br><span class=\"line\">        <span class=\"keyword\">super</span>(var1);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">int</span> <span class=\"title\">hashCode</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">         <span class=\"keyword\">return</span> (Integer)<span class=\"keyword\">super</span>.h.invoke(<span class=\"keyword\">this</span>, m0, (Object[])<span class=\"keyword\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">boolean</span> <span class=\"title\">equals</span><span class=\"params\">(Object var1)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (Boolean)<span class=\"keyword\">super</span>.h.invoke(<span class=\"keyword\">this</span>, m1, <span class=\"keyword\">new</span> Object[]&#123;var1&#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> String <span class=\"title\">toString</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (String)<span class=\"keyword\">super</span>.h.invoke(<span class=\"keyword\">this</span>, m2, (Object[])<span class=\"keyword\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> String <span class=\"title\">getName</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> (String)<span class=\"keyword\">super</span>.h.invoke(<span class=\"keyword\">this</span>, m3, (Object[])<span class=\"keyword\">null</span>);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">final</span> <span class=\"keyword\">void</span> <span class=\"title\">setName</span><span class=\"params\">(String var1)</span> </span>&#123;</span><br><span class=\"line\">         <span class=\"keyword\">super</span>.h.invoke(<span class=\"keyword\">this</span>, m4, <span class=\"keyword\">new</span> Object[]&#123;var1&#125;);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">\t<span class=\"comment\">//获取到method对象</span></span><br><span class=\"line\">    <span class=\"keyword\">static</span> &#123;      </span><br><span class=\"line\">        m0 = Class.forName(<span class=\"string\">\"java.lang.Object\"</span>).getMethod(<span class=\"string\">\"hashCode\"</span>);</span><br><span class=\"line\">        m1 = Class.forName(<span class=\"string\">\"java.lang.Object\"</span>).getMethod(<span class=\"string\">\"equals\"</span>, Class.forName(<span class=\"string\">\"java.lang.Object\"</span>));</span><br><span class=\"line\">        m2 = Class.forName(<span class=\"string\">\"java.lang.Object\"</span>).getMethod(<span class=\"string\">\"toString\"</span>);</span><br><span class=\"line\">        m3 = Class.forName(<span class=\"string\">\"org.lili.jdk.lang.reflect.Person\"</span>).getMethod(<span class=\"string\">\"getName\"</span>);</span><br><span class=\"line\">        m4 = Class.forName(<span class=\"string\">\"org.lili.jdk.lang.reflect.Person\"</span>).getMethod(<span class=\"string\">\"setName\"</span>, Class.forName(<span class=\"string\">\"java.lang.String\"</span>));</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"结构\"><a href=\"#结构\" class=\"headerlink\" title=\"结构\"></a>结构</h1><p>通过案例，我们可以勾画出动态代理的结构</p>\n<p><img src=\"/images/Proxy.png\" alt=\"\"></p>\n<p>$Proxy0作为Proxy，Person作为Subject，而PersonImpl作为RealSubject是和设计模式代理模式一模一样。</p>\n<p><img src=\"/images/GOF-Proxy.png\" alt=\"\"></p>\n<h1 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h1>"},{"title":"elasticsearch(1)-集群,节点与分片，理解查找过程","date":"2021-08-28T18:33:46.000Z","_content":"\n# 单机多节点集群\n\n```\n./elasticsearch -E node.name=node0 -E cluster.name=geektime -E path.data=node0_data -d\n./elasticsearch -E node.name=node1 -E cluster.name=geektime -E path.data=node1_data -d\n./elasticsearch -E node.name=node2 -E cluster.name=geektime -E path.data=node2_data -d\n./elasticsearch -E node.name=node3 -E cluster.name=geektime -E path.data=node3_data -d\n```\n\n\n\n可以通过`GET /_cat/nodes?v`查看node0是主节点。\n\n\n\n# 创建索引与分片\n\nes在一个有4个节点的集群上创建一个索引，并且索引里面只包含了一个文档，那么这份文档的存储和节点分布是什么样呢？\n\n\n\n```\nDELETE test\nPUT test\n{\n  \"settings\": {\n    \"number_of_shards\": 3,\n    \"number_of_replicas\": 2\n  }\n}\n```\n\n实际在4个节点总共有9个分片，3个主分片，6个副本分片。\n\n\n\n```\nPOST test/_doc\n{\n  \"company\":\"baidu\"\n}\n```\n\n\n\n```\nGET test/_search\n{\n  \"profile\": \"true\", \n  \"query\": {\n    \"term\": {\n      \"company\": {\n        \"value\": \"baidu\"\n      }\n    }\n  }\n}\n```\n\n\n\n```\n查看索引在节点的分配\nGET /_cat/shards?v&index=test\n```\n\n显示结果如下：\n\n```\nindex shard prirep state   docs store ip        node\ntest  1     r      STARTED    0  230b 127.0.0.1 node2\ntest  1     p      STARTED    0  230b 127.0.0.1 node3\ntest  1     r      STARTED    0  230b 127.0.0.1 node0\ntest  2     r      STARTED    0  230b 127.0.0.1 node1\ntest  2     r      STARTED    0  230b 127.0.0.1 node2\ntest  2     p      STARTED    0  230b 127.0.0.1 node0\ntest  0     r      STARTED    1 3.4kb 127.0.0.1 node1\ntest  0     p      STARTED    1 3.4kb 127.0.0.1 node2\ntest  0     r      STARTED    1 3.4kb 127.0.0.1 node3\n```\n\n\n\n<img src=\"/images/shard-legend.png\"/>\n\n\n\n可以看到创建一个索引的时候，被分配到4个node，node0是主节点leader节点(图片有星号)，node2~node4是非leader节点。而company=baidu文档被创建时候，被分片到node1，node2，node3上面（docs=1），**每一个文档被分配到一个分片**，node2是primary shard，而node1，node3是replica shard. 而在搜索company=baidu时候，打开profile api，会发现数据查找经历了3个shard，分别是\n\n```\n\"id\" : \"[S_H7_aQZQT6N1Xvak3Y5Gg][test][1]\"\n\"id\" : \"[Y6x8KA6XQzaa4ebI2QKrZg][test][0]\"\n\"id\" : \"[Y6x8KA6XQzaa4ebI2QKrZg][test][2]\"\n```\n\n根据`GET /_nodes/_all/nodes` 可以获取到节点名字\n\n```\nnode0：uvCcgxEFT82xFtQAv9aydA\nnode1：Y6x8KA6XQzaa4ebI2QKrZg\nnode2：S_H7_aQZQT6N1Xvak3Y5Gg\nnode3：BdHl3TItTv6B4BHm1DuwMA\n```\n\n可以得知，查找company=baidu时候，一定会查找三个分片（也就是**number_of_shards**的个数，primary和replica都有可能），profile api显示经历了1次node2[1]和2次node1[0]，node1[2]，恰好查找了三个分片0,1,2。但是文档存储在node1[0]，node2[0]，node3[0]，所以数据最终在node1[0]分片(**replica shard**)上找到了要查找的文档，在node1[2]，node2[1]并没有找到文档。每次重新执行的查找的时候，profile api也会动态变化，查询的节点和分片也会随之变化。（疑问：如果有50个节点，一个索引创建了3个分片(number_of_shards=3)，那么怎么知道需要遍历分片在哪里呢？而不是所有节点遍历一遍，也就是es怎么知道遍历哪些节点呢？所以es一定存了分片和）\n\n\n\n# 索引常用DSL\n\n## 查看节点详情\n\n```\nGET /_nodes\n```\n\n\n\n## 查看索引映射和配置\n\n```\nGET test\n```\n\n\n\n## 查看索引大小\n\n```\nGET /_cat/indices?v&index=test\n```\n\n\n\n## 查看segment\n\n```\nGET /_cat/segments?v&index=test\n```\n\n","source":"_posts/elasticsearch-series1-common.md","raw":"---\ntitle: elasticsearch(1)-集群,节点与分片，理解查找过程\ndate: 2021-08-29 02:33:46\ntags: \n  - 分布式系统泛型\n  - elasticsearch\ncategories:\n  - 分布式系统\n  - 搜索\n  - elasticsearch\n---\n\n# 单机多节点集群\n\n```\n./elasticsearch -E node.name=node0 -E cluster.name=geektime -E path.data=node0_data -d\n./elasticsearch -E node.name=node1 -E cluster.name=geektime -E path.data=node1_data -d\n./elasticsearch -E node.name=node2 -E cluster.name=geektime -E path.data=node2_data -d\n./elasticsearch -E node.name=node3 -E cluster.name=geektime -E path.data=node3_data -d\n```\n\n\n\n可以通过`GET /_cat/nodes?v`查看node0是主节点。\n\n\n\n# 创建索引与分片\n\nes在一个有4个节点的集群上创建一个索引，并且索引里面只包含了一个文档，那么这份文档的存储和节点分布是什么样呢？\n\n\n\n```\nDELETE test\nPUT test\n{\n  \"settings\": {\n    \"number_of_shards\": 3,\n    \"number_of_replicas\": 2\n  }\n}\n```\n\n实际在4个节点总共有9个分片，3个主分片，6个副本分片。\n\n\n\n```\nPOST test/_doc\n{\n  \"company\":\"baidu\"\n}\n```\n\n\n\n```\nGET test/_search\n{\n  \"profile\": \"true\", \n  \"query\": {\n    \"term\": {\n      \"company\": {\n        \"value\": \"baidu\"\n      }\n    }\n  }\n}\n```\n\n\n\n```\n查看索引在节点的分配\nGET /_cat/shards?v&index=test\n```\n\n显示结果如下：\n\n```\nindex shard prirep state   docs store ip        node\ntest  1     r      STARTED    0  230b 127.0.0.1 node2\ntest  1     p      STARTED    0  230b 127.0.0.1 node3\ntest  1     r      STARTED    0  230b 127.0.0.1 node0\ntest  2     r      STARTED    0  230b 127.0.0.1 node1\ntest  2     r      STARTED    0  230b 127.0.0.1 node2\ntest  2     p      STARTED    0  230b 127.0.0.1 node0\ntest  0     r      STARTED    1 3.4kb 127.0.0.1 node1\ntest  0     p      STARTED    1 3.4kb 127.0.0.1 node2\ntest  0     r      STARTED    1 3.4kb 127.0.0.1 node3\n```\n\n\n\n<img src=\"/images/shard-legend.png\"/>\n\n\n\n可以看到创建一个索引的时候，被分配到4个node，node0是主节点leader节点(图片有星号)，node2~node4是非leader节点。而company=baidu文档被创建时候，被分片到node1，node2，node3上面（docs=1），**每一个文档被分配到一个分片**，node2是primary shard，而node1，node3是replica shard. 而在搜索company=baidu时候，打开profile api，会发现数据查找经历了3个shard，分别是\n\n```\n\"id\" : \"[S_H7_aQZQT6N1Xvak3Y5Gg][test][1]\"\n\"id\" : \"[Y6x8KA6XQzaa4ebI2QKrZg][test][0]\"\n\"id\" : \"[Y6x8KA6XQzaa4ebI2QKrZg][test][2]\"\n```\n\n根据`GET /_nodes/_all/nodes` 可以获取到节点名字\n\n```\nnode0：uvCcgxEFT82xFtQAv9aydA\nnode1：Y6x8KA6XQzaa4ebI2QKrZg\nnode2：S_H7_aQZQT6N1Xvak3Y5Gg\nnode3：BdHl3TItTv6B4BHm1DuwMA\n```\n\n可以得知，查找company=baidu时候，一定会查找三个分片（也就是**number_of_shards**的个数，primary和replica都有可能），profile api显示经历了1次node2[1]和2次node1[0]，node1[2]，恰好查找了三个分片0,1,2。但是文档存储在node1[0]，node2[0]，node3[0]，所以数据最终在node1[0]分片(**replica shard**)上找到了要查找的文档，在node1[2]，node2[1]并没有找到文档。每次重新执行的查找的时候，profile api也会动态变化，查询的节点和分片也会随之变化。（疑问：如果有50个节点，一个索引创建了3个分片(number_of_shards=3)，那么怎么知道需要遍历分片在哪里呢？而不是所有节点遍历一遍，也就是es怎么知道遍历哪些节点呢？所以es一定存了分片和）\n\n\n\n# 索引常用DSL\n\n## 查看节点详情\n\n```\nGET /_nodes\n```\n\n\n\n## 查看索引映射和配置\n\n```\nGET test\n```\n\n\n\n## 查看索引大小\n\n```\nGET /_cat/indices?v&index=test\n```\n\n\n\n## 查看segment\n\n```\nGET /_cat/segments?v&index=test\n```\n\n","slug":"elasticsearch-series1-common","published":1,"updated":"2021-08-29T07:28:44.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clh7s5cty001ext8jglv0he17","content":"<h1 id=\"单机多节点集群\"><a href=\"#单机多节点集群\" class=\"headerlink\" title=\"单机多节点集群\"></a>单机多节点集群</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.&#x2F;elasticsearch -E node.name&#x3D;node0 -E cluster.name&#x3D;geektime -E path.data&#x3D;node0_data -d</span><br><span class=\"line\">.&#x2F;elasticsearch -E node.name&#x3D;node1 -E cluster.name&#x3D;geektime -E path.data&#x3D;node1_data -d</span><br><span class=\"line\">.&#x2F;elasticsearch -E node.name&#x3D;node2 -E cluster.name&#x3D;geektime -E path.data&#x3D;node2_data -d</span><br><span class=\"line\">.&#x2F;elasticsearch -E node.name&#x3D;node3 -E cluster.name&#x3D;geektime -E path.data&#x3D;node3_data -d</span><br></pre></td></tr></table></figure>\n\n\n\n<p>可以通过<code>GET /_cat/nodes?v</code>查看node0是主节点。</p>\n<h1 id=\"创建索引与分片\"><a href=\"#创建索引与分片\" class=\"headerlink\" title=\"创建索引与分片\"></a>创建索引与分片</h1><p>es在一个有4个节点的集群上创建一个索引，并且索引里面只包含了一个文档，那么这份文档的存储和节点分布是什么样呢？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DELETE test</span><br><span class=\"line\">PUT test</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;settings&quot;: &#123;</span><br><span class=\"line\">    &quot;number_of_shards&quot;: 3,</span><br><span class=\"line\">    &quot;number_of_replicas&quot;: 2</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实际在4个节点总共有9个分片，3个主分片，6个副本分片。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">POST test&#x2F;_doc</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;company&quot;:&quot;baidu&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET test&#x2F;_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;profile&quot;: &quot;true&quot;, </span><br><span class=\"line\">  &quot;query&quot;: &#123;</span><br><span class=\"line\">    &quot;term&quot;: &#123;</span><br><span class=\"line\">      &quot;company&quot;: &#123;</span><br><span class=\"line\">        &quot;value&quot;: &quot;baidu&quot;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">查看索引在节点的分配</span><br><span class=\"line\">GET &#x2F;_cat&#x2F;shards?v&amp;index&#x3D;test</span><br></pre></td></tr></table></figure>\n\n<p>显示结果如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">index shard prirep state   docs store ip        node</span><br><span class=\"line\">test  1     r      STARTED    0  230b 127.0.0.1 node2</span><br><span class=\"line\">test  1     p      STARTED    0  230b 127.0.0.1 node3</span><br><span class=\"line\">test  1     r      STARTED    0  230b 127.0.0.1 node0</span><br><span class=\"line\">test  2     r      STARTED    0  230b 127.0.0.1 node1</span><br><span class=\"line\">test  2     r      STARTED    0  230b 127.0.0.1 node2</span><br><span class=\"line\">test  2     p      STARTED    0  230b 127.0.0.1 node0</span><br><span class=\"line\">test  0     r      STARTED    1 3.4kb 127.0.0.1 node1</span><br><span class=\"line\">test  0     p      STARTED    1 3.4kb 127.0.0.1 node2</span><br><span class=\"line\">test  0     r      STARTED    1 3.4kb 127.0.0.1 node3</span><br></pre></td></tr></table></figure>\n\n\n\n<img src=\"/images/shard-legend.png\"/>\n\n\n\n<p>可以看到创建一个索引的时候，被分配到4个node，node0是主节点leader节点(图片有星号)，node2~node4是非leader节点。而company=baidu文档被创建时候，被分片到node1，node2，node3上面（docs=1），<strong>每一个文档被分配到一个分片</strong>，node2是primary shard，而node1，node3是replica shard. 而在搜索company=baidu时候，打开profile api，会发现数据查找经历了3个shard，分别是</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;id&quot; : &quot;[S_H7_aQZQT6N1Xvak3Y5Gg][test][1]&quot;</span><br><span class=\"line\">&quot;id&quot; : &quot;[Y6x8KA6XQzaa4ebI2QKrZg][test][0]&quot;</span><br><span class=\"line\">&quot;id&quot; : &quot;[Y6x8KA6XQzaa4ebI2QKrZg][test][2]&quot;</span><br></pre></td></tr></table></figure>\n\n<p>根据<code>GET /_nodes/_all/nodes</code> 可以获取到节点名字</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node0：uvCcgxEFT82xFtQAv9aydA</span><br><span class=\"line\">node1：Y6x8KA6XQzaa4ebI2QKrZg</span><br><span class=\"line\">node2：S_H7_aQZQT6N1Xvak3Y5Gg</span><br><span class=\"line\">node3：BdHl3TItTv6B4BHm1DuwMA</span><br></pre></td></tr></table></figure>\n\n<p>可以得知，查找company=baidu时候，一定会查找三个分片（也就是<strong>number_of_shards</strong>的个数，primary和replica都有可能），profile api显示经历了1次node2[1]和2次node1[0]，node1[2]，恰好查找了三个分片0,1,2。但是文档存储在node1[0]，node2[0]，node3[0]，所以数据最终在node1[0]分片(<strong>replica shard</strong>)上找到了要查找的文档，在node1[2]，node2[1]并没有找到文档。每次重新执行的查找的时候，profile api也会动态变化，查询的节点和分片也会随之变化。（疑问：如果有50个节点，一个索引创建了3个分片(number_of_shards=3)，那么怎么知道需要遍历分片在哪里呢？而不是所有节点遍历一遍，也就是es怎么知道遍历哪些节点呢？所以es一定存了分片和）</p>\n<h1 id=\"索引常用DSL\"><a href=\"#索引常用DSL\" class=\"headerlink\" title=\"索引常用DSL\"></a>索引常用DSL</h1><h2 id=\"查看节点详情\"><a href=\"#查看节点详情\" class=\"headerlink\" title=\"查看节点详情\"></a>查看节点详情</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET &#x2F;_nodes</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"查看索引映射和配置\"><a href=\"#查看索引映射和配置\" class=\"headerlink\" title=\"查看索引映射和配置\"></a>查看索引映射和配置</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET test</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"查看索引大小\"><a href=\"#查看索引大小\" class=\"headerlink\" title=\"查看索引大小\"></a>查看索引大小</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET &#x2F;_cat&#x2F;indices?v&amp;index&#x3D;test</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"查看segment\"><a href=\"#查看segment\" class=\"headerlink\" title=\"查看segment\"></a>查看segment</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET &#x2F;_cat&#x2F;segments?v&amp;index&#x3D;test</span><br></pre></td></tr></table></figure>\n\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"单机多节点集群\"><a href=\"#单机多节点集群\" class=\"headerlink\" title=\"单机多节点集群\"></a>单机多节点集群</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">.&#x2F;elasticsearch -E node.name&#x3D;node0 -E cluster.name&#x3D;geektime -E path.data&#x3D;node0_data -d</span><br><span class=\"line\">.&#x2F;elasticsearch -E node.name&#x3D;node1 -E cluster.name&#x3D;geektime -E path.data&#x3D;node1_data -d</span><br><span class=\"line\">.&#x2F;elasticsearch -E node.name&#x3D;node2 -E cluster.name&#x3D;geektime -E path.data&#x3D;node2_data -d</span><br><span class=\"line\">.&#x2F;elasticsearch -E node.name&#x3D;node3 -E cluster.name&#x3D;geektime -E path.data&#x3D;node3_data -d</span><br></pre></td></tr></table></figure>\n\n\n\n<p>可以通过<code>GET /_cat/nodes?v</code>查看node0是主节点。</p>\n<h1 id=\"创建索引与分片\"><a href=\"#创建索引与分片\" class=\"headerlink\" title=\"创建索引与分片\"></a>创建索引与分片</h1><p>es在一个有4个节点的集群上创建一个索引，并且索引里面只包含了一个文档，那么这份文档的存储和节点分布是什么样呢？</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DELETE test</span><br><span class=\"line\">PUT test</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;settings&quot;: &#123;</span><br><span class=\"line\">    &quot;number_of_shards&quot;: 3,</span><br><span class=\"line\">    &quot;number_of_replicas&quot;: 2</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>实际在4个节点总共有9个分片，3个主分片，6个副本分片。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">POST test&#x2F;_doc</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;company&quot;:&quot;baidu&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET test&#x2F;_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;profile&quot;: &quot;true&quot;, </span><br><span class=\"line\">  &quot;query&quot;: &#123;</span><br><span class=\"line\">    &quot;term&quot;: &#123;</span><br><span class=\"line\">      &quot;company&quot;: &#123;</span><br><span class=\"line\">        &quot;value&quot;: &quot;baidu&quot;</span><br><span class=\"line\">      &#125;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">查看索引在节点的分配</span><br><span class=\"line\">GET &#x2F;_cat&#x2F;shards?v&amp;index&#x3D;test</span><br></pre></td></tr></table></figure>\n\n<p>显示结果如下：</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">index shard prirep state   docs store ip        node</span><br><span class=\"line\">test  1     r      STARTED    0  230b 127.0.0.1 node2</span><br><span class=\"line\">test  1     p      STARTED    0  230b 127.0.0.1 node3</span><br><span class=\"line\">test  1     r      STARTED    0  230b 127.0.0.1 node0</span><br><span class=\"line\">test  2     r      STARTED    0  230b 127.0.0.1 node1</span><br><span class=\"line\">test  2     r      STARTED    0  230b 127.0.0.1 node2</span><br><span class=\"line\">test  2     p      STARTED    0  230b 127.0.0.1 node0</span><br><span class=\"line\">test  0     r      STARTED    1 3.4kb 127.0.0.1 node1</span><br><span class=\"line\">test  0     p      STARTED    1 3.4kb 127.0.0.1 node2</span><br><span class=\"line\">test  0     r      STARTED    1 3.4kb 127.0.0.1 node3</span><br></pre></td></tr></table></figure>\n\n\n\n<img src=\"/images/shard-legend.png\"/>\n\n\n\n<p>可以看到创建一个索引的时候，被分配到4个node，node0是主节点leader节点(图片有星号)，node2~node4是非leader节点。而company=baidu文档被创建时候，被分片到node1，node2，node3上面（docs=1），<strong>每一个文档被分配到一个分片</strong>，node2是primary shard，而node1，node3是replica shard. 而在搜索company=baidu时候，打开profile api，会发现数据查找经历了3个shard，分别是</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">&quot;id&quot; : &quot;[S_H7_aQZQT6N1Xvak3Y5Gg][test][1]&quot;</span><br><span class=\"line\">&quot;id&quot; : &quot;[Y6x8KA6XQzaa4ebI2QKrZg][test][0]&quot;</span><br><span class=\"line\">&quot;id&quot; : &quot;[Y6x8KA6XQzaa4ebI2QKrZg][test][2]&quot;</span><br></pre></td></tr></table></figure>\n\n<p>根据<code>GET /_nodes/_all/nodes</code> 可以获取到节点名字</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">node0：uvCcgxEFT82xFtQAv9aydA</span><br><span class=\"line\">node1：Y6x8KA6XQzaa4ebI2QKrZg</span><br><span class=\"line\">node2：S_H7_aQZQT6N1Xvak3Y5Gg</span><br><span class=\"line\">node3：BdHl3TItTv6B4BHm1DuwMA</span><br></pre></td></tr></table></figure>\n\n<p>可以得知，查找company=baidu时候，一定会查找三个分片（也就是<strong>number_of_shards</strong>的个数，primary和replica都有可能），profile api显示经历了1次node2[1]和2次node1[0]，node1[2]，恰好查找了三个分片0,1,2。但是文档存储在node1[0]，node2[0]，node3[0]，所以数据最终在node1[0]分片(<strong>replica shard</strong>)上找到了要查找的文档，在node1[2]，node2[1]并没有找到文档。每次重新执行的查找的时候，profile api也会动态变化，查询的节点和分片也会随之变化。（疑问：如果有50个节点，一个索引创建了3个分片(number_of_shards=3)，那么怎么知道需要遍历分片在哪里呢？而不是所有节点遍历一遍，也就是es怎么知道遍历哪些节点呢？所以es一定存了分片和）</p>\n<h1 id=\"索引常用DSL\"><a href=\"#索引常用DSL\" class=\"headerlink\" title=\"索引常用DSL\"></a>索引常用DSL</h1><h2 id=\"查看节点详情\"><a href=\"#查看节点详情\" class=\"headerlink\" title=\"查看节点详情\"></a>查看节点详情</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET &#x2F;_nodes</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"查看索引映射和配置\"><a href=\"#查看索引映射和配置\" class=\"headerlink\" title=\"查看索引映射和配置\"></a>查看索引映射和配置</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET test</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"查看索引大小\"><a href=\"#查看索引大小\" class=\"headerlink\" title=\"查看索引大小\"></a>查看索引大小</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET &#x2F;_cat&#x2F;indices?v&amp;index&#x3D;test</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"查看segment\"><a href=\"#查看segment\" class=\"headerlink\" title=\"查看segment\"></a>查看segment</h2><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">GET &#x2F;_cat&#x2F;segments?v&amp;index&#x3D;test</span><br></pre></td></tr></table></figure>\n\n"},{"title":"分布式事务解决方案","date":"2022-01-01T13:44:31.000Z","_content":"\n\n\n\n\n# 前言\n\n分布式事务划分为两个角度，1是存储层，也即数据库角度的分布式事务，多实现于分布式数据库事务 2是业务层，偏向于服务化系统以及业务系统的分布式事务。\n\n\n\n# 存储层\n\n[spanner](https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/spanner-osdi2012.pdf)，[XA](https://en.wikipedia.org/wiki/X/Open_XA)([2pc](https://en.wikipedia.org/wiki/Two-phase_commit_protocol))，，[3pc](https://en.wikipedia.org/wiki/Three-phase_commit_protocol)，[percolator](https://storage.googleapis.com/pub-tools-public-publication-data/pdf/36726.pdf)(2pc)，[calvin](http://cs.yale.edu/homes/thomson/publications/calvin-sigmod12.pdf)，[apache omid](https://omid.incubator.apache.org/)\n\n\n\n| 模型       | 数据模型  | 并发控制方案          | 隔离级别支持 | 限制                 |\n| ---------- | --------- | --------------------- | ------------ | -------------------- |\n| XA         | 不限      | 两阶段锁（悲观）      | 所有隔离级别 | 加读锁导致性能下降   |\n| Percolator | Key-Value | 加锁(悲观) & MVCC     | SI           |                      |\n| Omid       | Key-Value | 冲突检测(乐观) & MVCC | SI           |                      |\n| Calvin     | 不限      | 确定性数据库          | Serializable | 仅适用于One-Shot事务 |\n\n\n\n\n\n# 业务层\n\n解决思路有：XA(异构系统)，TCC，Saga，基于本地消息的分布式事务，基于事务消息的分布式事务\n\n具体的产品有：seata， hmily， byetcc， easytransaction,XA-JTA(atomikos,bitronix,narayana) ,JOTM, BTM, MSDTC\n\n\n\n## 同构与异构系统\n\n同构：MySQL Cluster NDB，VoltDB\n\n异构：MySQL和MQ，MySQL和Redis\n","source":"_posts/distributed-transaction.md","raw":"---\ntitle: 分布式事务解决方案\ndate: 2022-01-01 21:44:31\ntags: \n  - 分布式事务\ncategories:\n  - 分布式系统\n---\n\n\n\n\n\n# 前言\n\n分布式事务划分为两个角度，1是存储层，也即数据库角度的分布式事务，多实现于分布式数据库事务 2是业务层，偏向于服务化系统以及业务系统的分布式事务。\n\n\n\n# 存储层\n\n[spanner](https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/spanner-osdi2012.pdf)，[XA](https://en.wikipedia.org/wiki/X/Open_XA)([2pc](https://en.wikipedia.org/wiki/Two-phase_commit_protocol))，，[3pc](https://en.wikipedia.org/wiki/Three-phase_commit_protocol)，[percolator](https://storage.googleapis.com/pub-tools-public-publication-data/pdf/36726.pdf)(2pc)，[calvin](http://cs.yale.edu/homes/thomson/publications/calvin-sigmod12.pdf)，[apache omid](https://omid.incubator.apache.org/)\n\n\n\n| 模型       | 数据模型  | 并发控制方案          | 隔离级别支持 | 限制                 |\n| ---------- | --------- | --------------------- | ------------ | -------------------- |\n| XA         | 不限      | 两阶段锁（悲观）      | 所有隔离级别 | 加读锁导致性能下降   |\n| Percolator | Key-Value | 加锁(悲观) & MVCC     | SI           |                      |\n| Omid       | Key-Value | 冲突检测(乐观) & MVCC | SI           |                      |\n| Calvin     | 不限      | 确定性数据库          | Serializable | 仅适用于One-Shot事务 |\n\n\n\n\n\n# 业务层\n\n解决思路有：XA(异构系统)，TCC，Saga，基于本地消息的分布式事务，基于事务消息的分布式事务\n\n具体的产品有：seata， hmily， byetcc， easytransaction,XA-JTA(atomikos,bitronix,narayana) ,JOTM, BTM, MSDTC\n\n\n\n## 同构与异构系统\n\n同构：MySQL Cluster NDB，VoltDB\n\n异构：MySQL和MQ，MySQL和Redis\n","slug":"distributed-transaction","published":1,"updated":"2022-01-09T12:44:48.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clh7s5ctz001gxt8jcvt49bcb","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>分布式事务划分为两个角度，1是存储层，也即数据库角度的分布式事务，多实现于分布式数据库事务 2是业务层，偏向于服务化系统以及业务系统的分布式事务。</p>\n<h1 id=\"存储层\"><a href=\"#存储层\" class=\"headerlink\" title=\"存储层\"></a>存储层</h1><p><a href=\"https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/spanner-osdi2012.pdf\" target=\"_blank\" rel=\"noopener\">spanner</a>，<a href=\"https://en.wikipedia.org/wiki/X/Open_XA\" target=\"_blank\" rel=\"noopener\">XA</a>(<a href=\"https://en.wikipedia.org/wiki/Two-phase_commit_protocol\" target=\"_blank\" rel=\"noopener\">2pc</a>)，，<a href=\"https://en.wikipedia.org/wiki/Three-phase_commit_protocol\" target=\"_blank\" rel=\"noopener\">3pc</a>，<a href=\"https://storage.googleapis.com/pub-tools-public-publication-data/pdf/36726.pdf\" target=\"_blank\" rel=\"noopener\">percolator</a>(2pc)，<a href=\"http://cs.yale.edu/homes/thomson/publications/calvin-sigmod12.pdf\" target=\"_blank\" rel=\"noopener\">calvin</a>，<a href=\"https://omid.incubator.apache.org/\" target=\"_blank\" rel=\"noopener\">apache omid</a></p>\n<table>\n<thead>\n<tr>\n<th>模型</th>\n<th>数据模型</th>\n<th>并发控制方案</th>\n<th>隔离级别支持</th>\n<th>限制</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>XA</td>\n<td>不限</td>\n<td>两阶段锁（悲观）</td>\n<td>所有隔离级别</td>\n<td>加读锁导致性能下降</td>\n</tr>\n<tr>\n<td>Percolator</td>\n<td>Key-Value</td>\n<td>加锁(悲观) &amp; MVCC</td>\n<td>SI</td>\n<td></td>\n</tr>\n<tr>\n<td>Omid</td>\n<td>Key-Value</td>\n<td>冲突检测(乐观) &amp; MVCC</td>\n<td>SI</td>\n<td></td>\n</tr>\n<tr>\n<td>Calvin</td>\n<td>不限</td>\n<td>确定性数据库</td>\n<td>Serializable</td>\n<td>仅适用于One-Shot事务</td>\n</tr>\n</tbody></table>\n<h1 id=\"业务层\"><a href=\"#业务层\" class=\"headerlink\" title=\"业务层\"></a>业务层</h1><p>解决思路有：XA(异构系统)，TCC，Saga，基于本地消息的分布式事务，基于事务消息的分布式事务</p>\n<p>具体的产品有：seata， hmily， byetcc， easytransaction,XA-JTA(atomikos,bitronix,narayana) ,JOTM, BTM, MSDTC</p>\n<h2 id=\"同构与异构系统\"><a href=\"#同构与异构系统\" class=\"headerlink\" title=\"同构与异构系统\"></a>同构与异构系统</h2><p>同构：MySQL Cluster NDB，VoltDB</p>\n<p>异构：MySQL和MQ，MySQL和Redis</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>分布式事务划分为两个角度，1是存储层，也即数据库角度的分布式事务，多实现于分布式数据库事务 2是业务层，偏向于服务化系统以及业务系统的分布式事务。</p>\n<h1 id=\"存储层\"><a href=\"#存储层\" class=\"headerlink\" title=\"存储层\"></a>存储层</h1><p><a href=\"https://static.googleusercontent.com/media/research.google.com/zh-CN//archive/spanner-osdi2012.pdf\" target=\"_blank\" rel=\"noopener\">spanner</a>，<a href=\"https://en.wikipedia.org/wiki/X/Open_XA\" target=\"_blank\" rel=\"noopener\">XA</a>(<a href=\"https://en.wikipedia.org/wiki/Two-phase_commit_protocol\" target=\"_blank\" rel=\"noopener\">2pc</a>)，，<a href=\"https://en.wikipedia.org/wiki/Three-phase_commit_protocol\" target=\"_blank\" rel=\"noopener\">3pc</a>，<a href=\"https://storage.googleapis.com/pub-tools-public-publication-data/pdf/36726.pdf\" target=\"_blank\" rel=\"noopener\">percolator</a>(2pc)，<a href=\"http://cs.yale.edu/homes/thomson/publications/calvin-sigmod12.pdf\" target=\"_blank\" rel=\"noopener\">calvin</a>，<a href=\"https://omid.incubator.apache.org/\" target=\"_blank\" rel=\"noopener\">apache omid</a></p>\n<table>\n<thead>\n<tr>\n<th>模型</th>\n<th>数据模型</th>\n<th>并发控制方案</th>\n<th>隔离级别支持</th>\n<th>限制</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>XA</td>\n<td>不限</td>\n<td>两阶段锁（悲观）</td>\n<td>所有隔离级别</td>\n<td>加读锁导致性能下降</td>\n</tr>\n<tr>\n<td>Percolator</td>\n<td>Key-Value</td>\n<td>加锁(悲观) &amp; MVCC</td>\n<td>SI</td>\n<td></td>\n</tr>\n<tr>\n<td>Omid</td>\n<td>Key-Value</td>\n<td>冲突检测(乐观) &amp; MVCC</td>\n<td>SI</td>\n<td></td>\n</tr>\n<tr>\n<td>Calvin</td>\n<td>不限</td>\n<td>确定性数据库</td>\n<td>Serializable</td>\n<td>仅适用于One-Shot事务</td>\n</tr>\n</tbody></table>\n<h1 id=\"业务层\"><a href=\"#业务层\" class=\"headerlink\" title=\"业务层\"></a>业务层</h1><p>解决思路有：XA(异构系统)，TCC，Saga，基于本地消息的分布式事务，基于事务消息的分布式事务</p>\n<p>具体的产品有：seata， hmily， byetcc， easytransaction,XA-JTA(atomikos,bitronix,narayana) ,JOTM, BTM, MSDTC</p>\n<h2 id=\"同构与异构系统\"><a href=\"#同构与异构系统\" class=\"headerlink\" title=\"同构与异构系统\"></a>同构与异构系统</h2><p>同构：MySQL Cluster NDB，VoltDB</p>\n<p>异构：MySQL和MQ，MySQL和Redis</p>\n"},{"title":"elasticsearch(2)-query的match和term区别","date":"2021-08-29T13:12:04.000Z","_content":"\n# 区别\n\nmatch query在索引和查询时分词，term query在索引时候分词，在查询时候不分词。\n\nmatch query是全文搜索，term query是词项搜索。\n\nmatch query不是精确搜索，想要精确搜索，使用term keyword query.\n\n# 例子\n\n```\nDELETE test\nPUT test/_doc/1\n{\n  \"content\":\"Hello World\"\n}\n```\n\n\n\n# match query\n\n```\nPOST test/_search\n{\n  \"profile\": \"true\",\n  \"query\": {\n    \"match\": {\n      \"content\": \"hello world\"\n    }\n  }\n}\n```\n\n有结果返回。es的standard分词器会将Hello World索引数据时候，会分解成hello，world.\n\n而match query会将content进行分词为hello，world。所以可以搜到。\n\n\n\n```\nPOST test/_search\n{\n  \"profile\": \"true\",\n  \"query\": {\n    \"match\": {\n      \"content.keyword\": \"Hello World\"\n    }\n  }\n}\n```\n\n有结果返回。match query会将内容进行分词为hello，world，所以可以查到。\n\n\n\n```\nPOST test/_search\n{\n  \"profile\": \"true\",\n  \"query\": {\n    \"match\": {\n      \"content.keyword\": \"hello world\"\n    }\n  }\n}\n```\n\n无结果返回。match query keyword会将match query转换为term query，keyword搜索并不会分词，所以搜索不到。\n\n\n\n\n\n```\nPOST test/_search\n{\n  \"profile\": \"true\",\n  \"query\": {\n    \"match\": {\n      \"content\": \"Hello World\"\n    }\n  }\n}\n```\n\n有结果返回。match query会分词，将match query转换为term query\n\n\n\n# term query\n\n```\nPOST test/_search\n{\n  \"profile\": \"true\",\n  \"query\": {\n    \"term\": {\n      \"content\": \"hello world\"\n    }\n  }\n}\n```\n\n无结果返回。term query不会分词，hello world查询不到，因为index时候Hello World被转换成hello，world.\n\n\n\n```\nPOST test/_search\n{\n  \"profile\": \"true\",\n  \"query\": {\n    \"term\": {\n      \"content\": \"Hello World\"\n    }\n  }\n}\n```\n\n无结果返回。term query不会分词，数据在content被分成了hello，world.hello world查询不到，因为index时候Hello World被转换成hello，world.\n\n\n\n```\nPOST test/_search\n{\n  \"profile\": \"true\",\n  \"query\": {\n    \"term\": {\n      \"content.keyword\": \"hello world\"\n    }\n  }\n}\n```\n\n无结果返回，没有hello world，索引时候Hello World分解成hello，world两个词.\n\n\n\n```\nPOST test/_search\n{\n  \"profile\": \"true\",\n  \"query\": {\n    \"term\": {\n      \"content.keyword\": \"Hello World\"\n    }\n  }\n}\n```\n\n有结果返回。精确匹配。term query的精确匹配用keyword。\n\n\n\n","source":"_posts/elasticsearch-series2-match-term.md","raw":"---\ntitle: elasticsearch(2)-query的match和term区别\ndate: 2021-08-29 21:12:04\ntags: \n  - 分布式系统泛型\n  - elasticsearch\ncategories:\n  - 分布式系统\n  - 搜索\n  - elasticsearch\n---\n\n# 区别\n\nmatch query在索引和查询时分词，term query在索引时候分词，在查询时候不分词。\n\nmatch query是全文搜索，term query是词项搜索。\n\nmatch query不是精确搜索，想要精确搜索，使用term keyword query.\n\n# 例子\n\n```\nDELETE test\nPUT test/_doc/1\n{\n  \"content\":\"Hello World\"\n}\n```\n\n\n\n# match query\n\n```\nPOST test/_search\n{\n  \"profile\": \"true\",\n  \"query\": {\n    \"match\": {\n      \"content\": \"hello world\"\n    }\n  }\n}\n```\n\n有结果返回。es的standard分词器会将Hello World索引数据时候，会分解成hello，world.\n\n而match query会将content进行分词为hello，world。所以可以搜到。\n\n\n\n```\nPOST test/_search\n{\n  \"profile\": \"true\",\n  \"query\": {\n    \"match\": {\n      \"content.keyword\": \"Hello World\"\n    }\n  }\n}\n```\n\n有结果返回。match query会将内容进行分词为hello，world，所以可以查到。\n\n\n\n```\nPOST test/_search\n{\n  \"profile\": \"true\",\n  \"query\": {\n    \"match\": {\n      \"content.keyword\": \"hello world\"\n    }\n  }\n}\n```\n\n无结果返回。match query keyword会将match query转换为term query，keyword搜索并不会分词，所以搜索不到。\n\n\n\n\n\n```\nPOST test/_search\n{\n  \"profile\": \"true\",\n  \"query\": {\n    \"match\": {\n      \"content\": \"Hello World\"\n    }\n  }\n}\n```\n\n有结果返回。match query会分词，将match query转换为term query\n\n\n\n# term query\n\n```\nPOST test/_search\n{\n  \"profile\": \"true\",\n  \"query\": {\n    \"term\": {\n      \"content\": \"hello world\"\n    }\n  }\n}\n```\n\n无结果返回。term query不会分词，hello world查询不到，因为index时候Hello World被转换成hello，world.\n\n\n\n```\nPOST test/_search\n{\n  \"profile\": \"true\",\n  \"query\": {\n    \"term\": {\n      \"content\": \"Hello World\"\n    }\n  }\n}\n```\n\n无结果返回。term query不会分词，数据在content被分成了hello，world.hello world查询不到，因为index时候Hello World被转换成hello，world.\n\n\n\n```\nPOST test/_search\n{\n  \"profile\": \"true\",\n  \"query\": {\n    \"term\": {\n      \"content.keyword\": \"hello world\"\n    }\n  }\n}\n```\n\n无结果返回，没有hello world，索引时候Hello World分解成hello，world两个词.\n\n\n\n```\nPOST test/_search\n{\n  \"profile\": \"true\",\n  \"query\": {\n    \"term\": {\n      \"content.keyword\": \"Hello World\"\n    }\n  }\n}\n```\n\n有结果返回。精确匹配。term query的精确匹配用keyword。\n\n\n\n","slug":"elasticsearch-series2-match-term","published":1,"updated":"2021-08-29T13:57:36.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clh7s5cu0001lxt8j7sy104pt","content":"<h1 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h1><p>match query在索引和查询时分词，term query在索引时候分词，在查询时候不分词。</p>\n<p>match query是全文搜索，term query是词项搜索。</p>\n<p>match query不是精确搜索，想要精确搜索，使用term keyword query.</p>\n<h1 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DELETE test</span><br><span class=\"line\">PUT test&#x2F;_doc&#x2F;1</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;content&quot;:&quot;Hello World&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"match-query\"><a href=\"#match-query\" class=\"headerlink\" title=\"match query\"></a>match query</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">POST test&#x2F;_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;profile&quot;: &quot;true&quot;,</span><br><span class=\"line\">  &quot;query&quot;: &#123;</span><br><span class=\"line\">    &quot;match&quot;: &#123;</span><br><span class=\"line\">      &quot;content&quot;: &quot;hello world&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>有结果返回。es的standard分词器会将Hello World索引数据时候，会分解成hello，world.</p>\n<p>而match query会将content进行分词为hello，world。所以可以搜到。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">POST test&#x2F;_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;profile&quot;: &quot;true&quot;,</span><br><span class=\"line\">  &quot;query&quot;: &#123;</span><br><span class=\"line\">    &quot;match&quot;: &#123;</span><br><span class=\"line\">      &quot;content.keyword&quot;: &quot;Hello World&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>有结果返回。match query会将内容进行分词为hello，world，所以可以查到。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">POST test&#x2F;_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;profile&quot;: &quot;true&quot;,</span><br><span class=\"line\">  &quot;query&quot;: &#123;</span><br><span class=\"line\">    &quot;match&quot;: &#123;</span><br><span class=\"line\">      &quot;content.keyword&quot;: &quot;hello world&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>无结果返回。match query keyword会将match query转换为term query，keyword搜索并不会分词，所以搜索不到。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">POST test&#x2F;_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;profile&quot;: &quot;true&quot;,</span><br><span class=\"line\">  &quot;query&quot;: &#123;</span><br><span class=\"line\">    &quot;match&quot;: &#123;</span><br><span class=\"line\">      &quot;content&quot;: &quot;Hello World&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>有结果返回。match query会分词，将match query转换为term query</p>\n<h1 id=\"term-query\"><a href=\"#term-query\" class=\"headerlink\" title=\"term query\"></a>term query</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">POST test&#x2F;_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;profile&quot;: &quot;true&quot;,</span><br><span class=\"line\">  &quot;query&quot;: &#123;</span><br><span class=\"line\">    &quot;term&quot;: &#123;</span><br><span class=\"line\">      &quot;content&quot;: &quot;hello world&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>无结果返回。term query不会分词，hello world查询不到，因为index时候Hello World被转换成hello，world.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">POST test&#x2F;_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;profile&quot;: &quot;true&quot;,</span><br><span class=\"line\">  &quot;query&quot;: &#123;</span><br><span class=\"line\">    &quot;term&quot;: &#123;</span><br><span class=\"line\">      &quot;content&quot;: &quot;Hello World&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>无结果返回。term query不会分词，数据在content被分成了hello，world.hello world查询不到，因为index时候Hello World被转换成hello，world.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">POST test&#x2F;_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;profile&quot;: &quot;true&quot;,</span><br><span class=\"line\">  &quot;query&quot;: &#123;</span><br><span class=\"line\">    &quot;term&quot;: &#123;</span><br><span class=\"line\">      &quot;content.keyword&quot;: &quot;hello world&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>无结果返回，没有hello world，索引时候Hello World分解成hello，world两个词.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">POST test&#x2F;_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;profile&quot;: &quot;true&quot;,</span><br><span class=\"line\">  &quot;query&quot;: &#123;</span><br><span class=\"line\">    &quot;term&quot;: &#123;</span><br><span class=\"line\">      &quot;content.keyword&quot;: &quot;Hello World&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>有结果返回。精确匹配。term query的精确匹配用keyword。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"区别\"><a href=\"#区别\" class=\"headerlink\" title=\"区别\"></a>区别</h1><p>match query在索引和查询时分词，term query在索引时候分词，在查询时候不分词。</p>\n<p>match query是全文搜索，term query是词项搜索。</p>\n<p>match query不是精确搜索，想要精确搜索，使用term keyword query.</p>\n<h1 id=\"例子\"><a href=\"#例子\" class=\"headerlink\" title=\"例子\"></a>例子</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">DELETE test</span><br><span class=\"line\">PUT test&#x2F;_doc&#x2F;1</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;content&quot;:&quot;Hello World&quot;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h1 id=\"match-query\"><a href=\"#match-query\" class=\"headerlink\" title=\"match query\"></a>match query</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">POST test&#x2F;_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;profile&quot;: &quot;true&quot;,</span><br><span class=\"line\">  &quot;query&quot;: &#123;</span><br><span class=\"line\">    &quot;match&quot;: &#123;</span><br><span class=\"line\">      &quot;content&quot;: &quot;hello world&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>有结果返回。es的standard分词器会将Hello World索引数据时候，会分解成hello，world.</p>\n<p>而match query会将content进行分词为hello，world。所以可以搜到。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">POST test&#x2F;_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;profile&quot;: &quot;true&quot;,</span><br><span class=\"line\">  &quot;query&quot;: &#123;</span><br><span class=\"line\">    &quot;match&quot;: &#123;</span><br><span class=\"line\">      &quot;content.keyword&quot;: &quot;Hello World&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>有结果返回。match query会将内容进行分词为hello，world，所以可以查到。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">POST test&#x2F;_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;profile&quot;: &quot;true&quot;,</span><br><span class=\"line\">  &quot;query&quot;: &#123;</span><br><span class=\"line\">    &quot;match&quot;: &#123;</span><br><span class=\"line\">      &quot;content.keyword&quot;: &quot;hello world&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>无结果返回。match query keyword会将match query转换为term query，keyword搜索并不会分词，所以搜索不到。</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">POST test&#x2F;_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;profile&quot;: &quot;true&quot;,</span><br><span class=\"line\">  &quot;query&quot;: &#123;</span><br><span class=\"line\">    &quot;match&quot;: &#123;</span><br><span class=\"line\">      &quot;content&quot;: &quot;Hello World&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>有结果返回。match query会分词，将match query转换为term query</p>\n<h1 id=\"term-query\"><a href=\"#term-query\" class=\"headerlink\" title=\"term query\"></a>term query</h1><figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">POST test&#x2F;_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;profile&quot;: &quot;true&quot;,</span><br><span class=\"line\">  &quot;query&quot;: &#123;</span><br><span class=\"line\">    &quot;term&quot;: &#123;</span><br><span class=\"line\">      &quot;content&quot;: &quot;hello world&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>无结果返回。term query不会分词，hello world查询不到，因为index时候Hello World被转换成hello，world.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">POST test&#x2F;_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;profile&quot;: &quot;true&quot;,</span><br><span class=\"line\">  &quot;query&quot;: &#123;</span><br><span class=\"line\">    &quot;term&quot;: &#123;</span><br><span class=\"line\">      &quot;content&quot;: &quot;Hello World&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>无结果返回。term query不会分词，数据在content被分成了hello，world.hello world查询不到，因为index时候Hello World被转换成hello，world.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">POST test&#x2F;_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;profile&quot;: &quot;true&quot;,</span><br><span class=\"line\">  &quot;query&quot;: &#123;</span><br><span class=\"line\">    &quot;term&quot;: &#123;</span><br><span class=\"line\">      &quot;content.keyword&quot;: &quot;hello world&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>无结果返回，没有hello world，索引时候Hello World分解成hello，world两个词.</p>\n<figure class=\"highlight plain\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br></pre></td><td class=\"code\"><pre><span class=\"line\">POST test&#x2F;_search</span><br><span class=\"line\">&#123;</span><br><span class=\"line\">  &quot;profile&quot;: &quot;true&quot;,</span><br><span class=\"line\">  &quot;query&quot;: &#123;</span><br><span class=\"line\">    &quot;term&quot;: &#123;</span><br><span class=\"line\">      &quot;content.keyword&quot;: &quot;Hello World&quot;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">  &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>有结果返回。精确匹配。term query的精确匹配用keyword。</p>\n"},{"title":"项目，Kafka消费组和Topic关系","date":"2022-09-12T10:31:32.000Z","comments":1,"_content":"\n\n\n这里的项目可以认为是一个微服务。需要根据场景选择**项目**，**消费组**，**topic**关系。\n\n\n\n1. 一个项目下：多个消费组对应一个topic。（n：1）  教务美育结算\n2. 一个项目下，多个消费组对应多个topic。（1:1）    暂无？？？\n3. 一个项目下，一个消费组对应多个topic。(1 : n)     教务订单，智学用户\n4. 一个项目下，一个消费组对应一个topic。(1：1)     最简单情况 ，比如换课，退款\n5. 多个项目下，多个消费组对应一个topic。（n：1）  智学用户清除\n\n\n\n**问题在于2,3的区别是什么？ 3可以通过group(项目名字)找到所有的topic，方便查找，并且也不可能每起一个项目就开一堆消费组。看着是更省资源的方式。**\n\n简化这个问题：一个项目，要消费很多topic，选择多个group好还是一个group好呢？区别是啥?\n\n所以选择的维度是：**项目+消费组+topic**，这里可以看到没有了消费者的选择。\n","source":"_posts/kafka-project-consumer-group.md","raw":"---\ntitle: 项目，Kafka消费组和Topic关系\ndate: 2022-09-12 18:31:32\ntags: \n  - kafka\ncategories:\n  - 消息中间件\n  - kafka\ncomments: true\n---\n\n\n\n这里的项目可以认为是一个微服务。需要根据场景选择**项目**，**消费组**，**topic**关系。\n\n\n\n1. 一个项目下：多个消费组对应一个topic。（n：1）  教务美育结算\n2. 一个项目下，多个消费组对应多个topic。（1:1）    暂无？？？\n3. 一个项目下，一个消费组对应多个topic。(1 : n)     教务订单，智学用户\n4. 一个项目下，一个消费组对应一个topic。(1：1)     最简单情况 ，比如换课，退款\n5. 多个项目下，多个消费组对应一个topic。（n：1）  智学用户清除\n\n\n\n**问题在于2,3的区别是什么？ 3可以通过group(项目名字)找到所有的topic，方便查找，并且也不可能每起一个项目就开一堆消费组。看着是更省资源的方式。**\n\n简化这个问题：一个项目，要消费很多topic，选择多个group好还是一个group好呢？区别是啥?\n\n所以选择的维度是：**项目+消费组+topic**，这里可以看到没有了消费者的选择。\n","slug":"kafka-project-consumer-group","published":1,"updated":"2022-09-12T10:34:12.000Z","layout":"post","photos":[],"link":"","_id":"clh7s5cu1001oxt8jfl9s5wua","content":"<p>这里的项目可以认为是一个微服务。需要根据场景选择<strong>项目</strong>，<strong>消费组</strong>，<strong>topic</strong>关系。</p>\n<ol>\n<li>一个项目下：多个消费组对应一个topic。（n：1）  教务美育结算</li>\n<li>一个项目下，多个消费组对应多个topic。（1:1）    暂无？？？</li>\n<li>一个项目下，一个消费组对应多个topic。(1 : n)     教务订单，智学用户</li>\n<li>一个项目下，一个消费组对应一个topic。(1：1)     最简单情况 ，比如换课，退款</li>\n<li>多个项目下，多个消费组对应一个topic。（n：1）  智学用户清除</li>\n</ol>\n<p><strong>问题在于2,3的区别是什么？ 3可以通过group(项目名字)找到所有的topic，方便查找，并且也不可能每起一个项目就开一堆消费组。看着是更省资源的方式。</strong></p>\n<p>简化这个问题：一个项目，要消费很多topic，选择多个group好还是一个group好呢？区别是啥?</p>\n<p>所以选择的维度是：<strong>项目+消费组+topic</strong>，这里可以看到没有了消费者的选择。</p>\n","site":{"data":{}},"excerpt":"","more":"<p>这里的项目可以认为是一个微服务。需要根据场景选择<strong>项目</strong>，<strong>消费组</strong>，<strong>topic</strong>关系。</p>\n<ol>\n<li>一个项目下：多个消费组对应一个topic。（n：1）  教务美育结算</li>\n<li>一个项目下，多个消费组对应多个topic。（1:1）    暂无？？？</li>\n<li>一个项目下，一个消费组对应多个topic。(1 : n)     教务订单，智学用户</li>\n<li>一个项目下，一个消费组对应一个topic。(1：1)     最简单情况 ，比如换课，退款</li>\n<li>多个项目下，多个消费组对应一个topic。（n：1）  智学用户清除</li>\n</ol>\n<p><strong>问题在于2,3的区别是什么？ 3可以通过group(项目名字)找到所有的topic，方便查找，并且也不可能每起一个项目就开一堆消费组。看着是更省资源的方式。</strong></p>\n<p>简化这个问题：一个项目，要消费很多topic，选择多个group好还是一个group好呢？区别是啥?</p>\n<p>所以选择的维度是：<strong>项目+消费组+topic</strong>，这里可以看到没有了消费者的选择。</p>\n"},{"title":"Java应用组成集群的方式探索","date":"2021-12-20T13:49:26.000Z","_content":"\n\n\n# 概述\n\n本文主要讨论**分布式业务系统**(有别于分布式存储系统)中的组建集群方式，系统高可用的方式是节点冗余，而节点冗余本身并不需要保证节点互相通信，常用的方式是节点注册到注册中心，也即节点是无状态的，这是最简单的分布式模型，集群模式是在此模型上加了稍许复杂度，但是对于业务系统想要组成集群的话，需要集群间通信。本文主要探讨分布式业务系统组成集群的方法，而不是探讨集群模式下的具体功能设计(如分片，Workqueue，Sactter/Gather, Scale out等功能)。这里**集群定义**我认为需要**满足两个基本条件**：\n\n1. **必须有membership change的能力。**节点增加，移除，宕机对集群可感知。\n2. **必须有协调机制。**这里可以认为是Leader Select或者Primary Select能力，当然Amazon的Dynamo是通过Gossip实现的P2P系统并没有Leader节点。\n\n满足上述集群定义则系统会满足：\n\n**高可用 ->  复制(Replication)  ->  一致性(Consistency)  ->  共识(Consensus)**\n\n系统间通信方式有rpc，mq，系统体系结构有单机，多机（主从，对等，集群），而Java应用组成集群方式总结如下：\n\n1. 借助单机/分布式存储：etcd/zookeeper/nacos/consul/[doozerd](https://github.com/ha/doozerd)/mysql/[MFS](https://moosefs.com/)/NFS\n2. 借助中间件/框架：Hazelcast，Akka，[Serf](https://www.serf.io/)(Gossip)，[**JGroups**](http://www.jgroups.org/overview.html) , [**Erlang/OTP(非Java)**](https://www.erlang.org/doc/reference_manual/distributed.html)\n3. 借助协议：raft，gossip，zab，paxos。需要利用开源实现来构建系统。\n\n\n\n# 借助存储\n\n借助存储，一般会采用etcd/zk这种方式较多，可以非常方便实现Leader选举，任务分发，任务调度，分布式锁，分布式队列等功能，并且membership change可以检测到。当然用Redis也可以实现类似功能，但是redis实现membership change需要额外开发，本身并不支持。\n\n# 借助中间件/框架\n\nHazelcast也可以实现Leader选举，分布式弹性计算，分布式内存Map/List/Set等功能，应用系统借助嵌入式hazelcast便可以方便集成。或者Hazelcast竞品[Atomix](https://atomix.io/docs/latest/getting-started/), [Apache Ignite](https://ignite.apache.org/)\n\nAkka的[Cluster](https://doc.akka.io/docs/akka/current/typed/cluster.html)，[Cluster Singleton](https://doc.akka.io/docs/akka/current/typed/cluster-singleton.html), [Cluster Sharding](https://doc.akka.io/docs/akka/current/typed/cluster-sharding.html)，[Distributed Data](https://doc.akka.io/docs/akka/current/typed/distributed-data.html)功能非常强大，非常适合节点组建集群，用于解决集群单例，分片等问题。\n\nJGroups是Java的组通信框架，也可以实现集群成员变更，其官方有基于[**HSQLDB+JGroup**](http://www.jgroups.org/hsqldbr.html)的例子，[**任务分发系统**](http://www.jgroups.org/taskdistribution.html),  [**ReplicationCache**](http://www.jgroups.org/replcache.html)。\n\n# 借助协议\n\n借助协议实现较为复杂，但是灵活性最大。需要引入协议的实现库，并且自己构建业务系统，常用的Raft Plus的方式，Raft+业务系统，当然可以实现Raft协议本身的功能，比如选举，集群成员变更，具体取决于协议的实现，比如协议是否实现节点通信以及日志存储等功能，如etcd-raft用起来比较难，但是既然用了etcd-raft，为什么不直接用etcd呢？其他存储层Raft Plus方案还有，raft+redis=[redisraft](https://github.com/RedisLabs/redisraft)，raft+rocksdb=tikv，raft+sqllite=[rqlite](https://github.com/rqlite/rqlite)，[hashicorp-raft](https://github.com/hashicorp/raft)+boltdb=consul，mysql+paxos= MGR，这里只是参考，相比较存储层，在业务层用raft会简单一些。这里推荐Java的raft实现蚂蚁金服的[sofa-jraft](https://www.sofastack.tech/projects/sofa-jraft/overview/)。\n\n# 总结\n\n本文探讨了业务层组建集群方式，业务层组建集群相比较存储层组建集群要简单，因为存储层往往需要分布式事务+数据复制带来一致性的这些语义，而业务层相对来说弱化了这些语义，由下层基础设施保证。我认为相比较而言业务层组建集群方式以下更优：借助存储方案是etcd/zk(curator)，借助中间件/框架是Akka和Hazelcast，借助协议是Raft Plus.\n\n# 参考\n\n- hazelcast和ignite对比：https://hazelcast.com/resources/hazelcast-vs-gridgain/\n- 《分布式系统设计》- Brendan Burns [designing-distributed-systems](https://github.com/brendandburns/designing-distributed-systems)\n- 《云计算架构设计模式》- Microsoft https://docs.microsoft.com/zh-cn/azure/architecture/patterns/\n- 《Akka应用模式-分布式应用程序设计实践指南》- Michael Nash\n- 《高伸缩性系统 Erlang/OTP大型分布式容错设计》- Francesco Cesar\n- 分布式系统研究泛型模板 https://xiaozhiliaoo.github.io/2021/04/24/distributed-systems-research-paradigm/\n","source":"_posts/java-application-cluster.md","raw":"---\ntitle: Java应用组成集群的方式探索\ndate: 2021-12-20 21:49:26\ntags: distributed system\ncategories:\n  - 分布式系统\n  - 应用集群\n---\n\n\n\n# 概述\n\n本文主要讨论**分布式业务系统**(有别于分布式存储系统)中的组建集群方式，系统高可用的方式是节点冗余，而节点冗余本身并不需要保证节点互相通信，常用的方式是节点注册到注册中心，也即节点是无状态的，这是最简单的分布式模型，集群模式是在此模型上加了稍许复杂度，但是对于业务系统想要组成集群的话，需要集群间通信。本文主要探讨分布式业务系统组成集群的方法，而不是探讨集群模式下的具体功能设计(如分片，Workqueue，Sactter/Gather, Scale out等功能)。这里**集群定义**我认为需要**满足两个基本条件**：\n\n1. **必须有membership change的能力。**节点增加，移除，宕机对集群可感知。\n2. **必须有协调机制。**这里可以认为是Leader Select或者Primary Select能力，当然Amazon的Dynamo是通过Gossip实现的P2P系统并没有Leader节点。\n\n满足上述集群定义则系统会满足：\n\n**高可用 ->  复制(Replication)  ->  一致性(Consistency)  ->  共识(Consensus)**\n\n系统间通信方式有rpc，mq，系统体系结构有单机，多机（主从，对等，集群），而Java应用组成集群方式总结如下：\n\n1. 借助单机/分布式存储：etcd/zookeeper/nacos/consul/[doozerd](https://github.com/ha/doozerd)/mysql/[MFS](https://moosefs.com/)/NFS\n2. 借助中间件/框架：Hazelcast，Akka，[Serf](https://www.serf.io/)(Gossip)，[**JGroups**](http://www.jgroups.org/overview.html) , [**Erlang/OTP(非Java)**](https://www.erlang.org/doc/reference_manual/distributed.html)\n3. 借助协议：raft，gossip，zab，paxos。需要利用开源实现来构建系统。\n\n\n\n# 借助存储\n\n借助存储，一般会采用etcd/zk这种方式较多，可以非常方便实现Leader选举，任务分发，任务调度，分布式锁，分布式队列等功能，并且membership change可以检测到。当然用Redis也可以实现类似功能，但是redis实现membership change需要额外开发，本身并不支持。\n\n# 借助中间件/框架\n\nHazelcast也可以实现Leader选举，分布式弹性计算，分布式内存Map/List/Set等功能，应用系统借助嵌入式hazelcast便可以方便集成。或者Hazelcast竞品[Atomix](https://atomix.io/docs/latest/getting-started/), [Apache Ignite](https://ignite.apache.org/)\n\nAkka的[Cluster](https://doc.akka.io/docs/akka/current/typed/cluster.html)，[Cluster Singleton](https://doc.akka.io/docs/akka/current/typed/cluster-singleton.html), [Cluster Sharding](https://doc.akka.io/docs/akka/current/typed/cluster-sharding.html)，[Distributed Data](https://doc.akka.io/docs/akka/current/typed/distributed-data.html)功能非常强大，非常适合节点组建集群，用于解决集群单例，分片等问题。\n\nJGroups是Java的组通信框架，也可以实现集群成员变更，其官方有基于[**HSQLDB+JGroup**](http://www.jgroups.org/hsqldbr.html)的例子，[**任务分发系统**](http://www.jgroups.org/taskdistribution.html),  [**ReplicationCache**](http://www.jgroups.org/replcache.html)。\n\n# 借助协议\n\n借助协议实现较为复杂，但是灵活性最大。需要引入协议的实现库，并且自己构建业务系统，常用的Raft Plus的方式，Raft+业务系统，当然可以实现Raft协议本身的功能，比如选举，集群成员变更，具体取决于协议的实现，比如协议是否实现节点通信以及日志存储等功能，如etcd-raft用起来比较难，但是既然用了etcd-raft，为什么不直接用etcd呢？其他存储层Raft Plus方案还有，raft+redis=[redisraft](https://github.com/RedisLabs/redisraft)，raft+rocksdb=tikv，raft+sqllite=[rqlite](https://github.com/rqlite/rqlite)，[hashicorp-raft](https://github.com/hashicorp/raft)+boltdb=consul，mysql+paxos= MGR，这里只是参考，相比较存储层，在业务层用raft会简单一些。这里推荐Java的raft实现蚂蚁金服的[sofa-jraft](https://www.sofastack.tech/projects/sofa-jraft/overview/)。\n\n# 总结\n\n本文探讨了业务层组建集群方式，业务层组建集群相比较存储层组建集群要简单，因为存储层往往需要分布式事务+数据复制带来一致性的这些语义，而业务层相对来说弱化了这些语义，由下层基础设施保证。我认为相比较而言业务层组建集群方式以下更优：借助存储方案是etcd/zk(curator)，借助中间件/框架是Akka和Hazelcast，借助协议是Raft Plus.\n\n# 参考\n\n- hazelcast和ignite对比：https://hazelcast.com/resources/hazelcast-vs-gridgain/\n- 《分布式系统设计》- Brendan Burns [designing-distributed-systems](https://github.com/brendandburns/designing-distributed-systems)\n- 《云计算架构设计模式》- Microsoft https://docs.microsoft.com/zh-cn/azure/architecture/patterns/\n- 《Akka应用模式-分布式应用程序设计实践指南》- Michael Nash\n- 《高伸缩性系统 Erlang/OTP大型分布式容错设计》- Francesco Cesar\n- 分布式系统研究泛型模板 https://xiaozhiliaoo.github.io/2021/04/24/distributed-systems-research-paradigm/\n","slug":"java-application-cluster","published":1,"updated":"2022-06-28T17:18:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clh7s5cu2001sxt8j4d3ub029","content":"<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><p>本文主要讨论<strong>分布式业务系统</strong>(有别于分布式存储系统)中的组建集群方式，系统高可用的方式是节点冗余，而节点冗余本身并不需要保证节点互相通信，常用的方式是节点注册到注册中心，也即节点是无状态的，这是最简单的分布式模型，集群模式是在此模型上加了稍许复杂度，但是对于业务系统想要组成集群的话，需要集群间通信。本文主要探讨分布式业务系统组成集群的方法，而不是探讨集群模式下的具体功能设计(如分片，Workqueue，Sactter/Gather, Scale out等功能)。这里<strong>集群定义</strong>我认为需要<strong>满足两个基本条件</strong>：</p>\n<ol>\n<li><strong>必须有membership change的能力。</strong>节点增加，移除，宕机对集群可感知。</li>\n<li><strong>必须有协调机制。</strong>这里可以认为是Leader Select或者Primary Select能力，当然Amazon的Dynamo是通过Gossip实现的P2P系统并没有Leader节点。</li>\n</ol>\n<p>满足上述集群定义则系统会满足：</p>\n<p><strong>高可用 -&gt;  复制(Replication)  -&gt;  一致性(Consistency)  -&gt;  共识(Consensus)</strong></p>\n<p>系统间通信方式有rpc，mq，系统体系结构有单机，多机（主从，对等，集群），而Java应用组成集群方式总结如下：</p>\n<ol>\n<li>借助单机/分布式存储：etcd/zookeeper/nacos/consul/<a href=\"https://github.com/ha/doozerd\" target=\"_blank\" rel=\"noopener\">doozerd</a>/mysql/<a href=\"https://moosefs.com/\" target=\"_blank\" rel=\"noopener\">MFS</a>/NFS</li>\n<li>借助中间件/框架：Hazelcast，Akka，<a href=\"https://www.serf.io/\" target=\"_blank\" rel=\"noopener\">Serf</a>(Gossip)，<a href=\"http://www.jgroups.org/overview.html\" target=\"_blank\" rel=\"noopener\"><strong>JGroups</strong></a> , <a href=\"https://www.erlang.org/doc/reference_manual/distributed.html\" target=\"_blank\" rel=\"noopener\"><strong>Erlang/OTP(非Java)</strong></a></li>\n<li>借助协议：raft，gossip，zab，paxos。需要利用开源实现来构建系统。</li>\n</ol>\n<h1 id=\"借助存储\"><a href=\"#借助存储\" class=\"headerlink\" title=\"借助存储\"></a>借助存储</h1><p>借助存储，一般会采用etcd/zk这种方式较多，可以非常方便实现Leader选举，任务分发，任务调度，分布式锁，分布式队列等功能，并且membership change可以检测到。当然用Redis也可以实现类似功能，但是redis实现membership change需要额外开发，本身并不支持。</p>\n<h1 id=\"借助中间件-框架\"><a href=\"#借助中间件-框架\" class=\"headerlink\" title=\"借助中间件/框架\"></a>借助中间件/框架</h1><p>Hazelcast也可以实现Leader选举，分布式弹性计算，分布式内存Map/List/Set等功能，应用系统借助嵌入式hazelcast便可以方便集成。或者Hazelcast竞品<a href=\"https://atomix.io/docs/latest/getting-started/\" target=\"_blank\" rel=\"noopener\">Atomix</a>, <a href=\"https://ignite.apache.org/\" target=\"_blank\" rel=\"noopener\">Apache Ignite</a></p>\n<p>Akka的<a href=\"https://doc.akka.io/docs/akka/current/typed/cluster.html\" target=\"_blank\" rel=\"noopener\">Cluster</a>，<a href=\"https://doc.akka.io/docs/akka/current/typed/cluster-singleton.html\" target=\"_blank\" rel=\"noopener\">Cluster Singleton</a>, <a href=\"https://doc.akka.io/docs/akka/current/typed/cluster-sharding.html\" target=\"_blank\" rel=\"noopener\">Cluster Sharding</a>，<a href=\"https://doc.akka.io/docs/akka/current/typed/distributed-data.html\" target=\"_blank\" rel=\"noopener\">Distributed Data</a>功能非常强大，非常适合节点组建集群，用于解决集群单例，分片等问题。</p>\n<p>JGroups是Java的组通信框架，也可以实现集群成员变更，其官方有基于<a href=\"http://www.jgroups.org/hsqldbr.html\" target=\"_blank\" rel=\"noopener\"><strong>HSQLDB+JGroup</strong></a>的例子，<a href=\"http://www.jgroups.org/taskdistribution.html\" target=\"_blank\" rel=\"noopener\"><strong>任务分发系统</strong></a>,  <a href=\"http://www.jgroups.org/replcache.html\" target=\"_blank\" rel=\"noopener\"><strong>ReplicationCache</strong></a>。</p>\n<h1 id=\"借助协议\"><a href=\"#借助协议\" class=\"headerlink\" title=\"借助协议\"></a>借助协议</h1><p>借助协议实现较为复杂，但是灵活性最大。需要引入协议的实现库，并且自己构建业务系统，常用的Raft Plus的方式，Raft+业务系统，当然可以实现Raft协议本身的功能，比如选举，集群成员变更，具体取决于协议的实现，比如协议是否实现节点通信以及日志存储等功能，如etcd-raft用起来比较难，但是既然用了etcd-raft，为什么不直接用etcd呢？其他存储层Raft Plus方案还有，raft+redis=<a href=\"https://github.com/RedisLabs/redisraft\" target=\"_blank\" rel=\"noopener\">redisraft</a>，raft+rocksdb=tikv，raft+sqllite=<a href=\"https://github.com/rqlite/rqlite\" target=\"_blank\" rel=\"noopener\">rqlite</a>，<a href=\"https://github.com/hashicorp/raft\" target=\"_blank\" rel=\"noopener\">hashicorp-raft</a>+boltdb=consul，mysql+paxos= MGR，这里只是参考，相比较存储层，在业务层用raft会简单一些。这里推荐Java的raft实现蚂蚁金服的<a href=\"https://www.sofastack.tech/projects/sofa-jraft/overview/\" target=\"_blank\" rel=\"noopener\">sofa-jraft</a>。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>本文探讨了业务层组建集群方式，业务层组建集群相比较存储层组建集群要简单，因为存储层往往需要分布式事务+数据复制带来一致性的这些语义，而业务层相对来说弱化了这些语义，由下层基础设施保证。我认为相比较而言业务层组建集群方式以下更优：借助存储方案是etcd/zk(curator)，借助中间件/框架是Akka和Hazelcast，借助协议是Raft Plus.</p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><ul>\n<li>hazelcast和ignite对比：<a href=\"https://hazelcast.com/resources/hazelcast-vs-gridgain/\" target=\"_blank\" rel=\"noopener\">https://hazelcast.com/resources/hazelcast-vs-gridgain/</a></li>\n<li>《分布式系统设计》- Brendan Burns <a href=\"https://github.com/brendandburns/designing-distributed-systems\" target=\"_blank\" rel=\"noopener\">designing-distributed-systems</a></li>\n<li>《云计算架构设计模式》- Microsoft <a href=\"https://docs.microsoft.com/zh-cn/azure/architecture/patterns/\" target=\"_blank\" rel=\"noopener\">https://docs.microsoft.com/zh-cn/azure/architecture/patterns/</a></li>\n<li>《Akka应用模式-分布式应用程序设计实践指南》- Michael Nash</li>\n<li>《高伸缩性系统 Erlang/OTP大型分布式容错设计》- Francesco Cesar</li>\n<li>分布式系统研究泛型模板 <a href=\"https://xiaozhiliaoo.github.io/2021/04/24/distributed-systems-research-paradigm/\" target=\"_blank\" rel=\"noopener\">https://xiaozhiliaoo.github.io/2021/04/24/distributed-systems-research-paradigm/</a></li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"概述\"><a href=\"#概述\" class=\"headerlink\" title=\"概述\"></a>概述</h1><p>本文主要讨论<strong>分布式业务系统</strong>(有别于分布式存储系统)中的组建集群方式，系统高可用的方式是节点冗余，而节点冗余本身并不需要保证节点互相通信，常用的方式是节点注册到注册中心，也即节点是无状态的，这是最简单的分布式模型，集群模式是在此模型上加了稍许复杂度，但是对于业务系统想要组成集群的话，需要集群间通信。本文主要探讨分布式业务系统组成集群的方法，而不是探讨集群模式下的具体功能设计(如分片，Workqueue，Sactter/Gather, Scale out等功能)。这里<strong>集群定义</strong>我认为需要<strong>满足两个基本条件</strong>：</p>\n<ol>\n<li><strong>必须有membership change的能力。</strong>节点增加，移除，宕机对集群可感知。</li>\n<li><strong>必须有协调机制。</strong>这里可以认为是Leader Select或者Primary Select能力，当然Amazon的Dynamo是通过Gossip实现的P2P系统并没有Leader节点。</li>\n</ol>\n<p>满足上述集群定义则系统会满足：</p>\n<p><strong>高可用 -&gt;  复制(Replication)  -&gt;  一致性(Consistency)  -&gt;  共识(Consensus)</strong></p>\n<p>系统间通信方式有rpc，mq，系统体系结构有单机，多机（主从，对等，集群），而Java应用组成集群方式总结如下：</p>\n<ol>\n<li>借助单机/分布式存储：etcd/zookeeper/nacos/consul/<a href=\"https://github.com/ha/doozerd\" target=\"_blank\" rel=\"noopener\">doozerd</a>/mysql/<a href=\"https://moosefs.com/\" target=\"_blank\" rel=\"noopener\">MFS</a>/NFS</li>\n<li>借助中间件/框架：Hazelcast，Akka，<a href=\"https://www.serf.io/\" target=\"_blank\" rel=\"noopener\">Serf</a>(Gossip)，<a href=\"http://www.jgroups.org/overview.html\" target=\"_blank\" rel=\"noopener\"><strong>JGroups</strong></a> , <a href=\"https://www.erlang.org/doc/reference_manual/distributed.html\" target=\"_blank\" rel=\"noopener\"><strong>Erlang/OTP(非Java)</strong></a></li>\n<li>借助协议：raft，gossip，zab，paxos。需要利用开源实现来构建系统。</li>\n</ol>\n<h1 id=\"借助存储\"><a href=\"#借助存储\" class=\"headerlink\" title=\"借助存储\"></a>借助存储</h1><p>借助存储，一般会采用etcd/zk这种方式较多，可以非常方便实现Leader选举，任务分发，任务调度，分布式锁，分布式队列等功能，并且membership change可以检测到。当然用Redis也可以实现类似功能，但是redis实现membership change需要额外开发，本身并不支持。</p>\n<h1 id=\"借助中间件-框架\"><a href=\"#借助中间件-框架\" class=\"headerlink\" title=\"借助中间件/框架\"></a>借助中间件/框架</h1><p>Hazelcast也可以实现Leader选举，分布式弹性计算，分布式内存Map/List/Set等功能，应用系统借助嵌入式hazelcast便可以方便集成。或者Hazelcast竞品<a href=\"https://atomix.io/docs/latest/getting-started/\" target=\"_blank\" rel=\"noopener\">Atomix</a>, <a href=\"https://ignite.apache.org/\" target=\"_blank\" rel=\"noopener\">Apache Ignite</a></p>\n<p>Akka的<a href=\"https://doc.akka.io/docs/akka/current/typed/cluster.html\" target=\"_blank\" rel=\"noopener\">Cluster</a>，<a href=\"https://doc.akka.io/docs/akka/current/typed/cluster-singleton.html\" target=\"_blank\" rel=\"noopener\">Cluster Singleton</a>, <a href=\"https://doc.akka.io/docs/akka/current/typed/cluster-sharding.html\" target=\"_blank\" rel=\"noopener\">Cluster Sharding</a>，<a href=\"https://doc.akka.io/docs/akka/current/typed/distributed-data.html\" target=\"_blank\" rel=\"noopener\">Distributed Data</a>功能非常强大，非常适合节点组建集群，用于解决集群单例，分片等问题。</p>\n<p>JGroups是Java的组通信框架，也可以实现集群成员变更，其官方有基于<a href=\"http://www.jgroups.org/hsqldbr.html\" target=\"_blank\" rel=\"noopener\"><strong>HSQLDB+JGroup</strong></a>的例子，<a href=\"http://www.jgroups.org/taskdistribution.html\" target=\"_blank\" rel=\"noopener\"><strong>任务分发系统</strong></a>,  <a href=\"http://www.jgroups.org/replcache.html\" target=\"_blank\" rel=\"noopener\"><strong>ReplicationCache</strong></a>。</p>\n<h1 id=\"借助协议\"><a href=\"#借助协议\" class=\"headerlink\" title=\"借助协议\"></a>借助协议</h1><p>借助协议实现较为复杂，但是灵活性最大。需要引入协议的实现库，并且自己构建业务系统，常用的Raft Plus的方式，Raft+业务系统，当然可以实现Raft协议本身的功能，比如选举，集群成员变更，具体取决于协议的实现，比如协议是否实现节点通信以及日志存储等功能，如etcd-raft用起来比较难，但是既然用了etcd-raft，为什么不直接用etcd呢？其他存储层Raft Plus方案还有，raft+redis=<a href=\"https://github.com/RedisLabs/redisraft\" target=\"_blank\" rel=\"noopener\">redisraft</a>，raft+rocksdb=tikv，raft+sqllite=<a href=\"https://github.com/rqlite/rqlite\" target=\"_blank\" rel=\"noopener\">rqlite</a>，<a href=\"https://github.com/hashicorp/raft\" target=\"_blank\" rel=\"noopener\">hashicorp-raft</a>+boltdb=consul，mysql+paxos= MGR，这里只是参考，相比较存储层，在业务层用raft会简单一些。这里推荐Java的raft实现蚂蚁金服的<a href=\"https://www.sofastack.tech/projects/sofa-jraft/overview/\" target=\"_blank\" rel=\"noopener\">sofa-jraft</a>。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>本文探讨了业务层组建集群方式，业务层组建集群相比较存储层组建集群要简单，因为存储层往往需要分布式事务+数据复制带来一致性的这些语义，而业务层相对来说弱化了这些语义，由下层基础设施保证。我认为相比较而言业务层组建集群方式以下更优：借助存储方案是etcd/zk(curator)，借助中间件/框架是Akka和Hazelcast，借助协议是Raft Plus.</p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><ul>\n<li>hazelcast和ignite对比：<a href=\"https://hazelcast.com/resources/hazelcast-vs-gridgain/\" target=\"_blank\" rel=\"noopener\">https://hazelcast.com/resources/hazelcast-vs-gridgain/</a></li>\n<li>《分布式系统设计》- Brendan Burns <a href=\"https://github.com/brendandburns/designing-distributed-systems\" target=\"_blank\" rel=\"noopener\">designing-distributed-systems</a></li>\n<li>《云计算架构设计模式》- Microsoft <a href=\"https://docs.microsoft.com/zh-cn/azure/architecture/patterns/\" target=\"_blank\" rel=\"noopener\">https://docs.microsoft.com/zh-cn/azure/architecture/patterns/</a></li>\n<li>《Akka应用模式-分布式应用程序设计实践指南》- Michael Nash</li>\n<li>《高伸缩性系统 Erlang/OTP大型分布式容错设计》- Francesco Cesar</li>\n<li>分布式系统研究泛型模板 <a href=\"https://xiaozhiliaoo.github.io/2021/04/24/distributed-systems-research-paradigm/\" target=\"_blank\" rel=\"noopener\">https://xiaozhiliaoo.github.io/2021/04/24/distributed-systems-research-paradigm/</a></li>\n</ul>\n"},{"title":"Kafka监控概览","date":"2022-10-30T06:28:52.000Z","_content":"\n# Broker\n\n## kafka集群和broker\n\n\n\n## Borker\n\n\n\n\n\n## Topic\n\n\n\n\n\n# 客户端\n\n## 生产者\n\n### JMX type=producer-metrics\n\nrecord-error-rate\n\nrecord-retry-rate\n\nrequest-latency-avg\n\noutgoing-byte-rate\n\nrecord-send-rate\n\nrequest-rate\n\nrequest-size-avg\n\nbatch-size-avg\n\nrecord-size-avg\n\nrecords-per-request-avg\n\nrecord-queue-time-avg\n\n\n\n## 消费者\n\n### JMX type=consumer-fetch-manager-metrics\n\nfetch-latency-avg\n\nrecords-lag-max\n\nbytes-consumed-rate\n\nrecords-consumed-rate\n\nfetch-rate\n\nfetch-size-avg\n\nrecords-per-request-avg\n\n### JMX type=consumer-coordinator-metrics\n\nsync-time-avg\n\nsync-rate\n\ncommit-latency-avg\n\nassigned-partitions\n\n","source":"_posts/kafka-manager-explain.md","raw":"---\ntitle: Kafka监控概览\ndate: 2022-10-30 14:28:52\ntags:\n---\n\n# Broker\n\n## kafka集群和broker\n\n\n\n## Borker\n\n\n\n\n\n## Topic\n\n\n\n\n\n# 客户端\n\n## 生产者\n\n### JMX type=producer-metrics\n\nrecord-error-rate\n\nrecord-retry-rate\n\nrequest-latency-avg\n\noutgoing-byte-rate\n\nrecord-send-rate\n\nrequest-rate\n\nrequest-size-avg\n\nbatch-size-avg\n\nrecord-size-avg\n\nrecords-per-request-avg\n\nrecord-queue-time-avg\n\n\n\n## 消费者\n\n### JMX type=consumer-fetch-manager-metrics\n\nfetch-latency-avg\n\nrecords-lag-max\n\nbytes-consumed-rate\n\nrecords-consumed-rate\n\nfetch-rate\n\nfetch-size-avg\n\nrecords-per-request-avg\n\n### JMX type=consumer-coordinator-metrics\n\nsync-time-avg\n\nsync-rate\n\ncommit-latency-avg\n\nassigned-partitions\n\n","slug":"kafka-manager-explain","published":1,"updated":"2022-10-30T07:36:16.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clh7s5cu3001uxt8j3doy1btr","content":"<h1 id=\"Broker\"><a href=\"#Broker\" class=\"headerlink\" title=\"Broker\"></a>Broker</h1><h2 id=\"kafka集群和broker\"><a href=\"#kafka集群和broker\" class=\"headerlink\" title=\"kafka集群和broker\"></a>kafka集群和broker</h2><h2 id=\"Borker\"><a href=\"#Borker\" class=\"headerlink\" title=\"Borker\"></a>Borker</h2><h2 id=\"Topic\"><a href=\"#Topic\" class=\"headerlink\" title=\"Topic\"></a>Topic</h2><h1 id=\"客户端\"><a href=\"#客户端\" class=\"headerlink\" title=\"客户端\"></a>客户端</h1><h2 id=\"生产者\"><a href=\"#生产者\" class=\"headerlink\" title=\"生产者\"></a>生产者</h2><h3 id=\"JMX-type-producer-metrics\"><a href=\"#JMX-type-producer-metrics\" class=\"headerlink\" title=\"JMX type=producer-metrics\"></a>JMX type=producer-metrics</h3><p>record-error-rate</p>\n<p>record-retry-rate</p>\n<p>request-latency-avg</p>\n<p>outgoing-byte-rate</p>\n<p>record-send-rate</p>\n<p>request-rate</p>\n<p>request-size-avg</p>\n<p>batch-size-avg</p>\n<p>record-size-avg</p>\n<p>records-per-request-avg</p>\n<p>record-queue-time-avg</p>\n<h2 id=\"消费者\"><a href=\"#消费者\" class=\"headerlink\" title=\"消费者\"></a>消费者</h2><h3 id=\"JMX-type-consumer-fetch-manager-metrics\"><a href=\"#JMX-type-consumer-fetch-manager-metrics\" class=\"headerlink\" title=\"JMX type=consumer-fetch-manager-metrics\"></a>JMX type=consumer-fetch-manager-metrics</h3><p>fetch-latency-avg</p>\n<p>records-lag-max</p>\n<p>bytes-consumed-rate</p>\n<p>records-consumed-rate</p>\n<p>fetch-rate</p>\n<p>fetch-size-avg</p>\n<p>records-per-request-avg</p>\n<h3 id=\"JMX-type-consumer-coordinator-metrics\"><a href=\"#JMX-type-consumer-coordinator-metrics\" class=\"headerlink\" title=\"JMX type=consumer-coordinator-metrics\"></a>JMX type=consumer-coordinator-metrics</h3><p>sync-time-avg</p>\n<p>sync-rate</p>\n<p>commit-latency-avg</p>\n<p>assigned-partitions</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"Broker\"><a href=\"#Broker\" class=\"headerlink\" title=\"Broker\"></a>Broker</h1><h2 id=\"kafka集群和broker\"><a href=\"#kafka集群和broker\" class=\"headerlink\" title=\"kafka集群和broker\"></a>kafka集群和broker</h2><h2 id=\"Borker\"><a href=\"#Borker\" class=\"headerlink\" title=\"Borker\"></a>Borker</h2><h2 id=\"Topic\"><a href=\"#Topic\" class=\"headerlink\" title=\"Topic\"></a>Topic</h2><h1 id=\"客户端\"><a href=\"#客户端\" class=\"headerlink\" title=\"客户端\"></a>客户端</h1><h2 id=\"生产者\"><a href=\"#生产者\" class=\"headerlink\" title=\"生产者\"></a>生产者</h2><h3 id=\"JMX-type-producer-metrics\"><a href=\"#JMX-type-producer-metrics\" class=\"headerlink\" title=\"JMX type=producer-metrics\"></a>JMX type=producer-metrics</h3><p>record-error-rate</p>\n<p>record-retry-rate</p>\n<p>request-latency-avg</p>\n<p>outgoing-byte-rate</p>\n<p>record-send-rate</p>\n<p>request-rate</p>\n<p>request-size-avg</p>\n<p>batch-size-avg</p>\n<p>record-size-avg</p>\n<p>records-per-request-avg</p>\n<p>record-queue-time-avg</p>\n<h2 id=\"消费者\"><a href=\"#消费者\" class=\"headerlink\" title=\"消费者\"></a>消费者</h2><h3 id=\"JMX-type-consumer-fetch-manager-metrics\"><a href=\"#JMX-type-consumer-fetch-manager-metrics\" class=\"headerlink\" title=\"JMX type=consumer-fetch-manager-metrics\"></a>JMX type=consumer-fetch-manager-metrics</h3><p>fetch-latency-avg</p>\n<p>records-lag-max</p>\n<p>bytes-consumed-rate</p>\n<p>records-consumed-rate</p>\n<p>fetch-rate</p>\n<p>fetch-size-avg</p>\n<p>records-per-request-avg</p>\n<h3 id=\"JMX-type-consumer-coordinator-metrics\"><a href=\"#JMX-type-consumer-coordinator-metrics\" class=\"headerlink\" title=\"JMX type=consumer-coordinator-metrics\"></a>JMX type=consumer-coordinator-metrics</h3><p>sync-time-avg</p>\n<p>sync-rate</p>\n<p>commit-latency-avg</p>\n<p>assigned-partitions</p>\n"},{"title":"Java应用层实现MySQL读写分离","date":"2022-07-02T04:49:00.000Z","_content":"\n# 设计\n\n实现读写分离一般有4种机制：\n\n1. 应用层实现（借助Spring的[AbstractRoutingDataSource](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/jdbc/datasource/lookup/AbstractRoutingDataSource.html)）。\n2. 框架层（如[sharding-jdbc](https://shardingsphere.apache.org/document/4.1.0/cn/manual/sharding-jdbc/)，[tddl](https://github.com/alibaba/tb_tddl)）。 \n3. 中间件层（如[mycat](http://www.mycat.org.cn/)）。\n4. 数据库/分布式存储本身支持，如分布式数据库或newSQL，如[MySQL Cluster](https://en.wikipedia.org/wiki/MySQL_Cluster)，[OceanBase](https://www.oceanbase.com/)，Redis Cluster等。\n\n本文主要分析应用层实现读写分离思路。读写分离实现思路：配置多个读写数据源，通过当前DAO层请求方法判断当前应该请求的数据源类型，如果是读方法，那么请求读库，如果是写方法，那么请求写库，如果一个方法既有读和写，那么写后读全部走写库，从而避免主从延迟带来数据一致问题。\n\n应用层实现读写分离/垂直分库分表是简单的事情，但是应用层实现水平分库分表却是一个复杂问题，我曾经的项目是先遇到读写分离问题，于是自己应用层实现，然后遇到了分库分表问题，采用了sharding-jdbc的方案，该方案即解决了读写分离，也解决了分库分表。\n\n# 实现\n\n## 配置多数据源\n\n配置包含读写的数据源，主库命名**ds-write**，写库命名**ds-read**.\n\n## 判断当前读写方法\n\n通过Spring的AOP拦截DAO层请求方法，如下：\n\n```java\n@Aspect\n@Order(1)\n@Component\npublic class DataSourceAop {\n    @Pointcut(\"execution(* com.dao..*.*(..))\")\n    public void changeDataSource() {\n    }\n\n    @Before(\"changeDataSource()\")\n    public void changeDataSource(JoinPoint joinPoint) {\n        //切换主库或者从库\n        DataSourceInterceptor.changeDataSource(joinPoint);\n    }\n\n   \n    @After(\"changeDataSource()\")\n    public void clearDataSource(JoinPoint point) {\n        //方法离开DAO层要清除当前数据源，但是不会清除使用过的是主还是从\n        DataSourceInterceptor.removeDataSource(point);\n    }\n```\n\n\n\n## 切换主库的实现\n\n```java\npublic class DataSourceInterceptor {\n    //指定只读的方法(人为指定，如selectXXX，findXXX，getXXX)\n    private static List<String> READ_METHODS = Lists.newArrayList(\"selectXXX\");\n    //标识当前线程是否使用过主库\n    private static ThreadLocal<Boolean> masterFlag = new ThreadLocal<Boolean>();\n    \n    public static void changeDataSource(JoinPoint jp) {\n        String dataSource = \"ds-write\";\n        //当前线程如果写过主库，那么后面的请求均走主库\n        String methodName = jp.getSignature().getName();\n        if (!isMasterAccess() && READ_METHODS.contains(methodName)) {\n            dataSource = \"ds-read\";\n        } else {\n            setMasterFlag(true);\n        };\n        //设置最新的数据源\n        DataSourcetHolder.setDataSource(dataSource);\n    }\n    \n    public static boolean isMasterAccess() {\n        return masterFlag.get() == null ? false : masterFlag.get();\n    }\n    \n    public static void removeDataSource(JoinPoint jp) {\n        DataSourcetHolder.clearDataCourse();\n    }\n}\n```\n\n\n\n## 设置最新的数据源\n\n设置最新的数据源到**ThreadLocal**里面\n\n```java\n//用于存储数据源的名字，以方便获取当前数据源进行切换。\npublic class DataSourcetHolder {\n    private static final ThreadLocal<String> holder = new ThreadLocal<String>();\n\n    public static void setDataSource(String dsName) {\n        holder.set(dsName);\n    }\n\n    public static String currentDataSource() {\n        return holder.get();\n    }\n\n    public static void clearDataCourse() {\n        holder.remove();\n    }\n}\n```\n\n## 动态数据源切换\n\n动态数据源借助Spring的**AbstractRoutingDataSource**类来实现切换：\n\n```java\npublic class DynamicDataSource extends AbstractRoutingDataSource {\n\n\t@Override\n\tprotected Object determineCurrentLookupKey() {\n        //获取最新的数据源名字\n\t\treturn DataSourcetHolder.currentDataSource();\n\t}\n}\n```\n\n# 总结\n\n## 复制与延迟\n\n副本冗余的主从复制一定会带来数据一致性问题，由于不同系统的复制模型不同，所以不同系统保证的一致性级别不同。MySQL默认复制是异步复制，所以数据一致性问题是典型的最终一致性，一致性窗口时间没有确定性保证，而强制写后读走主库，属于会话Sticky，类似于一种会话一致性（非严格，因为读别人写不一定最新）或者读自己写一致性，但是在ShardingJDBC中，程序开始就设置HintManager.setMasterRouteOnly()，那么整个会话都走主库，所以保证会话一致性。由于MySQL异步复制由于采用从节点拉取主节点binlog，而不是主节点主动推送复制数据，所以从库会挂了而主库依旧不知道。我曾经在测试环境遇到从库挂了好几天的[情况](https://blog.51cto.com/thinklili/2591474)，主库依旧在工作。所以一致性几乎发生故障情况下不可保证。所以MySQL异步复制下，既有主库也有从库请求，一般是写后读全部查主库。但是如果MySQL配置的是全同步/半同步复制，那么数据一致性问题就会减弱，但是会导致严重性能问题。这是典型的PACELC的权衡。在没有发生网络分区或其他故障情况下，延迟和一致性的权衡。\n\n复制会带来一致性问题，不同复制模型带来的一致性问题不同，而一致性问题通过和顺序存在关系。复制，一致性，顺序，共识存在深刻的联系。理解这些关系，对理解系统限制会有帮助。\n\n## 分库，分表，读写分离，水平垂直\n\n对于一个数据表的设计，需要考虑是否分库，是否分表，是否读写分离，水平还是垂直。而每种选择意味着不同的设计，总共有16种可能性。分库(Y/N) **×** 分表(Y/N) **×** 读写分离(Y/N) **×** 水平或垂直 = 16种。但是如果读写分离是必须的，那么其实有8种选择。而8种选择里面，垂直是较少的，所以大部分是水平的，其实就剩下了4种，实际需要根据不同情况进行选择。\n\n# 参考\n\n1. MySQL半同步复制（ *https://dev.mysql.com/doc/refman/8.0/en/replication-semisync.html* ）\n1. Jepsen一致性模型（ *https://jepsen.io/consistency* ）\n","source":"_posts/java-impl-rw-separate.md","raw":"---\ntitle: Java应用层实现MySQL读写分离\ndate: 2022-07-02 12:49:00\ntags:\n  - 读写分离\n  - 应用设计\ncategories:\n  - 数据库\n---\n\n# 设计\n\n实现读写分离一般有4种机制：\n\n1. 应用层实现（借助Spring的[AbstractRoutingDataSource](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/jdbc/datasource/lookup/AbstractRoutingDataSource.html)）。\n2. 框架层（如[sharding-jdbc](https://shardingsphere.apache.org/document/4.1.0/cn/manual/sharding-jdbc/)，[tddl](https://github.com/alibaba/tb_tddl)）。 \n3. 中间件层（如[mycat](http://www.mycat.org.cn/)）。\n4. 数据库/分布式存储本身支持，如分布式数据库或newSQL，如[MySQL Cluster](https://en.wikipedia.org/wiki/MySQL_Cluster)，[OceanBase](https://www.oceanbase.com/)，Redis Cluster等。\n\n本文主要分析应用层实现读写分离思路。读写分离实现思路：配置多个读写数据源，通过当前DAO层请求方法判断当前应该请求的数据源类型，如果是读方法，那么请求读库，如果是写方法，那么请求写库，如果一个方法既有读和写，那么写后读全部走写库，从而避免主从延迟带来数据一致问题。\n\n应用层实现读写分离/垂直分库分表是简单的事情，但是应用层实现水平分库分表却是一个复杂问题，我曾经的项目是先遇到读写分离问题，于是自己应用层实现，然后遇到了分库分表问题，采用了sharding-jdbc的方案，该方案即解决了读写分离，也解决了分库分表。\n\n# 实现\n\n## 配置多数据源\n\n配置包含读写的数据源，主库命名**ds-write**，写库命名**ds-read**.\n\n## 判断当前读写方法\n\n通过Spring的AOP拦截DAO层请求方法，如下：\n\n```java\n@Aspect\n@Order(1)\n@Component\npublic class DataSourceAop {\n    @Pointcut(\"execution(* com.dao..*.*(..))\")\n    public void changeDataSource() {\n    }\n\n    @Before(\"changeDataSource()\")\n    public void changeDataSource(JoinPoint joinPoint) {\n        //切换主库或者从库\n        DataSourceInterceptor.changeDataSource(joinPoint);\n    }\n\n   \n    @After(\"changeDataSource()\")\n    public void clearDataSource(JoinPoint point) {\n        //方法离开DAO层要清除当前数据源，但是不会清除使用过的是主还是从\n        DataSourceInterceptor.removeDataSource(point);\n    }\n```\n\n\n\n## 切换主库的实现\n\n```java\npublic class DataSourceInterceptor {\n    //指定只读的方法(人为指定，如selectXXX，findXXX，getXXX)\n    private static List<String> READ_METHODS = Lists.newArrayList(\"selectXXX\");\n    //标识当前线程是否使用过主库\n    private static ThreadLocal<Boolean> masterFlag = new ThreadLocal<Boolean>();\n    \n    public static void changeDataSource(JoinPoint jp) {\n        String dataSource = \"ds-write\";\n        //当前线程如果写过主库，那么后面的请求均走主库\n        String methodName = jp.getSignature().getName();\n        if (!isMasterAccess() && READ_METHODS.contains(methodName)) {\n            dataSource = \"ds-read\";\n        } else {\n            setMasterFlag(true);\n        };\n        //设置最新的数据源\n        DataSourcetHolder.setDataSource(dataSource);\n    }\n    \n    public static boolean isMasterAccess() {\n        return masterFlag.get() == null ? false : masterFlag.get();\n    }\n    \n    public static void removeDataSource(JoinPoint jp) {\n        DataSourcetHolder.clearDataCourse();\n    }\n}\n```\n\n\n\n## 设置最新的数据源\n\n设置最新的数据源到**ThreadLocal**里面\n\n```java\n//用于存储数据源的名字，以方便获取当前数据源进行切换。\npublic class DataSourcetHolder {\n    private static final ThreadLocal<String> holder = new ThreadLocal<String>();\n\n    public static void setDataSource(String dsName) {\n        holder.set(dsName);\n    }\n\n    public static String currentDataSource() {\n        return holder.get();\n    }\n\n    public static void clearDataCourse() {\n        holder.remove();\n    }\n}\n```\n\n## 动态数据源切换\n\n动态数据源借助Spring的**AbstractRoutingDataSource**类来实现切换：\n\n```java\npublic class DynamicDataSource extends AbstractRoutingDataSource {\n\n\t@Override\n\tprotected Object determineCurrentLookupKey() {\n        //获取最新的数据源名字\n\t\treturn DataSourcetHolder.currentDataSource();\n\t}\n}\n```\n\n# 总结\n\n## 复制与延迟\n\n副本冗余的主从复制一定会带来数据一致性问题，由于不同系统的复制模型不同，所以不同系统保证的一致性级别不同。MySQL默认复制是异步复制，所以数据一致性问题是典型的最终一致性，一致性窗口时间没有确定性保证，而强制写后读走主库，属于会话Sticky，类似于一种会话一致性（非严格，因为读别人写不一定最新）或者读自己写一致性，但是在ShardingJDBC中，程序开始就设置HintManager.setMasterRouteOnly()，那么整个会话都走主库，所以保证会话一致性。由于MySQL异步复制由于采用从节点拉取主节点binlog，而不是主节点主动推送复制数据，所以从库会挂了而主库依旧不知道。我曾经在测试环境遇到从库挂了好几天的[情况](https://blog.51cto.com/thinklili/2591474)，主库依旧在工作。所以一致性几乎发生故障情况下不可保证。所以MySQL异步复制下，既有主库也有从库请求，一般是写后读全部查主库。但是如果MySQL配置的是全同步/半同步复制，那么数据一致性问题就会减弱，但是会导致严重性能问题。这是典型的PACELC的权衡。在没有发生网络分区或其他故障情况下，延迟和一致性的权衡。\n\n复制会带来一致性问题，不同复制模型带来的一致性问题不同，而一致性问题通过和顺序存在关系。复制，一致性，顺序，共识存在深刻的联系。理解这些关系，对理解系统限制会有帮助。\n\n## 分库，分表，读写分离，水平垂直\n\n对于一个数据表的设计，需要考虑是否分库，是否分表，是否读写分离，水平还是垂直。而每种选择意味着不同的设计，总共有16种可能性。分库(Y/N) **×** 分表(Y/N) **×** 读写分离(Y/N) **×** 水平或垂直 = 16种。但是如果读写分离是必须的，那么其实有8种选择。而8种选择里面，垂直是较少的，所以大部分是水平的，其实就剩下了4种，实际需要根据不同情况进行选择。\n\n# 参考\n\n1. MySQL半同步复制（ *https://dev.mysql.com/doc/refman/8.0/en/replication-semisync.html* ）\n1. Jepsen一致性模型（ *https://jepsen.io/consistency* ）\n","slug":"java-impl-rw-separate","published":1,"updated":"2022-07-04T04:10:38.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clh7s5cu4001zxt8ja4m03ej6","content":"<h1 id=\"设计\"><a href=\"#设计\" class=\"headerlink\" title=\"设计\"></a>设计</h1><p>实现读写分离一般有4种机制：</p>\n<ol>\n<li>应用层实现（借助Spring的<a href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/jdbc/datasource/lookup/AbstractRoutingDataSource.html\" target=\"_blank\" rel=\"noopener\">AbstractRoutingDataSource</a>）。</li>\n<li>框架层（如<a href=\"https://shardingsphere.apache.org/document/4.1.0/cn/manual/sharding-jdbc/\" target=\"_blank\" rel=\"noopener\">sharding-jdbc</a>，<a href=\"https://github.com/alibaba/tb_tddl\" target=\"_blank\" rel=\"noopener\">tddl</a>）。 </li>\n<li>中间件层（如<a href=\"http://www.mycat.org.cn/\" target=\"_blank\" rel=\"noopener\">mycat</a>）。</li>\n<li>数据库/分布式存储本身支持，如分布式数据库或newSQL，如<a href=\"https://en.wikipedia.org/wiki/MySQL_Cluster\" target=\"_blank\" rel=\"noopener\">MySQL Cluster</a>，<a href=\"https://www.oceanbase.com/\" target=\"_blank\" rel=\"noopener\">OceanBase</a>，Redis Cluster等。</li>\n</ol>\n<p>本文主要分析应用层实现读写分离思路。读写分离实现思路：配置多个读写数据源，通过当前DAO层请求方法判断当前应该请求的数据源类型，如果是读方法，那么请求读库，如果是写方法，那么请求写库，如果一个方法既有读和写，那么写后读全部走写库，从而避免主从延迟带来数据一致问题。</p>\n<p>应用层实现读写分离/垂直分库分表是简单的事情，但是应用层实现水平分库分表却是一个复杂问题，我曾经的项目是先遇到读写分离问题，于是自己应用层实现，然后遇到了分库分表问题，采用了sharding-jdbc的方案，该方案即解决了读写分离，也解决了分库分表。</p>\n<h1 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h1><h2 id=\"配置多数据源\"><a href=\"#配置多数据源\" class=\"headerlink\" title=\"配置多数据源\"></a>配置多数据源</h2><p>配置包含读写的数据源，主库命名<strong>ds-write</strong>，写库命名<strong>ds-read</strong>.</p>\n<h2 id=\"判断当前读写方法\"><a href=\"#判断当前读写方法\" class=\"headerlink\" title=\"判断当前读写方法\"></a>判断当前读写方法</h2><p>通过Spring的AOP拦截DAO层请求方法，如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"meta\">@Order</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DataSourceAop</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Pointcut</span>(<span class=\"string\">\"execution(* com.dao..*.*(..))\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">changeDataSource</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Before</span>(<span class=\"string\">\"changeDataSource()\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">changeDataSource</span><span class=\"params\">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//切换主库或者从库</span></span><br><span class=\"line\">        DataSourceInterceptor.changeDataSource(joinPoint);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"meta\">@After</span>(<span class=\"string\">\"changeDataSource()\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">clearDataSource</span><span class=\"params\">(JoinPoint point)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//方法离开DAO层要清除当前数据源，但是不会清除使用过的是主还是从</span></span><br><span class=\"line\">        DataSourceInterceptor.removeDataSource(point);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"切换主库的实现\"><a href=\"#切换主库的实现\" class=\"headerlink\" title=\"切换主库的实现\"></a>切换主库的实现</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DataSourceInterceptor</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//指定只读的方法(人为指定，如selectXXX，findXXX，getXXX)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> List&lt;String&gt; READ_METHODS = Lists.newArrayList(<span class=\"string\">\"selectXXX\"</span>);</span><br><span class=\"line\">    <span class=\"comment\">//标识当前线程是否使用过主库</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> ThreadLocal&lt;Boolean&gt; masterFlag = <span class=\"keyword\">new</span> ThreadLocal&lt;Boolean&gt;();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">changeDataSource</span><span class=\"params\">(JoinPoint jp)</span> </span>&#123;</span><br><span class=\"line\">        String dataSource = <span class=\"string\">\"ds-write\"</span>;</span><br><span class=\"line\">        <span class=\"comment\">//当前线程如果写过主库，那么后面的请求均走主库</span></span><br><span class=\"line\">        String methodName = jp.getSignature().getName();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!isMasterAccess() &amp;&amp; READ_METHODS.contains(methodName)) &#123;</span><br><span class=\"line\">            dataSource = <span class=\"string\">\"ds-read\"</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            setMasterFlag(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"comment\">//设置最新的数据源</span></span><br><span class=\"line\">        DataSourcetHolder.setDataSource(dataSource);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isMasterAccess</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> masterFlag.get() == <span class=\"keyword\">null</span> ? <span class=\"keyword\">false</span> : masterFlag.get();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">removeDataSource</span><span class=\"params\">(JoinPoint jp)</span> </span>&#123;</span><br><span class=\"line\">        DataSourcetHolder.clearDataCourse();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"设置最新的数据源\"><a href=\"#设置最新的数据源\" class=\"headerlink\" title=\"设置最新的数据源\"></a>设置最新的数据源</h2><p>设置最新的数据源到<strong>ThreadLocal</strong>里面</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//用于存储数据源的名字，以方便获取当前数据源进行切换。</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DataSourcetHolder</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ThreadLocal&lt;String&gt; holder = <span class=\"keyword\">new</span> ThreadLocal&lt;String&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">setDataSource</span><span class=\"params\">(String dsName)</span> </span>&#123;</span><br><span class=\"line\">        holder.set(dsName);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">currentDataSource</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> holder.get();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">clearDataCourse</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        holder.remove();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"动态数据源切换\"><a href=\"#动态数据源切换\" class=\"headerlink\" title=\"动态数据源切换\"></a>动态数据源切换</h2><p>动态数据源借助Spring的<strong>AbstractRoutingDataSource</strong>类来实现切换：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DynamicDataSource</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractRoutingDataSource</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">protected</span> Object <span class=\"title\">determineCurrentLookupKey</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//获取最新的数据源名字</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> DataSourcetHolder.currentDataSource();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><h2 id=\"复制与延迟\"><a href=\"#复制与延迟\" class=\"headerlink\" title=\"复制与延迟\"></a>复制与延迟</h2><p>副本冗余的主从复制一定会带来数据一致性问题，由于不同系统的复制模型不同，所以不同系统保证的一致性级别不同。MySQL默认复制是异步复制，所以数据一致性问题是典型的最终一致性，一致性窗口时间没有确定性保证，而强制写后读走主库，属于会话Sticky，类似于一种会话一致性（非严格，因为读别人写不一定最新）或者读自己写一致性，但是在ShardingJDBC中，程序开始就设置HintManager.setMasterRouteOnly()，那么整个会话都走主库，所以保证会话一致性。由于MySQL异步复制由于采用从节点拉取主节点binlog，而不是主节点主动推送复制数据，所以从库会挂了而主库依旧不知道。我曾经在测试环境遇到从库挂了好几天的<a href=\"https://blog.51cto.com/thinklili/2591474\" target=\"_blank\" rel=\"noopener\">情况</a>，主库依旧在工作。所以一致性几乎发生故障情况下不可保证。所以MySQL异步复制下，既有主库也有从库请求，一般是写后读全部查主库。但是如果MySQL配置的是全同步/半同步复制，那么数据一致性问题就会减弱，但是会导致严重性能问题。这是典型的PACELC的权衡。在没有发生网络分区或其他故障情况下，延迟和一致性的权衡。</p>\n<p>复制会带来一致性问题，不同复制模型带来的一致性问题不同，而一致性问题通过和顺序存在关系。复制，一致性，顺序，共识存在深刻的联系。理解这些关系，对理解系统限制会有帮助。</p>\n<h2 id=\"分库，分表，读写分离，水平垂直\"><a href=\"#分库，分表，读写分离，水平垂直\" class=\"headerlink\" title=\"分库，分表，读写分离，水平垂直\"></a>分库，分表，读写分离，水平垂直</h2><p>对于一个数据表的设计，需要考虑是否分库，是否分表，是否读写分离，水平还是垂直。而每种选择意味着不同的设计，总共有16种可能性。分库(Y/N) <strong>×</strong> 分表(Y/N) <strong>×</strong> 读写分离(Y/N) <strong>×</strong> 水平或垂直 = 16种。但是如果读写分离是必须的，那么其实有8种选择。而8种选择里面，垂直是较少的，所以大部分是水平的，其实就剩下了4种，实际需要根据不同情况进行选择。</p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><ol>\n<li>MySQL半同步复制（ <em><a href=\"https://dev.mysql.com/doc/refman/8.0/en/replication-semisync.html\" target=\"_blank\" rel=\"noopener\">https://dev.mysql.com/doc/refman/8.0/en/replication-semisync.html</a></em> ）</li>\n<li>Jepsen一致性模型（ <em><a href=\"https://jepsen.io/consistency\" target=\"_blank\" rel=\"noopener\">https://jepsen.io/consistency</a></em> ）</li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"设计\"><a href=\"#设计\" class=\"headerlink\" title=\"设计\"></a>设计</h1><p>实现读写分离一般有4种机制：</p>\n<ol>\n<li>应用层实现（借助Spring的<a href=\"https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/jdbc/datasource/lookup/AbstractRoutingDataSource.html\" target=\"_blank\" rel=\"noopener\">AbstractRoutingDataSource</a>）。</li>\n<li>框架层（如<a href=\"https://shardingsphere.apache.org/document/4.1.0/cn/manual/sharding-jdbc/\" target=\"_blank\" rel=\"noopener\">sharding-jdbc</a>，<a href=\"https://github.com/alibaba/tb_tddl\" target=\"_blank\" rel=\"noopener\">tddl</a>）。 </li>\n<li>中间件层（如<a href=\"http://www.mycat.org.cn/\" target=\"_blank\" rel=\"noopener\">mycat</a>）。</li>\n<li>数据库/分布式存储本身支持，如分布式数据库或newSQL，如<a href=\"https://en.wikipedia.org/wiki/MySQL_Cluster\" target=\"_blank\" rel=\"noopener\">MySQL Cluster</a>，<a href=\"https://www.oceanbase.com/\" target=\"_blank\" rel=\"noopener\">OceanBase</a>，Redis Cluster等。</li>\n</ol>\n<p>本文主要分析应用层实现读写分离思路。读写分离实现思路：配置多个读写数据源，通过当前DAO层请求方法判断当前应该请求的数据源类型，如果是读方法，那么请求读库，如果是写方法，那么请求写库，如果一个方法既有读和写，那么写后读全部走写库，从而避免主从延迟带来数据一致问题。</p>\n<p>应用层实现读写分离/垂直分库分表是简单的事情，但是应用层实现水平分库分表却是一个复杂问题，我曾经的项目是先遇到读写分离问题，于是自己应用层实现，然后遇到了分库分表问题，采用了sharding-jdbc的方案，该方案即解决了读写分离，也解决了分库分表。</p>\n<h1 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h1><h2 id=\"配置多数据源\"><a href=\"#配置多数据源\" class=\"headerlink\" title=\"配置多数据源\"></a>配置多数据源</h2><p>配置包含读写的数据源，主库命名<strong>ds-write</strong>，写库命名<strong>ds-read</strong>.</p>\n<h2 id=\"判断当前读写方法\"><a href=\"#判断当前读写方法\" class=\"headerlink\" title=\"判断当前读写方法\"></a>判断当前读写方法</h2><p>通过Spring的AOP拦截DAO层请求方法，如下：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Aspect</span></span><br><span class=\"line\"><span class=\"meta\">@Order</span>(<span class=\"number\">1</span>)</span><br><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DataSourceAop</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Pointcut</span>(<span class=\"string\">\"execution(* com.dao..*.*(..))\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">changeDataSource</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Before</span>(<span class=\"string\">\"changeDataSource()\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">changeDataSource</span><span class=\"params\">(JoinPoint joinPoint)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//切换主库或者从库</span></span><br><span class=\"line\">        DataSourceInterceptor.changeDataSource(joinPoint);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"meta\">@After</span>(<span class=\"string\">\"changeDataSource()\"</span>)</span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">clearDataSource</span><span class=\"params\">(JoinPoint point)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//方法离开DAO层要清除当前数据源，但是不会清除使用过的是主还是从</span></span><br><span class=\"line\">        DataSourceInterceptor.removeDataSource(point);</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"切换主库的实现\"><a href=\"#切换主库的实现\" class=\"headerlink\" title=\"切换主库的实现\"></a>切换主库的实现</h2><figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DataSourceInterceptor</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//指定只读的方法(人为指定，如selectXXX，findXXX，getXXX)</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> List&lt;String&gt; READ_METHODS = Lists.newArrayList(<span class=\"string\">\"selectXXX\"</span>);</span><br><span class=\"line\">    <span class=\"comment\">//标识当前线程是否使用过主库</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> ThreadLocal&lt;Boolean&gt; masterFlag = <span class=\"keyword\">new</span> ThreadLocal&lt;Boolean&gt;();</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">changeDataSource</span><span class=\"params\">(JoinPoint jp)</span> </span>&#123;</span><br><span class=\"line\">        String dataSource = <span class=\"string\">\"ds-write\"</span>;</span><br><span class=\"line\">        <span class=\"comment\">//当前线程如果写过主库，那么后面的请求均走主库</span></span><br><span class=\"line\">        String methodName = jp.getSignature().getName();</span><br><span class=\"line\">        <span class=\"keyword\">if</span> (!isMasterAccess() &amp;&amp; READ_METHODS.contains(methodName)) &#123;</span><br><span class=\"line\">            dataSource = <span class=\"string\">\"ds-read\"</span>;</span><br><span class=\"line\">        &#125; <span class=\"keyword\">else</span> &#123;</span><br><span class=\"line\">            setMasterFlag(<span class=\"keyword\">true</span>);</span><br><span class=\"line\">        &#125;;</span><br><span class=\"line\">        <span class=\"comment\">//设置最新的数据源</span></span><br><span class=\"line\">        DataSourcetHolder.setDataSource(dataSource);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">boolean</span> <span class=\"title\">isMasterAccess</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> masterFlag.get() == <span class=\"keyword\">null</span> ? <span class=\"keyword\">false</span> : masterFlag.get();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">    </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">removeDataSource</span><span class=\"params\">(JoinPoint jp)</span> </span>&#123;</span><br><span class=\"line\">        DataSourcetHolder.clearDataCourse();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"设置最新的数据源\"><a href=\"#设置最新的数据源\" class=\"headerlink\" title=\"设置最新的数据源\"></a>设置最新的数据源</h2><p>设置最新的数据源到<strong>ThreadLocal</strong>里面</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"comment\">//用于存储数据源的名字，以方便获取当前数据源进行切换。</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DataSourcetHolder</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> <span class=\"keyword\">static</span> <span class=\"keyword\">final</span> ThreadLocal&lt;String&gt; holder = <span class=\"keyword\">new</span> ThreadLocal&lt;String&gt;();</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">setDataSource</span><span class=\"params\">(String dsName)</span> </span>&#123;</span><br><span class=\"line\">        holder.set(dsName);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> String <span class=\"title\">currentDataSource</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> holder.get();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">static</span> <span class=\"keyword\">void</span> <span class=\"title\">clearDataCourse</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        holder.remove();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h2 id=\"动态数据源切换\"><a href=\"#动态数据源切换\" class=\"headerlink\" title=\"动态数据源切换\"></a>动态数据源切换</h2><p>动态数据源借助Spring的<strong>AbstractRoutingDataSource</strong>类来实现切换：</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">DynamicDataSource</span> <span class=\"keyword\">extends</span> <span class=\"title\">AbstractRoutingDataSource</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">\t<span class=\"meta\">@Override</span></span><br><span class=\"line\">\t<span class=\"function\"><span class=\"keyword\">protected</span> Object <span class=\"title\">determineCurrentLookupKey</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"comment\">//获取最新的数据源名字</span></span><br><span class=\"line\">\t\t<span class=\"keyword\">return</span> DataSourcetHolder.currentDataSource();</span><br><span class=\"line\">\t&#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><h2 id=\"复制与延迟\"><a href=\"#复制与延迟\" class=\"headerlink\" title=\"复制与延迟\"></a>复制与延迟</h2><p>副本冗余的主从复制一定会带来数据一致性问题，由于不同系统的复制模型不同，所以不同系统保证的一致性级别不同。MySQL默认复制是异步复制，所以数据一致性问题是典型的最终一致性，一致性窗口时间没有确定性保证，而强制写后读走主库，属于会话Sticky，类似于一种会话一致性（非严格，因为读别人写不一定最新）或者读自己写一致性，但是在ShardingJDBC中，程序开始就设置HintManager.setMasterRouteOnly()，那么整个会话都走主库，所以保证会话一致性。由于MySQL异步复制由于采用从节点拉取主节点binlog，而不是主节点主动推送复制数据，所以从库会挂了而主库依旧不知道。我曾经在测试环境遇到从库挂了好几天的<a href=\"https://blog.51cto.com/thinklili/2591474\" target=\"_blank\" rel=\"noopener\">情况</a>，主库依旧在工作。所以一致性几乎发生故障情况下不可保证。所以MySQL异步复制下，既有主库也有从库请求，一般是写后读全部查主库。但是如果MySQL配置的是全同步/半同步复制，那么数据一致性问题就会减弱，但是会导致严重性能问题。这是典型的PACELC的权衡。在没有发生网络分区或其他故障情况下，延迟和一致性的权衡。</p>\n<p>复制会带来一致性问题，不同复制模型带来的一致性问题不同，而一致性问题通过和顺序存在关系。复制，一致性，顺序，共识存在深刻的联系。理解这些关系，对理解系统限制会有帮助。</p>\n<h2 id=\"分库，分表，读写分离，水平垂直\"><a href=\"#分库，分表，读写分离，水平垂直\" class=\"headerlink\" title=\"分库，分表，读写分离，水平垂直\"></a>分库，分表，读写分离，水平垂直</h2><p>对于一个数据表的设计，需要考虑是否分库，是否分表，是否读写分离，水平还是垂直。而每种选择意味着不同的设计，总共有16种可能性。分库(Y/N) <strong>×</strong> 分表(Y/N) <strong>×</strong> 读写分离(Y/N) <strong>×</strong> 水平或垂直 = 16种。但是如果读写分离是必须的，那么其实有8种选择。而8种选择里面，垂直是较少的，所以大部分是水平的，其实就剩下了4种，实际需要根据不同情况进行选择。</p>\n<h1 id=\"参考\"><a href=\"#参考\" class=\"headerlink\" title=\"参考\"></a>参考</h1><ol>\n<li>MySQL半同步复制（ <em><a href=\"https://dev.mysql.com/doc/refman/8.0/en/replication-semisync.html\" target=\"_blank\" rel=\"noopener\">https://dev.mysql.com/doc/refman/8.0/en/replication-semisync.html</a></em> ）</li>\n<li>Jepsen一致性模型（ <em><a href=\"https://jepsen.io/consistency\" target=\"_blank\" rel=\"noopener\">https://jepsen.io/consistency</a></em> ）</li>\n</ol>\n"},{"title":"kafka系列1-设计与实现","date":"2022-01-08T13:18:44.000Z","comments":1,"_content":"\n\n\n\n\n# 核心概念\n\n\n\n\n\n# 设计\n\n## 动机\n\n## 持久化\n\n### 不要害怕文件系统！\n\n### 常量时间足够了\n\n\n\n## 效率\n\n### 端到端批量压缩\n\n## 生产者\n\n### 负载均衡\n\n### 异步发送\n\n\n\n## 消费者\n\n### 推VS拉\n\n### 消费者位置\n\n### 离线数据加载\n\n### 静态成员关系\n\n\n\n## 消息传递语义\n\n## 复制\n\n### 复制日志：Quorums,ISRs,State Machines(天啊)\n\n\n\n### 未完成的领导选举：如果他们全部挂了呢？\n\n\n\n### 可用性和持久化保证\n\n\n\n### 复制管理\n\n\n\n\n\n\n\n## 日志压缩\n\n### 日志压缩基础\n\n\n\n### 日志压缩提供了什么样的保证？\n\n\n\n\n\n### 日志压缩细节\n\n\n\n\n\n### 配置日志清理器\n\n\n\n\n\n\n\n\n\n## 配额\n\n### 为什么配额是必须的？\n\n\n\n### 客户端组\n\n\n\n### 配额配置\n\n\n\n\n\n### 网络带宽的配额\n\n\n\n### 请求速率的带宽\n\n\n\n\n\n### 强制\n\n\n\n\n\n# 实现\n\n## 网络层\n\n## 消息\n\n## 消息格式\n\n### 批记录\n\n#### 控制批次\n\n\n\n### 记录\n\n#### 记录头\n\n### 旧版消息格式\n\n\n\n\n\n\n\n## 日志\n\n### 写入\n\n\n\n### 读取\n\n\n\n### 删除\n\n\n\n\n\n### 保证性\n\n\n\n\n\n\n\n\n\n## 分配\n\n### 消费者偏移追踪\n\n\n\n### Zookeeper目录\n\n\n\n### 表示法\n\n\n\n### Broker节点注册\n\n\n\n### Broker主题注册\n\n\n\n\n\n### 集群ID\n\n\n\n\n\n### Broker节点注册\n","source":"_posts/kafka-series1-design-and-implementation.md","raw":"---\ntitle: kafka系列1-设计与实现\ndate: 2022-01-08 21:18:44\ntags: \n  - kafka\ncategories:\n  - 消息中间件\n  - kafka\ncomments: true\n---\n\n\n\n\n\n# 核心概念\n\n\n\n\n\n# 设计\n\n## 动机\n\n## 持久化\n\n### 不要害怕文件系统！\n\n### 常量时间足够了\n\n\n\n## 效率\n\n### 端到端批量压缩\n\n## 生产者\n\n### 负载均衡\n\n### 异步发送\n\n\n\n## 消费者\n\n### 推VS拉\n\n### 消费者位置\n\n### 离线数据加载\n\n### 静态成员关系\n\n\n\n## 消息传递语义\n\n## 复制\n\n### 复制日志：Quorums,ISRs,State Machines(天啊)\n\n\n\n### 未完成的领导选举：如果他们全部挂了呢？\n\n\n\n### 可用性和持久化保证\n\n\n\n### 复制管理\n\n\n\n\n\n\n\n## 日志压缩\n\n### 日志压缩基础\n\n\n\n### 日志压缩提供了什么样的保证？\n\n\n\n\n\n### 日志压缩细节\n\n\n\n\n\n### 配置日志清理器\n\n\n\n\n\n\n\n\n\n## 配额\n\n### 为什么配额是必须的？\n\n\n\n### 客户端组\n\n\n\n### 配额配置\n\n\n\n\n\n### 网络带宽的配额\n\n\n\n### 请求速率的带宽\n\n\n\n\n\n### 强制\n\n\n\n\n\n# 实现\n\n## 网络层\n\n## 消息\n\n## 消息格式\n\n### 批记录\n\n#### 控制批次\n\n\n\n### 记录\n\n#### 记录头\n\n### 旧版消息格式\n\n\n\n\n\n\n\n## 日志\n\n### 写入\n\n\n\n### 读取\n\n\n\n### 删除\n\n\n\n\n\n### 保证性\n\n\n\n\n\n\n\n\n\n## 分配\n\n### 消费者偏移追踪\n\n\n\n### Zookeeper目录\n\n\n\n### 表示法\n\n\n\n### Broker节点注册\n\n\n\n### Broker主题注册\n\n\n\n\n\n### 集群ID\n\n\n\n\n\n### Broker节点注册\n","slug":"kafka-series1-design-and-implementation","published":1,"updated":"2022-06-29T05:53:30.000Z","layout":"post","photos":[],"link":"","_id":"clh7s5cu50022xt8jgru837ac","content":"<h1 id=\"核心概念\"><a href=\"#核心概念\" class=\"headerlink\" title=\"核心概念\"></a>核心概念</h1><h1 id=\"设计\"><a href=\"#设计\" class=\"headerlink\" title=\"设计\"></a>设计</h1><h2 id=\"动机\"><a href=\"#动机\" class=\"headerlink\" title=\"动机\"></a>动机</h2><h2 id=\"持久化\"><a href=\"#持久化\" class=\"headerlink\" title=\"持久化\"></a>持久化</h2><h3 id=\"不要害怕文件系统！\"><a href=\"#不要害怕文件系统！\" class=\"headerlink\" title=\"不要害怕文件系统！\"></a>不要害怕文件系统！</h3><h3 id=\"常量时间足够了\"><a href=\"#常量时间足够了\" class=\"headerlink\" title=\"常量时间足够了\"></a>常量时间足够了</h3><h2 id=\"效率\"><a href=\"#效率\" class=\"headerlink\" title=\"效率\"></a>效率</h2><h3 id=\"端到端批量压缩\"><a href=\"#端到端批量压缩\" class=\"headerlink\" title=\"端到端批量压缩\"></a>端到端批量压缩</h3><h2 id=\"生产者\"><a href=\"#生产者\" class=\"headerlink\" title=\"生产者\"></a>生产者</h2><h3 id=\"负载均衡\"><a href=\"#负载均衡\" class=\"headerlink\" title=\"负载均衡\"></a>负载均衡</h3><h3 id=\"异步发送\"><a href=\"#异步发送\" class=\"headerlink\" title=\"异步发送\"></a>异步发送</h3><h2 id=\"消费者\"><a href=\"#消费者\" class=\"headerlink\" title=\"消费者\"></a>消费者</h2><h3 id=\"推VS拉\"><a href=\"#推VS拉\" class=\"headerlink\" title=\"推VS拉\"></a>推VS拉</h3><h3 id=\"消费者位置\"><a href=\"#消费者位置\" class=\"headerlink\" title=\"消费者位置\"></a>消费者位置</h3><h3 id=\"离线数据加载\"><a href=\"#离线数据加载\" class=\"headerlink\" title=\"离线数据加载\"></a>离线数据加载</h3><h3 id=\"静态成员关系\"><a href=\"#静态成员关系\" class=\"headerlink\" title=\"静态成员关系\"></a>静态成员关系</h3><h2 id=\"消息传递语义\"><a href=\"#消息传递语义\" class=\"headerlink\" title=\"消息传递语义\"></a>消息传递语义</h2><h2 id=\"复制\"><a href=\"#复制\" class=\"headerlink\" title=\"复制\"></a>复制</h2><h3 id=\"复制日志：Quorums-ISRs-State-Machines-天啊\"><a href=\"#复制日志：Quorums-ISRs-State-Machines-天啊\" class=\"headerlink\" title=\"复制日志：Quorums,ISRs,State Machines(天啊)\"></a>复制日志：Quorums,ISRs,State Machines(天啊)</h3><h3 id=\"未完成的领导选举：如果他们全部挂了呢？\"><a href=\"#未完成的领导选举：如果他们全部挂了呢？\" class=\"headerlink\" title=\"未完成的领导选举：如果他们全部挂了呢？\"></a>未完成的领导选举：如果他们全部挂了呢？</h3><h3 id=\"可用性和持久化保证\"><a href=\"#可用性和持久化保证\" class=\"headerlink\" title=\"可用性和持久化保证\"></a>可用性和持久化保证</h3><h3 id=\"复制管理\"><a href=\"#复制管理\" class=\"headerlink\" title=\"复制管理\"></a>复制管理</h3><h2 id=\"日志压缩\"><a href=\"#日志压缩\" class=\"headerlink\" title=\"日志压缩\"></a>日志压缩</h2><h3 id=\"日志压缩基础\"><a href=\"#日志压缩基础\" class=\"headerlink\" title=\"日志压缩基础\"></a>日志压缩基础</h3><h3 id=\"日志压缩提供了什么样的保证？\"><a href=\"#日志压缩提供了什么样的保证？\" class=\"headerlink\" title=\"日志压缩提供了什么样的保证？\"></a>日志压缩提供了什么样的保证？</h3><h3 id=\"日志压缩细节\"><a href=\"#日志压缩细节\" class=\"headerlink\" title=\"日志压缩细节\"></a>日志压缩细节</h3><h3 id=\"配置日志清理器\"><a href=\"#配置日志清理器\" class=\"headerlink\" title=\"配置日志清理器\"></a>配置日志清理器</h3><h2 id=\"配额\"><a href=\"#配额\" class=\"headerlink\" title=\"配额\"></a>配额</h2><h3 id=\"为什么配额是必须的？\"><a href=\"#为什么配额是必须的？\" class=\"headerlink\" title=\"为什么配额是必须的？\"></a>为什么配额是必须的？</h3><h3 id=\"客户端组\"><a href=\"#客户端组\" class=\"headerlink\" title=\"客户端组\"></a>客户端组</h3><h3 id=\"配额配置\"><a href=\"#配额配置\" class=\"headerlink\" title=\"配额配置\"></a>配额配置</h3><h3 id=\"网络带宽的配额\"><a href=\"#网络带宽的配额\" class=\"headerlink\" title=\"网络带宽的配额\"></a>网络带宽的配额</h3><h3 id=\"请求速率的带宽\"><a href=\"#请求速率的带宽\" class=\"headerlink\" title=\"请求速率的带宽\"></a>请求速率的带宽</h3><h3 id=\"强制\"><a href=\"#强制\" class=\"headerlink\" title=\"强制\"></a>强制</h3><h1 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h1><h2 id=\"网络层\"><a href=\"#网络层\" class=\"headerlink\" title=\"网络层\"></a>网络层</h2><h2 id=\"消息\"><a href=\"#消息\" class=\"headerlink\" title=\"消息\"></a>消息</h2><h2 id=\"消息格式\"><a href=\"#消息格式\" class=\"headerlink\" title=\"消息格式\"></a>消息格式</h2><h3 id=\"批记录\"><a href=\"#批记录\" class=\"headerlink\" title=\"批记录\"></a>批记录</h3><h4 id=\"控制批次\"><a href=\"#控制批次\" class=\"headerlink\" title=\"控制批次\"></a>控制批次</h4><h3 id=\"记录\"><a href=\"#记录\" class=\"headerlink\" title=\"记录\"></a>记录</h3><h4 id=\"记录头\"><a href=\"#记录头\" class=\"headerlink\" title=\"记录头\"></a>记录头</h4><h3 id=\"旧版消息格式\"><a href=\"#旧版消息格式\" class=\"headerlink\" title=\"旧版消息格式\"></a>旧版消息格式</h3><h2 id=\"日志\"><a href=\"#日志\" class=\"headerlink\" title=\"日志\"></a>日志</h2><h3 id=\"写入\"><a href=\"#写入\" class=\"headerlink\" title=\"写入\"></a>写入</h3><h3 id=\"读取\"><a href=\"#读取\" class=\"headerlink\" title=\"读取\"></a>读取</h3><h3 id=\"删除\"><a href=\"#删除\" class=\"headerlink\" title=\"删除\"></a>删除</h3><h3 id=\"保证性\"><a href=\"#保证性\" class=\"headerlink\" title=\"保证性\"></a>保证性</h3><h2 id=\"分配\"><a href=\"#分配\" class=\"headerlink\" title=\"分配\"></a>分配</h2><h3 id=\"消费者偏移追踪\"><a href=\"#消费者偏移追踪\" class=\"headerlink\" title=\"消费者偏移追踪\"></a>消费者偏移追踪</h3><h3 id=\"Zookeeper目录\"><a href=\"#Zookeeper目录\" class=\"headerlink\" title=\"Zookeeper目录\"></a>Zookeeper目录</h3><h3 id=\"表示法\"><a href=\"#表示法\" class=\"headerlink\" title=\"表示法\"></a>表示法</h3><h3 id=\"Broker节点注册\"><a href=\"#Broker节点注册\" class=\"headerlink\" title=\"Broker节点注册\"></a>Broker节点注册</h3><h3 id=\"Broker主题注册\"><a href=\"#Broker主题注册\" class=\"headerlink\" title=\"Broker主题注册\"></a>Broker主题注册</h3><h3 id=\"集群ID\"><a href=\"#集群ID\" class=\"headerlink\" title=\"集群ID\"></a>集群ID</h3><h3 id=\"Broker节点注册-1\"><a href=\"#Broker节点注册-1\" class=\"headerlink\" title=\"Broker节点注册\"></a>Broker节点注册</h3>","site":{"data":{}},"excerpt":"","more":"<h1 id=\"核心概念\"><a href=\"#核心概念\" class=\"headerlink\" title=\"核心概念\"></a>核心概念</h1><h1 id=\"设计\"><a href=\"#设计\" class=\"headerlink\" title=\"设计\"></a>设计</h1><h2 id=\"动机\"><a href=\"#动机\" class=\"headerlink\" title=\"动机\"></a>动机</h2><h2 id=\"持久化\"><a href=\"#持久化\" class=\"headerlink\" title=\"持久化\"></a>持久化</h2><h3 id=\"不要害怕文件系统！\"><a href=\"#不要害怕文件系统！\" class=\"headerlink\" title=\"不要害怕文件系统！\"></a>不要害怕文件系统！</h3><h3 id=\"常量时间足够了\"><a href=\"#常量时间足够了\" class=\"headerlink\" title=\"常量时间足够了\"></a>常量时间足够了</h3><h2 id=\"效率\"><a href=\"#效率\" class=\"headerlink\" title=\"效率\"></a>效率</h2><h3 id=\"端到端批量压缩\"><a href=\"#端到端批量压缩\" class=\"headerlink\" title=\"端到端批量压缩\"></a>端到端批量压缩</h3><h2 id=\"生产者\"><a href=\"#生产者\" class=\"headerlink\" title=\"生产者\"></a>生产者</h2><h3 id=\"负载均衡\"><a href=\"#负载均衡\" class=\"headerlink\" title=\"负载均衡\"></a>负载均衡</h3><h3 id=\"异步发送\"><a href=\"#异步发送\" class=\"headerlink\" title=\"异步发送\"></a>异步发送</h3><h2 id=\"消费者\"><a href=\"#消费者\" class=\"headerlink\" title=\"消费者\"></a>消费者</h2><h3 id=\"推VS拉\"><a href=\"#推VS拉\" class=\"headerlink\" title=\"推VS拉\"></a>推VS拉</h3><h3 id=\"消费者位置\"><a href=\"#消费者位置\" class=\"headerlink\" title=\"消费者位置\"></a>消费者位置</h3><h3 id=\"离线数据加载\"><a href=\"#离线数据加载\" class=\"headerlink\" title=\"离线数据加载\"></a>离线数据加载</h3><h3 id=\"静态成员关系\"><a href=\"#静态成员关系\" class=\"headerlink\" title=\"静态成员关系\"></a>静态成员关系</h3><h2 id=\"消息传递语义\"><a href=\"#消息传递语义\" class=\"headerlink\" title=\"消息传递语义\"></a>消息传递语义</h2><h2 id=\"复制\"><a href=\"#复制\" class=\"headerlink\" title=\"复制\"></a>复制</h2><h3 id=\"复制日志：Quorums-ISRs-State-Machines-天啊\"><a href=\"#复制日志：Quorums-ISRs-State-Machines-天啊\" class=\"headerlink\" title=\"复制日志：Quorums,ISRs,State Machines(天啊)\"></a>复制日志：Quorums,ISRs,State Machines(天啊)</h3><h3 id=\"未完成的领导选举：如果他们全部挂了呢？\"><a href=\"#未完成的领导选举：如果他们全部挂了呢？\" class=\"headerlink\" title=\"未完成的领导选举：如果他们全部挂了呢？\"></a>未完成的领导选举：如果他们全部挂了呢？</h3><h3 id=\"可用性和持久化保证\"><a href=\"#可用性和持久化保证\" class=\"headerlink\" title=\"可用性和持久化保证\"></a>可用性和持久化保证</h3><h3 id=\"复制管理\"><a href=\"#复制管理\" class=\"headerlink\" title=\"复制管理\"></a>复制管理</h3><h2 id=\"日志压缩\"><a href=\"#日志压缩\" class=\"headerlink\" title=\"日志压缩\"></a>日志压缩</h2><h3 id=\"日志压缩基础\"><a href=\"#日志压缩基础\" class=\"headerlink\" title=\"日志压缩基础\"></a>日志压缩基础</h3><h3 id=\"日志压缩提供了什么样的保证？\"><a href=\"#日志压缩提供了什么样的保证？\" class=\"headerlink\" title=\"日志压缩提供了什么样的保证？\"></a>日志压缩提供了什么样的保证？</h3><h3 id=\"日志压缩细节\"><a href=\"#日志压缩细节\" class=\"headerlink\" title=\"日志压缩细节\"></a>日志压缩细节</h3><h3 id=\"配置日志清理器\"><a href=\"#配置日志清理器\" class=\"headerlink\" title=\"配置日志清理器\"></a>配置日志清理器</h3><h2 id=\"配额\"><a href=\"#配额\" class=\"headerlink\" title=\"配额\"></a>配额</h2><h3 id=\"为什么配额是必须的？\"><a href=\"#为什么配额是必须的？\" class=\"headerlink\" title=\"为什么配额是必须的？\"></a>为什么配额是必须的？</h3><h3 id=\"客户端组\"><a href=\"#客户端组\" class=\"headerlink\" title=\"客户端组\"></a>客户端组</h3><h3 id=\"配额配置\"><a href=\"#配额配置\" class=\"headerlink\" title=\"配额配置\"></a>配额配置</h3><h3 id=\"网络带宽的配额\"><a href=\"#网络带宽的配额\" class=\"headerlink\" title=\"网络带宽的配额\"></a>网络带宽的配额</h3><h3 id=\"请求速率的带宽\"><a href=\"#请求速率的带宽\" class=\"headerlink\" title=\"请求速率的带宽\"></a>请求速率的带宽</h3><h3 id=\"强制\"><a href=\"#强制\" class=\"headerlink\" title=\"强制\"></a>强制</h3><h1 id=\"实现\"><a href=\"#实现\" class=\"headerlink\" title=\"实现\"></a>实现</h1><h2 id=\"网络层\"><a href=\"#网络层\" class=\"headerlink\" title=\"网络层\"></a>网络层</h2><h2 id=\"消息\"><a href=\"#消息\" class=\"headerlink\" title=\"消息\"></a>消息</h2><h2 id=\"消息格式\"><a href=\"#消息格式\" class=\"headerlink\" title=\"消息格式\"></a>消息格式</h2><h3 id=\"批记录\"><a href=\"#批记录\" class=\"headerlink\" title=\"批记录\"></a>批记录</h3><h4 id=\"控制批次\"><a href=\"#控制批次\" class=\"headerlink\" title=\"控制批次\"></a>控制批次</h4><h3 id=\"记录\"><a href=\"#记录\" class=\"headerlink\" title=\"记录\"></a>记录</h3><h4 id=\"记录头\"><a href=\"#记录头\" class=\"headerlink\" title=\"记录头\"></a>记录头</h4><h3 id=\"旧版消息格式\"><a href=\"#旧版消息格式\" class=\"headerlink\" title=\"旧版消息格式\"></a>旧版消息格式</h3><h2 id=\"日志\"><a href=\"#日志\" class=\"headerlink\" title=\"日志\"></a>日志</h2><h3 id=\"写入\"><a href=\"#写入\" class=\"headerlink\" title=\"写入\"></a>写入</h3><h3 id=\"读取\"><a href=\"#读取\" class=\"headerlink\" title=\"读取\"></a>读取</h3><h3 id=\"删除\"><a href=\"#删除\" class=\"headerlink\" title=\"删除\"></a>删除</h3><h3 id=\"保证性\"><a href=\"#保证性\" class=\"headerlink\" title=\"保证性\"></a>保证性</h3><h2 id=\"分配\"><a href=\"#分配\" class=\"headerlink\" title=\"分配\"></a>分配</h2><h3 id=\"消费者偏移追踪\"><a href=\"#消费者偏移追踪\" class=\"headerlink\" title=\"消费者偏移追踪\"></a>消费者偏移追踪</h3><h3 id=\"Zookeeper目录\"><a href=\"#Zookeeper目录\" class=\"headerlink\" title=\"Zookeeper目录\"></a>Zookeeper目录</h3><h3 id=\"表示法\"><a href=\"#表示法\" class=\"headerlink\" title=\"表示法\"></a>表示法</h3><h3 id=\"Broker节点注册\"><a href=\"#Broker节点注册\" class=\"headerlink\" title=\"Broker节点注册\"></a>Broker节点注册</h3><h3 id=\"Broker主题注册\"><a href=\"#Broker主题注册\" class=\"headerlink\" title=\"Broker主题注册\"></a>Broker主题注册</h3><h3 id=\"集群ID\"><a href=\"#集群ID\" class=\"headerlink\" title=\"集群ID\"></a>集群ID</h3><h3 id=\"Broker节点注册-1\"><a href=\"#Broker节点注册-1\" class=\"headerlink\" title=\"Broker节点注册\"></a>Broker节点注册</h3>"},{"title":"软考-高级架构师历年综合知识","date":"2021-09-13T07:57:36.000Z","_content":"\n\n\n每日一练最后一列：https://www.educity.cn/tiku/dp100110011003-43.html\n\n分数评比：\n\n67.5-75 优秀(90-100)\n\n60-67.5 良好(80-90)\n\n45-60 及格(60-80)\n\n45以下 不及格(60以下)\n\n\n\n2009年2020年，11年考题。准备考试时间从2021-08-31号开始。\n\n| 年份 | 类型     | 测试报告                                               | 备注 |\n| ---- | -------- | ------------------------------------------------------ | ---- |\n| 2009 | 综合知识 | https://uc.educity.cn/tiku/testReport.html?id=18951089 | 49   |\n|      | 综合知识 | https://uc.educity.cn/tiku/testReport.html?id=20674226 | 60   |\n| 2009 | 案例分析 | https://uc.educity.cn/tiku/testReport.html?id=18991552 | 0    |\n| 2009 | 论文     | https://uc.educity.cn/tiku/testReport.html?id=20723180 | 0    |\n| 2010 | 综合知识 | https://uc.educity.cn/tiku/testReport.html?id=18979952 | 50   |\n|      |          | https://uc.educity.cn/tiku/testReport.html?id=20702165 | 61   |\n| 2010 | 案例分析 | https://uc.educity.cn/tiku/testReport.html?id=20723068 | 0    |\n| 2010 | 论文     | https://uc.educity.cn/tiku/testReport.html?id=20723204 | 0    |\n| 2011 | 综合知识 | https://uc.educity.cn/tiku/testReport.html?id=19028653 | 52   |\n|      | 综合知识 | https://uc.educity.cn/tiku/testReport.html?id=20719531 | 64   |\n| 2011 | 案例分析 | https://uc.educity.cn/tiku/testReport.html?id=20723282 | 0    |\n| 2011 | 论文     | https://uc.educity.cn/tiku/testReport.html?id=20723101 | 0    |\n| 2012 | 综合知识 | https://uc.educity.cn/tiku/testReport.html?id=19200689 | 47   |\n|      | 综合知识 | https://uc.educity.cn/tiku/testReport.html?id=20723550 | 62   |\n| 2012 | 案例分析 | https://uc.educity.cn/tiku/testReport.html?id=20728268 |      |\n| 2012 | 论文     | https://uc.educity.cn/tiku/testReport.html?id=20728304 |      |\n| 2013 | 综合知识 | https://uc.educity.cn/tiku/testReport.html?id=19488274 | 40   |\n|      |          | https://uc.educity.cn/tiku/testReport.html?id=20728338 | 60   |\n| 2013 | 案例分析 | https://uc.educity.cn/tiku/testReport.html?id=20729999 |      |\n| 2013 | 论文     | https://uc.educity.cn/tiku/testReport.html?id=20730013 |      |\n| 2014 | 综合知识 | https://uc.educity.cn/tiku/testReport.html?id=19562008 | 46   |\n|      |          | https://uc.educity.cn/tiku/testReport.html?id=20735393 | 59   |\n| 2014 | 案例分析 | https://uc.educity.cn/tiku/testReport.html?id=21180440 |      |\n| 2014 | 论文     | https://uc.educity.cn/tiku/testReport.html?id=21180468 |      |\n| 2015 | 综合知识 | https://uc.educity.cn/tiku/testReport.html?id=19394496 | 51   |\n|      |          | https://uc.educity.cn/tiku/testReport.html?id=21031654 | 63   |\n| 2015 | 案例分析 | https://uc.educity.cn/tiku/testReport.html?id=21180523 |      |\n| 2015 | 论文     | https://uc.educity.cn/tiku/testReport.html?id=21180495 |      |\n| 2016 | 综合知识 | https://uc.educity.cn/tiku/testReport.html?id=19331712 | 42   |\n|      |          | https://uc.educity.cn/tiku/testReport.html?id=21175344 | 55   |\n| 2016 | 案例分析 | https://uc.educity.cn/tiku/testReport.html?id=21180541 |      |\n| 2016 | 论文     | https://uc.educity.cn/tiku/testReport.html?id=21180560 |      |\n| 2017 | 综合知识 | https://uc.educity.cn/tiku/testReport.html?id=19241523 | 50   |\n|      |          | https://uc.educity.cn/tiku/testReport.html?id=21180641 | 56   |\n| 2017 | 案例分析 | https://uc.educity.cn/tiku/testReport.html?id=21182428 |      |\n| 2017 | 论文     | https://uc.educity.cn/tiku/testReport.html?id=21182438 |      |\n| 2018 | 综合知识 | https://uc.educity.cn/tiku/testReport.html?id=19211415 | 54   |\n|      |          | https://uc.educity.cn/tiku/testReport.html?id=21183026 | 64   |\n| 2018 | 案例分析 | https://uc.educity.cn/tiku/testReport.html?id=19435318 |      |\n| 2018 | 论文     | https://uc.educity.cn/tiku/testReport.html?id=21182374 |      |\n| 2019 | 综合知识 | https://uc.educity.cn/tiku/testReport.html?id=19095458 | 47   |\n|      |          |                                                        |      |\n| 2019 | 案例分析 | https://uc.educity.cn/tiku/testReport.html?id=21182466 |      |\n| 2019 | 论文     | https://uc.educity.cn/tiku/testReport.html?id=18720605 |      |\n| 2020 | 综合知识 |                                                        |      |\n| 2020 | 案例分析 |                                                        |      |\n| 2020 | 论文     |                                                        |      |\n\n\n\n\n\n\n\n| 每日练习 | 测试报告 |\n| -------- | -------- |\n|          |          |\n|          |          |\n|          |          |\n|          |          |\n|          |          |\n|          |          |\n|          |          |\n|          |          |\n|          |          |\n\n","source":"_posts/ruankao-architect-comprehensive-knowledge.md","raw":"---\ntitle: 软考-高级架构师历年综合知识\ndate: 2021-09-13 15:57:36\ntags: 软考\ncategories:\n  - 考试\n  - 软考\n---\n\n\n\n每日一练最后一列：https://www.educity.cn/tiku/dp100110011003-43.html\n\n分数评比：\n\n67.5-75 优秀(90-100)\n\n60-67.5 良好(80-90)\n\n45-60 及格(60-80)\n\n45以下 不及格(60以下)\n\n\n\n2009年2020年，11年考题。准备考试时间从2021-08-31号开始。\n\n| 年份 | 类型     | 测试报告                                               | 备注 |\n| ---- | -------- | ------------------------------------------------------ | ---- |\n| 2009 | 综合知识 | https://uc.educity.cn/tiku/testReport.html?id=18951089 | 49   |\n|      | 综合知识 | https://uc.educity.cn/tiku/testReport.html?id=20674226 | 60   |\n| 2009 | 案例分析 | https://uc.educity.cn/tiku/testReport.html?id=18991552 | 0    |\n| 2009 | 论文     | https://uc.educity.cn/tiku/testReport.html?id=20723180 | 0    |\n| 2010 | 综合知识 | https://uc.educity.cn/tiku/testReport.html?id=18979952 | 50   |\n|      |          | https://uc.educity.cn/tiku/testReport.html?id=20702165 | 61   |\n| 2010 | 案例分析 | https://uc.educity.cn/tiku/testReport.html?id=20723068 | 0    |\n| 2010 | 论文     | https://uc.educity.cn/tiku/testReport.html?id=20723204 | 0    |\n| 2011 | 综合知识 | https://uc.educity.cn/tiku/testReport.html?id=19028653 | 52   |\n|      | 综合知识 | https://uc.educity.cn/tiku/testReport.html?id=20719531 | 64   |\n| 2011 | 案例分析 | https://uc.educity.cn/tiku/testReport.html?id=20723282 | 0    |\n| 2011 | 论文     | https://uc.educity.cn/tiku/testReport.html?id=20723101 | 0    |\n| 2012 | 综合知识 | https://uc.educity.cn/tiku/testReport.html?id=19200689 | 47   |\n|      | 综合知识 | https://uc.educity.cn/tiku/testReport.html?id=20723550 | 62   |\n| 2012 | 案例分析 | https://uc.educity.cn/tiku/testReport.html?id=20728268 |      |\n| 2012 | 论文     | https://uc.educity.cn/tiku/testReport.html?id=20728304 |      |\n| 2013 | 综合知识 | https://uc.educity.cn/tiku/testReport.html?id=19488274 | 40   |\n|      |          | https://uc.educity.cn/tiku/testReport.html?id=20728338 | 60   |\n| 2013 | 案例分析 | https://uc.educity.cn/tiku/testReport.html?id=20729999 |      |\n| 2013 | 论文     | https://uc.educity.cn/tiku/testReport.html?id=20730013 |      |\n| 2014 | 综合知识 | https://uc.educity.cn/tiku/testReport.html?id=19562008 | 46   |\n|      |          | https://uc.educity.cn/tiku/testReport.html?id=20735393 | 59   |\n| 2014 | 案例分析 | https://uc.educity.cn/tiku/testReport.html?id=21180440 |      |\n| 2014 | 论文     | https://uc.educity.cn/tiku/testReport.html?id=21180468 |      |\n| 2015 | 综合知识 | https://uc.educity.cn/tiku/testReport.html?id=19394496 | 51   |\n|      |          | https://uc.educity.cn/tiku/testReport.html?id=21031654 | 63   |\n| 2015 | 案例分析 | https://uc.educity.cn/tiku/testReport.html?id=21180523 |      |\n| 2015 | 论文     | https://uc.educity.cn/tiku/testReport.html?id=21180495 |      |\n| 2016 | 综合知识 | https://uc.educity.cn/tiku/testReport.html?id=19331712 | 42   |\n|      |          | https://uc.educity.cn/tiku/testReport.html?id=21175344 | 55   |\n| 2016 | 案例分析 | https://uc.educity.cn/tiku/testReport.html?id=21180541 |      |\n| 2016 | 论文     | https://uc.educity.cn/tiku/testReport.html?id=21180560 |      |\n| 2017 | 综合知识 | https://uc.educity.cn/tiku/testReport.html?id=19241523 | 50   |\n|      |          | https://uc.educity.cn/tiku/testReport.html?id=21180641 | 56   |\n| 2017 | 案例分析 | https://uc.educity.cn/tiku/testReport.html?id=21182428 |      |\n| 2017 | 论文     | https://uc.educity.cn/tiku/testReport.html?id=21182438 |      |\n| 2018 | 综合知识 | https://uc.educity.cn/tiku/testReport.html?id=19211415 | 54   |\n|      |          | https://uc.educity.cn/tiku/testReport.html?id=21183026 | 64   |\n| 2018 | 案例分析 | https://uc.educity.cn/tiku/testReport.html?id=19435318 |      |\n| 2018 | 论文     | https://uc.educity.cn/tiku/testReport.html?id=21182374 |      |\n| 2019 | 综合知识 | https://uc.educity.cn/tiku/testReport.html?id=19095458 | 47   |\n|      |          |                                                        |      |\n| 2019 | 案例分析 | https://uc.educity.cn/tiku/testReport.html?id=21182466 |      |\n| 2019 | 论文     | https://uc.educity.cn/tiku/testReport.html?id=18720605 |      |\n| 2020 | 综合知识 |                                                        |      |\n| 2020 | 案例分析 |                                                        |      |\n| 2020 | 论文     |                                                        |      |\n\n\n\n\n\n\n\n| 每日练习 | 测试报告 |\n| -------- | -------- |\n|          |          |\n|          |          |\n|          |          |\n|          |          |\n|          |          |\n|          |          |\n|          |          |\n|          |          |\n|          |          |\n\n","slug":"ruankao-architect-comprehensive-knowledge","published":1,"updated":"2021-10-31T13:26:10.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clh7s5cu60026xt8j8ez5053g","content":"<p>每日一练最后一列：<a href=\"https://www.educity.cn/tiku/dp100110011003-43.html\" target=\"_blank\" rel=\"noopener\">https://www.educity.cn/tiku/dp100110011003-43.html</a></p>\n<p>分数评比：</p>\n<p>67.5-75 优秀(90-100)</p>\n<p>60-67.5 良好(80-90)</p>\n<p>45-60 及格(60-80)</p>\n<p>45以下 不及格(60以下)</p>\n<p>2009年2020年，11年考题。准备考试时间从2021-08-31号开始。</p>\n<table>\n<thead>\n<tr>\n<th>年份</th>\n<th>类型</th>\n<th>测试报告</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>2009</td>\n<td>综合知识</td>\n<td><a href=\"https://uc.educity.cn/tiku/testReport.html?id=18951089\" target=\"_blank\" rel=\"noopener\">https://uc.educity.cn/tiku/testReport.html?id=18951089</a></td>\n<td>49</td>\n</tr>\n<tr>\n<td></td>\n<td>综合知识</td>\n<td><a href=\"https://uc.educity.cn/tiku/testReport.html?id=20674226\" target=\"_blank\" rel=\"noopener\">https://uc.educity.cn/tiku/testReport.html?id=20674226</a></td>\n<td>60</td>\n</tr>\n<tr>\n<td>2009</td>\n<td>案例分析</td>\n<td><a href=\"https://uc.educity.cn/tiku/testReport.html?id=18991552\" target=\"_blank\" rel=\"noopener\">https://uc.educity.cn/tiku/testReport.html?id=18991552</a></td>\n<td>0</td>\n</tr>\n<tr>\n<td>2009</td>\n<td>论文</td>\n<td><a href=\"https://uc.educity.cn/tiku/testReport.html?id=20723180\" target=\"_blank\" rel=\"noopener\">https://uc.educity.cn/tiku/testReport.html?id=20723180</a></td>\n<td>0</td>\n</tr>\n<tr>\n<td>2010</td>\n<td>综合知识</td>\n<td><a href=\"https://uc.educity.cn/tiku/testReport.html?id=18979952\" target=\"_blank\" rel=\"noopener\">https://uc.educity.cn/tiku/testReport.html?id=18979952</a></td>\n<td>50</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td><a href=\"https://uc.educity.cn/tiku/testReport.html?id=20702165\" target=\"_blank\" rel=\"noopener\">https://uc.educity.cn/tiku/testReport.html?id=20702165</a></td>\n<td>61</td>\n</tr>\n<tr>\n<td>2010</td>\n<td>案例分析</td>\n<td><a href=\"https://uc.educity.cn/tiku/testReport.html?id=20723068\" target=\"_blank\" rel=\"noopener\">https://uc.educity.cn/tiku/testReport.html?id=20723068</a></td>\n<td>0</td>\n</tr>\n<tr>\n<td>2010</td>\n<td>论文</td>\n<td><a href=\"https://uc.educity.cn/tiku/testReport.html?id=20723204\" target=\"_blank\" rel=\"noopener\">https://uc.educity.cn/tiku/testReport.html?id=20723204</a></td>\n<td>0</td>\n</tr>\n<tr>\n<td>2011</td>\n<td>综合知识</td>\n<td><a href=\"https://uc.educity.cn/tiku/testReport.html?id=19028653\" target=\"_blank\" rel=\"noopener\">https://uc.educity.cn/tiku/testReport.html?id=19028653</a></td>\n<td>52</td>\n</tr>\n<tr>\n<td></td>\n<td>综合知识</td>\n<td><a href=\"https://uc.educity.cn/tiku/testReport.html?id=20719531\" target=\"_blank\" rel=\"noopener\">https://uc.educity.cn/tiku/testReport.html?id=20719531</a></td>\n<td>64</td>\n</tr>\n<tr>\n<td>2011</td>\n<td>案例分析</td>\n<td><a href=\"https://uc.educity.cn/tiku/testReport.html?id=20723282\" target=\"_blank\" rel=\"noopener\">https://uc.educity.cn/tiku/testReport.html?id=20723282</a></td>\n<td>0</td>\n</tr>\n<tr>\n<td>2011</td>\n<td>论文</td>\n<td><a href=\"https://uc.educity.cn/tiku/testReport.html?id=20723101\" target=\"_blank\" rel=\"noopener\">https://uc.educity.cn/tiku/testReport.html?id=20723101</a></td>\n<td>0</td>\n</tr>\n<tr>\n<td>2012</td>\n<td>综合知识</td>\n<td><a href=\"https://uc.educity.cn/tiku/testReport.html?id=19200689\" target=\"_blank\" rel=\"noopener\">https://uc.educity.cn/tiku/testReport.html?id=19200689</a></td>\n<td>47</td>\n</tr>\n<tr>\n<td></td>\n<td>综合知识</td>\n<td><a href=\"https://uc.educity.cn/tiku/testReport.html?id=20723550\" target=\"_blank\" rel=\"noopener\">https://uc.educity.cn/tiku/testReport.html?id=20723550</a></td>\n<td>62</td>\n</tr>\n<tr>\n<td>2012</td>\n<td>案例分析</td>\n<td><a href=\"https://uc.educity.cn/tiku/testReport.html?id=20728268\" target=\"_blank\" rel=\"noopener\">https://uc.educity.cn/tiku/testReport.html?id=20728268</a></td>\n<td></td>\n</tr>\n<tr>\n<td>2012</td>\n<td>论文</td>\n<td><a href=\"https://uc.educity.cn/tiku/testReport.html?id=20728304\" target=\"_blank\" rel=\"noopener\">https://uc.educity.cn/tiku/testReport.html?id=20728304</a></td>\n<td></td>\n</tr>\n<tr>\n<td>2013</td>\n<td>综合知识</td>\n<td><a href=\"https://uc.educity.cn/tiku/testReport.html?id=19488274\" target=\"_blank\" rel=\"noopener\">https://uc.educity.cn/tiku/testReport.html?id=19488274</a></td>\n<td>40</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td><a href=\"https://uc.educity.cn/tiku/testReport.html?id=20728338\" target=\"_blank\" rel=\"noopener\">https://uc.educity.cn/tiku/testReport.html?id=20728338</a></td>\n<td>60</td>\n</tr>\n<tr>\n<td>2013</td>\n<td>案例分析</td>\n<td><a href=\"https://uc.educity.cn/tiku/testReport.html?id=20729999\" target=\"_blank\" rel=\"noopener\">https://uc.educity.cn/tiku/testReport.html?id=20729999</a></td>\n<td></td>\n</tr>\n<tr>\n<td>2013</td>\n<td>论文</td>\n<td><a href=\"https://uc.educity.cn/tiku/testReport.html?id=20730013\" target=\"_blank\" rel=\"noopener\">https://uc.educity.cn/tiku/testReport.html?id=20730013</a></td>\n<td></td>\n</tr>\n<tr>\n<td>2014</td>\n<td>综合知识</td>\n<td><a href=\"https://uc.educity.cn/tiku/testReport.html?id=19562008\" target=\"_blank\" rel=\"noopener\">https://uc.educity.cn/tiku/testReport.html?id=19562008</a></td>\n<td>46</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td><a href=\"https://uc.educity.cn/tiku/testReport.html?id=20735393\" target=\"_blank\" rel=\"noopener\">https://uc.educity.cn/tiku/testReport.html?id=20735393</a></td>\n<td>59</td>\n</tr>\n<tr>\n<td>2014</td>\n<td>案例分析</td>\n<td><a href=\"https://uc.educity.cn/tiku/testReport.html?id=21180440\" target=\"_blank\" rel=\"noopener\">https://uc.educity.cn/tiku/testReport.html?id=21180440</a></td>\n<td></td>\n</tr>\n<tr>\n<td>2014</td>\n<td>论文</td>\n<td><a href=\"https://uc.educity.cn/tiku/testReport.html?id=21180468\" target=\"_blank\" rel=\"noopener\">https://uc.educity.cn/tiku/testReport.html?id=21180468</a></td>\n<td></td>\n</tr>\n<tr>\n<td>2015</td>\n<td>综合知识</td>\n<td><a href=\"https://uc.educity.cn/tiku/testReport.html?id=19394496\" target=\"_blank\" rel=\"noopener\">https://uc.educity.cn/tiku/testReport.html?id=19394496</a></td>\n<td>51</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td><a href=\"https://uc.educity.cn/tiku/testReport.html?id=21031654\" target=\"_blank\" rel=\"noopener\">https://uc.educity.cn/tiku/testReport.html?id=21031654</a></td>\n<td>63</td>\n</tr>\n<tr>\n<td>2015</td>\n<td>案例分析</td>\n<td><a href=\"https://uc.educity.cn/tiku/testReport.html?id=21180523\" target=\"_blank\" rel=\"noopener\">https://uc.educity.cn/tiku/testReport.html?id=21180523</a></td>\n<td></td>\n</tr>\n<tr>\n<td>2015</td>\n<td>论文</td>\n<td><a href=\"https://uc.educity.cn/tiku/testReport.html?id=21180495\" target=\"_blank\" rel=\"noopener\">https://uc.educity.cn/tiku/testReport.html?id=21180495</a></td>\n<td></td>\n</tr>\n<tr>\n<td>2016</td>\n<td>综合知识</td>\n<td><a href=\"https://uc.educity.cn/tiku/testReport.html?id=19331712\" target=\"_blank\" rel=\"noopener\">https://uc.educity.cn/tiku/testReport.html?id=19331712</a></td>\n<td>42</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td><a href=\"https://uc.educity.cn/tiku/testReport.html?id=21175344\" target=\"_blank\" rel=\"noopener\">https://uc.educity.cn/tiku/testReport.html?id=21175344</a></td>\n<td>55</td>\n</tr>\n<tr>\n<td>2016</td>\n<td>案例分析</td>\n<td><a href=\"https://uc.educity.cn/tiku/testReport.html?id=21180541\" target=\"_blank\" rel=\"noopener\">https://uc.educity.cn/tiku/testReport.html?id=21180541</a></td>\n<td></td>\n</tr>\n<tr>\n<td>2016</td>\n<td>论文</td>\n<td><a href=\"https://uc.educity.cn/tiku/testReport.html?id=21180560\" target=\"_blank\" rel=\"noopener\">https://uc.educity.cn/tiku/testReport.html?id=21180560</a></td>\n<td></td>\n</tr>\n<tr>\n<td>2017</td>\n<td>综合知识</td>\n<td><a href=\"https://uc.educity.cn/tiku/testReport.html?id=19241523\" target=\"_blank\" rel=\"noopener\">https://uc.educity.cn/tiku/testReport.html?id=19241523</a></td>\n<td>50</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td><a href=\"https://uc.educity.cn/tiku/testReport.html?id=21180641\" target=\"_blank\" rel=\"noopener\">https://uc.educity.cn/tiku/testReport.html?id=21180641</a></td>\n<td>56</td>\n</tr>\n<tr>\n<td>2017</td>\n<td>案例分析</td>\n<td><a href=\"https://uc.educity.cn/tiku/testReport.html?id=21182428\" target=\"_blank\" rel=\"noopener\">https://uc.educity.cn/tiku/testReport.html?id=21182428</a></td>\n<td></td>\n</tr>\n<tr>\n<td>2017</td>\n<td>论文</td>\n<td><a href=\"https://uc.educity.cn/tiku/testReport.html?id=21182438\" target=\"_blank\" rel=\"noopener\">https://uc.educity.cn/tiku/testReport.html?id=21182438</a></td>\n<td></td>\n</tr>\n<tr>\n<td>2018</td>\n<td>综合知识</td>\n<td><a href=\"https://uc.educity.cn/tiku/testReport.html?id=19211415\" target=\"_blank\" rel=\"noopener\">https://uc.educity.cn/tiku/testReport.html?id=19211415</a></td>\n<td>54</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td><a href=\"https://uc.educity.cn/tiku/testReport.html?id=21183026\" target=\"_blank\" rel=\"noopener\">https://uc.educity.cn/tiku/testReport.html?id=21183026</a></td>\n<td>64</td>\n</tr>\n<tr>\n<td>2018</td>\n<td>案例分析</td>\n<td><a href=\"https://uc.educity.cn/tiku/testReport.html?id=19435318\" target=\"_blank\" rel=\"noopener\">https://uc.educity.cn/tiku/testReport.html?id=19435318</a></td>\n<td></td>\n</tr>\n<tr>\n<td>2018</td>\n<td>论文</td>\n<td><a href=\"https://uc.educity.cn/tiku/testReport.html?id=21182374\" target=\"_blank\" rel=\"noopener\">https://uc.educity.cn/tiku/testReport.html?id=21182374</a></td>\n<td></td>\n</tr>\n<tr>\n<td>2019</td>\n<td>综合知识</td>\n<td><a href=\"https://uc.educity.cn/tiku/testReport.html?id=19095458\" target=\"_blank\" rel=\"noopener\">https://uc.educity.cn/tiku/testReport.html?id=19095458</a></td>\n<td>47</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>2019</td>\n<td>案例分析</td>\n<td><a href=\"https://uc.educity.cn/tiku/testReport.html?id=21182466\" target=\"_blank\" rel=\"noopener\">https://uc.educity.cn/tiku/testReport.html?id=21182466</a></td>\n<td></td>\n</tr>\n<tr>\n<td>2019</td>\n<td>论文</td>\n<td><a href=\"https://uc.educity.cn/tiku/testReport.html?id=18720605\" target=\"_blank\" rel=\"noopener\">https://uc.educity.cn/tiku/testReport.html?id=18720605</a></td>\n<td></td>\n</tr>\n<tr>\n<td>2020</td>\n<td>综合知识</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>2020</td>\n<td>案例分析</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>2020</td>\n<td>论文</td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>每日练习</th>\n<th>测试报告</th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n","site":{"data":{}},"excerpt":"","more":"<p>每日一练最后一列：<a href=\"https://www.educity.cn/tiku/dp100110011003-43.html\" target=\"_blank\" rel=\"noopener\">https://www.educity.cn/tiku/dp100110011003-43.html</a></p>\n<p>分数评比：</p>\n<p>67.5-75 优秀(90-100)</p>\n<p>60-67.5 良好(80-90)</p>\n<p>45-60 及格(60-80)</p>\n<p>45以下 不及格(60以下)</p>\n<p>2009年2020年，11年考题。准备考试时间从2021-08-31号开始。</p>\n<table>\n<thead>\n<tr>\n<th>年份</th>\n<th>类型</th>\n<th>测试报告</th>\n<th>备注</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>2009</td>\n<td>综合知识</td>\n<td><a href=\"https://uc.educity.cn/tiku/testReport.html?id=18951089\" target=\"_blank\" rel=\"noopener\">https://uc.educity.cn/tiku/testReport.html?id=18951089</a></td>\n<td>49</td>\n</tr>\n<tr>\n<td></td>\n<td>综合知识</td>\n<td><a href=\"https://uc.educity.cn/tiku/testReport.html?id=20674226\" target=\"_blank\" rel=\"noopener\">https://uc.educity.cn/tiku/testReport.html?id=20674226</a></td>\n<td>60</td>\n</tr>\n<tr>\n<td>2009</td>\n<td>案例分析</td>\n<td><a href=\"https://uc.educity.cn/tiku/testReport.html?id=18991552\" target=\"_blank\" rel=\"noopener\">https://uc.educity.cn/tiku/testReport.html?id=18991552</a></td>\n<td>0</td>\n</tr>\n<tr>\n<td>2009</td>\n<td>论文</td>\n<td><a href=\"https://uc.educity.cn/tiku/testReport.html?id=20723180\" target=\"_blank\" rel=\"noopener\">https://uc.educity.cn/tiku/testReport.html?id=20723180</a></td>\n<td>0</td>\n</tr>\n<tr>\n<td>2010</td>\n<td>综合知识</td>\n<td><a href=\"https://uc.educity.cn/tiku/testReport.html?id=18979952\" target=\"_blank\" rel=\"noopener\">https://uc.educity.cn/tiku/testReport.html?id=18979952</a></td>\n<td>50</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td><a href=\"https://uc.educity.cn/tiku/testReport.html?id=20702165\" target=\"_blank\" rel=\"noopener\">https://uc.educity.cn/tiku/testReport.html?id=20702165</a></td>\n<td>61</td>\n</tr>\n<tr>\n<td>2010</td>\n<td>案例分析</td>\n<td><a href=\"https://uc.educity.cn/tiku/testReport.html?id=20723068\" target=\"_blank\" rel=\"noopener\">https://uc.educity.cn/tiku/testReport.html?id=20723068</a></td>\n<td>0</td>\n</tr>\n<tr>\n<td>2010</td>\n<td>论文</td>\n<td><a href=\"https://uc.educity.cn/tiku/testReport.html?id=20723204\" target=\"_blank\" rel=\"noopener\">https://uc.educity.cn/tiku/testReport.html?id=20723204</a></td>\n<td>0</td>\n</tr>\n<tr>\n<td>2011</td>\n<td>综合知识</td>\n<td><a href=\"https://uc.educity.cn/tiku/testReport.html?id=19028653\" target=\"_blank\" rel=\"noopener\">https://uc.educity.cn/tiku/testReport.html?id=19028653</a></td>\n<td>52</td>\n</tr>\n<tr>\n<td></td>\n<td>综合知识</td>\n<td><a href=\"https://uc.educity.cn/tiku/testReport.html?id=20719531\" target=\"_blank\" rel=\"noopener\">https://uc.educity.cn/tiku/testReport.html?id=20719531</a></td>\n<td>64</td>\n</tr>\n<tr>\n<td>2011</td>\n<td>案例分析</td>\n<td><a href=\"https://uc.educity.cn/tiku/testReport.html?id=20723282\" target=\"_blank\" rel=\"noopener\">https://uc.educity.cn/tiku/testReport.html?id=20723282</a></td>\n<td>0</td>\n</tr>\n<tr>\n<td>2011</td>\n<td>论文</td>\n<td><a href=\"https://uc.educity.cn/tiku/testReport.html?id=20723101\" target=\"_blank\" rel=\"noopener\">https://uc.educity.cn/tiku/testReport.html?id=20723101</a></td>\n<td>0</td>\n</tr>\n<tr>\n<td>2012</td>\n<td>综合知识</td>\n<td><a href=\"https://uc.educity.cn/tiku/testReport.html?id=19200689\" target=\"_blank\" rel=\"noopener\">https://uc.educity.cn/tiku/testReport.html?id=19200689</a></td>\n<td>47</td>\n</tr>\n<tr>\n<td></td>\n<td>综合知识</td>\n<td><a href=\"https://uc.educity.cn/tiku/testReport.html?id=20723550\" target=\"_blank\" rel=\"noopener\">https://uc.educity.cn/tiku/testReport.html?id=20723550</a></td>\n<td>62</td>\n</tr>\n<tr>\n<td>2012</td>\n<td>案例分析</td>\n<td><a href=\"https://uc.educity.cn/tiku/testReport.html?id=20728268\" target=\"_blank\" rel=\"noopener\">https://uc.educity.cn/tiku/testReport.html?id=20728268</a></td>\n<td></td>\n</tr>\n<tr>\n<td>2012</td>\n<td>论文</td>\n<td><a href=\"https://uc.educity.cn/tiku/testReport.html?id=20728304\" target=\"_blank\" rel=\"noopener\">https://uc.educity.cn/tiku/testReport.html?id=20728304</a></td>\n<td></td>\n</tr>\n<tr>\n<td>2013</td>\n<td>综合知识</td>\n<td><a href=\"https://uc.educity.cn/tiku/testReport.html?id=19488274\" target=\"_blank\" rel=\"noopener\">https://uc.educity.cn/tiku/testReport.html?id=19488274</a></td>\n<td>40</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td><a href=\"https://uc.educity.cn/tiku/testReport.html?id=20728338\" target=\"_blank\" rel=\"noopener\">https://uc.educity.cn/tiku/testReport.html?id=20728338</a></td>\n<td>60</td>\n</tr>\n<tr>\n<td>2013</td>\n<td>案例分析</td>\n<td><a href=\"https://uc.educity.cn/tiku/testReport.html?id=20729999\" target=\"_blank\" rel=\"noopener\">https://uc.educity.cn/tiku/testReport.html?id=20729999</a></td>\n<td></td>\n</tr>\n<tr>\n<td>2013</td>\n<td>论文</td>\n<td><a href=\"https://uc.educity.cn/tiku/testReport.html?id=20730013\" target=\"_blank\" rel=\"noopener\">https://uc.educity.cn/tiku/testReport.html?id=20730013</a></td>\n<td></td>\n</tr>\n<tr>\n<td>2014</td>\n<td>综合知识</td>\n<td><a href=\"https://uc.educity.cn/tiku/testReport.html?id=19562008\" target=\"_blank\" rel=\"noopener\">https://uc.educity.cn/tiku/testReport.html?id=19562008</a></td>\n<td>46</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td><a href=\"https://uc.educity.cn/tiku/testReport.html?id=20735393\" target=\"_blank\" rel=\"noopener\">https://uc.educity.cn/tiku/testReport.html?id=20735393</a></td>\n<td>59</td>\n</tr>\n<tr>\n<td>2014</td>\n<td>案例分析</td>\n<td><a href=\"https://uc.educity.cn/tiku/testReport.html?id=21180440\" target=\"_blank\" rel=\"noopener\">https://uc.educity.cn/tiku/testReport.html?id=21180440</a></td>\n<td></td>\n</tr>\n<tr>\n<td>2014</td>\n<td>论文</td>\n<td><a href=\"https://uc.educity.cn/tiku/testReport.html?id=21180468\" target=\"_blank\" rel=\"noopener\">https://uc.educity.cn/tiku/testReport.html?id=21180468</a></td>\n<td></td>\n</tr>\n<tr>\n<td>2015</td>\n<td>综合知识</td>\n<td><a href=\"https://uc.educity.cn/tiku/testReport.html?id=19394496\" target=\"_blank\" rel=\"noopener\">https://uc.educity.cn/tiku/testReport.html?id=19394496</a></td>\n<td>51</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td><a href=\"https://uc.educity.cn/tiku/testReport.html?id=21031654\" target=\"_blank\" rel=\"noopener\">https://uc.educity.cn/tiku/testReport.html?id=21031654</a></td>\n<td>63</td>\n</tr>\n<tr>\n<td>2015</td>\n<td>案例分析</td>\n<td><a href=\"https://uc.educity.cn/tiku/testReport.html?id=21180523\" target=\"_blank\" rel=\"noopener\">https://uc.educity.cn/tiku/testReport.html?id=21180523</a></td>\n<td></td>\n</tr>\n<tr>\n<td>2015</td>\n<td>论文</td>\n<td><a href=\"https://uc.educity.cn/tiku/testReport.html?id=21180495\" target=\"_blank\" rel=\"noopener\">https://uc.educity.cn/tiku/testReport.html?id=21180495</a></td>\n<td></td>\n</tr>\n<tr>\n<td>2016</td>\n<td>综合知识</td>\n<td><a href=\"https://uc.educity.cn/tiku/testReport.html?id=19331712\" target=\"_blank\" rel=\"noopener\">https://uc.educity.cn/tiku/testReport.html?id=19331712</a></td>\n<td>42</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td><a href=\"https://uc.educity.cn/tiku/testReport.html?id=21175344\" target=\"_blank\" rel=\"noopener\">https://uc.educity.cn/tiku/testReport.html?id=21175344</a></td>\n<td>55</td>\n</tr>\n<tr>\n<td>2016</td>\n<td>案例分析</td>\n<td><a href=\"https://uc.educity.cn/tiku/testReport.html?id=21180541\" target=\"_blank\" rel=\"noopener\">https://uc.educity.cn/tiku/testReport.html?id=21180541</a></td>\n<td></td>\n</tr>\n<tr>\n<td>2016</td>\n<td>论文</td>\n<td><a href=\"https://uc.educity.cn/tiku/testReport.html?id=21180560\" target=\"_blank\" rel=\"noopener\">https://uc.educity.cn/tiku/testReport.html?id=21180560</a></td>\n<td></td>\n</tr>\n<tr>\n<td>2017</td>\n<td>综合知识</td>\n<td><a href=\"https://uc.educity.cn/tiku/testReport.html?id=19241523\" target=\"_blank\" rel=\"noopener\">https://uc.educity.cn/tiku/testReport.html?id=19241523</a></td>\n<td>50</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td><a href=\"https://uc.educity.cn/tiku/testReport.html?id=21180641\" target=\"_blank\" rel=\"noopener\">https://uc.educity.cn/tiku/testReport.html?id=21180641</a></td>\n<td>56</td>\n</tr>\n<tr>\n<td>2017</td>\n<td>案例分析</td>\n<td><a href=\"https://uc.educity.cn/tiku/testReport.html?id=21182428\" target=\"_blank\" rel=\"noopener\">https://uc.educity.cn/tiku/testReport.html?id=21182428</a></td>\n<td></td>\n</tr>\n<tr>\n<td>2017</td>\n<td>论文</td>\n<td><a href=\"https://uc.educity.cn/tiku/testReport.html?id=21182438\" target=\"_blank\" rel=\"noopener\">https://uc.educity.cn/tiku/testReport.html?id=21182438</a></td>\n<td></td>\n</tr>\n<tr>\n<td>2018</td>\n<td>综合知识</td>\n<td><a href=\"https://uc.educity.cn/tiku/testReport.html?id=19211415\" target=\"_blank\" rel=\"noopener\">https://uc.educity.cn/tiku/testReport.html?id=19211415</a></td>\n<td>54</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td><a href=\"https://uc.educity.cn/tiku/testReport.html?id=21183026\" target=\"_blank\" rel=\"noopener\">https://uc.educity.cn/tiku/testReport.html?id=21183026</a></td>\n<td>64</td>\n</tr>\n<tr>\n<td>2018</td>\n<td>案例分析</td>\n<td><a href=\"https://uc.educity.cn/tiku/testReport.html?id=19435318\" target=\"_blank\" rel=\"noopener\">https://uc.educity.cn/tiku/testReport.html?id=19435318</a></td>\n<td></td>\n</tr>\n<tr>\n<td>2018</td>\n<td>论文</td>\n<td><a href=\"https://uc.educity.cn/tiku/testReport.html?id=21182374\" target=\"_blank\" rel=\"noopener\">https://uc.educity.cn/tiku/testReport.html?id=21182374</a></td>\n<td></td>\n</tr>\n<tr>\n<td>2019</td>\n<td>综合知识</td>\n<td><a href=\"https://uc.educity.cn/tiku/testReport.html?id=19095458\" target=\"_blank\" rel=\"noopener\">https://uc.educity.cn/tiku/testReport.html?id=19095458</a></td>\n<td>47</td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>2019</td>\n<td>案例分析</td>\n<td><a href=\"https://uc.educity.cn/tiku/testReport.html?id=21182466\" target=\"_blank\" rel=\"noopener\">https://uc.educity.cn/tiku/testReport.html?id=21182466</a></td>\n<td></td>\n</tr>\n<tr>\n<td>2019</td>\n<td>论文</td>\n<td><a href=\"https://uc.educity.cn/tiku/testReport.html?id=18720605\" target=\"_blank\" rel=\"noopener\">https://uc.educity.cn/tiku/testReport.html?id=18720605</a></td>\n<td></td>\n</tr>\n<tr>\n<td>2020</td>\n<td>综合知识</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>2020</td>\n<td>案例分析</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>2020</td>\n<td>论文</td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n<table>\n<thead>\n<tr>\n<th>每日练习</th>\n<th>测试报告</th>\n</tr>\n</thead>\n<tbody><tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n"},{"title":"面向对象设计的启发60条黄金法则","date":"2020-09-01T03:15:41.000Z","_content":"\n\n\n本文翻译内容来自http://www.cs.uno.edu/~jaime/Courses/4210/heuristics.pdf ，主要是面向对象设计的启发。而这些checklist来自Arthur J. Riel的书Object-Oriented Design Heuristics总结的checklist,中文出版书叫面向对象启示录,非常棒的一本书。中文也有相关checklist的翻译，https://www.cnblogs.com/dxz/archive/2006/07/06/443860.html ，但是我没有参考这个，结合了自己的理解尽可能客观的翻译原文。虽然有些地方很生硬，但是作为提高设计水平也值得尝试。\n\n\n\n1. 不要重复自己！不要重复自己！不要重复自己！（我已经重复了）\n2. 所有数据应该隐藏在类内。\n3. 类的使用者必须依赖于公共接口，但是类不应该依赖于使用它的客户端。\n4. 最小化类的消息规范。\n5. 实现所有客户端可理解的最小接口。\n6. 不要在一个类的公共接口展现实现细节，比如支持的功能。\n7. 不要将用户不需要的或者不感兴趣特性的聚集在公共接口。\n8. 一个类应该捕获有且只有一个关键抽象。\n9. 保存数据和行为在同一地方。\n10. 拆分不相关信息到另一个类。\n11. 不要向对象请求它的状态，或者显示设置状态。向对象请求为你做事。\n12. 将对象视为一类服务而不是一类数据。\n13. 设计面向对象服务时使用它们的状态决定行为。\n14. 使用不可变对象，也叫信使。\n15. 设计时，尽可能水平得，统一得分配系统智能。\n16. 系统中不要创建上帝对象，对那些名字包含Driver, Manager, System, or Subsystem的类保持怀疑。\n17. 小心那些在公共接口中有很多访问器方法的类，拥有这些意味着相关数据和行为没有保持在一处。\n18. todo\n19. 尽可能对真实世界建模。\n20. 从设计中消除不相关的类\n21. 减少系统无关的类。\n22. todo\n23. 最小化类和其他类的协作者。\n24. 最小化类和协作者之间的消息传递。（这是一种叫动态解耦的解耦形式）\n25. 最小化类和协作者之间的协作数量，比如不同的消息传递。\n26. 如果一个类包含另一个类的对象，包含类应该传递消息给被包含对象，包含关系应始终暗示使用关系。\n27. 在一个类内定义的大多数方法大多数情况下应该使用数据成员变量。当这个启发被打破时候意味着差的内聚性。\n28. 类不应该包含  开发者能够短期记忆记住的类的实例变量，这个数字一般是6.\n29. 一个类必须知道它包含什么，但是永远不应该知道谁包含它。\n30. 继承应该只被用作对层次体系建模。\n31. 派生类必须根据定义了解其基类，但基类不应知道任何关于它们的派生类的信息。\n32. 所以数据在基类中应该私有，不要使用受保护的数据，指定受保护查询当希望数据隐藏其表现。\n33. 理论上，继承层次应该很深，越深越好。\n34. todo\n35. 对于实现继承结构，所有抽象类必须是基类。\n36. 在实现继承时，所有基类应该是抽象类。\n37. 如果两个或以上类仅仅共享数据（非公共行为），应该让他们共同继承包含数据和方法的公共基类。\n38. 如果两个或以上类仅仅共享接口（而非实现），仅当它们将被多态使用时，它们应该继承自Java接口或公共基类。\n39. \n\n","source":"_posts/ood-heuristics-translate.md","raw":"---\ntitle: 面向对象设计的启发60条黄金法则\ndate: 2020-09-01 11:15:41\ntags:\n  - OOD\ncategories:\n  - 翻译\n\n---\n\n\n\n本文翻译内容来自http://www.cs.uno.edu/~jaime/Courses/4210/heuristics.pdf ，主要是面向对象设计的启发。而这些checklist来自Arthur J. Riel的书Object-Oriented Design Heuristics总结的checklist,中文出版书叫面向对象启示录,非常棒的一本书。中文也有相关checklist的翻译，https://www.cnblogs.com/dxz/archive/2006/07/06/443860.html ，但是我没有参考这个，结合了自己的理解尽可能客观的翻译原文。虽然有些地方很生硬，但是作为提高设计水平也值得尝试。\n\n\n\n1. 不要重复自己！不要重复自己！不要重复自己！（我已经重复了）\n2. 所有数据应该隐藏在类内。\n3. 类的使用者必须依赖于公共接口，但是类不应该依赖于使用它的客户端。\n4. 最小化类的消息规范。\n5. 实现所有客户端可理解的最小接口。\n6. 不要在一个类的公共接口展现实现细节，比如支持的功能。\n7. 不要将用户不需要的或者不感兴趣特性的聚集在公共接口。\n8. 一个类应该捕获有且只有一个关键抽象。\n9. 保存数据和行为在同一地方。\n10. 拆分不相关信息到另一个类。\n11. 不要向对象请求它的状态，或者显示设置状态。向对象请求为你做事。\n12. 将对象视为一类服务而不是一类数据。\n13. 设计面向对象服务时使用它们的状态决定行为。\n14. 使用不可变对象，也叫信使。\n15. 设计时，尽可能水平得，统一得分配系统智能。\n16. 系统中不要创建上帝对象，对那些名字包含Driver, Manager, System, or Subsystem的类保持怀疑。\n17. 小心那些在公共接口中有很多访问器方法的类，拥有这些意味着相关数据和行为没有保持在一处。\n18. todo\n19. 尽可能对真实世界建模。\n20. 从设计中消除不相关的类\n21. 减少系统无关的类。\n22. todo\n23. 最小化类和其他类的协作者。\n24. 最小化类和协作者之间的消息传递。（这是一种叫动态解耦的解耦形式）\n25. 最小化类和协作者之间的协作数量，比如不同的消息传递。\n26. 如果一个类包含另一个类的对象，包含类应该传递消息给被包含对象，包含关系应始终暗示使用关系。\n27. 在一个类内定义的大多数方法大多数情况下应该使用数据成员变量。当这个启发被打破时候意味着差的内聚性。\n28. 类不应该包含  开发者能够短期记忆记住的类的实例变量，这个数字一般是6.\n29. 一个类必须知道它包含什么，但是永远不应该知道谁包含它。\n30. 继承应该只被用作对层次体系建模。\n31. 派生类必须根据定义了解其基类，但基类不应知道任何关于它们的派生类的信息。\n32. 所以数据在基类中应该私有，不要使用受保护的数据，指定受保护查询当希望数据隐藏其表现。\n33. 理论上，继承层次应该很深，越深越好。\n34. todo\n35. 对于实现继承结构，所有抽象类必须是基类。\n36. 在实现继承时，所有基类应该是抽象类。\n37. 如果两个或以上类仅仅共享数据（非公共行为），应该让他们共同继承包含数据和方法的公共基类。\n38. 如果两个或以上类仅仅共享接口（而非实现），仅当它们将被多态使用时，它们应该继承自Java接口或公共基类。\n39. \n\n","slug":"ood-heuristics-translate","published":1,"updated":"2020-09-05T06:54:58.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clh7s5cu60029xt8j7bm25rky","content":"<p>本文翻译内容来自<a href=\"http://www.cs.uno.edu/~jaime/Courses/4210/heuristics.pdf\" target=\"_blank\" rel=\"noopener\">http://www.cs.uno.edu/~jaime/Courses/4210/heuristics.pdf</a> ，主要是面向对象设计的启发。而这些checklist来自Arthur J. Riel的书Object-Oriented Design Heuristics总结的checklist,中文出版书叫面向对象启示录,非常棒的一本书。中文也有相关checklist的翻译，<a href=\"https://www.cnblogs.com/dxz/archive/2006/07/06/443860.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/dxz/archive/2006/07/06/443860.html</a> ，但是我没有参考这个，结合了自己的理解尽可能客观的翻译原文。虽然有些地方很生硬，但是作为提高设计水平也值得尝试。</p>\n<ol>\n<li>不要重复自己！不要重复自己！不要重复自己！（我已经重复了）</li>\n<li>所有数据应该隐藏在类内。</li>\n<li>类的使用者必须依赖于公共接口，但是类不应该依赖于使用它的客户端。</li>\n<li>最小化类的消息规范。</li>\n<li>实现所有客户端可理解的最小接口。</li>\n<li>不要在一个类的公共接口展现实现细节，比如支持的功能。</li>\n<li>不要将用户不需要的或者不感兴趣特性的聚集在公共接口。</li>\n<li>一个类应该捕获有且只有一个关键抽象。</li>\n<li>保存数据和行为在同一地方。</li>\n<li>拆分不相关信息到另一个类。</li>\n<li>不要向对象请求它的状态，或者显示设置状态。向对象请求为你做事。</li>\n<li>将对象视为一类服务而不是一类数据。</li>\n<li>设计面向对象服务时使用它们的状态决定行为。</li>\n<li>使用不可变对象，也叫信使。</li>\n<li>设计时，尽可能水平得，统一得分配系统智能。</li>\n<li>系统中不要创建上帝对象，对那些名字包含Driver, Manager, System, or Subsystem的类保持怀疑。</li>\n<li>小心那些在公共接口中有很多访问器方法的类，拥有这些意味着相关数据和行为没有保持在一处。</li>\n<li>todo</li>\n<li>尽可能对真实世界建模。</li>\n<li>从设计中消除不相关的类</li>\n<li>减少系统无关的类。</li>\n<li>todo</li>\n<li>最小化类和其他类的协作者。</li>\n<li>最小化类和协作者之间的消息传递。（这是一种叫动态解耦的解耦形式）</li>\n<li>最小化类和协作者之间的协作数量，比如不同的消息传递。</li>\n<li>如果一个类包含另一个类的对象，包含类应该传递消息给被包含对象，包含关系应始终暗示使用关系。</li>\n<li>在一个类内定义的大多数方法大多数情况下应该使用数据成员变量。当这个启发被打破时候意味着差的内聚性。</li>\n<li>类不应该包含  开发者能够短期记忆记住的类的实例变量，这个数字一般是6.</li>\n<li>一个类必须知道它包含什么，但是永远不应该知道谁包含它。</li>\n<li>继承应该只被用作对层次体系建模。</li>\n<li>派生类必须根据定义了解其基类，但基类不应知道任何关于它们的派生类的信息。</li>\n<li>所以数据在基类中应该私有，不要使用受保护的数据，指定受保护查询当希望数据隐藏其表现。</li>\n<li>理论上，继承层次应该很深，越深越好。</li>\n<li>todo</li>\n<li>对于实现继承结构，所有抽象类必须是基类。</li>\n<li>在实现继承时，所有基类应该是抽象类。</li>\n<li>如果两个或以上类仅仅共享数据（非公共行为），应该让他们共同继承包含数据和方法的公共基类。</li>\n<li>如果两个或以上类仅仅共享接口（而非实现），仅当它们将被多态使用时，它们应该继承自Java接口或公共基类。</li>\n<li></li>\n</ol>\n","site":{"data":{}},"excerpt":"","more":"<p>本文翻译内容来自<a href=\"http://www.cs.uno.edu/~jaime/Courses/4210/heuristics.pdf\" target=\"_blank\" rel=\"noopener\">http://www.cs.uno.edu/~jaime/Courses/4210/heuristics.pdf</a> ，主要是面向对象设计的启发。而这些checklist来自Arthur J. Riel的书Object-Oriented Design Heuristics总结的checklist,中文出版书叫面向对象启示录,非常棒的一本书。中文也有相关checklist的翻译，<a href=\"https://www.cnblogs.com/dxz/archive/2006/07/06/443860.html\" target=\"_blank\" rel=\"noopener\">https://www.cnblogs.com/dxz/archive/2006/07/06/443860.html</a> ，但是我没有参考这个，结合了自己的理解尽可能客观的翻译原文。虽然有些地方很生硬，但是作为提高设计水平也值得尝试。</p>\n<ol>\n<li>不要重复自己！不要重复自己！不要重复自己！（我已经重复了）</li>\n<li>所有数据应该隐藏在类内。</li>\n<li>类的使用者必须依赖于公共接口，但是类不应该依赖于使用它的客户端。</li>\n<li>最小化类的消息规范。</li>\n<li>实现所有客户端可理解的最小接口。</li>\n<li>不要在一个类的公共接口展现实现细节，比如支持的功能。</li>\n<li>不要将用户不需要的或者不感兴趣特性的聚集在公共接口。</li>\n<li>一个类应该捕获有且只有一个关键抽象。</li>\n<li>保存数据和行为在同一地方。</li>\n<li>拆分不相关信息到另一个类。</li>\n<li>不要向对象请求它的状态，或者显示设置状态。向对象请求为你做事。</li>\n<li>将对象视为一类服务而不是一类数据。</li>\n<li>设计面向对象服务时使用它们的状态决定行为。</li>\n<li>使用不可变对象，也叫信使。</li>\n<li>设计时，尽可能水平得，统一得分配系统智能。</li>\n<li>系统中不要创建上帝对象，对那些名字包含Driver, Manager, System, or Subsystem的类保持怀疑。</li>\n<li>小心那些在公共接口中有很多访问器方法的类，拥有这些意味着相关数据和行为没有保持在一处。</li>\n<li>todo</li>\n<li>尽可能对真实世界建模。</li>\n<li>从设计中消除不相关的类</li>\n<li>减少系统无关的类。</li>\n<li>todo</li>\n<li>最小化类和其他类的协作者。</li>\n<li>最小化类和协作者之间的消息传递。（这是一种叫动态解耦的解耦形式）</li>\n<li>最小化类和协作者之间的协作数量，比如不同的消息传递。</li>\n<li>如果一个类包含另一个类的对象，包含类应该传递消息给被包含对象，包含关系应始终暗示使用关系。</li>\n<li>在一个类内定义的大多数方法大多数情况下应该使用数据成员变量。当这个启发被打破时候意味着差的内聚性。</li>\n<li>类不应该包含  开发者能够短期记忆记住的类的实例变量，这个数字一般是6.</li>\n<li>一个类必须知道它包含什么，但是永远不应该知道谁包含它。</li>\n<li>继承应该只被用作对层次体系建模。</li>\n<li>派生类必须根据定义了解其基类，但基类不应知道任何关于它们的派生类的信息。</li>\n<li>所以数据在基类中应该私有，不要使用受保护的数据，指定受保护查询当希望数据隐藏其表现。</li>\n<li>理论上，继承层次应该很深，越深越好。</li>\n<li>todo</li>\n<li>对于实现继承结构，所有抽象类必须是基类。</li>\n<li>在实现继承时，所有基类应该是抽象类。</li>\n<li>如果两个或以上类仅仅共享数据（非公共行为），应该让他们共同继承包含数据和方法的公共基类。</li>\n<li>如果两个或以上类仅仅共享接口（而非实现），仅当它们将被多态使用时，它们应该继承自Java接口或公共基类。</li>\n<li></li>\n</ol>\n"},{"title":"软考-高级架构师历年案例分析","date":"2021-10-09T12:50:48.000Z","_content":"\n\n\n| 时间 | 考点               | 知识点                                                       |\n| ---- | ------------------ | ------------------------------------------------------------ |\n| 2020 | 软件架构设计       | 质量属性，架构风格                                           |\n|      | 数据库模型设计     | 逻辑结构                                                     |\n|      | 分布式数据库       | Redis数据结构，持久化策略，淘汰策略                          |\n|      | Web系统设计        | MVC,非功能需求                                               |\n| 2019 | 软件架构设计       | 软件质量属性，架构风格，                                     |\n|      | 软件系统建模       | DFD，流程图                                                  |\n|      | 嵌入式系统         | 开放式架构                                                   |\n|      | 分布式数据库       | 缓存设计，数据一致性，缓存失效，雪崩，穿透                   |\n|      | Web系统架构        | 非功能需求，MVC，SQL注入                                     |\n| 2018 | 系统设计           | 非功能需求，瘦客户端CS架构                                   |\n|      | 软件系统建模       | 结构化方法和DFD，ERD，用例                                   |\n|      | 嵌入式系统         | 实时任务简单任何和复杂任务区别，“腰”型通信模型架构           |\n|      | 分布式数据库       | memcache和redis，数据可靠性与一致性，redis集群切片           |\n|      | Web系统设计        | SOA，ESB，web安全                                            |\n| 2017 | 软件架构评估       | 软件质量属性场景，质量属性效用树，架构风险，敏感点，权衡点   |\n|      | 软件系统设计       | MVC，EJB                                                     |\n|      | 嵌入式系统         | ROS系统，                                                    |\n|      | 数据库设计         | ORM，DAO，工厂设计模式                                       |\n|      | Web系统设计        | 响应式WEB，主从复制，系统设计架构图填充                      |\n| 2016 | 软件架构设计       | 软件质量属性，管道过滤器和数据仓储风格对比，架构图完成       |\n|      | 软件系统建模       | 面向对象，用例图，类图                                       |\n|      | 嵌入式系统         | 实时系统概念，实时特性分类，可靠性分析                       |\n|      | Web系统设计        | J2EE，应用服务器，稳定性与扩展性                             |\n|      | 软件开发模型       | scrum开发过程，MVC，分层架构                                 |\n| 2015 | 软件架构评估       | 软件质量属性，软件属性效用树，系统风险，敏感点，权衡点，     |\n|      | 软件系统建模       | 状态图，活动图                                               |\n|      | 嵌入式系统         | 系统可靠性，恢复块方法，N版本程序设计                        |\n|      | 分布式数据设计     | 关系型，文件系统，内存数据库，SQL设计                        |\n|      | Web系统设计        | MVC，数据持久层好处，数据持久层技术                          |\n| 2014 | 系统架构设计       | MVC，扩展接口模式，                                          |\n|      | 软件系统建模       | DFD，CRUD矩阵                                                |\n|      | 嵌入式系统         | 遗留工程，构件技术和标准                                     |\n|      | 软件架构评估       | 质量属性效用树，系统风险，敏感点，权衡点                     |\n|      | Web系统设计        | 负载均衡，数据分区，MySQL主从，Memcache分布式缓存，磁盘IO问题 |\n| 2013 | 企业应用集成       | ESB，服务建模                                                |\n|      | 项目管理           | 项目计划内容，项目绩效计算，项目延期解决方案                 |\n|      | 嵌入式系统         | FMEA方法，软件风险优先级                                     |\n|      | 设计模式与XML      | MVC设计模式，XML界面管理计算                                 |\n|      | 信息安全           | 公钥体系，数据库敏感字段加密                                 |\n| 2012 | 软件架构设计       | 软件架构风格，不同风格的对比                                 |\n|      | 分布式系统设计     | ODP，进程间通信，分布式中间件                                |\n|      | 嵌入式系统         | GOA开放架构设计，                                            |\n|      | 设计模型           | 创建，结构，行为模式，设计模型选择和应用                     |\n|      | 分布式数据和可设计 | NoSQL，关系型设计，NoSQL的优点和缺点                         |\n| 2011 | 软件架构评估       | 软件质量属性效用树，系统风险，敏感点和权衡点，               |\n|      | 数据库设计         | 反范式化，数据库数据模型                                     |\n|      | 嵌入式系统         | 嵌入式系统架构以及系统设计                                   |\n|      | Web系统设计        | REST，数据获取，交互，访问设计                               |\n|      | 信息系统安全       | 对称加密与公钥加密，机密性和完整性机制，                     |\n| 2010 | 软件架构设计       | 软件架构风格，对比共享数据的主子程序和管道过滤器模式，       |\n|      | 软件系统数据建模   | 单点故障，软化质量属性实现（集中式和分布式）                 |\n|      | 嵌入式系统         | 嵌入式操作系统，开放式架构                                   |\n|      | 企业应用集成       | ESB，                                                        |\n|      | 系统可靠性         | 动态冗余，N版本程序设计技术，检错技术                        |\n| 2009 | 软件架构设计       | 软件质量属性，软件质量属性的实现                             |\n|      | 软件系统建模       | 结构化建模，DFD，高质量DFD设计                               |\n|      | 嵌入式系统         | TLS结构，嵌入式操作系统，可靠性设计                          |\n|      | 软件架构设计       | 软件架构风格，对比架构风格                                   |\n|      | 软件安全           | 信息系统安全，认证方式                                       |\n\n","source":"_posts/ruankao-architect-case-analysis.md","raw":"---\ntitle: 软考-高级架构师历年案例分析\ndate: 2021-10-09 20:50:48\ntags:\n  - 高级架构师案例分析\ncategories:\n  - 考试\n  - 软考\n---\n\n\n\n| 时间 | 考点               | 知识点                                                       |\n| ---- | ------------------ | ------------------------------------------------------------ |\n| 2020 | 软件架构设计       | 质量属性，架构风格                                           |\n|      | 数据库模型设计     | 逻辑结构                                                     |\n|      | 分布式数据库       | Redis数据结构，持久化策略，淘汰策略                          |\n|      | Web系统设计        | MVC,非功能需求                                               |\n| 2019 | 软件架构设计       | 软件质量属性，架构风格，                                     |\n|      | 软件系统建模       | DFD，流程图                                                  |\n|      | 嵌入式系统         | 开放式架构                                                   |\n|      | 分布式数据库       | 缓存设计，数据一致性，缓存失效，雪崩，穿透                   |\n|      | Web系统架构        | 非功能需求，MVC，SQL注入                                     |\n| 2018 | 系统设计           | 非功能需求，瘦客户端CS架构                                   |\n|      | 软件系统建模       | 结构化方法和DFD，ERD，用例                                   |\n|      | 嵌入式系统         | 实时任务简单任何和复杂任务区别，“腰”型通信模型架构           |\n|      | 分布式数据库       | memcache和redis，数据可靠性与一致性，redis集群切片           |\n|      | Web系统设计        | SOA，ESB，web安全                                            |\n| 2017 | 软件架构评估       | 软件质量属性场景，质量属性效用树，架构风险，敏感点，权衡点   |\n|      | 软件系统设计       | MVC，EJB                                                     |\n|      | 嵌入式系统         | ROS系统，                                                    |\n|      | 数据库设计         | ORM，DAO，工厂设计模式                                       |\n|      | Web系统设计        | 响应式WEB，主从复制，系统设计架构图填充                      |\n| 2016 | 软件架构设计       | 软件质量属性，管道过滤器和数据仓储风格对比，架构图完成       |\n|      | 软件系统建模       | 面向对象，用例图，类图                                       |\n|      | 嵌入式系统         | 实时系统概念，实时特性分类，可靠性分析                       |\n|      | Web系统设计        | J2EE，应用服务器，稳定性与扩展性                             |\n|      | 软件开发模型       | scrum开发过程，MVC，分层架构                                 |\n| 2015 | 软件架构评估       | 软件质量属性，软件属性效用树，系统风险，敏感点，权衡点，     |\n|      | 软件系统建模       | 状态图，活动图                                               |\n|      | 嵌入式系统         | 系统可靠性，恢复块方法，N版本程序设计                        |\n|      | 分布式数据设计     | 关系型，文件系统，内存数据库，SQL设计                        |\n|      | Web系统设计        | MVC，数据持久层好处，数据持久层技术                          |\n| 2014 | 系统架构设计       | MVC，扩展接口模式，                                          |\n|      | 软件系统建模       | DFD，CRUD矩阵                                                |\n|      | 嵌入式系统         | 遗留工程，构件技术和标准                                     |\n|      | 软件架构评估       | 质量属性效用树，系统风险，敏感点，权衡点                     |\n|      | Web系统设计        | 负载均衡，数据分区，MySQL主从，Memcache分布式缓存，磁盘IO问题 |\n| 2013 | 企业应用集成       | ESB，服务建模                                                |\n|      | 项目管理           | 项目计划内容，项目绩效计算，项目延期解决方案                 |\n|      | 嵌入式系统         | FMEA方法，软件风险优先级                                     |\n|      | 设计模式与XML      | MVC设计模式，XML界面管理计算                                 |\n|      | 信息安全           | 公钥体系，数据库敏感字段加密                                 |\n| 2012 | 软件架构设计       | 软件架构风格，不同风格的对比                                 |\n|      | 分布式系统设计     | ODP，进程间通信，分布式中间件                                |\n|      | 嵌入式系统         | GOA开放架构设计，                                            |\n|      | 设计模型           | 创建，结构，行为模式，设计模型选择和应用                     |\n|      | 分布式数据和可设计 | NoSQL，关系型设计，NoSQL的优点和缺点                         |\n| 2011 | 软件架构评估       | 软件质量属性效用树，系统风险，敏感点和权衡点，               |\n|      | 数据库设计         | 反范式化，数据库数据模型                                     |\n|      | 嵌入式系统         | 嵌入式系统架构以及系统设计                                   |\n|      | Web系统设计        | REST，数据获取，交互，访问设计                               |\n|      | 信息系统安全       | 对称加密与公钥加密，机密性和完整性机制，                     |\n| 2010 | 软件架构设计       | 软件架构风格，对比共享数据的主子程序和管道过滤器模式，       |\n|      | 软件系统数据建模   | 单点故障，软化质量属性实现（集中式和分布式）                 |\n|      | 嵌入式系统         | 嵌入式操作系统，开放式架构                                   |\n|      | 企业应用集成       | ESB，                                                        |\n|      | 系统可靠性         | 动态冗余，N版本程序设计技术，检错技术                        |\n| 2009 | 软件架构设计       | 软件质量属性，软件质量属性的实现                             |\n|      | 软件系统建模       | 结构化建模，DFD，高质量DFD设计                               |\n|      | 嵌入式系统         | TLS结构，嵌入式操作系统，可靠性设计                          |\n|      | 软件架构设计       | 软件架构风格，对比架构风格                                   |\n|      | 软件安全           | 信息系统安全，认证方式                                       |\n\n","slug":"ruankao-architect-case-analysis","published":1,"updated":"2021-10-31T12:59:42.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clh7s5cu8002dxt8j3pyudln2","content":"<table>\n<thead>\n<tr>\n<th>时间</th>\n<th>考点</th>\n<th>知识点</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>2020</td>\n<td>软件架构设计</td>\n<td>质量属性，架构风格</td>\n</tr>\n<tr>\n<td></td>\n<td>数据库模型设计</td>\n<td>逻辑结构</td>\n</tr>\n<tr>\n<td></td>\n<td>分布式数据库</td>\n<td>Redis数据结构，持久化策略，淘汰策略</td>\n</tr>\n<tr>\n<td></td>\n<td>Web系统设计</td>\n<td>MVC,非功能需求</td>\n</tr>\n<tr>\n<td>2019</td>\n<td>软件架构设计</td>\n<td>软件质量属性，架构风格，</td>\n</tr>\n<tr>\n<td></td>\n<td>软件系统建模</td>\n<td>DFD，流程图</td>\n</tr>\n<tr>\n<td></td>\n<td>嵌入式系统</td>\n<td>开放式架构</td>\n</tr>\n<tr>\n<td></td>\n<td>分布式数据库</td>\n<td>缓存设计，数据一致性，缓存失效，雪崩，穿透</td>\n</tr>\n<tr>\n<td></td>\n<td>Web系统架构</td>\n<td>非功能需求，MVC，SQL注入</td>\n</tr>\n<tr>\n<td>2018</td>\n<td>系统设计</td>\n<td>非功能需求，瘦客户端CS架构</td>\n</tr>\n<tr>\n<td></td>\n<td>软件系统建模</td>\n<td>结构化方法和DFD，ERD，用例</td>\n</tr>\n<tr>\n<td></td>\n<td>嵌入式系统</td>\n<td>实时任务简单任何和复杂任务区别，“腰”型通信模型架构</td>\n</tr>\n<tr>\n<td></td>\n<td>分布式数据库</td>\n<td>memcache和redis，数据可靠性与一致性，redis集群切片</td>\n</tr>\n<tr>\n<td></td>\n<td>Web系统设计</td>\n<td>SOA，ESB，web安全</td>\n</tr>\n<tr>\n<td>2017</td>\n<td>软件架构评估</td>\n<td>软件质量属性场景，质量属性效用树，架构风险，敏感点，权衡点</td>\n</tr>\n<tr>\n<td></td>\n<td>软件系统设计</td>\n<td>MVC，EJB</td>\n</tr>\n<tr>\n<td></td>\n<td>嵌入式系统</td>\n<td>ROS系统，</td>\n</tr>\n<tr>\n<td></td>\n<td>数据库设计</td>\n<td>ORM，DAO，工厂设计模式</td>\n</tr>\n<tr>\n<td></td>\n<td>Web系统设计</td>\n<td>响应式WEB，主从复制，系统设计架构图填充</td>\n</tr>\n<tr>\n<td>2016</td>\n<td>软件架构设计</td>\n<td>软件质量属性，管道过滤器和数据仓储风格对比，架构图完成</td>\n</tr>\n<tr>\n<td></td>\n<td>软件系统建模</td>\n<td>面向对象，用例图，类图</td>\n</tr>\n<tr>\n<td></td>\n<td>嵌入式系统</td>\n<td>实时系统概念，实时特性分类，可靠性分析</td>\n</tr>\n<tr>\n<td></td>\n<td>Web系统设计</td>\n<td>J2EE，应用服务器，稳定性与扩展性</td>\n</tr>\n<tr>\n<td></td>\n<td>软件开发模型</td>\n<td>scrum开发过程，MVC，分层架构</td>\n</tr>\n<tr>\n<td>2015</td>\n<td>软件架构评估</td>\n<td>软件质量属性，软件属性效用树，系统风险，敏感点，权衡点，</td>\n</tr>\n<tr>\n<td></td>\n<td>软件系统建模</td>\n<td>状态图，活动图</td>\n</tr>\n<tr>\n<td></td>\n<td>嵌入式系统</td>\n<td>系统可靠性，恢复块方法，N版本程序设计</td>\n</tr>\n<tr>\n<td></td>\n<td>分布式数据设计</td>\n<td>关系型，文件系统，内存数据库，SQL设计</td>\n</tr>\n<tr>\n<td></td>\n<td>Web系统设计</td>\n<td>MVC，数据持久层好处，数据持久层技术</td>\n</tr>\n<tr>\n<td>2014</td>\n<td>系统架构设计</td>\n<td>MVC，扩展接口模式，</td>\n</tr>\n<tr>\n<td></td>\n<td>软件系统建模</td>\n<td>DFD，CRUD矩阵</td>\n</tr>\n<tr>\n<td></td>\n<td>嵌入式系统</td>\n<td>遗留工程，构件技术和标准</td>\n</tr>\n<tr>\n<td></td>\n<td>软件架构评估</td>\n<td>质量属性效用树，系统风险，敏感点，权衡点</td>\n</tr>\n<tr>\n<td></td>\n<td>Web系统设计</td>\n<td>负载均衡，数据分区，MySQL主从，Memcache分布式缓存，磁盘IO问题</td>\n</tr>\n<tr>\n<td>2013</td>\n<td>企业应用集成</td>\n<td>ESB，服务建模</td>\n</tr>\n<tr>\n<td></td>\n<td>项目管理</td>\n<td>项目计划内容，项目绩效计算，项目延期解决方案</td>\n</tr>\n<tr>\n<td></td>\n<td>嵌入式系统</td>\n<td>FMEA方法，软件风险优先级</td>\n</tr>\n<tr>\n<td></td>\n<td>设计模式与XML</td>\n<td>MVC设计模式，XML界面管理计算</td>\n</tr>\n<tr>\n<td></td>\n<td>信息安全</td>\n<td>公钥体系，数据库敏感字段加密</td>\n</tr>\n<tr>\n<td>2012</td>\n<td>软件架构设计</td>\n<td>软件架构风格，不同风格的对比</td>\n</tr>\n<tr>\n<td></td>\n<td>分布式系统设计</td>\n<td>ODP，进程间通信，分布式中间件</td>\n</tr>\n<tr>\n<td></td>\n<td>嵌入式系统</td>\n<td>GOA开放架构设计，</td>\n</tr>\n<tr>\n<td></td>\n<td>设计模型</td>\n<td>创建，结构，行为模式，设计模型选择和应用</td>\n</tr>\n<tr>\n<td></td>\n<td>分布式数据和可设计</td>\n<td>NoSQL，关系型设计，NoSQL的优点和缺点</td>\n</tr>\n<tr>\n<td>2011</td>\n<td>软件架构评估</td>\n<td>软件质量属性效用树，系统风险，敏感点和权衡点，</td>\n</tr>\n<tr>\n<td></td>\n<td>数据库设计</td>\n<td>反范式化，数据库数据模型</td>\n</tr>\n<tr>\n<td></td>\n<td>嵌入式系统</td>\n<td>嵌入式系统架构以及系统设计</td>\n</tr>\n<tr>\n<td></td>\n<td>Web系统设计</td>\n<td>REST，数据获取，交互，访问设计</td>\n</tr>\n<tr>\n<td></td>\n<td>信息系统安全</td>\n<td>对称加密与公钥加密，机密性和完整性机制，</td>\n</tr>\n<tr>\n<td>2010</td>\n<td>软件架构设计</td>\n<td>软件架构风格，对比共享数据的主子程序和管道过滤器模式，</td>\n</tr>\n<tr>\n<td></td>\n<td>软件系统数据建模</td>\n<td>单点故障，软化质量属性实现（集中式和分布式）</td>\n</tr>\n<tr>\n<td></td>\n<td>嵌入式系统</td>\n<td>嵌入式操作系统，开放式架构</td>\n</tr>\n<tr>\n<td></td>\n<td>企业应用集成</td>\n<td>ESB，</td>\n</tr>\n<tr>\n<td></td>\n<td>系统可靠性</td>\n<td>动态冗余，N版本程序设计技术，检错技术</td>\n</tr>\n<tr>\n<td>2009</td>\n<td>软件架构设计</td>\n<td>软件质量属性，软件质量属性的实现</td>\n</tr>\n<tr>\n<td></td>\n<td>软件系统建模</td>\n<td>结构化建模，DFD，高质量DFD设计</td>\n</tr>\n<tr>\n<td></td>\n<td>嵌入式系统</td>\n<td>TLS结构，嵌入式操作系统，可靠性设计</td>\n</tr>\n<tr>\n<td></td>\n<td>软件架构设计</td>\n<td>软件架构风格，对比架构风格</td>\n</tr>\n<tr>\n<td></td>\n<td>软件安全</td>\n<td>信息系统安全，认证方式</td>\n</tr>\n</tbody></table>\n","site":{"data":{}},"excerpt":"","more":"<table>\n<thead>\n<tr>\n<th>时间</th>\n<th>考点</th>\n<th>知识点</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>2020</td>\n<td>软件架构设计</td>\n<td>质量属性，架构风格</td>\n</tr>\n<tr>\n<td></td>\n<td>数据库模型设计</td>\n<td>逻辑结构</td>\n</tr>\n<tr>\n<td></td>\n<td>分布式数据库</td>\n<td>Redis数据结构，持久化策略，淘汰策略</td>\n</tr>\n<tr>\n<td></td>\n<td>Web系统设计</td>\n<td>MVC,非功能需求</td>\n</tr>\n<tr>\n<td>2019</td>\n<td>软件架构设计</td>\n<td>软件质量属性，架构风格，</td>\n</tr>\n<tr>\n<td></td>\n<td>软件系统建模</td>\n<td>DFD，流程图</td>\n</tr>\n<tr>\n<td></td>\n<td>嵌入式系统</td>\n<td>开放式架构</td>\n</tr>\n<tr>\n<td></td>\n<td>分布式数据库</td>\n<td>缓存设计，数据一致性，缓存失效，雪崩，穿透</td>\n</tr>\n<tr>\n<td></td>\n<td>Web系统架构</td>\n<td>非功能需求，MVC，SQL注入</td>\n</tr>\n<tr>\n<td>2018</td>\n<td>系统设计</td>\n<td>非功能需求，瘦客户端CS架构</td>\n</tr>\n<tr>\n<td></td>\n<td>软件系统建模</td>\n<td>结构化方法和DFD，ERD，用例</td>\n</tr>\n<tr>\n<td></td>\n<td>嵌入式系统</td>\n<td>实时任务简单任何和复杂任务区别，“腰”型通信模型架构</td>\n</tr>\n<tr>\n<td></td>\n<td>分布式数据库</td>\n<td>memcache和redis，数据可靠性与一致性，redis集群切片</td>\n</tr>\n<tr>\n<td></td>\n<td>Web系统设计</td>\n<td>SOA，ESB，web安全</td>\n</tr>\n<tr>\n<td>2017</td>\n<td>软件架构评估</td>\n<td>软件质量属性场景，质量属性效用树，架构风险，敏感点，权衡点</td>\n</tr>\n<tr>\n<td></td>\n<td>软件系统设计</td>\n<td>MVC，EJB</td>\n</tr>\n<tr>\n<td></td>\n<td>嵌入式系统</td>\n<td>ROS系统，</td>\n</tr>\n<tr>\n<td></td>\n<td>数据库设计</td>\n<td>ORM，DAO，工厂设计模式</td>\n</tr>\n<tr>\n<td></td>\n<td>Web系统设计</td>\n<td>响应式WEB，主从复制，系统设计架构图填充</td>\n</tr>\n<tr>\n<td>2016</td>\n<td>软件架构设计</td>\n<td>软件质量属性，管道过滤器和数据仓储风格对比，架构图完成</td>\n</tr>\n<tr>\n<td></td>\n<td>软件系统建模</td>\n<td>面向对象，用例图，类图</td>\n</tr>\n<tr>\n<td></td>\n<td>嵌入式系统</td>\n<td>实时系统概念，实时特性分类，可靠性分析</td>\n</tr>\n<tr>\n<td></td>\n<td>Web系统设计</td>\n<td>J2EE，应用服务器，稳定性与扩展性</td>\n</tr>\n<tr>\n<td></td>\n<td>软件开发模型</td>\n<td>scrum开发过程，MVC，分层架构</td>\n</tr>\n<tr>\n<td>2015</td>\n<td>软件架构评估</td>\n<td>软件质量属性，软件属性效用树，系统风险，敏感点，权衡点，</td>\n</tr>\n<tr>\n<td></td>\n<td>软件系统建模</td>\n<td>状态图，活动图</td>\n</tr>\n<tr>\n<td></td>\n<td>嵌入式系统</td>\n<td>系统可靠性，恢复块方法，N版本程序设计</td>\n</tr>\n<tr>\n<td></td>\n<td>分布式数据设计</td>\n<td>关系型，文件系统，内存数据库，SQL设计</td>\n</tr>\n<tr>\n<td></td>\n<td>Web系统设计</td>\n<td>MVC，数据持久层好处，数据持久层技术</td>\n</tr>\n<tr>\n<td>2014</td>\n<td>系统架构设计</td>\n<td>MVC，扩展接口模式，</td>\n</tr>\n<tr>\n<td></td>\n<td>软件系统建模</td>\n<td>DFD，CRUD矩阵</td>\n</tr>\n<tr>\n<td></td>\n<td>嵌入式系统</td>\n<td>遗留工程，构件技术和标准</td>\n</tr>\n<tr>\n<td></td>\n<td>软件架构评估</td>\n<td>质量属性效用树，系统风险，敏感点，权衡点</td>\n</tr>\n<tr>\n<td></td>\n<td>Web系统设计</td>\n<td>负载均衡，数据分区，MySQL主从，Memcache分布式缓存，磁盘IO问题</td>\n</tr>\n<tr>\n<td>2013</td>\n<td>企业应用集成</td>\n<td>ESB，服务建模</td>\n</tr>\n<tr>\n<td></td>\n<td>项目管理</td>\n<td>项目计划内容，项目绩效计算，项目延期解决方案</td>\n</tr>\n<tr>\n<td></td>\n<td>嵌入式系统</td>\n<td>FMEA方法，软件风险优先级</td>\n</tr>\n<tr>\n<td></td>\n<td>设计模式与XML</td>\n<td>MVC设计模式，XML界面管理计算</td>\n</tr>\n<tr>\n<td></td>\n<td>信息安全</td>\n<td>公钥体系，数据库敏感字段加密</td>\n</tr>\n<tr>\n<td>2012</td>\n<td>软件架构设计</td>\n<td>软件架构风格，不同风格的对比</td>\n</tr>\n<tr>\n<td></td>\n<td>分布式系统设计</td>\n<td>ODP，进程间通信，分布式中间件</td>\n</tr>\n<tr>\n<td></td>\n<td>嵌入式系统</td>\n<td>GOA开放架构设计，</td>\n</tr>\n<tr>\n<td></td>\n<td>设计模型</td>\n<td>创建，结构，行为模式，设计模型选择和应用</td>\n</tr>\n<tr>\n<td></td>\n<td>分布式数据和可设计</td>\n<td>NoSQL，关系型设计，NoSQL的优点和缺点</td>\n</tr>\n<tr>\n<td>2011</td>\n<td>软件架构评估</td>\n<td>软件质量属性效用树，系统风险，敏感点和权衡点，</td>\n</tr>\n<tr>\n<td></td>\n<td>数据库设计</td>\n<td>反范式化，数据库数据模型</td>\n</tr>\n<tr>\n<td></td>\n<td>嵌入式系统</td>\n<td>嵌入式系统架构以及系统设计</td>\n</tr>\n<tr>\n<td></td>\n<td>Web系统设计</td>\n<td>REST，数据获取，交互，访问设计</td>\n</tr>\n<tr>\n<td></td>\n<td>信息系统安全</td>\n<td>对称加密与公钥加密，机密性和完整性机制，</td>\n</tr>\n<tr>\n<td>2010</td>\n<td>软件架构设计</td>\n<td>软件架构风格，对比共享数据的主子程序和管道过滤器模式，</td>\n</tr>\n<tr>\n<td></td>\n<td>软件系统数据建模</td>\n<td>单点故障，软化质量属性实现（集中式和分布式）</td>\n</tr>\n<tr>\n<td></td>\n<td>嵌入式系统</td>\n<td>嵌入式操作系统，开放式架构</td>\n</tr>\n<tr>\n<td></td>\n<td>企业应用集成</td>\n<td>ESB，</td>\n</tr>\n<tr>\n<td></td>\n<td>系统可靠性</td>\n<td>动态冗余，N版本程序设计技术，检错技术</td>\n</tr>\n<tr>\n<td>2009</td>\n<td>软件架构设计</td>\n<td>软件质量属性，软件质量属性的实现</td>\n</tr>\n<tr>\n<td></td>\n<td>软件系统建模</td>\n<td>结构化建模，DFD，高质量DFD设计</td>\n</tr>\n<tr>\n<td></td>\n<td>嵌入式系统</td>\n<td>TLS结构，嵌入式操作系统，可靠性设计</td>\n</tr>\n<tr>\n<td></td>\n<td>软件架构设计</td>\n<td>软件架构风格，对比架构风格</td>\n</tr>\n<tr>\n<td></td>\n<td>软件安全</td>\n<td>信息系统安全，认证方式</td>\n</tr>\n</tbody></table>\n"},{"title":"软考-高级架构师历年论文汇总","date":"2021-10-07T05:24:00.000Z","_content":"\n\n\n| 年份 | 1试题一                            | 2试题二                                | 3试题三                            | 4试题四                                |\n| ---- | ---------------------------------- | -------------------------------------- | ---------------------------------- | -------------------------------------- |\n| 2020 | 论数据分片技术及其应用             | 论云原生架构及其应用                   | 论软件测试中缺陷管理以及应用       | 论企业集成架构设计以及应用             |\n| 2019 | 论负载均衡技术在Web系统中的应用    | 论数据湖技术及其应用                   | 论软件系统架构评估及其应用         | 论软件设计方法以及应用                 |\n| 2018 | 论软件开发过程RUP以及应用          | 论软件体系结构的演化                   | 论面向服务架构设计与应用           | **论NoSQL数据库技术以及应用**          |\n| 2017 | 论软件系统建模方法以及应用         | **论软件架构风格**                     | 论无服务器架构以及应用             | 论软件质量保证及其应用                 |\n| 2016 | **论软件系统架构评估**             | **论软件设计模式以及应用**             | 论数据访问层设计技术以及应用       | 论微服务架构及其应用                   |\n| 2015 | 论应用服务器基础软件               | 论软件系统架构风格                     | **论面向服务的架构及其应用**       | **论企业集成平台的技术以及应用**       |\n| 2014 | 论软件需求管理                     | 论非功能性需求对企业应用架构设计的影响 | **论软件的可靠性设计**             | 论网络安全体系设计                     |\n| 2013 | 论软件架构建模技术与应用           | **论企业应用系统的分层架构风格**       | 论软件可靠性设计技术以及应用       | 论分布式存储系统架构设计               |\n| 2012 | 论企业信息化规划的实施与应用       | 论决策支持系统的开发与应用             | 论企业应用系统的数据持久层架构设计 | 论基于架构的软件设计方法(ABSD)以及应用 |\n| 2011 | 论模型驱动架构在系统开发中的应用   | 论企业集成平台的架构设计               | 论企业架构管理与应用               | 论软件需求获取技术以及应用             |\n| 2010 | 论软件的静态演化和动态演化及其应用 | 论数据挖掘技术的应用                   | 论大规模分布式系统缓存设计策略     | 论软件可靠性评价                       |\n| 2009 | 论基于DSSA的软件架构设计与应用     | 论信息系统建模方法                     | 论基于REST服务的Web应用系统设计    | 论软件可靠性设计与应用                 |\n\n\n\n**往年考题需要针对几个类型去练习**：\n\n1 架构风格\n\n2 面向服务的架构\n\n3 架构评估\n\n4 企业应用集成\n\n5 软件可靠性设计\n\n6 多层架构\n\n7 设计模式\n\n\n\n**时间规划**\n\n2021-10-10  软件架构风格\n\n2021-11-16  设计模式\n\n2021-11-17  面向服务的架构\n\n2021-11-23 企业应用集成\n\n2021-11-24 多层架构\n\n2021-11-30 架构评估\n\n2021-11-31 软件可靠性设计\n\n","source":"_posts/ruankao-architect-paper.md","raw":"---\ntitle: 软考-高级架构师历年论文汇总\ndate: 2021-10-07 13:24:00\ntags:\n  - 高级架构师论文\ncategories:\n  - 考试\n  - 软考\n---\n\n\n\n| 年份 | 1试题一                            | 2试题二                                | 3试题三                            | 4试题四                                |\n| ---- | ---------------------------------- | -------------------------------------- | ---------------------------------- | -------------------------------------- |\n| 2020 | 论数据分片技术及其应用             | 论云原生架构及其应用                   | 论软件测试中缺陷管理以及应用       | 论企业集成架构设计以及应用             |\n| 2019 | 论负载均衡技术在Web系统中的应用    | 论数据湖技术及其应用                   | 论软件系统架构评估及其应用         | 论软件设计方法以及应用                 |\n| 2018 | 论软件开发过程RUP以及应用          | 论软件体系结构的演化                   | 论面向服务架构设计与应用           | **论NoSQL数据库技术以及应用**          |\n| 2017 | 论软件系统建模方法以及应用         | **论软件架构风格**                     | 论无服务器架构以及应用             | 论软件质量保证及其应用                 |\n| 2016 | **论软件系统架构评估**             | **论软件设计模式以及应用**             | 论数据访问层设计技术以及应用       | 论微服务架构及其应用                   |\n| 2015 | 论应用服务器基础软件               | 论软件系统架构风格                     | **论面向服务的架构及其应用**       | **论企业集成平台的技术以及应用**       |\n| 2014 | 论软件需求管理                     | 论非功能性需求对企业应用架构设计的影响 | **论软件的可靠性设计**             | 论网络安全体系设计                     |\n| 2013 | 论软件架构建模技术与应用           | **论企业应用系统的分层架构风格**       | 论软件可靠性设计技术以及应用       | 论分布式存储系统架构设计               |\n| 2012 | 论企业信息化规划的实施与应用       | 论决策支持系统的开发与应用             | 论企业应用系统的数据持久层架构设计 | 论基于架构的软件设计方法(ABSD)以及应用 |\n| 2011 | 论模型驱动架构在系统开发中的应用   | 论企业集成平台的架构设计               | 论企业架构管理与应用               | 论软件需求获取技术以及应用             |\n| 2010 | 论软件的静态演化和动态演化及其应用 | 论数据挖掘技术的应用                   | 论大规模分布式系统缓存设计策略     | 论软件可靠性评价                       |\n| 2009 | 论基于DSSA的软件架构设计与应用     | 论信息系统建模方法                     | 论基于REST服务的Web应用系统设计    | 论软件可靠性设计与应用                 |\n\n\n\n**往年考题需要针对几个类型去练习**：\n\n1 架构风格\n\n2 面向服务的架构\n\n3 架构评估\n\n4 企业应用集成\n\n5 软件可靠性设计\n\n6 多层架构\n\n7 设计模式\n\n\n\n**时间规划**\n\n2021-10-10  软件架构风格\n\n2021-11-16  设计模式\n\n2021-11-17  面向服务的架构\n\n2021-11-23 企业应用集成\n\n2021-11-24 多层架构\n\n2021-11-30 架构评估\n\n2021-11-31 软件可靠性设计\n\n","slug":"ruankao-architect-paper","published":1,"updated":"2021-10-11T18:50:08.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clh7s5cu8002gxt8jbrsdc09j","content":"<table>\n<thead>\n<tr>\n<th>年份</th>\n<th>1试题一</th>\n<th>2试题二</th>\n<th>3试题三</th>\n<th>4试题四</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>2020</td>\n<td>论数据分片技术及其应用</td>\n<td>论云原生架构及其应用</td>\n<td>论软件测试中缺陷管理以及应用</td>\n<td>论企业集成架构设计以及应用</td>\n</tr>\n<tr>\n<td>2019</td>\n<td>论负载均衡技术在Web系统中的应用</td>\n<td>论数据湖技术及其应用</td>\n<td>论软件系统架构评估及其应用</td>\n<td>论软件设计方法以及应用</td>\n</tr>\n<tr>\n<td>2018</td>\n<td>论软件开发过程RUP以及应用</td>\n<td>论软件体系结构的演化</td>\n<td>论面向服务架构设计与应用</td>\n<td><strong>论NoSQL数据库技术以及应用</strong></td>\n</tr>\n<tr>\n<td>2017</td>\n<td>论软件系统建模方法以及应用</td>\n<td><strong>论软件架构风格</strong></td>\n<td>论无服务器架构以及应用</td>\n<td>论软件质量保证及其应用</td>\n</tr>\n<tr>\n<td>2016</td>\n<td><strong>论软件系统架构评估</strong></td>\n<td><strong>论软件设计模式以及应用</strong></td>\n<td>论数据访问层设计技术以及应用</td>\n<td>论微服务架构及其应用</td>\n</tr>\n<tr>\n<td>2015</td>\n<td>论应用服务器基础软件</td>\n<td>论软件系统架构风格</td>\n<td><strong>论面向服务的架构及其应用</strong></td>\n<td><strong>论企业集成平台的技术以及应用</strong></td>\n</tr>\n<tr>\n<td>2014</td>\n<td>论软件需求管理</td>\n<td>论非功能性需求对企业应用架构设计的影响</td>\n<td><strong>论软件的可靠性设计</strong></td>\n<td>论网络安全体系设计</td>\n</tr>\n<tr>\n<td>2013</td>\n<td>论软件架构建模技术与应用</td>\n<td><strong>论企业应用系统的分层架构风格</strong></td>\n<td>论软件可靠性设计技术以及应用</td>\n<td>论分布式存储系统架构设计</td>\n</tr>\n<tr>\n<td>2012</td>\n<td>论企业信息化规划的实施与应用</td>\n<td>论决策支持系统的开发与应用</td>\n<td>论企业应用系统的数据持久层架构设计</td>\n<td>论基于架构的软件设计方法(ABSD)以及应用</td>\n</tr>\n<tr>\n<td>2011</td>\n<td>论模型驱动架构在系统开发中的应用</td>\n<td>论企业集成平台的架构设计</td>\n<td>论企业架构管理与应用</td>\n<td>论软件需求获取技术以及应用</td>\n</tr>\n<tr>\n<td>2010</td>\n<td>论软件的静态演化和动态演化及其应用</td>\n<td>论数据挖掘技术的应用</td>\n<td>论大规模分布式系统缓存设计策略</td>\n<td>论软件可靠性评价</td>\n</tr>\n<tr>\n<td>2009</td>\n<td>论基于DSSA的软件架构设计与应用</td>\n<td>论信息系统建模方法</td>\n<td>论基于REST服务的Web应用系统设计</td>\n<td>论软件可靠性设计与应用</td>\n</tr>\n</tbody></table>\n<p><strong>往年考题需要针对几个类型去练习</strong>：</p>\n<p>1 架构风格</p>\n<p>2 面向服务的架构</p>\n<p>3 架构评估</p>\n<p>4 企业应用集成</p>\n<p>5 软件可靠性设计</p>\n<p>6 多层架构</p>\n<p>7 设计模式</p>\n<p><strong>时间规划</strong></p>\n<p>2021-10-10  软件架构风格</p>\n<p>2021-11-16  设计模式</p>\n<p>2021-11-17  面向服务的架构</p>\n<p>2021-11-23 企业应用集成</p>\n<p>2021-11-24 多层架构</p>\n<p>2021-11-30 架构评估</p>\n<p>2021-11-31 软件可靠性设计</p>\n","site":{"data":{}},"excerpt":"","more":"<table>\n<thead>\n<tr>\n<th>年份</th>\n<th>1试题一</th>\n<th>2试题二</th>\n<th>3试题三</th>\n<th>4试题四</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>2020</td>\n<td>论数据分片技术及其应用</td>\n<td>论云原生架构及其应用</td>\n<td>论软件测试中缺陷管理以及应用</td>\n<td>论企业集成架构设计以及应用</td>\n</tr>\n<tr>\n<td>2019</td>\n<td>论负载均衡技术在Web系统中的应用</td>\n<td>论数据湖技术及其应用</td>\n<td>论软件系统架构评估及其应用</td>\n<td>论软件设计方法以及应用</td>\n</tr>\n<tr>\n<td>2018</td>\n<td>论软件开发过程RUP以及应用</td>\n<td>论软件体系结构的演化</td>\n<td>论面向服务架构设计与应用</td>\n<td><strong>论NoSQL数据库技术以及应用</strong></td>\n</tr>\n<tr>\n<td>2017</td>\n<td>论软件系统建模方法以及应用</td>\n<td><strong>论软件架构风格</strong></td>\n<td>论无服务器架构以及应用</td>\n<td>论软件质量保证及其应用</td>\n</tr>\n<tr>\n<td>2016</td>\n<td><strong>论软件系统架构评估</strong></td>\n<td><strong>论软件设计模式以及应用</strong></td>\n<td>论数据访问层设计技术以及应用</td>\n<td>论微服务架构及其应用</td>\n</tr>\n<tr>\n<td>2015</td>\n<td>论应用服务器基础软件</td>\n<td>论软件系统架构风格</td>\n<td><strong>论面向服务的架构及其应用</strong></td>\n<td><strong>论企业集成平台的技术以及应用</strong></td>\n</tr>\n<tr>\n<td>2014</td>\n<td>论软件需求管理</td>\n<td>论非功能性需求对企业应用架构设计的影响</td>\n<td><strong>论软件的可靠性设计</strong></td>\n<td>论网络安全体系设计</td>\n</tr>\n<tr>\n<td>2013</td>\n<td>论软件架构建模技术与应用</td>\n<td><strong>论企业应用系统的分层架构风格</strong></td>\n<td>论软件可靠性设计技术以及应用</td>\n<td>论分布式存储系统架构设计</td>\n</tr>\n<tr>\n<td>2012</td>\n<td>论企业信息化规划的实施与应用</td>\n<td>论决策支持系统的开发与应用</td>\n<td>论企业应用系统的数据持久层架构设计</td>\n<td>论基于架构的软件设计方法(ABSD)以及应用</td>\n</tr>\n<tr>\n<td>2011</td>\n<td>论模型驱动架构在系统开发中的应用</td>\n<td>论企业集成平台的架构设计</td>\n<td>论企业架构管理与应用</td>\n<td>论软件需求获取技术以及应用</td>\n</tr>\n<tr>\n<td>2010</td>\n<td>论软件的静态演化和动态演化及其应用</td>\n<td>论数据挖掘技术的应用</td>\n<td>论大规模分布式系统缓存设计策略</td>\n<td>论软件可靠性评价</td>\n</tr>\n<tr>\n<td>2009</td>\n<td>论基于DSSA的软件架构设计与应用</td>\n<td>论信息系统建模方法</td>\n<td>论基于REST服务的Web应用系统设计</td>\n<td>论软件可靠性设计与应用</td>\n</tr>\n</tbody></table>\n<p><strong>往年考题需要针对几个类型去练习</strong>：</p>\n<p>1 架构风格</p>\n<p>2 面向服务的架构</p>\n<p>3 架构评估</p>\n<p>4 企业应用集成</p>\n<p>5 软件可靠性设计</p>\n<p>6 多层架构</p>\n<p>7 设计模式</p>\n<p><strong>时间规划</strong></p>\n<p>2021-10-10  软件架构风格</p>\n<p>2021-11-16  设计模式</p>\n<p>2021-11-17  面向服务的架构</p>\n<p>2021-11-23 企业应用集成</p>\n<p>2021-11-24 多层架构</p>\n<p>2021-11-30 架构评估</p>\n<p>2021-11-31 软件可靠性设计</p>\n"},{"title":"COSEA模型:软件系统模型的探索","date":"2022-10-30T08:22:53.000Z","_content":"\n# 前言\n\n系统研究，首先需要还原论，然后是系统论。**还原论**把系统进行拆解，对每一部分进行深入研究，相对静态，**系统论**将每一部分进行整合，形成整体，与外部进行交互，相对动态。如**《庄子 · 养生主第三》庖丁解牛所言：“臣之所好者，道也，进乎技矣。始臣之解牛之时，所见无非牛者。三年之后，未尝见全牛也。方今之时，臣以神遇而不以目视，官知止而神欲行”**。研究递进层次和生物学类似，从细胞（源码）->组织（包）->器官（功能）->系统（模块）->人体（软件）-> 生态（生态圈）。本文主要探讨了对软件系统的研究模型，模型对技术选型，体系化认知，以及更进一步学习技术有帮助。\n\n# 模型\n\n![任务结构](/images/System-Reasearch.png)\n\n**COSEA**模型是软件系统模型，全称 C：Config配置，O：Operation运维，S：System系统，E：Ecosystem生态，A：Admin管理。\n\n模型回答了一个核心问题：**如何研究软件系统？**\n\n模型给出的答案是：从配置C，运维O，系统S，生态E，管理A这五个角度研究软件系统。\n\n黄色方框是五个最重要的因素，层级较高，蓝色方框是对五个因素的分解。总而言之：**配置和运维影响系统，而系统会产生生态和管理**。字母**顺序**也暗含了，先配置，后运维（安装），然后系统跑起来，然后产生管理和生态。\n\n## Config:配置\n\n服务器配置，客户端配置等，理解配置对于**理解**系统，以及系统**调优**非常重要，很多系统概念都在配置中体现，系统的**权衡**也在配置中体现，需要精通最**常用**的配置。很多时候，调优的一大部分其实是改配置。配置分为**操作系统层**的**CPU（线程数），内存（虚拟内存），网络，磁盘**，以及**系统层**的优化。系统层和操作系统层互相影响。借助操作系统实现系统本身的，操作系统配置非常重要。系统层配置也通过**分形原则**到达了操作系统层。通用配置有：压缩算法选择，磁盘读取/写入，缓存，线程。\n\n## Operation:运维\n\n运维包括维护，安装，备份，硬件，安全，部署。包括常用命令，线上配置等。\n\n## System:系统\n\n系统是软件本身，包括**架构**和**功能**，架构包括设计和实现，功能有读写功能，以及业务代码编写等。系统架构回答的基本问题是：**读写流程是什么？以及启动流程？**功能和架构相互影响的是单机和分布式。**单机特性**有：数据模型，存储模型，读写性能，启动流程等，**分布式特性**有：**用户视角**：读/写(增删改查)路径，启动/关闭过程，**系统视角**：一致性模型，复制，分区，共识，容错。复制，共识，分区等等细节都会在用户读写路径视角展现。而系统视角具有通用性的，可以和其他系统进行**类比**，也可以更深一步分析（CAP，PACELC等）。系统核心是：**内部实现，外部交互，系统属性**。总结如下：\n\n- 内部实现，外部交互，系统属性。\n- 单机特性（对标数据库）\n  - 数据模型，存储模型，查询模型（读写性能）\n- 分布式特性（对标分布式系统）\n  - 用户视角：读写路径，启动/关闭。\n  - 系统视角：复制和一致性，容错，分区，共识。\n\n## Ecosystem:生态\n\n生态是围绕该软件的工具链，培训，开源社区，公司，客户，基金会，出版书籍，论文，创始人履历等等。\n\n## Admin:管理\n\n管理主要是监控，包括管理控制台，主要判断系统是否健康，以及内部状态统计等。\n\n# 总结\n\n不同角色关注系统点不一样，想要全面了解系统，以上所有点均需要学习，不求甚解，对系统形成完整认识。本文虽然在讲系统，但是抽象层次还是较低，不够通用，但较为实用。\n","source":"_posts/system-research-template.md","raw":"---\ntitle: COSEA模型:软件系统模型的探索\ndate: 2022-10-30 16:22:53\ntags:\n  - 软件系统模型\n  - COSEA策略\n  - 创造\ncategories:\n  - 模型\n  - 软件模型\n---\n\n# 前言\n\n系统研究，首先需要还原论，然后是系统论。**还原论**把系统进行拆解，对每一部分进行深入研究，相对静态，**系统论**将每一部分进行整合，形成整体，与外部进行交互，相对动态。如**《庄子 · 养生主第三》庖丁解牛所言：“臣之所好者，道也，进乎技矣。始臣之解牛之时，所见无非牛者。三年之后，未尝见全牛也。方今之时，臣以神遇而不以目视，官知止而神欲行”**。研究递进层次和生物学类似，从细胞（源码）->组织（包）->器官（功能）->系统（模块）->人体（软件）-> 生态（生态圈）。本文主要探讨了对软件系统的研究模型，模型对技术选型，体系化认知，以及更进一步学习技术有帮助。\n\n# 模型\n\n![任务结构](/images/System-Reasearch.png)\n\n**COSEA**模型是软件系统模型，全称 C：Config配置，O：Operation运维，S：System系统，E：Ecosystem生态，A：Admin管理。\n\n模型回答了一个核心问题：**如何研究软件系统？**\n\n模型给出的答案是：从配置C，运维O，系统S，生态E，管理A这五个角度研究软件系统。\n\n黄色方框是五个最重要的因素，层级较高，蓝色方框是对五个因素的分解。总而言之：**配置和运维影响系统，而系统会产生生态和管理**。字母**顺序**也暗含了，先配置，后运维（安装），然后系统跑起来，然后产生管理和生态。\n\n## Config:配置\n\n服务器配置，客户端配置等，理解配置对于**理解**系统，以及系统**调优**非常重要，很多系统概念都在配置中体现，系统的**权衡**也在配置中体现，需要精通最**常用**的配置。很多时候，调优的一大部分其实是改配置。配置分为**操作系统层**的**CPU（线程数），内存（虚拟内存），网络，磁盘**，以及**系统层**的优化。系统层和操作系统层互相影响。借助操作系统实现系统本身的，操作系统配置非常重要。系统层配置也通过**分形原则**到达了操作系统层。通用配置有：压缩算法选择，磁盘读取/写入，缓存，线程。\n\n## Operation:运维\n\n运维包括维护，安装，备份，硬件，安全，部署。包括常用命令，线上配置等。\n\n## System:系统\n\n系统是软件本身，包括**架构**和**功能**，架构包括设计和实现，功能有读写功能，以及业务代码编写等。系统架构回答的基本问题是：**读写流程是什么？以及启动流程？**功能和架构相互影响的是单机和分布式。**单机特性**有：数据模型，存储模型，读写性能，启动流程等，**分布式特性**有：**用户视角**：读/写(增删改查)路径，启动/关闭过程，**系统视角**：一致性模型，复制，分区，共识，容错。复制，共识，分区等等细节都会在用户读写路径视角展现。而系统视角具有通用性的，可以和其他系统进行**类比**，也可以更深一步分析（CAP，PACELC等）。系统核心是：**内部实现，外部交互，系统属性**。总结如下：\n\n- 内部实现，外部交互，系统属性。\n- 单机特性（对标数据库）\n  - 数据模型，存储模型，查询模型（读写性能）\n- 分布式特性（对标分布式系统）\n  - 用户视角：读写路径，启动/关闭。\n  - 系统视角：复制和一致性，容错，分区，共识。\n\n## Ecosystem:生态\n\n生态是围绕该软件的工具链，培训，开源社区，公司，客户，基金会，出版书籍，论文，创始人履历等等。\n\n## Admin:管理\n\n管理主要是监控，包括管理控制台，主要判断系统是否健康，以及内部状态统计等。\n\n# 总结\n\n不同角色关注系统点不一样，想要全面了解系统，以上所有点均需要学习，不求甚解，对系统形成完整认识。本文虽然在讲系统，但是抽象层次还是较低，不够通用，但较为实用。\n","slug":"system-research-template","published":1,"updated":"2022-11-04T03:23:18.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clh7s5cu9002kxt8j9gv409ar","content":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>系统研究，首先需要还原论，然后是系统论。<strong>还原论</strong>把系统进行拆解，对每一部分进行深入研究，相对静态，<strong>系统论</strong>将每一部分进行整合，形成整体，与外部进行交互，相对动态。如<strong>《庄子 · 养生主第三》庖丁解牛所言：“臣之所好者，道也，进乎技矣。始臣之解牛之时，所见无非牛者。三年之后，未尝见全牛也。方今之时，臣以神遇而不以目视，官知止而神欲行”</strong>。研究递进层次和生物学类似，从细胞（源码）-&gt;组织（包）-&gt;器官（功能）-&gt;系统（模块）-&gt;人体（软件）-&gt; 生态（生态圈）。本文主要探讨了对软件系统的研究模型，模型对技术选型，体系化认知，以及更进一步学习技术有帮助。</p>\n<h1 id=\"模型\"><a href=\"#模型\" class=\"headerlink\" title=\"模型\"></a>模型</h1><p><img src=\"/images/System-Reasearch.png\" alt=\"任务结构\"></p>\n<p><strong>COSEA</strong>模型是软件系统模型，全称 C：Config配置，O：Operation运维，S：System系统，E：Ecosystem生态，A：Admin管理。</p>\n<p>模型回答了一个核心问题：<strong>如何研究软件系统？</strong></p>\n<p>模型给出的答案是：从配置C，运维O，系统S，生态E，管理A这五个角度研究软件系统。</p>\n<p>黄色方框是五个最重要的因素，层级较高，蓝色方框是对五个因素的分解。总而言之：<strong>配置和运维影响系统，而系统会产生生态和管理</strong>。字母<strong>顺序</strong>也暗含了，先配置，后运维（安装），然后系统跑起来，然后产生管理和生态。</p>\n<h2 id=\"Config-配置\"><a href=\"#Config-配置\" class=\"headerlink\" title=\"Config:配置\"></a>Config:配置</h2><p>服务器配置，客户端配置等，理解配置对于<strong>理解</strong>系统，以及系统<strong>调优</strong>非常重要，很多系统概念都在配置中体现，系统的<strong>权衡</strong>也在配置中体现，需要精通最<strong>常用</strong>的配置。很多时候，调优的一大部分其实是改配置。配置分为<strong>操作系统层</strong>的<strong>CPU（线程数），内存（虚拟内存），网络，磁盘</strong>，以及<strong>系统层</strong>的优化。系统层和操作系统层互相影响。借助操作系统实现系统本身的，操作系统配置非常重要。系统层配置也通过<strong>分形原则</strong>到达了操作系统层。通用配置有：压缩算法选择，磁盘读取/写入，缓存，线程。</p>\n<h2 id=\"Operation-运维\"><a href=\"#Operation-运维\" class=\"headerlink\" title=\"Operation:运维\"></a>Operation:运维</h2><p>运维包括维护，安装，备份，硬件，安全，部署。包括常用命令，线上配置等。</p>\n<h2 id=\"System-系统\"><a href=\"#System-系统\" class=\"headerlink\" title=\"System:系统\"></a>System:系统</h2><p>系统是软件本身，包括<strong>架构</strong>和<strong>功能</strong>，架构包括设计和实现，功能有读写功能，以及业务代码编写等。系统架构回答的基本问题是：<strong>读写流程是什么？以及启动流程？</strong>功能和架构相互影响的是单机和分布式。<strong>单机特性</strong>有：数据模型，存储模型，读写性能，启动流程等，<strong>分布式特性</strong>有：<strong>用户视角</strong>：读/写(增删改查)路径，启动/关闭过程，<strong>系统视角</strong>：一致性模型，复制，分区，共识，容错。复制，共识，分区等等细节都会在用户读写路径视角展现。而系统视角具有通用性的，可以和其他系统进行<strong>类比</strong>，也可以更深一步分析（CAP，PACELC等）。系统核心是：<strong>内部实现，外部交互，系统属性</strong>。总结如下：</p>\n<ul>\n<li>内部实现，外部交互，系统属性。</li>\n<li>单机特性（对标数据库）<ul>\n<li>数据模型，存储模型，查询模型（读写性能）</li>\n</ul>\n</li>\n<li>分布式特性（对标分布式系统）<ul>\n<li>用户视角：读写路径，启动/关闭。</li>\n<li>系统视角：复制和一致性，容错，分区，共识。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Ecosystem-生态\"><a href=\"#Ecosystem-生态\" class=\"headerlink\" title=\"Ecosystem:生态\"></a>Ecosystem:生态</h2><p>生态是围绕该软件的工具链，培训，开源社区，公司，客户，基金会，出版书籍，论文，创始人履历等等。</p>\n<h2 id=\"Admin-管理\"><a href=\"#Admin-管理\" class=\"headerlink\" title=\"Admin:管理\"></a>Admin:管理</h2><p>管理主要是监控，包括管理控制台，主要判断系统是否健康，以及内部状态统计等。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>不同角色关注系统点不一样，想要全面了解系统，以上所有点均需要学习，不求甚解，对系统形成完整认识。本文虽然在讲系统，但是抽象层次还是较低，不够通用，但较为实用。</p>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"前言\"><a href=\"#前言\" class=\"headerlink\" title=\"前言\"></a>前言</h1><p>系统研究，首先需要还原论，然后是系统论。<strong>还原论</strong>把系统进行拆解，对每一部分进行深入研究，相对静态，<strong>系统论</strong>将每一部分进行整合，形成整体，与外部进行交互，相对动态。如<strong>《庄子 · 养生主第三》庖丁解牛所言：“臣之所好者，道也，进乎技矣。始臣之解牛之时，所见无非牛者。三年之后，未尝见全牛也。方今之时，臣以神遇而不以目视，官知止而神欲行”</strong>。研究递进层次和生物学类似，从细胞（源码）-&gt;组织（包）-&gt;器官（功能）-&gt;系统（模块）-&gt;人体（软件）-&gt; 生态（生态圈）。本文主要探讨了对软件系统的研究模型，模型对技术选型，体系化认知，以及更进一步学习技术有帮助。</p>\n<h1 id=\"模型\"><a href=\"#模型\" class=\"headerlink\" title=\"模型\"></a>模型</h1><p><img src=\"/images/System-Reasearch.png\" alt=\"任务结构\"></p>\n<p><strong>COSEA</strong>模型是软件系统模型，全称 C：Config配置，O：Operation运维，S：System系统，E：Ecosystem生态，A：Admin管理。</p>\n<p>模型回答了一个核心问题：<strong>如何研究软件系统？</strong></p>\n<p>模型给出的答案是：从配置C，运维O，系统S，生态E，管理A这五个角度研究软件系统。</p>\n<p>黄色方框是五个最重要的因素，层级较高，蓝色方框是对五个因素的分解。总而言之：<strong>配置和运维影响系统，而系统会产生生态和管理</strong>。字母<strong>顺序</strong>也暗含了，先配置，后运维（安装），然后系统跑起来，然后产生管理和生态。</p>\n<h2 id=\"Config-配置\"><a href=\"#Config-配置\" class=\"headerlink\" title=\"Config:配置\"></a>Config:配置</h2><p>服务器配置，客户端配置等，理解配置对于<strong>理解</strong>系统，以及系统<strong>调优</strong>非常重要，很多系统概念都在配置中体现，系统的<strong>权衡</strong>也在配置中体现，需要精通最<strong>常用</strong>的配置。很多时候，调优的一大部分其实是改配置。配置分为<strong>操作系统层</strong>的<strong>CPU（线程数），内存（虚拟内存），网络，磁盘</strong>，以及<strong>系统层</strong>的优化。系统层和操作系统层互相影响。借助操作系统实现系统本身的，操作系统配置非常重要。系统层配置也通过<strong>分形原则</strong>到达了操作系统层。通用配置有：压缩算法选择，磁盘读取/写入，缓存，线程。</p>\n<h2 id=\"Operation-运维\"><a href=\"#Operation-运维\" class=\"headerlink\" title=\"Operation:运维\"></a>Operation:运维</h2><p>运维包括维护，安装，备份，硬件，安全，部署。包括常用命令，线上配置等。</p>\n<h2 id=\"System-系统\"><a href=\"#System-系统\" class=\"headerlink\" title=\"System:系统\"></a>System:系统</h2><p>系统是软件本身，包括<strong>架构</strong>和<strong>功能</strong>，架构包括设计和实现，功能有读写功能，以及业务代码编写等。系统架构回答的基本问题是：<strong>读写流程是什么？以及启动流程？</strong>功能和架构相互影响的是单机和分布式。<strong>单机特性</strong>有：数据模型，存储模型，读写性能，启动流程等，<strong>分布式特性</strong>有：<strong>用户视角</strong>：读/写(增删改查)路径，启动/关闭过程，<strong>系统视角</strong>：一致性模型，复制，分区，共识，容错。复制，共识，分区等等细节都会在用户读写路径视角展现。而系统视角具有通用性的，可以和其他系统进行<strong>类比</strong>，也可以更深一步分析（CAP，PACELC等）。系统核心是：<strong>内部实现，外部交互，系统属性</strong>。总结如下：</p>\n<ul>\n<li>内部实现，外部交互，系统属性。</li>\n<li>单机特性（对标数据库）<ul>\n<li>数据模型，存储模型，查询模型（读写性能）</li>\n</ul>\n</li>\n<li>分布式特性（对标分布式系统）<ul>\n<li>用户视角：读写路径，启动/关闭。</li>\n<li>系统视角：复制和一致性，容错，分区，共识。</li>\n</ul>\n</li>\n</ul>\n<h2 id=\"Ecosystem-生态\"><a href=\"#Ecosystem-生态\" class=\"headerlink\" title=\"Ecosystem:生态\"></a>Ecosystem:生态</h2><p>生态是围绕该软件的工具链，培训，开源社区，公司，客户，基金会，出版书籍，论文，创始人履历等等。</p>\n<h2 id=\"Admin-管理\"><a href=\"#Admin-管理\" class=\"headerlink\" title=\"Admin:管理\"></a>Admin:管理</h2><p>管理主要是监控，包括管理控制台，主要判断系统是否健康，以及内部状态统计等。</p>\n<h1 id=\"总结\"><a href=\"#总结\" class=\"headerlink\" title=\"总结\"></a>总结</h1><p>不同角色关注系统点不一样，想要全面了解系统，以上所有点均需要学习，不求甚解，对系统形成完整认识。本文虽然在讲系统，但是抽象层次还是较低，不够通用，但较为实用。</p>\n"},{"title":"lintcode解题记录","date":"2019-01-01T15:59:02.000Z","_content":"\n\n\n本文章是一个系列，主要记录自己解算法题的一个记录，每道题会出一篇解题报告，作为自己算法功底的沉淀。每次迭代全部从头开始，并且记录以日期。\n\n下面记录的必须在ide和lintcode上提交过，并且写过代码的。\n\n解题七步曲：1 倾听问题，2样本确认， 3 动口不动手的暴力天然解， 4 动口也动手的最优解，5 路演你的思路，6 结构化的编码，7 单元测试     \n\n我的笔记：[here](https://www.lintcode.com/note/?user__username=xiaozhiliaoo)  (复习时候，刷这个效率更高)\n\n我AC的题目：[here](https://www.lintcode.com/problem/?user_status=accepted)\n\n| No   | Problem                                                      | Describe                                                     | Type                                                       | Diffculty | Note     | Date1     | Date2     | Date3 |\n| ---- | ------------------------------------------------------------ | ------------------------------------------------------------ | ---------------------------------------------------------- | --------- | -------- | --------- | --------- | ----- |\n| 1    | [13-implement-strstr](https://www.lintcode.com/problem/implement-strstr/description) | 字符串查找                                                   | string                                                     | Easy      |          | 2020/6/19 |           |       |\n| 2    | [594-strstr-ii](https://www.lintcode.com/problem/594/)       | 字符串查找 II                                                | hash,kmp                                                   | Hard      |          | 2020/6/19 |           |       |\n| 3    | [17-subsets](https://www.lintcode.com/problem/17/)           | 子集(无重复)                                                 | combination,dfs                                            | Medium    |          | 2020/6/19 |           |       |\n| 4    | [18-subsets-ii](https://www.lintcode.com/problem/18/)        | 子集 II(有重复)                                              | dfs,backtracking                                           | Medium    |          | 2020/6/19 |           |       |\n| 5    | [1361-text-justification](https://www.lintcode.com/problem/1361/) | 文字并排                                                     | simulation                                                 | Hard      |          | 2020/6/19 |           |       |\n| 6    | [38-search-a-2d-matrix-ii](https://www.lintcode.com/problem/38/) | 搜索二维矩阵 II                                              | sort-matrix                                                | Medium    |          | 2020/6/19 |           |       |\n| 7    | [39-recover-rotated-sorted-array](https://www.lintcode.com/problem/recover-rotated-sorted-array) | 恢复旋转排序数组                                             | sort-array                                                 | Easy      |          | 2020/6/19 |           |       |\n| 8    | [573-build-post-office-ii](https://www.lintcode.com/problem/573/) | 邮局的建立 II                                                | bfs                                                        | Medium    |          | 2020/6/21 |           |       |\n| 9    | [616-course-schedule-ii](https://www.lintcode.com/problem/616/) | 安排课程                                                     | bfs,topological-sort                                       | Medium    |          | 2020/6/21 |           |       |\n| 10   | [598-zombie-in-matrix](https://www.lintcode.com/problem/598/) | 僵尸矩阵                                                     | bfs                                                        | Medium    |          | 2020/6/21 |           |       |\n| 11   | [127-topological-sorting](https://www.lintcode.com/problem/127/) | 拓扑排序                                                     | bfs or dfs                                                 | Medium    |          | 2020/6/21 |           |       |\n| 12   | [433-number-of-islands](https://www.lintcode.com/problem/433/) | 岛屿的个数                                                   | bfs or union-find                                          | Easy      |          | 2020/6/21 |           |       |\n| 13   | [677-number-of-big-islands](https://www.lintcode.com/problem/number-of-big-islands/) | 大岛的数量                                                   | bfs                                                        | Medium    |          | 2020/6/22 |           |       |\n| 14   | [109-triangle](https://www.lintcode.com/problem/109/)        | 数字三角形                                                   | dp，坐标型                                                 | Medium    |          | 2020/6/22 |           |       |\n| 15   | [110-minimum-path-sum](https://www.lintcode.com/problem/110) | 最小路径和                                                   | dp                                                         | Easy      |          | 2020/6/22 |           |       |\n| 16   | [114-unique-paths](https://www.lintcode.com/problem/114/)    | 不同的路径                                                   | dp，坐标型号dp                                             | Easy      |          | 2020/6/22 |           |       |\n| 17   | [99-reorder-list](https://www.lintcode.com/problem/99)       | 重排链表                                                     | LinkedList                                                 | Medium    |          | 2020/6/22 |           |       |\n| 18   | [174-remove-nth-node-from-end-of-list](https://www.lintcode.com/problem/174/) | 删除链表中倒数第n个节点                                      | LinkedList                                                 | Easy      |          | 2020/6/23 |           |       |\n| 19   | [102-linked-list-cycle](https://www.lintcode.com/problem/102/) | 带环链表                                                     | LinkedList                                                 | Medium    |          | 2020/6/23 |           |       |\n| 20   | [103-linked-list-cycle-ii](https://www.lintcode.com/problem/103/) | 带环链表 返回环起点值                                        | LinkedList                                                 | Hard      |          | 2020/6/23 |           |       |\n| 21   | [104-merge-k-sorted-lists](https://www.lintcode.com/problem/104/) | 合并k个排序链表                                              | LinkedList                                                 | Medium    |          | 2020/6/23 |           |       |\n| 22   | [105-copy-list-with-random-pointer](https://www.lintcode.com/problem/105/) | 复制带随机指针的链表                                         | LinkedList                                                 | Medium    |          | 2020/6/23 |           |       |\n| 23   | [106-convert-sorted-list-to-binary-search-tree](https://www.lintcode.com/problem/106/) | 有序链表转换为二叉搜索树                                     | LinkedList                                                 | Medium    |          | 2020/6/23 |           |       |\n| 24   | [177-convert-sorted-array-to-binary-search-tree-with-minimal-height](https://www.lintcode.com/problem/177/) | 把排序数组转换为高度最小的二叉搜索树                         | LinkedList                                                 | Easy      |          | 2020/6/23 |           |       |\n| 25   | [74 first-bad-version](https://www.lintcode.com/problem/74/) | 第一个错误的代码版本                                         | binarysearch                                               | Medium    |          | 2020/6/24 |           |       |\n| 26   | [1496  implement-rand10-using-rand7](https://www.lintcode.com/problem/1496/) | 用Rand7()实现Rand10()                                        | simulation                                                 | Medium    |          | 2020/6/24 |           |       |\n| 27   | [66  binary-tree-preorder-traversal](https://www.lintcode.com/problem/66/) | 二叉树的前序遍历                                             | Tree，recursion and iteration(Stack)                       | Easy      |          | 2020/6/24 |           |       |\n| 28   | [67  binary-tree-inorder-traversal](https://www.lintcode.com/problem/67/) | 二叉树的中序遍历                                             | Tree，recursion and iteration(Stack)                       | Easy      |          | 2020/6/24 |           |       |\n| 29   | [68  binary-tree-postorder-traversal](https://www.lintcode.com/problem/68/) | 二叉树的后序遍历                                             | Tree，recursion and iteration(Stack)                       | Easy      |          | 2020/6/24 |           |       |\n| 30   | [86  binary-search-tree-iterator](https://www.lintcode.com/problem/86/) | 二叉查找树迭代器                                             | Tree                                                       | Hard      |          | 2020/6/24 |           |       |\n| 31   | [97  maximum-depth-of-binary-tree](https://www.lintcode.com/problem/97/) | 二叉树的最大深度                                             | DC                                                         | Easy      |          | 2020/6/24 |           |       |\n| 32   | [93  balanced-binary-tree](https://www.lintcode.com/problem/93/) | 是否是平衡二叉树                                             | DC，Recursion                                              | Easy      |          | 2020/6/24 |           |       |\n| 33   | [31  partition-array](https://www.lintcode.com/problem/31/)  | 数组划分                                                     | Array,Quick Sort，Two Pointer                              | Medium    |          | 2020/6/25 |           |       |\n| 34   | [94  binary-tree-maximum-path-sum](https://www.lintcode.com/problem/94/) | 二叉树中的最大路径和                                         | DC                                                         | Medium    |          | 2020/6/25 |           |       |\n| 35   | [88  lowest-common-ancestor-of-a-binary-tree](https://www.lintcode.com/problem/88/) | 最近公共祖先(LCA)                                            | DC,RE，LCA                                                 | Medium    |          | 2020/6/25 |           |       |\n| 36   | [69  binary-tree-level-order-traversal](https://www.lintcode.com/problem/69/) | 二叉树的层次遍历                                             | BFS,Queue                                                  | Easy      |          | 2020/6/25 |           |       |\n| 37   | [70  binary-tree-level-order-traversal-ii](https://www.lintcode.com/problem/70/) | 二叉树的层次遍历 II                                          | BFS                                                        | Medium    |          | 2020/6/25 |           |       |\n| 38   | [95  validate-binary-search-tree](https://www.lintcode.com/problem/95/) | 验证二叉查找树                                               | traversal                                                  | Medium    |          | 2020/6/25 |           |       |\n| 39   | [85  insert-node-in-a-binary-search-tree](https://www.lintcode.com/problem/85/) | 在二叉查找树中插入节点                                       | BST，分治                                                  | Medium    |          | 2020/6/25 |           |       |\n| 40   | [86  binary-search-tree-iterator](https://www.lintcode.com/problem/86/) | 在二叉查找树中插入节点                                       | BST，分治                                                  | Hard      |          | 2020/6/25 |           |       |\n| 41   | [87  remove-node-in-binary-search-tree](https://www.lintcode.com/problem/87/) | 删除二叉查找树的节点                                         | BST，分治                                                  | Hard      |          | 2020/6/25 |           |       |\n| 42   | [11  search-range-in-binary-search-tree](https://www.lintcode.com/problem/11/) | 二叉查找树中搜索区间                                         | tree-traversal                                             | Medium    |          | 2020/6/25 |           |       |\n| 42   | [12  min-stack](https://www.lintcode.com/problem/12/)        | 最小栈                                                       | stack，Simulation                                          | Medium    |          | 2020/6/25 |           |       |\n| 43   | [40  implement-queue-by-two-stacks](https://www.lintcode.com/problem/40/) | 双栈实现队列                                                 | stack，Simulation                                          | Medium    |          | 2020/6/25 |           |       |\n| 44   | [494-implement-stack-by-two-queues](https://www.lintcode.com/problem/494/) | 双队列实现栈                                                 | queue                                                      | Medium    |          | 2020/6/25 |           |       |\n| 45   | [130  heapify](https://www.lintcode.com/problem/130/)        | 堆化                                                         | heap                                                       | Medium    |          | 2020/6/25 |           |       |\n| 46   | [158  valid-anagram](https://www.lintcode.com/problem/158/)  | 两个字符串是变位词                                           | string,map                                                 | Easy      |          | 2020/6/26 |           |       |\n| 47   | [122  largest-rectangle-in-histogram](https://www.lintcode.com/problem/122/) | 直方图最大矩形覆盖                                           | monotonic stack                                            | Hard      |          | 2020/6/26 |           |       |\n| 48   | [126-max-tree](https://www.lintcode.com/problem/126/)        | 最大树                                                       | monotonic stack                                            | Hard      |          | 2020/6/26 |           |       |\n| 49   | [134-lru  cache](https://www.lintcode.com/problem/134/)      | LRU缓存策略                                                  | hash                                                       | Hard      |          | 2020/6/26 |           |       |\n| 50   | [24-lfu  cache](https://www.lintcode.com/problem/24/)        | LFU缓存                                                      | hash                                                       | Hard      |          | 2020/6/26 |           |       |\n| 51   | [129-rehashing](https://www.lintcode.com/problem/129/)       | 重哈希                                                       | hash                                                       | Medium    |          | 2020/6/26 |           |       |\n| 52   | [171-anagrams](https://www.lintcode.com/problem/171/)        | 变位词                                                       | hash                                                       | Medium    |          | 2020/6/26 |           |       |\n| 53   | [138-subarray-sum](https://www.lintcode.com/problem/138/)    | 子数组之和                                                   | hash，前缀和                                               | Easy      |          | 2020/6/26 |           |       |\n| 54   | [124-longest-consecutive-sequence](https://www.lintcode.com/problem/124/) | 最长连续序列                                                 | hash                                                       | Medium    |          | 2020/6/26 | 2021/2/13 |       |\n| 55   | [81-find-median-from-data-stream](https://www.lintcode.com/problem/81/) | 数据流中位数                                                 | heap                                                       | Hard      |          | 2020/6/26 |           |       |\n| 56   | [132-word-search-ii](https://www.lintcode.com/problem/132/)  | 单词搜索 II                                                  | trie                                                       | Hard      |          | 2020/6/26 |           |       |\n| 57   | [442-implement-trie-prefix-tree](https://www.lintcode.com/problem/442/) | 实现 Trie（前缀树）                                          | trie                                                       |           |          | 2020/6/27 |           |       |\n| 58   | [61-search-for-a-range](https://www.lintcode.com/problem/61/) | 搜索区间(对比[138](https://www.lintcode.com/problem/138/))   | binarysearch                                               | Medium    |          | 2020/6/27 | 2021/2/13 |       |\n| 59   | [60-search-insert-position](https://www.lintcode.com/problem/60/) | 搜索插入位置                                                 | binarysearch                                               | Easy      |          | 2020/6/27 |           |       |\n| 60   | [28-search-a-2d-matrix](https://www.lintcode.com/problem/28/) | 搜索二维矩阵                                                 | binarysearch                                               | Easy      |          | 2020/6/27 |           |       |\n| 61   | [75-find-peak-element](https://www.lintcode.com/problem/75/) | 寻找峰值                                                     | binarysearch                                               | Medium    |          | 2020/6/27 |           |       |\n| 62   | [62-search-in-rotated-sorted-array(无重复)](https://www.lintcode.com/problem/62/) | 搜索旋转排序数组                                             | binarysearch                                               | Medium    |          | 2020/6/27 |           |       |\n| 63   | [63-search-in-rotated-sorted-array-ii(有重复)](https://www.lintcode.com/problem/63/) | 搜索旋转排序数组                                             | 62 follow up                                               | Medium    |          | 2020/6/27 |           |       |\n| 64   | [6-merge-two-sorted-arrays](https://www.lintcode.com/problem/6/) | 合并排序数组 II                                              | Two Pointers                                               | Easy      |          | 2020/6/27 |           |       |\n| 65   | [64-merge-sorted-array](https://www.lintcode.com/problem/64/) | 合并排序数组                                                 | Two Pointers                                               | Easy      |          | 2020/6/27 |           |       |\n| 66   | [159-find-minimum-in-rotated-sorted-array](https://www.lintcode.com/problem/159/) | 寻找旋转排序数组中的最小值(无重复)                           | binarysearch                                               | Medium    |          | 2020/6/27 |           |       |\n| 67   | [160-find-minimum-in-rotated-sorted-array-ii](https://www.lintcode.com/problem/160/) | 寻找旋转排序数组中的最小值(有重复)                           | binarysearch                                               | Medium    |          | 2020/6/27 |           |       |\n| 68   | [65-median-of-two-sorted-arrays](https://www.lintcode.com/problem/65/) | 两个排序数组的中位数                                         | binarysearch,FindKMax                                      | Hard      |          | 2020/6/27 |           |       |\n| 69   | [8-rotate-string](https://www.lintcode.com/problem/8/)       | 旋转字符串                                                   | string，simulation，三步翻转法                             | Easy      |          | 2020/6/27 |           |       |\n| 70   | [53-reverse-words-in-a-string](https://www.lintcode.com/problem/53/) | 翻转字符串中的单词                                           | string                                                     | Easy      |          | 2020/6/27 |           |       |\n| 71   | [241-string-to-integer](https://www.lintcode.com/problem/241/) | 转换字符串到整数                                             | string                                                     | Easy      |          | 2020/6/28 |           |       |\n| 72   | [1510-buddy-strings](https://www.lintcode.com/problem/1510/) | 亲密字符串                                                   | string                                                     | Easy      |          | 2020/6/28 |           |       |\n| 73   | [415-valid-palindrome](https://www.lintcode.com/problem/415/) | 有效回文串                                                   | string，双指针                                             | Medium    |          | 2020/6/28 |           |       |\n| 74   | [767-reverse-array](https://www.lintcode.com/problem/767/)   | 翻转数组                                                     | string，reverse                                            | Easy      |          | 2020/6/28 |           |       |\n| 75   | [1283-reverse-string](https://www.lintcode.com/problem/1283/) | 翻转字符串                                                   | string，reverse                                            | Easy      |          | 2020/6/28 |           |       |\n| 76   | [78-longest-common-prefix](https://www.lintcode.com/problem/78/) | 最长公共前缀 (LCP)                                           | string。Simulation                                         | Medium    |          | 2020/6/28 |           |       |\n| 77   | [1263-is-subsequence](https://www.lintcode.com/problem/1263/) | 是子序列吗                                                   | string，Simulation                                         | Medium    |          | 2020/6/28 |           |       |\n| 78   | [384-longest-substring-without-repeating-characters](https://www.lintcode.com/problem/384/) | 最长无重复字符的子串                                         | string，two pointer                                        | Medium    |          | 2020/6/29 | 2021/2/14 |       |\n| 79   | [213-string-compression](https://www.lintcode.com/problem/213/) | 字符串压缩                                                   | string                                                     | Easy      |          | 2020/6/29 |           |       |\n| 80   | [1352-compare-version-numbers](https://www.lintcode.com/problem/1352/) | 比较版本号                                                   | string                                                     | Medium    |          | 2020/6/29 |           |       |\n| 81   | [1542-nexttime-norepeat](https://www.lintcode.com/problem/1542/) | 下一个不重复的时间                                           | string                                                     | Medium    |          | 2020/6/29 |           |       |\n| 82   | [192-wildcard-matching](https://www.lintcode.com/problem/192/) | 通配符匹配                                                   | string，DFS                                                | Hard      |          | 2020/6/30 |           |       |\n| 83   | [98-sort-list（排序链表）](https://www.lintcode.com/problem/98/) | 链表排序(归并和快速)                                         | sort                                                       | Medium    |          | 2020/6/30 |           |       |\n| 84   | [463-sort-integers](https://www.lintcode.com/problem/463/)   | 整数排序                                                     | sort【直接选择(选择)，冒泡排序(交换)，直接插入排序(插入)】 | Native    | 简单排序 | 2020/6/30 |           |       |\n| 85   | [464-sort-integers-ii ](https://www.lintcode.com/problem/464/) | 整数排序2                                                    | sort【堆排序(选择)，快排(交换)，归并排序(归并)】           | Medium    | 分治排序 | 2020/6/30 |           |       |\n| 86   | [136-palindrome-partitioning](https://www.lintcode.com/problem/136/) | 分割回文串                                                   | 组合型DFS+Backtracking                                     | Medium    |          | 2020/7/1  |           |       |\n| 87   | [77-longest-common-subsequence](https://www.lintcode.com/problem/77/) | 最长公共子序列(LCS)                                          | match-dp                                                   | Medium    |          | 2020/7/2  |           |       |\n| 88   | [79-longest-common-substring](https://www.lintcode.com/problem/79/) | 最长公共子串(LCS)                                            | Two Sequences DP                                           | Medium    |          | 2020/7/2  |           |       |\n| 89   | [680-spilt-string](https://www.lintcode.com/problem/680/)    | 分割字符串                                                   | 组合型DFS+Backtracking                                     | Medium    |          | 2020/7/2  |           |       |\n| 90   | [15-permutations](https://www.lintcode.com/problem/15/)      | 全排列                                                       | 排列型DFS+Backtracking                                     | Medium    |          | 2020/7/2  |           |       |\n| 91   | [16-permutations-ii](https://www.lintcode.com/problem/16/)   | 全排列                                                       | 排列型DFS+Backtracking                                     | Medium    |          | 2020/7/2  |           |       |\n| 92   | [669-coin-change](https://www.lintcode.com/problem/669/)     | 换硬币                                                       | 无限背包,DFS,DP,不用回溯                                   |           |          | 2020/7/3  |           |       |\n| 93   | [816-traveling-salesman-problem](https://www.lintcode.com/problem/816/) | 旅行商问题                                                   | 排列型DFS，pruning,dp,旅行售货员问题，TSP问题，组合优化    | Hard      |          | 2020/7/3  |           |       |\n| 94   | [1147-work-plan](https://www.lintcode.com/problem/1147/)     | 工作安排                                                     | coordinate-dp                                              | Medium    |          | 2020/7/3  |           |       |\n| 95   | [76-longest-increasing-subsequence](https://www.lintcode.com/problem/76/) | 最长上升子序列(LIS)                                          | match-dp，LIS                                              | Medium    |          | 2020/7/3  |           |       |\n| 96   | [91-minimum-adjustment-cost](https://www.lintcode.com/problem/91/) | 最小调整代价                                                 | dp                                                         | Medium    |          | 2020/7/3  |           |       |\n| 97   | [34-n-queens-ii](https://www.lintcode.com/problem/34/)       | N皇后问题（方案数）                                          | Backtracking+DFS                                           | Medium    |          | 2020/7/4  |           |       |\n| 98   | [33-n-queens](https://www.lintcode.com/problem/33/)          | N皇后问题（具体方案）                                        | Backtracking+DFS                                           | Medium    |          | 2020/7/4  |           |       |\n| 99   | [622-frog-jump](https://www.lintcode.com/problem/622/)       | 青蛙跳                                                       | DFS，DP                                                    | Hard      |          | 2020/7/4  |           |       |\n| 100  | [602-russian-doll-envelopes](https://www.lintcode.com/problem/602/) | 俄罗斯套娃信封                                               | dfs(指数级),dp(正解)                                       | Hard      |          | 2020/7/4  |           |       |\n| 101  | [116-jump-game](https://www.lintcode.com/problem/116/)       | 跳跃游戏                                                     | 单序列dp(可行性)，贪心                                     | Medium    |          | 2020/7/4  |           |       |\n| 102  | [117-jump-game-ii](https://www.lintcode.com/problem/117/)    | 跳跃游戏                                                     | 单序列dp(最小值)                                           | Medium    |          | 2020/7/4  |           |       |\n| 103  | [149-best-time-to-buy-and-sell-stock](https://www.lintcode.com/problem/149/) | 买卖股票的最佳时机（一次交易）                               | 单序列dp(最大值)                                           | Medium    |          | 2020/7/4  |           |       |\n| 104  | [115-unique-paths-ii](https://www.lintcode.com/problem/115/) | 不同的路径 II                                                | 坐标DP                                                     | Easy      |          | 2020/7/4  |           |       |\n| 105  | [111-climbing-stairs](https://www.lintcode.com/problem/111/) | 爬楼梯                                                       | 单序列dp(计数问题)                                         | Easy      |          | 2020/7/4  |           |       |\n| 106  | [563-backpack-v](https://www.lintcode.com/problem/563/)      | 背包问题 V                                                   | Backpack DP                                                | Medium    |          | 2020/7/4  |           |       |\n| 107  | [630-knight-shortest-path-ii](https://www.lintcode.com/problem/630/) | 骑士的最短路径II                                             | 坐标dp, 单向BFS->双向BFS                                   | Medium    |          | 2020/7/6  |           |       |\n| 108  | [564-combination-sum-iv(backpack-vi)](https://www.lintcode.com/problem/564/) | 组合总和 IV                                                  | 单序列dp，Backpack DP                                      | Medium    |          | 2020/7/6  |           |       |\n| 109  | [512-decode-ways](https://www.lintcode.com/problem/512/)     | 解码方法                                                     | dp                                                         | Medium    |          | 2020/7/7  |           |       |\n| 110  | [589-connecting-graph](https://www.lintcode.com/problem/589/) | 连接图                                                       | union-find                                                 | Medium    |          | 2020/7/7  | 2021/2/14 |       |\n| 111  | [752-rogue-knight-sven](https://www.lintcode.com/problem/752/) | 流浪剑客斯温                                                 | dp                                                         | Medium    |          | 2020/7/7  |           |       |\n| 112  | [590-connecting-graph-ii](https://www.lintcode.com/problem/590/) | 连接图                                                       | union-find                                                 | Medium    |          | 2020/7/8  |           |       |\n| 113  | [360-sliding-window-median](https://www.lintcode.com/problem/360/) | 滑动窗口的中位数                                             | heap，Sliding Window                                       | Hard      |          | 2020/7/8  |           |       |\n| 114  | [401-kth-smallest-number-in-sorted-matrix](https://www.lintcode.com/problem/401/) | 排序矩阵中的从小到大第k个数                                  | heap                                                       | Medium    |          | 2020/7/8  |           |       |\n| 115  | [362-sliding-window-maximum](https://www.lintcode.com/problem/362/) | 滑动窗口的最大值                                             | monotonic-queue                                            | Hard      |          | 2020/7/8  |           |       |\n| 116  | [178-graph-valid-tree](https://www.lintcode.com/problem/178/) | 图是否是树                                                   | union-find                                                 | Medium    |          | 2020/7/8  |           |       |\n| 117  | [434-number-of-islands-ii](https://www.lintcode.com/problem/434/) | 岛屿的个数II                                                 | union-find                                                 | Medium    |          | 2020/7/9  |           |       |\n| 118  | [430-scramble-string](https://www.lintcode.com/problem/430/) | 攀爬字符串                                                   | dfs+pruning                                                | Hard      |          | 2020/7/9  |           |       |\n| 119  | [802-sudoku-solver](https://www.lintcode.com/problem/802/)   | 数独                                                         | dfs+pruning+backtracking                                   | Hard      |          | 2020/7/10 |           |       |\n| 120  | [121-word-ladder-ii](https://www.lintcode.com/problem/121/)  | 单词接龙 II                                                  | dfs+pruning+backtracking                                   | Hard      |          | 2020/7/10 |           |       |\n| 121  | [582-word-break-ii](https://www.lintcode.com/problem/582/)   | 单词拆分II                                                   | dfs+pruning+backtracking                                   | Hard      |          | 2020/7/11 |           |       |\n| 122  | [652-factorization](https://www.lintcode.com/problem/652/)   | 因式分解                                                     | dfs+pruning+backtracking                                   | Medium    |          | 2020/7/11 |           |       |\n| 123  | [119-edit-distance](https://www.lintcode.com/problem/119/)   | 编辑距离                                                     | 匹配性dp                                                   | Medium    |          | 2020/7/11 |           |       |\n| 124  | [787-the-maze](https://www.lintcode.com/problem/787/)        | 迷宫                                                         | bfs                                                        | Medium    |          | 2020/7/11 |           |       |\n| 125  | [788-the-maze-ii](https://www.lintcode.com/problem/788/)     | 迷宫                                                         | bfs                                                        | Medium    |          | 2020/7/11 |           |       |\n| 126  | [789-the-maze-iii](https://www.lintcode.com/problem/789/)    | 迷宫                                                         | bfs                                                        | Hard      |          | 2020/7/11 |           |       |\n| 127  | [691-recover-binary-search-tree](https://www.lintcode.com/problem/691/) | 恢复二叉搜索树                                               | bst                                                        | Medium    |          | 2020/7/12 |           |       |\n| 128  | [82-single-number](https://www.lintcode.com/problem/82/)     | 落单的数2n*1,两次                                            | bit，hash                                                  | Easy      |          | 2020/7/12 |           |       |\n| 129  | [83-single-number-ii](https://www.lintcode.com/problem/83/)  | 落单的数 II 3n*1，三次                                       | bit，hash                                                  | Medium    |          | 2020/7/12 |           |       |\n| 130  | [84-single-number-iii](https://www.lintcode.com/problem/84/) | 落单的数2*n + 2                                              | bit，hash                                                  | Medium    |          | 2020/7/12 |           |       |\n| 131  | [46-majority-element](https://www.lintcode.com/problem/46/)  | 主元素(不是众数) 1/2                                         | Enumerate                                                  | Easy      |          | 2020/7/12 |           |       |\n| 132  | [1018-champagne-tower(triangle)](https://www.lintcode.com/problem/1018/) | 香槟塔                                                       | 二维坐标dp                                                 | Medium    |          | 2020/7/12 |           |       |\n| 133  | [200-longest-palindromic-substring](https://www.lintcode.com/problem/200/) | 最长回文子串                                                 | 区间dp                                                     | Medium    |          | 2020/7/14 |           |       |\n| 134  | [1565-modern-ludo-i](https://www.lintcode.com/problem/1565/) | 飞行棋 I                                                     | 一维坐标dp                                                 | Medium    |          | 2020/7/16 |           |       |\n| 135  | [1141-the-months-days](https://www.lintcode.com/problem/1141/) | 月份天数                                                     | 闰年                                                       | Easy      |          | 2020/7/16 |           |       |\n| 136  | [254-drop-eggs](https://www.lintcode.com/problem/254/)       | 丢鸡蛋                                                       | 归纳法                                                     | Easy      |          | 2020/7/16 |           |       |\n| 137  | [47-majority-element-ii](https://www.lintcode.com/problem/47/) | 主元素1/3                                                    | Enumerate                                                  | Medium    |          | 2020/7/19 |           |       |\n| 138  | [48-majority-element-iii](https://www.lintcode.com/problem/48/) | 主元素1/k                                                    | HashTable                                                  | Medium    |          | 2020/7/20 |           |       |\n| 139  | [150-best-time-to-buy-and-sell-stock-ii](https://www.lintcode.com/problem/150/) | 买卖股票的最佳时机 II(多次交易)                              | 贪心                                                       | Medium    |          | 2020/7/20 |           |       |\n| 140  | [151-best-time-to-buy-and-sell-stock-iii](https://www.lintcode.com/problem/151/) | 买卖股票的最佳时机 III(两笔交易)                             | Enumerate                                                  | Medium    |          | 2020/7/20 |           |       |\n| 141  | [393-best-time-to-buy-and-sell-stock-iv](https://www.lintcode.com/problem/393/) | 买卖股票的最佳时机 III(K笔交易)                              | dp                                                         | Medium    |          | 2020/7/20 |           |       |\n| 142  | [44-minimum-subarray](https://www.lintcode.com/problem/44/)  | 最小子数组                                                   | 贪心                                                       | Easy      |          | 2020/7/20 |           |       |\n| 143  | [45-maximum-subarray-difference](https://www.lintcode.com/problem/45/) | 最大子数组差                                                 | 贪心                                                       | Easy      |          | 2020/7/20 |           |       |\n| 144  | [138-subarray-sum](https://www.lintcode.com/problem/138/)    | 子数组之和                                                   | hashmap                                                    | Easy      |          | 2020/7/20 |           |       |\n| 145  | [139-subarray-sum-closest](https://www.lintcode.com/problem/139/) | 最接近零的子数组和                                           | Two Pointers，hashmap                                      | Medium    |          | 2020/7/20 |           |       |\n| 146  | [56-two-sum](https://www.lintcode.com/problem/56/)           | 两数之和                                                     | Two Pointers                                               | Easy      |          | 2020/7/20 |           |       |\n| 147  | [608-two-sum-ii-input-array-is-sorted](https://www.lintcode.com/problem/608/) | 两数和 II-输入已排序的数组                                   | Two Pointers                                               | Medium    |          | 2020/7/20 |           |       |\n| 148  | [57-3sum](https://www.lintcode.com/problem/57/)              | 三数之和                                                     | Two Pointers                                               | Medium    |          | 2020/7/20 |           |       |\n| 149  | [533-two-sum-closest-to-target](https://www.lintcode.com/problem/533/) | 两数和的最接近值                                             | Two Pointers                                               | Medium    |          | 2020/7/20 |           |       |\n| 150  | [89-k-sum](https://www.lintcode.com/problem/89/)             | K数之和                                                      | dp                                                         | Hard      |          | 2020/7/20 |           |       |\n| 151  | [140-fast-power](https://www.lintcode.com/problem/140/)      | 快速幂                                                       | DC                                                         | Medium    |          | 2020/7/21 |           |       |\n| 152  | [1324-count-primes](https://www.lintcode.com/problem/1324/)  | 质数的个数                                                   | Mathmatics                                                 | Easy      |          | 2020/7/21 |           |       |\n| 153  | [141-sqrtx](https://www.lintcode.com/problem/141/)           | 对x开根                                                      | Mathmatics                                                 | Easy      |          | 2020/7/21 |           |       |\n| 154  | [2-trailing-zeros](https://www.lintcode.com/problem/2/)      | 尾部的零                                                     | Mathmatics                                                 | Easy      |          | 2020/7/21 |           |       |\n| 155  | [142.o1-check-power-of-2](https://www.lintcode.com/problem/142/) | O(1)时间检测2的幂次                                          | Binary                                                     | Easy      |          | 2020/7/21 |           |       |\n| 156  | [49-sort-letters-by-case](https://www.lintcode.com/problem/49/) | 字符大小写排序                                               | Two Pointers                                               | Medium    |          | 2020/7/21 |           |       |\n| 157  | [1563-shortest-path-to-the-destination](https://www.lintcode.com/problem/1563/) | 目的地的最短路径                                             | bfs                                                        | Medium    |          | 2020/7/21 |           |       |\n| 158  | [108-palindrome-partitioning-ii](https://www.lintcode.com/problem/108/) | 分割回文串 II                                                | dp                                                         | Medium    |          | 2020/8/2  |           |       |\n| 159  | [107-word-break](https://www.lintcode.com/problem/107/)      | 单词拆分 I                                                   | dp                                                         | Medium    |          | 2020/8/2  |           |       |\n| 160  | [41-maximum-subarray](https://www.lintcode.com/problem/41/)  | 最大子数组                                                   | dp                                                         | Easy      |          | 2020/8/3  |           |       |\n| 161  | [29-interleaving-string](https://www.lintcode.com/problem/29/) | 交叉字符串                                                   | dp                                                         | Medium    |          | 2020/8/9  |           |       |\n| 162  | [513-perfect-squares](https://www.lintcode.com/problem/513/) | 完美平方                                                     | dp                                                         | Medium    |          | 2020/8/9  |           |       |\n| 163  | [394-coins-in-a-line](https://www.lintcode.com/problem/394/) | 硬币排成线                                                   | dp                                                         | Medium    |          | 2020/8/9  |           |       |\n| 164  | [92-backpack](https://www.lintcode.com/problem/92/)          | 背包问题                                                     | dp                                                         | Medium    |          | 2020/8/9  |           |       |\n| 165  | [118-distinct-subsequences](https://www.lintcode.com/problem/118/) | 不同的子序列                                                 | dp                                                         | Medium    |          | 2020/8/9  |           |       |\n| 166  | [604-window-sum](https://www.lintcode.com/problem/604/)      | 滑动窗口内数的和                                             | two-pointer                                                | Easy      |          | 2020/8/9  |           |       |\n| 167  | [539-move-zeroes](https://www.lintcode.com/problem/539/)     | 移动0                                                        | two-pointer                                                | Easy      |          | 2020/8/10 |           |       |\n| 168  | [521.remove-duplicate-numbers-in-array](https://www.lintcode.com/problem/521/) | 数组去重                                                     | two-pointer                                                | Easy      |          | 2020/8/10 |           |       |\n| 169  | [638. Isomorphic Strings](https://www.lintcode.com/problem/638/) | 字符同构                                                     | string                                                     | Easy      |          | 2021/2/10 |           |       |\n| 170  | [626. Rectangle Overlap](https://www.lintcode.com/problem/626/) | 矩形重叠                                                     | string                                                     | Easy      |          | 2021/2/10 |           |       |\n| 171  | [637. Valid Word Abbreviation](https://www.lintcode.com/problem/637/) | 检查缩写单词                                                 | string                                                     | Easy      |          | 2021/2/10 |           |       |\n| 172  | [639. Word Abbreviation](https://www.lintcode.com/problem/639/) | 单词缩写                                                     | string                                                     | Hard      |          | 2021/2/11 |           |       |\n| 173  | [642. Moving Average from Data Stream](https://www.lintcode.com/problem/642/) | 数据流滑动窗口平均值                                         | Prefix Sum Array，rolling array                            | Easy      |          | 2021/2/11 |           |       |\n| 174  | [644. Strobogrammatic Number](https://www.lintcode.com/problem/644/) | 镜像数字                                                     | Enumerate                                                  | Easy      |          | 2021/2/11 |           |       |\n| 175  | [640. One Edit Distance](https://www.lintcode.com/problem/640/) | 一次编辑距离                                                 | Enumerate                                                  | Medium    |          | 2021/2/11 |           |       |\n| 176  | [660. Read N Characters Given Read4](https://www.lintcode.com/problem/660/) | 用Read4从文件中读取N个字符 II-多次调用                       | Enumerate                                                  | Hard      |          | 2021/2/12 |           |       |\n| 177  | [659. Encode and Decode Strings](https://www.lintcode.com/problem/659/) | 编码和解码字符串                                             | Enumerate                                                  | Medium    |          | 2021/2/12 |           |       |\n| 178  | [419. Roman to Integer](https://www.lintcode.com/problem/419/) | 罗马数字转整数                                               | Enumerate                                                  | Medium    |          | 2021/2/12 |           |       |\n| 179  | [418. Integer to Roman](https://www.lintcode.com/problem/418/) | 整数转罗马数字                                               | Enumerate                                                  | Medium    |          | 2021/2/12 |           |       |\n| 180  | [645. Find the Celebrity](https://www.lintcode.com/problem/645/) | 识别名人                                                     | Enumerate                                                  | Medium    |          | 2021/2/12 |           |       |\n| 181  | [641. Missing Ranges](https://www.lintcode.com/problem/641/) | 丢失的间隔                                                   | Enumerate                                                  | Medium    |          | 2021/2/12 |           |       |\n| 182  | [156. Merge Intervals](https://www.lintcode.com/problem/156/) | 合并区间                                                     | Enumerate                                                  | Easy      |          | 2021/2/12 |           |       |\n| 183  | [30. Insert Interval](https://www.lintcode.com/problem/30/)  | 插入区间                                                     | Enumerate                                                  | Medium    |          | 2021/2/12 |           |       |\n| 184  | [646. First Position Unique Character](https://www.lintcode.com/problem/646/) | 第一个不重复字符位置                                         | Hash                                                       | Easy      |          | 2021/2/12 |           |       |\n| 185  | [647. Find All Anagrams in a String](https://www.lintcode.com/problem/647/) | 子串字谜                                                     | Hash+Siding Windows                                        | Medium    |          | 2021/2/12 |           |       |\n| 186  | [423. Valid Parentheses](https://www.lintcode.com/problem/423/) | 有效的括号序列                                               | Stack                                                      | Easy      |          | 2021/2/13 |           |       |\n| 187  | [526. Load Balancer](https://www.jiuzhang.com/problem/load-balancer/) | 负载均衡                                                     | DS                                                         |           |          | 2021/2/13 |           |       |\n| 188  | [662. Guess Number Higher or Lower](https://www.lintcode.com/problem/662/) | 猜数游戏                                                     | Binary Search                                              | Easy      |          | 2021/2/13 |           |       |\n| 189  | [661. Convert BST to Greater Tree](https://www.lintcode.com/problem/661/) | 把二叉搜索树转化成更大的树                                   | BST                                                        | Easy      |          | 2021/2/13 |           |       |\n| 190  | [649. Binary Tree Upside Down](https://www.lintcode.com/problem/649/) | 二叉树翻转                                                   | BST                                                        | Medium    |          | 2021/2/13 |           |       |\n| 191  | [650. Find Leaves of Binary Tree](https://www.lintcode.com/problem/650/) | 二叉树叶子顺序遍历                                           | BST                                                        | Medium    |          | 2021/2/13 |           |       |\n| 192  | [651. Binary Tree Vertical Order Traversal](https://www.lintcode.com/problem/651/) | 二叉树垂直遍历                                               | Hash+BFS                                                   | Medium    |          | 2021/2/13 |           |       |\n| 193  | [448. Inorder Successor in BST](https://www.lintcode.com/problem/448/) | 二叉查找树的中序后继                                         | BST                                                        | Medium    |          | 2021/2/13 |           |       |\n| 194  | [477. Surrounded Regions](https://www.lintcode.com/problem/477/) | 被围绕的区域                                                 | BFS                                                        | Medium    |          | 2021/2/13 |           |       |\n| 195  | [663. Walls and Gates](https://www.lintcode.com/problem/663/) | 墙和门                                                       | BFS                                                        | Medium    |          | 2021/2/13 |           |       |\n| 196  | [32. Minimum Window Substring](https://www.lintcode.com/problem/32/) | 最小子串覆盖                                                 | Two pointer                                                | Medium    |          | 2021/2/14 |           |       |\n| 197  | [543. Kth Largest in N Arrays](https://www.lintcode.com/problem/543/) | N数组第K大元素(一个数组第[K大](https://www.lintcode.com/problem/5/)) | Heap                                                       | Hard      |          | 2021/2/14 |           |       |\n| 198  | [465. Kth Smallest Sum In Two Sorted Arrays](https://www.lintcode.com/problem/465/) | 两个排序数组和的第K小                                        | Heap                                                       | Hard      |          | 2021/2/14 |           |       |\n| 199  | [591. Connecting Graph III](https://www.lintcode.com/problem/591/) | 连接图 III                                                   | UF                                                         | Medium    |          | 2021/2/14 |           |       |\n| 200  | [1179. Friend Circles](https://www.lintcode.com/problem/1179/) | 朋友圈                                                       | UF                                                         | Medium    |          | 2021/2/14 |           |       |\n| 201  | [152. Combinations](https://www.lintcode.com/problem/152/)   | 组合                                                         | DFS，组合                                                  | Medium    |          | 2021/2/15 |           |       |\n| 202  | [135. Combination Sum I](https://www.lintcode.com/problem/135/) | 组合数之和                                                   | DFS，组合                                                  | Medium    |          | 2021/2/15 |           |       |\n| 203  | [153. Combination Sum II](https://www.lintcode.com/problem/153/) | 组合数之和                                                   | DFS，组合                                                  | Medium    |          | 2021/2/15 |           |       |\n| 204  | [1321. Combination Sum III](https://www.lintcode.com/problem/1321/) | 组合数之和                                                   | DFS，组合                                                  | Medium    |          | 2021/2/15 |           |       |\n| 205  | [457. Classical Binary Search](https://www.lintcode.com/problem/457/) | 经典二分查找问题                                             | Binary Search                                              | Easy      |          | 2021/2/15 |           |       |\n| 206  | [366. Fibonacci](https://www.lintcode.com/problem/366/)      | 斐波那契                                                     | iteration/recursion,多项公式                               | Naive     |          | 2021/2/16 |           |       |\n| 207  | [1807. Fibonacci easy](https://www.lintcode.com/problem/1807/) | 斐波那契                                                     | iteration                                                  | Easy      |          | 2021/2/16 |           |       |\n| 208  | [428. Pow(x, n)](https://www.lintcode.com/problem/powx-n/)   | x的n次幂                                                     | recursion,decrease-and-conquer                             | Medium    |          | 2021/2/16 |           |       |\n| 209  | [451. Swap Nodes in Pairs](https://www.lintcode.com/problem/451/) | 两两交换链表中的节点                                         |                                                            |           |          | 2021/2/16 |           |       |\n| 210  | [450. Reverse Nodes in k-Group](https://www.lintcode.com/problem/450/) | K组翻转链表                                                  |                                                            |           |          | 2021/2/16 |           |       |\n| 211  | [1425. Backspace String Compare](https://www.lintcode.com/problem/1425/) | 比较含退格的字符串                                           |                                                            |           |          | 2021/2/16 |           |       |\n| 212  | [5.Kth Largest Element](https://www.lintcode.com/problem/5/) | 数组第k大元素                                                |                                                            |           |          | 2021/2/16 |           |       |\n| 213  | [471. Top K Frequent Words](https://www.lintcode.com/problem/471/) | 最高频的K个单词                                              |                                                            |           |          | 2021/2/16 |           |       |\n| 214  | [1311. Lowest Common Ancestor of a Binary Search Tree](https://www.lintcode.com/problem/1311/) | 二叉搜索树的最近公共祖先                                     |                                                            | Easy      |          | 2021/2/16 |           |       |\n| 215  | [1509. Lemonade Change](https://www.lintcode.com/problem/1509/) | 柠檬水找零                                                   | Greedy                                                     | Easy      |          | 2021/2/16 |           |       |\n| 216  | [1230. Assign Cookies](https://www.lintcode.com/problem/1230/) | 分饼干                                                       | Greedy                                                     | Easy      |          | 2021/2/16 |           |       |\n| 217  | [1493. Walking Robot Simulation](https://www.lintcode.com/problem/1493/) | 模拟行走机器人                                               | Greedy                                                     |           |          | 2021/2/16 |           |       |\n| 218  | [155. Minimum Depth of Binary Tree](https://www.lintcode.com/problem/155/) | 二叉树的最小深度                                             |                                                            |           |          | 2021/2/16 |           |       |\n| 219  | [1360. Symmetric Tree](https://www.lintcode.com/problem/1360/) | 对称树                                                       |                                                            |           |          | 2021/2/16 |           |       |\n| 220  | [1244. Minimum Genetic Mutation](https://www.lintcode.com/problem/1244/) | 最小基因变化                                                 |                                                            |           |          | 2021/2/16 |           |       |\n| 221  | [427. Generate Parentheses](https://www.lintcode.com/problem/427/) | 生成括号                                                     |                                                            |           |          | 2021/2/16 |           |       |\n| 222  | [1195. Find Largest Value in Each Tree Row](https://www.lintcode.com/problem/1195/) | 找出树中每行的最大值                                         |                                                            | Medium    |          | 2021/2/16 |           |       |\n| 223  | [120. Word Ladder](https://www.lintcode.com/problem/120/)    | 单词接龙                                                     |                                                            |           |          | 2021/2/16 |           |       |\n| 224  | [615. Course Schedule](https://www.lintcode.com/problem/615/) | 课程表                                                       |                                                            |           |          | 2021/2/16 |           |       |\n| 225  | [1189. Minesweeper](https://www.lintcode.com/problem/1189/)  | 扫雷游戏                                                     | BFS                                                        | Medium    |          | 2021/2/16 |           |       |\n| 226  | [389. Valid Sudoku](https://www.lintcode.com/problem/389/)   | 判断数独是否合法                                             | Simulation                                                 | Easy      |          | 2021/2/16 |           |       |\n| 227  | [123. Word Search](https://www.lintcode.com/problem/123/)    | 单词搜索                                                     | DFS                                                        | Medium    |          | 2021/2/16 |           |       |\n| 228  | [664. Counting Bits](https://www.lintcode.com/problem/664/)  | 数 1                                                         | Bit，DP                                                    | Medium    |          | 2021/2/16 |           |       |\n| 229  | [191. Maximum Product Subarray](https://www.lintcode.com/problem/maximum-product-subarray/) | 乘积最大子序列                                               | 线性dp                                                     | Medium    |          | 2021/2/16 |           |       |\n| 230  | [556. Standard Bloom Filter](https://www.lintcode.com/problem/556/) | 标准型布隆过滤器                                             |                                                            | Medium    |          | 2021/2/16 |           |       |\n| 231  | [555. Counting Bloom Filter](https://www.lintcode.com/problem/555/) | 计数型布隆过滤器                                             |                                                            | Medium    |          | 2021/2/16 |           |       |\n| 232  | [1332. Number of 1 Bits](https://www.lintcode.com/problem/1332/) | 判断一个整数中有多少个1                                      | Bit                                                        | Easy      |          | 2021/2/16 |           |       |\n| 233  | [204. Singleton](https://www.lintcode.com/problem/204/)      | 单例                                                         | OOD                                                        | Easy      |          | 2021/2/16 |           |       |\n| 234  | [496. Toy Factory](https://www.lintcode.com/problem/496/)    | 工厂                                                         | OOD                                                        | Easy      |          | 2021/2/16 |           |       |\n| 235  | [175. Invert Binary Tree](https://www.lintcode.com/problem/175/) | 反转二叉树                                                   | Tree                                                       | Easy      |          | 2021/2/16 |           |       |\n|      |                                                              |                                                              |                                                            |           |          |           |           |       |\n|      |                                                              |                                                              |                                                            |           |          |           |           |       |\n|      |                                                              |                                                              |                                                            |           |          |           |           |       |\n|      |                                                              |                                                              |                                                            |           |          |           |           |       |\n|      |                                                              |                                                              |                                                            |           |          |           |           |       |\n|      |                                                              |                                                              |                                                            |           |          |           |           |       |\n\n\n\n","source":"_posts/lintcode-algorithm.md","raw":"---\ntitle: lintcode解题记录\ndate: 2019-01-01 23:59:02\ntags: \n  - lintcode\n  - interview\ncategories:\n  - 算法\n  - 面试算法\n---\n\n\n\n本文章是一个系列，主要记录自己解算法题的一个记录，每道题会出一篇解题报告，作为自己算法功底的沉淀。每次迭代全部从头开始，并且记录以日期。\n\n下面记录的必须在ide和lintcode上提交过，并且写过代码的。\n\n解题七步曲：1 倾听问题，2样本确认， 3 动口不动手的暴力天然解， 4 动口也动手的最优解，5 路演你的思路，6 结构化的编码，7 单元测试     \n\n我的笔记：[here](https://www.lintcode.com/note/?user__username=xiaozhiliaoo)  (复习时候，刷这个效率更高)\n\n我AC的题目：[here](https://www.lintcode.com/problem/?user_status=accepted)\n\n| No   | Problem                                                      | Describe                                                     | Type                                                       | Diffculty | Note     | Date1     | Date2     | Date3 |\n| ---- | ------------------------------------------------------------ | ------------------------------------------------------------ | ---------------------------------------------------------- | --------- | -------- | --------- | --------- | ----- |\n| 1    | [13-implement-strstr](https://www.lintcode.com/problem/implement-strstr/description) | 字符串查找                                                   | string                                                     | Easy      |          | 2020/6/19 |           |       |\n| 2    | [594-strstr-ii](https://www.lintcode.com/problem/594/)       | 字符串查找 II                                                | hash,kmp                                                   | Hard      |          | 2020/6/19 |           |       |\n| 3    | [17-subsets](https://www.lintcode.com/problem/17/)           | 子集(无重复)                                                 | combination,dfs                                            | Medium    |          | 2020/6/19 |           |       |\n| 4    | [18-subsets-ii](https://www.lintcode.com/problem/18/)        | 子集 II(有重复)                                              | dfs,backtracking                                           | Medium    |          | 2020/6/19 |           |       |\n| 5    | [1361-text-justification](https://www.lintcode.com/problem/1361/) | 文字并排                                                     | simulation                                                 | Hard      |          | 2020/6/19 |           |       |\n| 6    | [38-search-a-2d-matrix-ii](https://www.lintcode.com/problem/38/) | 搜索二维矩阵 II                                              | sort-matrix                                                | Medium    |          | 2020/6/19 |           |       |\n| 7    | [39-recover-rotated-sorted-array](https://www.lintcode.com/problem/recover-rotated-sorted-array) | 恢复旋转排序数组                                             | sort-array                                                 | Easy      |          | 2020/6/19 |           |       |\n| 8    | [573-build-post-office-ii](https://www.lintcode.com/problem/573/) | 邮局的建立 II                                                | bfs                                                        | Medium    |          | 2020/6/21 |           |       |\n| 9    | [616-course-schedule-ii](https://www.lintcode.com/problem/616/) | 安排课程                                                     | bfs,topological-sort                                       | Medium    |          | 2020/6/21 |           |       |\n| 10   | [598-zombie-in-matrix](https://www.lintcode.com/problem/598/) | 僵尸矩阵                                                     | bfs                                                        | Medium    |          | 2020/6/21 |           |       |\n| 11   | [127-topological-sorting](https://www.lintcode.com/problem/127/) | 拓扑排序                                                     | bfs or dfs                                                 | Medium    |          | 2020/6/21 |           |       |\n| 12   | [433-number-of-islands](https://www.lintcode.com/problem/433/) | 岛屿的个数                                                   | bfs or union-find                                          | Easy      |          | 2020/6/21 |           |       |\n| 13   | [677-number-of-big-islands](https://www.lintcode.com/problem/number-of-big-islands/) | 大岛的数量                                                   | bfs                                                        | Medium    |          | 2020/6/22 |           |       |\n| 14   | [109-triangle](https://www.lintcode.com/problem/109/)        | 数字三角形                                                   | dp，坐标型                                                 | Medium    |          | 2020/6/22 |           |       |\n| 15   | [110-minimum-path-sum](https://www.lintcode.com/problem/110) | 最小路径和                                                   | dp                                                         | Easy      |          | 2020/6/22 |           |       |\n| 16   | [114-unique-paths](https://www.lintcode.com/problem/114/)    | 不同的路径                                                   | dp，坐标型号dp                                             | Easy      |          | 2020/6/22 |           |       |\n| 17   | [99-reorder-list](https://www.lintcode.com/problem/99)       | 重排链表                                                     | LinkedList                                                 | Medium    |          | 2020/6/22 |           |       |\n| 18   | [174-remove-nth-node-from-end-of-list](https://www.lintcode.com/problem/174/) | 删除链表中倒数第n个节点                                      | LinkedList                                                 | Easy      |          | 2020/6/23 |           |       |\n| 19   | [102-linked-list-cycle](https://www.lintcode.com/problem/102/) | 带环链表                                                     | LinkedList                                                 | Medium    |          | 2020/6/23 |           |       |\n| 20   | [103-linked-list-cycle-ii](https://www.lintcode.com/problem/103/) | 带环链表 返回环起点值                                        | LinkedList                                                 | Hard      |          | 2020/6/23 |           |       |\n| 21   | [104-merge-k-sorted-lists](https://www.lintcode.com/problem/104/) | 合并k个排序链表                                              | LinkedList                                                 | Medium    |          | 2020/6/23 |           |       |\n| 22   | [105-copy-list-with-random-pointer](https://www.lintcode.com/problem/105/) | 复制带随机指针的链表                                         | LinkedList                                                 | Medium    |          | 2020/6/23 |           |       |\n| 23   | [106-convert-sorted-list-to-binary-search-tree](https://www.lintcode.com/problem/106/) | 有序链表转换为二叉搜索树                                     | LinkedList                                                 | Medium    |          | 2020/6/23 |           |       |\n| 24   | [177-convert-sorted-array-to-binary-search-tree-with-minimal-height](https://www.lintcode.com/problem/177/) | 把排序数组转换为高度最小的二叉搜索树                         | LinkedList                                                 | Easy      |          | 2020/6/23 |           |       |\n| 25   | [74 first-bad-version](https://www.lintcode.com/problem/74/) | 第一个错误的代码版本                                         | binarysearch                                               | Medium    |          | 2020/6/24 |           |       |\n| 26   | [1496  implement-rand10-using-rand7](https://www.lintcode.com/problem/1496/) | 用Rand7()实现Rand10()                                        | simulation                                                 | Medium    |          | 2020/6/24 |           |       |\n| 27   | [66  binary-tree-preorder-traversal](https://www.lintcode.com/problem/66/) | 二叉树的前序遍历                                             | Tree，recursion and iteration(Stack)                       | Easy      |          | 2020/6/24 |           |       |\n| 28   | [67  binary-tree-inorder-traversal](https://www.lintcode.com/problem/67/) | 二叉树的中序遍历                                             | Tree，recursion and iteration(Stack)                       | Easy      |          | 2020/6/24 |           |       |\n| 29   | [68  binary-tree-postorder-traversal](https://www.lintcode.com/problem/68/) | 二叉树的后序遍历                                             | Tree，recursion and iteration(Stack)                       | Easy      |          | 2020/6/24 |           |       |\n| 30   | [86  binary-search-tree-iterator](https://www.lintcode.com/problem/86/) | 二叉查找树迭代器                                             | Tree                                                       | Hard      |          | 2020/6/24 |           |       |\n| 31   | [97  maximum-depth-of-binary-tree](https://www.lintcode.com/problem/97/) | 二叉树的最大深度                                             | DC                                                         | Easy      |          | 2020/6/24 |           |       |\n| 32   | [93  balanced-binary-tree](https://www.lintcode.com/problem/93/) | 是否是平衡二叉树                                             | DC，Recursion                                              | Easy      |          | 2020/6/24 |           |       |\n| 33   | [31  partition-array](https://www.lintcode.com/problem/31/)  | 数组划分                                                     | Array,Quick Sort，Two Pointer                              | Medium    |          | 2020/6/25 |           |       |\n| 34   | [94  binary-tree-maximum-path-sum](https://www.lintcode.com/problem/94/) | 二叉树中的最大路径和                                         | DC                                                         | Medium    |          | 2020/6/25 |           |       |\n| 35   | [88  lowest-common-ancestor-of-a-binary-tree](https://www.lintcode.com/problem/88/) | 最近公共祖先(LCA)                                            | DC,RE，LCA                                                 | Medium    |          | 2020/6/25 |           |       |\n| 36   | [69  binary-tree-level-order-traversal](https://www.lintcode.com/problem/69/) | 二叉树的层次遍历                                             | BFS,Queue                                                  | Easy      |          | 2020/6/25 |           |       |\n| 37   | [70  binary-tree-level-order-traversal-ii](https://www.lintcode.com/problem/70/) | 二叉树的层次遍历 II                                          | BFS                                                        | Medium    |          | 2020/6/25 |           |       |\n| 38   | [95  validate-binary-search-tree](https://www.lintcode.com/problem/95/) | 验证二叉查找树                                               | traversal                                                  | Medium    |          | 2020/6/25 |           |       |\n| 39   | [85  insert-node-in-a-binary-search-tree](https://www.lintcode.com/problem/85/) | 在二叉查找树中插入节点                                       | BST，分治                                                  | Medium    |          | 2020/6/25 |           |       |\n| 40   | [86  binary-search-tree-iterator](https://www.lintcode.com/problem/86/) | 在二叉查找树中插入节点                                       | BST，分治                                                  | Hard      |          | 2020/6/25 |           |       |\n| 41   | [87  remove-node-in-binary-search-tree](https://www.lintcode.com/problem/87/) | 删除二叉查找树的节点                                         | BST，分治                                                  | Hard      |          | 2020/6/25 |           |       |\n| 42   | [11  search-range-in-binary-search-tree](https://www.lintcode.com/problem/11/) | 二叉查找树中搜索区间                                         | tree-traversal                                             | Medium    |          | 2020/6/25 |           |       |\n| 42   | [12  min-stack](https://www.lintcode.com/problem/12/)        | 最小栈                                                       | stack，Simulation                                          | Medium    |          | 2020/6/25 |           |       |\n| 43   | [40  implement-queue-by-two-stacks](https://www.lintcode.com/problem/40/) | 双栈实现队列                                                 | stack，Simulation                                          | Medium    |          | 2020/6/25 |           |       |\n| 44   | [494-implement-stack-by-two-queues](https://www.lintcode.com/problem/494/) | 双队列实现栈                                                 | queue                                                      | Medium    |          | 2020/6/25 |           |       |\n| 45   | [130  heapify](https://www.lintcode.com/problem/130/)        | 堆化                                                         | heap                                                       | Medium    |          | 2020/6/25 |           |       |\n| 46   | [158  valid-anagram](https://www.lintcode.com/problem/158/)  | 两个字符串是变位词                                           | string,map                                                 | Easy      |          | 2020/6/26 |           |       |\n| 47   | [122  largest-rectangle-in-histogram](https://www.lintcode.com/problem/122/) | 直方图最大矩形覆盖                                           | monotonic stack                                            | Hard      |          | 2020/6/26 |           |       |\n| 48   | [126-max-tree](https://www.lintcode.com/problem/126/)        | 最大树                                                       | monotonic stack                                            | Hard      |          | 2020/6/26 |           |       |\n| 49   | [134-lru  cache](https://www.lintcode.com/problem/134/)      | LRU缓存策略                                                  | hash                                                       | Hard      |          | 2020/6/26 |           |       |\n| 50   | [24-lfu  cache](https://www.lintcode.com/problem/24/)        | LFU缓存                                                      | hash                                                       | Hard      |          | 2020/6/26 |           |       |\n| 51   | [129-rehashing](https://www.lintcode.com/problem/129/)       | 重哈希                                                       | hash                                                       | Medium    |          | 2020/6/26 |           |       |\n| 52   | [171-anagrams](https://www.lintcode.com/problem/171/)        | 变位词                                                       | hash                                                       | Medium    |          | 2020/6/26 |           |       |\n| 53   | [138-subarray-sum](https://www.lintcode.com/problem/138/)    | 子数组之和                                                   | hash，前缀和                                               | Easy      |          | 2020/6/26 |           |       |\n| 54   | [124-longest-consecutive-sequence](https://www.lintcode.com/problem/124/) | 最长连续序列                                                 | hash                                                       | Medium    |          | 2020/6/26 | 2021/2/13 |       |\n| 55   | [81-find-median-from-data-stream](https://www.lintcode.com/problem/81/) | 数据流中位数                                                 | heap                                                       | Hard      |          | 2020/6/26 |           |       |\n| 56   | [132-word-search-ii](https://www.lintcode.com/problem/132/)  | 单词搜索 II                                                  | trie                                                       | Hard      |          | 2020/6/26 |           |       |\n| 57   | [442-implement-trie-prefix-tree](https://www.lintcode.com/problem/442/) | 实现 Trie（前缀树）                                          | trie                                                       |           |          | 2020/6/27 |           |       |\n| 58   | [61-search-for-a-range](https://www.lintcode.com/problem/61/) | 搜索区间(对比[138](https://www.lintcode.com/problem/138/))   | binarysearch                                               | Medium    |          | 2020/6/27 | 2021/2/13 |       |\n| 59   | [60-search-insert-position](https://www.lintcode.com/problem/60/) | 搜索插入位置                                                 | binarysearch                                               | Easy      |          | 2020/6/27 |           |       |\n| 60   | [28-search-a-2d-matrix](https://www.lintcode.com/problem/28/) | 搜索二维矩阵                                                 | binarysearch                                               | Easy      |          | 2020/6/27 |           |       |\n| 61   | [75-find-peak-element](https://www.lintcode.com/problem/75/) | 寻找峰值                                                     | binarysearch                                               | Medium    |          | 2020/6/27 |           |       |\n| 62   | [62-search-in-rotated-sorted-array(无重复)](https://www.lintcode.com/problem/62/) | 搜索旋转排序数组                                             | binarysearch                                               | Medium    |          | 2020/6/27 |           |       |\n| 63   | [63-search-in-rotated-sorted-array-ii(有重复)](https://www.lintcode.com/problem/63/) | 搜索旋转排序数组                                             | 62 follow up                                               | Medium    |          | 2020/6/27 |           |       |\n| 64   | [6-merge-two-sorted-arrays](https://www.lintcode.com/problem/6/) | 合并排序数组 II                                              | Two Pointers                                               | Easy      |          | 2020/6/27 |           |       |\n| 65   | [64-merge-sorted-array](https://www.lintcode.com/problem/64/) | 合并排序数组                                                 | Two Pointers                                               | Easy      |          | 2020/6/27 |           |       |\n| 66   | [159-find-minimum-in-rotated-sorted-array](https://www.lintcode.com/problem/159/) | 寻找旋转排序数组中的最小值(无重复)                           | binarysearch                                               | Medium    |          | 2020/6/27 |           |       |\n| 67   | [160-find-minimum-in-rotated-sorted-array-ii](https://www.lintcode.com/problem/160/) | 寻找旋转排序数组中的最小值(有重复)                           | binarysearch                                               | Medium    |          | 2020/6/27 |           |       |\n| 68   | [65-median-of-two-sorted-arrays](https://www.lintcode.com/problem/65/) | 两个排序数组的中位数                                         | binarysearch,FindKMax                                      | Hard      |          | 2020/6/27 |           |       |\n| 69   | [8-rotate-string](https://www.lintcode.com/problem/8/)       | 旋转字符串                                                   | string，simulation，三步翻转法                             | Easy      |          | 2020/6/27 |           |       |\n| 70   | [53-reverse-words-in-a-string](https://www.lintcode.com/problem/53/) | 翻转字符串中的单词                                           | string                                                     | Easy      |          | 2020/6/27 |           |       |\n| 71   | [241-string-to-integer](https://www.lintcode.com/problem/241/) | 转换字符串到整数                                             | string                                                     | Easy      |          | 2020/6/28 |           |       |\n| 72   | [1510-buddy-strings](https://www.lintcode.com/problem/1510/) | 亲密字符串                                                   | string                                                     | Easy      |          | 2020/6/28 |           |       |\n| 73   | [415-valid-palindrome](https://www.lintcode.com/problem/415/) | 有效回文串                                                   | string，双指针                                             | Medium    |          | 2020/6/28 |           |       |\n| 74   | [767-reverse-array](https://www.lintcode.com/problem/767/)   | 翻转数组                                                     | string，reverse                                            | Easy      |          | 2020/6/28 |           |       |\n| 75   | [1283-reverse-string](https://www.lintcode.com/problem/1283/) | 翻转字符串                                                   | string，reverse                                            | Easy      |          | 2020/6/28 |           |       |\n| 76   | [78-longest-common-prefix](https://www.lintcode.com/problem/78/) | 最长公共前缀 (LCP)                                           | string。Simulation                                         | Medium    |          | 2020/6/28 |           |       |\n| 77   | [1263-is-subsequence](https://www.lintcode.com/problem/1263/) | 是子序列吗                                                   | string，Simulation                                         | Medium    |          | 2020/6/28 |           |       |\n| 78   | [384-longest-substring-without-repeating-characters](https://www.lintcode.com/problem/384/) | 最长无重复字符的子串                                         | string，two pointer                                        | Medium    |          | 2020/6/29 | 2021/2/14 |       |\n| 79   | [213-string-compression](https://www.lintcode.com/problem/213/) | 字符串压缩                                                   | string                                                     | Easy      |          | 2020/6/29 |           |       |\n| 80   | [1352-compare-version-numbers](https://www.lintcode.com/problem/1352/) | 比较版本号                                                   | string                                                     | Medium    |          | 2020/6/29 |           |       |\n| 81   | [1542-nexttime-norepeat](https://www.lintcode.com/problem/1542/) | 下一个不重复的时间                                           | string                                                     | Medium    |          | 2020/6/29 |           |       |\n| 82   | [192-wildcard-matching](https://www.lintcode.com/problem/192/) | 通配符匹配                                                   | string，DFS                                                | Hard      |          | 2020/6/30 |           |       |\n| 83   | [98-sort-list（排序链表）](https://www.lintcode.com/problem/98/) | 链表排序(归并和快速)                                         | sort                                                       | Medium    |          | 2020/6/30 |           |       |\n| 84   | [463-sort-integers](https://www.lintcode.com/problem/463/)   | 整数排序                                                     | sort【直接选择(选择)，冒泡排序(交换)，直接插入排序(插入)】 | Native    | 简单排序 | 2020/6/30 |           |       |\n| 85   | [464-sort-integers-ii ](https://www.lintcode.com/problem/464/) | 整数排序2                                                    | sort【堆排序(选择)，快排(交换)，归并排序(归并)】           | Medium    | 分治排序 | 2020/6/30 |           |       |\n| 86   | [136-palindrome-partitioning](https://www.lintcode.com/problem/136/) | 分割回文串                                                   | 组合型DFS+Backtracking                                     | Medium    |          | 2020/7/1  |           |       |\n| 87   | [77-longest-common-subsequence](https://www.lintcode.com/problem/77/) | 最长公共子序列(LCS)                                          | match-dp                                                   | Medium    |          | 2020/7/2  |           |       |\n| 88   | [79-longest-common-substring](https://www.lintcode.com/problem/79/) | 最长公共子串(LCS)                                            | Two Sequences DP                                           | Medium    |          | 2020/7/2  |           |       |\n| 89   | [680-spilt-string](https://www.lintcode.com/problem/680/)    | 分割字符串                                                   | 组合型DFS+Backtracking                                     | Medium    |          | 2020/7/2  |           |       |\n| 90   | [15-permutations](https://www.lintcode.com/problem/15/)      | 全排列                                                       | 排列型DFS+Backtracking                                     | Medium    |          | 2020/7/2  |           |       |\n| 91   | [16-permutations-ii](https://www.lintcode.com/problem/16/)   | 全排列                                                       | 排列型DFS+Backtracking                                     | Medium    |          | 2020/7/2  |           |       |\n| 92   | [669-coin-change](https://www.lintcode.com/problem/669/)     | 换硬币                                                       | 无限背包,DFS,DP,不用回溯                                   |           |          | 2020/7/3  |           |       |\n| 93   | [816-traveling-salesman-problem](https://www.lintcode.com/problem/816/) | 旅行商问题                                                   | 排列型DFS，pruning,dp,旅行售货员问题，TSP问题，组合优化    | Hard      |          | 2020/7/3  |           |       |\n| 94   | [1147-work-plan](https://www.lintcode.com/problem/1147/)     | 工作安排                                                     | coordinate-dp                                              | Medium    |          | 2020/7/3  |           |       |\n| 95   | [76-longest-increasing-subsequence](https://www.lintcode.com/problem/76/) | 最长上升子序列(LIS)                                          | match-dp，LIS                                              | Medium    |          | 2020/7/3  |           |       |\n| 96   | [91-minimum-adjustment-cost](https://www.lintcode.com/problem/91/) | 最小调整代价                                                 | dp                                                         | Medium    |          | 2020/7/3  |           |       |\n| 97   | [34-n-queens-ii](https://www.lintcode.com/problem/34/)       | N皇后问题（方案数）                                          | Backtracking+DFS                                           | Medium    |          | 2020/7/4  |           |       |\n| 98   | [33-n-queens](https://www.lintcode.com/problem/33/)          | N皇后问题（具体方案）                                        | Backtracking+DFS                                           | Medium    |          | 2020/7/4  |           |       |\n| 99   | [622-frog-jump](https://www.lintcode.com/problem/622/)       | 青蛙跳                                                       | DFS，DP                                                    | Hard      |          | 2020/7/4  |           |       |\n| 100  | [602-russian-doll-envelopes](https://www.lintcode.com/problem/602/) | 俄罗斯套娃信封                                               | dfs(指数级),dp(正解)                                       | Hard      |          | 2020/7/4  |           |       |\n| 101  | [116-jump-game](https://www.lintcode.com/problem/116/)       | 跳跃游戏                                                     | 单序列dp(可行性)，贪心                                     | Medium    |          | 2020/7/4  |           |       |\n| 102  | [117-jump-game-ii](https://www.lintcode.com/problem/117/)    | 跳跃游戏                                                     | 单序列dp(最小值)                                           | Medium    |          | 2020/7/4  |           |       |\n| 103  | [149-best-time-to-buy-and-sell-stock](https://www.lintcode.com/problem/149/) | 买卖股票的最佳时机（一次交易）                               | 单序列dp(最大值)                                           | Medium    |          | 2020/7/4  |           |       |\n| 104  | [115-unique-paths-ii](https://www.lintcode.com/problem/115/) | 不同的路径 II                                                | 坐标DP                                                     | Easy      |          | 2020/7/4  |           |       |\n| 105  | [111-climbing-stairs](https://www.lintcode.com/problem/111/) | 爬楼梯                                                       | 单序列dp(计数问题)                                         | Easy      |          | 2020/7/4  |           |       |\n| 106  | [563-backpack-v](https://www.lintcode.com/problem/563/)      | 背包问题 V                                                   | Backpack DP                                                | Medium    |          | 2020/7/4  |           |       |\n| 107  | [630-knight-shortest-path-ii](https://www.lintcode.com/problem/630/) | 骑士的最短路径II                                             | 坐标dp, 单向BFS->双向BFS                                   | Medium    |          | 2020/7/6  |           |       |\n| 108  | [564-combination-sum-iv(backpack-vi)](https://www.lintcode.com/problem/564/) | 组合总和 IV                                                  | 单序列dp，Backpack DP                                      | Medium    |          | 2020/7/6  |           |       |\n| 109  | [512-decode-ways](https://www.lintcode.com/problem/512/)     | 解码方法                                                     | dp                                                         | Medium    |          | 2020/7/7  |           |       |\n| 110  | [589-connecting-graph](https://www.lintcode.com/problem/589/) | 连接图                                                       | union-find                                                 | Medium    |          | 2020/7/7  | 2021/2/14 |       |\n| 111  | [752-rogue-knight-sven](https://www.lintcode.com/problem/752/) | 流浪剑客斯温                                                 | dp                                                         | Medium    |          | 2020/7/7  |           |       |\n| 112  | [590-connecting-graph-ii](https://www.lintcode.com/problem/590/) | 连接图                                                       | union-find                                                 | Medium    |          | 2020/7/8  |           |       |\n| 113  | [360-sliding-window-median](https://www.lintcode.com/problem/360/) | 滑动窗口的中位数                                             | heap，Sliding Window                                       | Hard      |          | 2020/7/8  |           |       |\n| 114  | [401-kth-smallest-number-in-sorted-matrix](https://www.lintcode.com/problem/401/) | 排序矩阵中的从小到大第k个数                                  | heap                                                       | Medium    |          | 2020/7/8  |           |       |\n| 115  | [362-sliding-window-maximum](https://www.lintcode.com/problem/362/) | 滑动窗口的最大值                                             | monotonic-queue                                            | Hard      |          | 2020/7/8  |           |       |\n| 116  | [178-graph-valid-tree](https://www.lintcode.com/problem/178/) | 图是否是树                                                   | union-find                                                 | Medium    |          | 2020/7/8  |           |       |\n| 117  | [434-number-of-islands-ii](https://www.lintcode.com/problem/434/) | 岛屿的个数II                                                 | union-find                                                 | Medium    |          | 2020/7/9  |           |       |\n| 118  | [430-scramble-string](https://www.lintcode.com/problem/430/) | 攀爬字符串                                                   | dfs+pruning                                                | Hard      |          | 2020/7/9  |           |       |\n| 119  | [802-sudoku-solver](https://www.lintcode.com/problem/802/)   | 数独                                                         | dfs+pruning+backtracking                                   | Hard      |          | 2020/7/10 |           |       |\n| 120  | [121-word-ladder-ii](https://www.lintcode.com/problem/121/)  | 单词接龙 II                                                  | dfs+pruning+backtracking                                   | Hard      |          | 2020/7/10 |           |       |\n| 121  | [582-word-break-ii](https://www.lintcode.com/problem/582/)   | 单词拆分II                                                   | dfs+pruning+backtracking                                   | Hard      |          | 2020/7/11 |           |       |\n| 122  | [652-factorization](https://www.lintcode.com/problem/652/)   | 因式分解                                                     | dfs+pruning+backtracking                                   | Medium    |          | 2020/7/11 |           |       |\n| 123  | [119-edit-distance](https://www.lintcode.com/problem/119/)   | 编辑距离                                                     | 匹配性dp                                                   | Medium    |          | 2020/7/11 |           |       |\n| 124  | [787-the-maze](https://www.lintcode.com/problem/787/)        | 迷宫                                                         | bfs                                                        | Medium    |          | 2020/7/11 |           |       |\n| 125  | [788-the-maze-ii](https://www.lintcode.com/problem/788/)     | 迷宫                                                         | bfs                                                        | Medium    |          | 2020/7/11 |           |       |\n| 126  | [789-the-maze-iii](https://www.lintcode.com/problem/789/)    | 迷宫                                                         | bfs                                                        | Hard      |          | 2020/7/11 |           |       |\n| 127  | [691-recover-binary-search-tree](https://www.lintcode.com/problem/691/) | 恢复二叉搜索树                                               | bst                                                        | Medium    |          | 2020/7/12 |           |       |\n| 128  | [82-single-number](https://www.lintcode.com/problem/82/)     | 落单的数2n*1,两次                                            | bit，hash                                                  | Easy      |          | 2020/7/12 |           |       |\n| 129  | [83-single-number-ii](https://www.lintcode.com/problem/83/)  | 落单的数 II 3n*1，三次                                       | bit，hash                                                  | Medium    |          | 2020/7/12 |           |       |\n| 130  | [84-single-number-iii](https://www.lintcode.com/problem/84/) | 落单的数2*n + 2                                              | bit，hash                                                  | Medium    |          | 2020/7/12 |           |       |\n| 131  | [46-majority-element](https://www.lintcode.com/problem/46/)  | 主元素(不是众数) 1/2                                         | Enumerate                                                  | Easy      |          | 2020/7/12 |           |       |\n| 132  | [1018-champagne-tower(triangle)](https://www.lintcode.com/problem/1018/) | 香槟塔                                                       | 二维坐标dp                                                 | Medium    |          | 2020/7/12 |           |       |\n| 133  | [200-longest-palindromic-substring](https://www.lintcode.com/problem/200/) | 最长回文子串                                                 | 区间dp                                                     | Medium    |          | 2020/7/14 |           |       |\n| 134  | [1565-modern-ludo-i](https://www.lintcode.com/problem/1565/) | 飞行棋 I                                                     | 一维坐标dp                                                 | Medium    |          | 2020/7/16 |           |       |\n| 135  | [1141-the-months-days](https://www.lintcode.com/problem/1141/) | 月份天数                                                     | 闰年                                                       | Easy      |          | 2020/7/16 |           |       |\n| 136  | [254-drop-eggs](https://www.lintcode.com/problem/254/)       | 丢鸡蛋                                                       | 归纳法                                                     | Easy      |          | 2020/7/16 |           |       |\n| 137  | [47-majority-element-ii](https://www.lintcode.com/problem/47/) | 主元素1/3                                                    | Enumerate                                                  | Medium    |          | 2020/7/19 |           |       |\n| 138  | [48-majority-element-iii](https://www.lintcode.com/problem/48/) | 主元素1/k                                                    | HashTable                                                  | Medium    |          | 2020/7/20 |           |       |\n| 139  | [150-best-time-to-buy-and-sell-stock-ii](https://www.lintcode.com/problem/150/) | 买卖股票的最佳时机 II(多次交易)                              | 贪心                                                       | Medium    |          | 2020/7/20 |           |       |\n| 140  | [151-best-time-to-buy-and-sell-stock-iii](https://www.lintcode.com/problem/151/) | 买卖股票的最佳时机 III(两笔交易)                             | Enumerate                                                  | Medium    |          | 2020/7/20 |           |       |\n| 141  | [393-best-time-to-buy-and-sell-stock-iv](https://www.lintcode.com/problem/393/) | 买卖股票的最佳时机 III(K笔交易)                              | dp                                                         | Medium    |          | 2020/7/20 |           |       |\n| 142  | [44-minimum-subarray](https://www.lintcode.com/problem/44/)  | 最小子数组                                                   | 贪心                                                       | Easy      |          | 2020/7/20 |           |       |\n| 143  | [45-maximum-subarray-difference](https://www.lintcode.com/problem/45/) | 最大子数组差                                                 | 贪心                                                       | Easy      |          | 2020/7/20 |           |       |\n| 144  | [138-subarray-sum](https://www.lintcode.com/problem/138/)    | 子数组之和                                                   | hashmap                                                    | Easy      |          | 2020/7/20 |           |       |\n| 145  | [139-subarray-sum-closest](https://www.lintcode.com/problem/139/) | 最接近零的子数组和                                           | Two Pointers，hashmap                                      | Medium    |          | 2020/7/20 |           |       |\n| 146  | [56-two-sum](https://www.lintcode.com/problem/56/)           | 两数之和                                                     | Two Pointers                                               | Easy      |          | 2020/7/20 |           |       |\n| 147  | [608-two-sum-ii-input-array-is-sorted](https://www.lintcode.com/problem/608/) | 两数和 II-输入已排序的数组                                   | Two Pointers                                               | Medium    |          | 2020/7/20 |           |       |\n| 148  | [57-3sum](https://www.lintcode.com/problem/57/)              | 三数之和                                                     | Two Pointers                                               | Medium    |          | 2020/7/20 |           |       |\n| 149  | [533-two-sum-closest-to-target](https://www.lintcode.com/problem/533/) | 两数和的最接近值                                             | Two Pointers                                               | Medium    |          | 2020/7/20 |           |       |\n| 150  | [89-k-sum](https://www.lintcode.com/problem/89/)             | K数之和                                                      | dp                                                         | Hard      |          | 2020/7/20 |           |       |\n| 151  | [140-fast-power](https://www.lintcode.com/problem/140/)      | 快速幂                                                       | DC                                                         | Medium    |          | 2020/7/21 |           |       |\n| 152  | [1324-count-primes](https://www.lintcode.com/problem/1324/)  | 质数的个数                                                   | Mathmatics                                                 | Easy      |          | 2020/7/21 |           |       |\n| 153  | [141-sqrtx](https://www.lintcode.com/problem/141/)           | 对x开根                                                      | Mathmatics                                                 | Easy      |          | 2020/7/21 |           |       |\n| 154  | [2-trailing-zeros](https://www.lintcode.com/problem/2/)      | 尾部的零                                                     | Mathmatics                                                 | Easy      |          | 2020/7/21 |           |       |\n| 155  | [142.o1-check-power-of-2](https://www.lintcode.com/problem/142/) | O(1)时间检测2的幂次                                          | Binary                                                     | Easy      |          | 2020/7/21 |           |       |\n| 156  | [49-sort-letters-by-case](https://www.lintcode.com/problem/49/) | 字符大小写排序                                               | Two Pointers                                               | Medium    |          | 2020/7/21 |           |       |\n| 157  | [1563-shortest-path-to-the-destination](https://www.lintcode.com/problem/1563/) | 目的地的最短路径                                             | bfs                                                        | Medium    |          | 2020/7/21 |           |       |\n| 158  | [108-palindrome-partitioning-ii](https://www.lintcode.com/problem/108/) | 分割回文串 II                                                | dp                                                         | Medium    |          | 2020/8/2  |           |       |\n| 159  | [107-word-break](https://www.lintcode.com/problem/107/)      | 单词拆分 I                                                   | dp                                                         | Medium    |          | 2020/8/2  |           |       |\n| 160  | [41-maximum-subarray](https://www.lintcode.com/problem/41/)  | 最大子数组                                                   | dp                                                         | Easy      |          | 2020/8/3  |           |       |\n| 161  | [29-interleaving-string](https://www.lintcode.com/problem/29/) | 交叉字符串                                                   | dp                                                         | Medium    |          | 2020/8/9  |           |       |\n| 162  | [513-perfect-squares](https://www.lintcode.com/problem/513/) | 完美平方                                                     | dp                                                         | Medium    |          | 2020/8/9  |           |       |\n| 163  | [394-coins-in-a-line](https://www.lintcode.com/problem/394/) | 硬币排成线                                                   | dp                                                         | Medium    |          | 2020/8/9  |           |       |\n| 164  | [92-backpack](https://www.lintcode.com/problem/92/)          | 背包问题                                                     | dp                                                         | Medium    |          | 2020/8/9  |           |       |\n| 165  | [118-distinct-subsequences](https://www.lintcode.com/problem/118/) | 不同的子序列                                                 | dp                                                         | Medium    |          | 2020/8/9  |           |       |\n| 166  | [604-window-sum](https://www.lintcode.com/problem/604/)      | 滑动窗口内数的和                                             | two-pointer                                                | Easy      |          | 2020/8/9  |           |       |\n| 167  | [539-move-zeroes](https://www.lintcode.com/problem/539/)     | 移动0                                                        | two-pointer                                                | Easy      |          | 2020/8/10 |           |       |\n| 168  | [521.remove-duplicate-numbers-in-array](https://www.lintcode.com/problem/521/) | 数组去重                                                     | two-pointer                                                | Easy      |          | 2020/8/10 |           |       |\n| 169  | [638. Isomorphic Strings](https://www.lintcode.com/problem/638/) | 字符同构                                                     | string                                                     | Easy      |          | 2021/2/10 |           |       |\n| 170  | [626. Rectangle Overlap](https://www.lintcode.com/problem/626/) | 矩形重叠                                                     | string                                                     | Easy      |          | 2021/2/10 |           |       |\n| 171  | [637. Valid Word Abbreviation](https://www.lintcode.com/problem/637/) | 检查缩写单词                                                 | string                                                     | Easy      |          | 2021/2/10 |           |       |\n| 172  | [639. Word Abbreviation](https://www.lintcode.com/problem/639/) | 单词缩写                                                     | string                                                     | Hard      |          | 2021/2/11 |           |       |\n| 173  | [642. Moving Average from Data Stream](https://www.lintcode.com/problem/642/) | 数据流滑动窗口平均值                                         | Prefix Sum Array，rolling array                            | Easy      |          | 2021/2/11 |           |       |\n| 174  | [644. Strobogrammatic Number](https://www.lintcode.com/problem/644/) | 镜像数字                                                     | Enumerate                                                  | Easy      |          | 2021/2/11 |           |       |\n| 175  | [640. One Edit Distance](https://www.lintcode.com/problem/640/) | 一次编辑距离                                                 | Enumerate                                                  | Medium    |          | 2021/2/11 |           |       |\n| 176  | [660. Read N Characters Given Read4](https://www.lintcode.com/problem/660/) | 用Read4从文件中读取N个字符 II-多次调用                       | Enumerate                                                  | Hard      |          | 2021/2/12 |           |       |\n| 177  | [659. Encode and Decode Strings](https://www.lintcode.com/problem/659/) | 编码和解码字符串                                             | Enumerate                                                  | Medium    |          | 2021/2/12 |           |       |\n| 178  | [419. Roman to Integer](https://www.lintcode.com/problem/419/) | 罗马数字转整数                                               | Enumerate                                                  | Medium    |          | 2021/2/12 |           |       |\n| 179  | [418. Integer to Roman](https://www.lintcode.com/problem/418/) | 整数转罗马数字                                               | Enumerate                                                  | Medium    |          | 2021/2/12 |           |       |\n| 180  | [645. Find the Celebrity](https://www.lintcode.com/problem/645/) | 识别名人                                                     | Enumerate                                                  | Medium    |          | 2021/2/12 |           |       |\n| 181  | [641. Missing Ranges](https://www.lintcode.com/problem/641/) | 丢失的间隔                                                   | Enumerate                                                  | Medium    |          | 2021/2/12 |           |       |\n| 182  | [156. Merge Intervals](https://www.lintcode.com/problem/156/) | 合并区间                                                     | Enumerate                                                  | Easy      |          | 2021/2/12 |           |       |\n| 183  | [30. Insert Interval](https://www.lintcode.com/problem/30/)  | 插入区间                                                     | Enumerate                                                  | Medium    |          | 2021/2/12 |           |       |\n| 184  | [646. First Position Unique Character](https://www.lintcode.com/problem/646/) | 第一个不重复字符位置                                         | Hash                                                       | Easy      |          | 2021/2/12 |           |       |\n| 185  | [647. Find All Anagrams in a String](https://www.lintcode.com/problem/647/) | 子串字谜                                                     | Hash+Siding Windows                                        | Medium    |          | 2021/2/12 |           |       |\n| 186  | [423. Valid Parentheses](https://www.lintcode.com/problem/423/) | 有效的括号序列                                               | Stack                                                      | Easy      |          | 2021/2/13 |           |       |\n| 187  | [526. Load Balancer](https://www.jiuzhang.com/problem/load-balancer/) | 负载均衡                                                     | DS                                                         |           |          | 2021/2/13 |           |       |\n| 188  | [662. Guess Number Higher or Lower](https://www.lintcode.com/problem/662/) | 猜数游戏                                                     | Binary Search                                              | Easy      |          | 2021/2/13 |           |       |\n| 189  | [661. Convert BST to Greater Tree](https://www.lintcode.com/problem/661/) | 把二叉搜索树转化成更大的树                                   | BST                                                        | Easy      |          | 2021/2/13 |           |       |\n| 190  | [649. Binary Tree Upside Down](https://www.lintcode.com/problem/649/) | 二叉树翻转                                                   | BST                                                        | Medium    |          | 2021/2/13 |           |       |\n| 191  | [650. Find Leaves of Binary Tree](https://www.lintcode.com/problem/650/) | 二叉树叶子顺序遍历                                           | BST                                                        | Medium    |          | 2021/2/13 |           |       |\n| 192  | [651. Binary Tree Vertical Order Traversal](https://www.lintcode.com/problem/651/) | 二叉树垂直遍历                                               | Hash+BFS                                                   | Medium    |          | 2021/2/13 |           |       |\n| 193  | [448. Inorder Successor in BST](https://www.lintcode.com/problem/448/) | 二叉查找树的中序后继                                         | BST                                                        | Medium    |          | 2021/2/13 |           |       |\n| 194  | [477. Surrounded Regions](https://www.lintcode.com/problem/477/) | 被围绕的区域                                                 | BFS                                                        | Medium    |          | 2021/2/13 |           |       |\n| 195  | [663. Walls and Gates](https://www.lintcode.com/problem/663/) | 墙和门                                                       | BFS                                                        | Medium    |          | 2021/2/13 |           |       |\n| 196  | [32. Minimum Window Substring](https://www.lintcode.com/problem/32/) | 最小子串覆盖                                                 | Two pointer                                                | Medium    |          | 2021/2/14 |           |       |\n| 197  | [543. Kth Largest in N Arrays](https://www.lintcode.com/problem/543/) | N数组第K大元素(一个数组第[K大](https://www.lintcode.com/problem/5/)) | Heap                                                       | Hard      |          | 2021/2/14 |           |       |\n| 198  | [465. Kth Smallest Sum In Two Sorted Arrays](https://www.lintcode.com/problem/465/) | 两个排序数组和的第K小                                        | Heap                                                       | Hard      |          | 2021/2/14 |           |       |\n| 199  | [591. Connecting Graph III](https://www.lintcode.com/problem/591/) | 连接图 III                                                   | UF                                                         | Medium    |          | 2021/2/14 |           |       |\n| 200  | [1179. Friend Circles](https://www.lintcode.com/problem/1179/) | 朋友圈                                                       | UF                                                         | Medium    |          | 2021/2/14 |           |       |\n| 201  | [152. Combinations](https://www.lintcode.com/problem/152/)   | 组合                                                         | DFS，组合                                                  | Medium    |          | 2021/2/15 |           |       |\n| 202  | [135. Combination Sum I](https://www.lintcode.com/problem/135/) | 组合数之和                                                   | DFS，组合                                                  | Medium    |          | 2021/2/15 |           |       |\n| 203  | [153. Combination Sum II](https://www.lintcode.com/problem/153/) | 组合数之和                                                   | DFS，组合                                                  | Medium    |          | 2021/2/15 |           |       |\n| 204  | [1321. Combination Sum III](https://www.lintcode.com/problem/1321/) | 组合数之和                                                   | DFS，组合                                                  | Medium    |          | 2021/2/15 |           |       |\n| 205  | [457. Classical Binary Search](https://www.lintcode.com/problem/457/) | 经典二分查找问题                                             | Binary Search                                              | Easy      |          | 2021/2/15 |           |       |\n| 206  | [366. Fibonacci](https://www.lintcode.com/problem/366/)      | 斐波那契                                                     | iteration/recursion,多项公式                               | Naive     |          | 2021/2/16 |           |       |\n| 207  | [1807. Fibonacci easy](https://www.lintcode.com/problem/1807/) | 斐波那契                                                     | iteration                                                  | Easy      |          | 2021/2/16 |           |       |\n| 208  | [428. Pow(x, n)](https://www.lintcode.com/problem/powx-n/)   | x的n次幂                                                     | recursion,decrease-and-conquer                             | Medium    |          | 2021/2/16 |           |       |\n| 209  | [451. Swap Nodes in Pairs](https://www.lintcode.com/problem/451/) | 两两交换链表中的节点                                         |                                                            |           |          | 2021/2/16 |           |       |\n| 210  | [450. Reverse Nodes in k-Group](https://www.lintcode.com/problem/450/) | K组翻转链表                                                  |                                                            |           |          | 2021/2/16 |           |       |\n| 211  | [1425. Backspace String Compare](https://www.lintcode.com/problem/1425/) | 比较含退格的字符串                                           |                                                            |           |          | 2021/2/16 |           |       |\n| 212  | [5.Kth Largest Element](https://www.lintcode.com/problem/5/) | 数组第k大元素                                                |                                                            |           |          | 2021/2/16 |           |       |\n| 213  | [471. Top K Frequent Words](https://www.lintcode.com/problem/471/) | 最高频的K个单词                                              |                                                            |           |          | 2021/2/16 |           |       |\n| 214  | [1311. Lowest Common Ancestor of a Binary Search Tree](https://www.lintcode.com/problem/1311/) | 二叉搜索树的最近公共祖先                                     |                                                            | Easy      |          | 2021/2/16 |           |       |\n| 215  | [1509. Lemonade Change](https://www.lintcode.com/problem/1509/) | 柠檬水找零                                                   | Greedy                                                     | Easy      |          | 2021/2/16 |           |       |\n| 216  | [1230. Assign Cookies](https://www.lintcode.com/problem/1230/) | 分饼干                                                       | Greedy                                                     | Easy      |          | 2021/2/16 |           |       |\n| 217  | [1493. Walking Robot Simulation](https://www.lintcode.com/problem/1493/) | 模拟行走机器人                                               | Greedy                                                     |           |          | 2021/2/16 |           |       |\n| 218  | [155. Minimum Depth of Binary Tree](https://www.lintcode.com/problem/155/) | 二叉树的最小深度                                             |                                                            |           |          | 2021/2/16 |           |       |\n| 219  | [1360. Symmetric Tree](https://www.lintcode.com/problem/1360/) | 对称树                                                       |                                                            |           |          | 2021/2/16 |           |       |\n| 220  | [1244. Minimum Genetic Mutation](https://www.lintcode.com/problem/1244/) | 最小基因变化                                                 |                                                            |           |          | 2021/2/16 |           |       |\n| 221  | [427. Generate Parentheses](https://www.lintcode.com/problem/427/) | 生成括号                                                     |                                                            |           |          | 2021/2/16 |           |       |\n| 222  | [1195. Find Largest Value in Each Tree Row](https://www.lintcode.com/problem/1195/) | 找出树中每行的最大值                                         |                                                            | Medium    |          | 2021/2/16 |           |       |\n| 223  | [120. Word Ladder](https://www.lintcode.com/problem/120/)    | 单词接龙                                                     |                                                            |           |          | 2021/2/16 |           |       |\n| 224  | [615. Course Schedule](https://www.lintcode.com/problem/615/) | 课程表                                                       |                                                            |           |          | 2021/2/16 |           |       |\n| 225  | [1189. Minesweeper](https://www.lintcode.com/problem/1189/)  | 扫雷游戏                                                     | BFS                                                        | Medium    |          | 2021/2/16 |           |       |\n| 226  | [389. Valid Sudoku](https://www.lintcode.com/problem/389/)   | 判断数独是否合法                                             | Simulation                                                 | Easy      |          | 2021/2/16 |           |       |\n| 227  | [123. Word Search](https://www.lintcode.com/problem/123/)    | 单词搜索                                                     | DFS                                                        | Medium    |          | 2021/2/16 |           |       |\n| 228  | [664. Counting Bits](https://www.lintcode.com/problem/664/)  | 数 1                                                         | Bit，DP                                                    | Medium    |          | 2021/2/16 |           |       |\n| 229  | [191. Maximum Product Subarray](https://www.lintcode.com/problem/maximum-product-subarray/) | 乘积最大子序列                                               | 线性dp                                                     | Medium    |          | 2021/2/16 |           |       |\n| 230  | [556. Standard Bloom Filter](https://www.lintcode.com/problem/556/) | 标准型布隆过滤器                                             |                                                            | Medium    |          | 2021/2/16 |           |       |\n| 231  | [555. Counting Bloom Filter](https://www.lintcode.com/problem/555/) | 计数型布隆过滤器                                             |                                                            | Medium    |          | 2021/2/16 |           |       |\n| 232  | [1332. Number of 1 Bits](https://www.lintcode.com/problem/1332/) | 判断一个整数中有多少个1                                      | Bit                                                        | Easy      |          | 2021/2/16 |           |       |\n| 233  | [204. Singleton](https://www.lintcode.com/problem/204/)      | 单例                                                         | OOD                                                        | Easy      |          | 2021/2/16 |           |       |\n| 234  | [496. Toy Factory](https://www.lintcode.com/problem/496/)    | 工厂                                                         | OOD                                                        | Easy      |          | 2021/2/16 |           |       |\n| 235  | [175. Invert Binary Tree](https://www.lintcode.com/problem/175/) | 反转二叉树                                                   | Tree                                                       | Easy      |          | 2021/2/16 |           |       |\n|      |                                                              |                                                              |                                                            |           |          |           |           |       |\n|      |                                                              |                                                              |                                                            |           |          |           |           |       |\n|      |                                                              |                                                              |                                                            |           |          |           |           |       |\n|      |                                                              |                                                              |                                                            |           |          |           |           |       |\n|      |                                                              |                                                              |                                                            |           |          |           |           |       |\n|      |                                                              |                                                              |                                                            |           |          |           |           |       |\n\n\n\n","slug":"lintcode-algorithm","published":1,"updated":"2022-06-28T17:24:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clh7s5cua002lxt8j5quuagbk","content":"<p>本文章是一个系列，主要记录自己解算法题的一个记录，每道题会出一篇解题报告，作为自己算法功底的沉淀。每次迭代全部从头开始，并且记录以日期。</p>\n<p>下面记录的必须在ide和lintcode上提交过，并且写过代码的。</p>\n<p>解题七步曲：1 倾听问题，2样本确认， 3 动口不动手的暴力天然解， 4 动口也动手的最优解，5 路演你的思路，6 结构化的编码，7 单元测试     </p>\n<p>我的笔记：<a href=\"https://www.lintcode.com/note/?user__username=xiaozhiliaoo\" target=\"_blank\" rel=\"noopener\">here</a>  (复习时候，刷这个效率更高)</p>\n<p>我AC的题目：<a href=\"https://www.lintcode.com/problem/?user_status=accepted\" target=\"_blank\" rel=\"noopener\">here</a></p>\n<table>\n<thead>\n<tr>\n<th>No</th>\n<th>Problem</th>\n<th>Describe</th>\n<th>Type</th>\n<th>Diffculty</th>\n<th>Note</th>\n<th>Date1</th>\n<th>Date2</th>\n<th>Date3</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td><a href=\"https://www.lintcode.com/problem/implement-strstr/description\" target=\"_blank\" rel=\"noopener\">13-implement-strstr</a></td>\n<td>字符串查找</td>\n<td>string</td>\n<td>Easy</td>\n<td></td>\n<td>2020/6/19</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>2</td>\n<td><a href=\"https://www.lintcode.com/problem/594/\" target=\"_blank\" rel=\"noopener\">594-strstr-ii</a></td>\n<td>字符串查找 II</td>\n<td>hash,kmp</td>\n<td>Hard</td>\n<td></td>\n<td>2020/6/19</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>3</td>\n<td><a href=\"https://www.lintcode.com/problem/17/\" target=\"_blank\" rel=\"noopener\">17-subsets</a></td>\n<td>子集(无重复)</td>\n<td>combination,dfs</td>\n<td>Medium</td>\n<td></td>\n<td>2020/6/19</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>4</td>\n<td><a href=\"https://www.lintcode.com/problem/18/\" target=\"_blank\" rel=\"noopener\">18-subsets-ii</a></td>\n<td>子集 II(有重复)</td>\n<td>dfs,backtracking</td>\n<td>Medium</td>\n<td></td>\n<td>2020/6/19</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>5</td>\n<td><a href=\"https://www.lintcode.com/problem/1361/\" target=\"_blank\" rel=\"noopener\">1361-text-justification</a></td>\n<td>文字并排</td>\n<td>simulation</td>\n<td>Hard</td>\n<td></td>\n<td>2020/6/19</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>6</td>\n<td><a href=\"https://www.lintcode.com/problem/38/\" target=\"_blank\" rel=\"noopener\">38-search-a-2d-matrix-ii</a></td>\n<td>搜索二维矩阵 II</td>\n<td>sort-matrix</td>\n<td>Medium</td>\n<td></td>\n<td>2020/6/19</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>7</td>\n<td><a href=\"https://www.lintcode.com/problem/recover-rotated-sorted-array\" target=\"_blank\" rel=\"noopener\">39-recover-rotated-sorted-array</a></td>\n<td>恢复旋转排序数组</td>\n<td>sort-array</td>\n<td>Easy</td>\n<td></td>\n<td>2020/6/19</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>8</td>\n<td><a href=\"https://www.lintcode.com/problem/573/\" target=\"_blank\" rel=\"noopener\">573-build-post-office-ii</a></td>\n<td>邮局的建立 II</td>\n<td>bfs</td>\n<td>Medium</td>\n<td></td>\n<td>2020/6/21</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>9</td>\n<td><a href=\"https://www.lintcode.com/problem/616/\" target=\"_blank\" rel=\"noopener\">616-course-schedule-ii</a></td>\n<td>安排课程</td>\n<td>bfs,topological-sort</td>\n<td>Medium</td>\n<td></td>\n<td>2020/6/21</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>10</td>\n<td><a href=\"https://www.lintcode.com/problem/598/\" target=\"_blank\" rel=\"noopener\">598-zombie-in-matrix</a></td>\n<td>僵尸矩阵</td>\n<td>bfs</td>\n<td>Medium</td>\n<td></td>\n<td>2020/6/21</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>11</td>\n<td><a href=\"https://www.lintcode.com/problem/127/\" target=\"_blank\" rel=\"noopener\">127-topological-sorting</a></td>\n<td>拓扑排序</td>\n<td>bfs or dfs</td>\n<td>Medium</td>\n<td></td>\n<td>2020/6/21</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>12</td>\n<td><a href=\"https://www.lintcode.com/problem/433/\" target=\"_blank\" rel=\"noopener\">433-number-of-islands</a></td>\n<td>岛屿的个数</td>\n<td>bfs or union-find</td>\n<td>Easy</td>\n<td></td>\n<td>2020/6/21</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>13</td>\n<td><a href=\"https://www.lintcode.com/problem/number-of-big-islands/\" target=\"_blank\" rel=\"noopener\">677-number-of-big-islands</a></td>\n<td>大岛的数量</td>\n<td>bfs</td>\n<td>Medium</td>\n<td></td>\n<td>2020/6/22</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>14</td>\n<td><a href=\"https://www.lintcode.com/problem/109/\" target=\"_blank\" rel=\"noopener\">109-triangle</a></td>\n<td>数字三角形</td>\n<td>dp，坐标型</td>\n<td>Medium</td>\n<td></td>\n<td>2020/6/22</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>15</td>\n<td><a href=\"https://www.lintcode.com/problem/110\" target=\"_blank\" rel=\"noopener\">110-minimum-path-sum</a></td>\n<td>最小路径和</td>\n<td>dp</td>\n<td>Easy</td>\n<td></td>\n<td>2020/6/22</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>16</td>\n<td><a href=\"https://www.lintcode.com/problem/114/\" target=\"_blank\" rel=\"noopener\">114-unique-paths</a></td>\n<td>不同的路径</td>\n<td>dp，坐标型号dp</td>\n<td>Easy</td>\n<td></td>\n<td>2020/6/22</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>17</td>\n<td><a href=\"https://www.lintcode.com/problem/99\" target=\"_blank\" rel=\"noopener\">99-reorder-list</a></td>\n<td>重排链表</td>\n<td>LinkedList</td>\n<td>Medium</td>\n<td></td>\n<td>2020/6/22</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>18</td>\n<td><a href=\"https://www.lintcode.com/problem/174/\" target=\"_blank\" rel=\"noopener\">174-remove-nth-node-from-end-of-list</a></td>\n<td>删除链表中倒数第n个节点</td>\n<td>LinkedList</td>\n<td>Easy</td>\n<td></td>\n<td>2020/6/23</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>19</td>\n<td><a href=\"https://www.lintcode.com/problem/102/\" target=\"_blank\" rel=\"noopener\">102-linked-list-cycle</a></td>\n<td>带环链表</td>\n<td>LinkedList</td>\n<td>Medium</td>\n<td></td>\n<td>2020/6/23</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>20</td>\n<td><a href=\"https://www.lintcode.com/problem/103/\" target=\"_blank\" rel=\"noopener\">103-linked-list-cycle-ii</a></td>\n<td>带环链表 返回环起点值</td>\n<td>LinkedList</td>\n<td>Hard</td>\n<td></td>\n<td>2020/6/23</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>21</td>\n<td><a href=\"https://www.lintcode.com/problem/104/\" target=\"_blank\" rel=\"noopener\">104-merge-k-sorted-lists</a></td>\n<td>合并k个排序链表</td>\n<td>LinkedList</td>\n<td>Medium</td>\n<td></td>\n<td>2020/6/23</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>22</td>\n<td><a href=\"https://www.lintcode.com/problem/105/\" target=\"_blank\" rel=\"noopener\">105-copy-list-with-random-pointer</a></td>\n<td>复制带随机指针的链表</td>\n<td>LinkedList</td>\n<td>Medium</td>\n<td></td>\n<td>2020/6/23</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>23</td>\n<td><a href=\"https://www.lintcode.com/problem/106/\" target=\"_blank\" rel=\"noopener\">106-convert-sorted-list-to-binary-search-tree</a></td>\n<td>有序链表转换为二叉搜索树</td>\n<td>LinkedList</td>\n<td>Medium</td>\n<td></td>\n<td>2020/6/23</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>24</td>\n<td><a href=\"https://www.lintcode.com/problem/177/\" target=\"_blank\" rel=\"noopener\">177-convert-sorted-array-to-binary-search-tree-with-minimal-height</a></td>\n<td>把排序数组转换为高度最小的二叉搜索树</td>\n<td>LinkedList</td>\n<td>Easy</td>\n<td></td>\n<td>2020/6/23</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>25</td>\n<td><a href=\"https://www.lintcode.com/problem/74/\" target=\"_blank\" rel=\"noopener\">74 first-bad-version</a></td>\n<td>第一个错误的代码版本</td>\n<td>binarysearch</td>\n<td>Medium</td>\n<td></td>\n<td>2020/6/24</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>26</td>\n<td><a href=\"https://www.lintcode.com/problem/1496/\" target=\"_blank\" rel=\"noopener\">1496  implement-rand10-using-rand7</a></td>\n<td>用Rand7()实现Rand10()</td>\n<td>simulation</td>\n<td>Medium</td>\n<td></td>\n<td>2020/6/24</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>27</td>\n<td><a href=\"https://www.lintcode.com/problem/66/\" target=\"_blank\" rel=\"noopener\">66  binary-tree-preorder-traversal</a></td>\n<td>二叉树的前序遍历</td>\n<td>Tree，recursion and iteration(Stack)</td>\n<td>Easy</td>\n<td></td>\n<td>2020/6/24</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>28</td>\n<td><a href=\"https://www.lintcode.com/problem/67/\" target=\"_blank\" rel=\"noopener\">67  binary-tree-inorder-traversal</a></td>\n<td>二叉树的中序遍历</td>\n<td>Tree，recursion and iteration(Stack)</td>\n<td>Easy</td>\n<td></td>\n<td>2020/6/24</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>29</td>\n<td><a href=\"https://www.lintcode.com/problem/68/\" target=\"_blank\" rel=\"noopener\">68  binary-tree-postorder-traversal</a></td>\n<td>二叉树的后序遍历</td>\n<td>Tree，recursion and iteration(Stack)</td>\n<td>Easy</td>\n<td></td>\n<td>2020/6/24</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>30</td>\n<td><a href=\"https://www.lintcode.com/problem/86/\" target=\"_blank\" rel=\"noopener\">86  binary-search-tree-iterator</a></td>\n<td>二叉查找树迭代器</td>\n<td>Tree</td>\n<td>Hard</td>\n<td></td>\n<td>2020/6/24</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>31</td>\n<td><a href=\"https://www.lintcode.com/problem/97/\" target=\"_blank\" rel=\"noopener\">97  maximum-depth-of-binary-tree</a></td>\n<td>二叉树的最大深度</td>\n<td>DC</td>\n<td>Easy</td>\n<td></td>\n<td>2020/6/24</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>32</td>\n<td><a href=\"https://www.lintcode.com/problem/93/\" target=\"_blank\" rel=\"noopener\">93  balanced-binary-tree</a></td>\n<td>是否是平衡二叉树</td>\n<td>DC，Recursion</td>\n<td>Easy</td>\n<td></td>\n<td>2020/6/24</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>33</td>\n<td><a href=\"https://www.lintcode.com/problem/31/\" target=\"_blank\" rel=\"noopener\">31  partition-array</a></td>\n<td>数组划分</td>\n<td>Array,Quick Sort，Two Pointer</td>\n<td>Medium</td>\n<td></td>\n<td>2020/6/25</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>34</td>\n<td><a href=\"https://www.lintcode.com/problem/94/\" target=\"_blank\" rel=\"noopener\">94  binary-tree-maximum-path-sum</a></td>\n<td>二叉树中的最大路径和</td>\n<td>DC</td>\n<td>Medium</td>\n<td></td>\n<td>2020/6/25</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>35</td>\n<td><a href=\"https://www.lintcode.com/problem/88/\" target=\"_blank\" rel=\"noopener\">88  lowest-common-ancestor-of-a-binary-tree</a></td>\n<td>最近公共祖先(LCA)</td>\n<td>DC,RE，LCA</td>\n<td>Medium</td>\n<td></td>\n<td>2020/6/25</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>36</td>\n<td><a href=\"https://www.lintcode.com/problem/69/\" target=\"_blank\" rel=\"noopener\">69  binary-tree-level-order-traversal</a></td>\n<td>二叉树的层次遍历</td>\n<td>BFS,Queue</td>\n<td>Easy</td>\n<td></td>\n<td>2020/6/25</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>37</td>\n<td><a href=\"https://www.lintcode.com/problem/70/\" target=\"_blank\" rel=\"noopener\">70  binary-tree-level-order-traversal-ii</a></td>\n<td>二叉树的层次遍历 II</td>\n<td>BFS</td>\n<td>Medium</td>\n<td></td>\n<td>2020/6/25</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>38</td>\n<td><a href=\"https://www.lintcode.com/problem/95/\" target=\"_blank\" rel=\"noopener\">95  validate-binary-search-tree</a></td>\n<td>验证二叉查找树</td>\n<td>traversal</td>\n<td>Medium</td>\n<td></td>\n<td>2020/6/25</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>39</td>\n<td><a href=\"https://www.lintcode.com/problem/85/\" target=\"_blank\" rel=\"noopener\">85  insert-node-in-a-binary-search-tree</a></td>\n<td>在二叉查找树中插入节点</td>\n<td>BST，分治</td>\n<td>Medium</td>\n<td></td>\n<td>2020/6/25</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>40</td>\n<td><a href=\"https://www.lintcode.com/problem/86/\" target=\"_blank\" rel=\"noopener\">86  binary-search-tree-iterator</a></td>\n<td>在二叉查找树中插入节点</td>\n<td>BST，分治</td>\n<td>Hard</td>\n<td></td>\n<td>2020/6/25</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>41</td>\n<td><a href=\"https://www.lintcode.com/problem/87/\" target=\"_blank\" rel=\"noopener\">87  remove-node-in-binary-search-tree</a></td>\n<td>删除二叉查找树的节点</td>\n<td>BST，分治</td>\n<td>Hard</td>\n<td></td>\n<td>2020/6/25</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>42</td>\n<td><a href=\"https://www.lintcode.com/problem/11/\" target=\"_blank\" rel=\"noopener\">11  search-range-in-binary-search-tree</a></td>\n<td>二叉查找树中搜索区间</td>\n<td>tree-traversal</td>\n<td>Medium</td>\n<td></td>\n<td>2020/6/25</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>42</td>\n<td><a href=\"https://www.lintcode.com/problem/12/\" target=\"_blank\" rel=\"noopener\">12  min-stack</a></td>\n<td>最小栈</td>\n<td>stack，Simulation</td>\n<td>Medium</td>\n<td></td>\n<td>2020/6/25</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>43</td>\n<td><a href=\"https://www.lintcode.com/problem/40/\" target=\"_blank\" rel=\"noopener\">40  implement-queue-by-two-stacks</a></td>\n<td>双栈实现队列</td>\n<td>stack，Simulation</td>\n<td>Medium</td>\n<td></td>\n<td>2020/6/25</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>44</td>\n<td><a href=\"https://www.lintcode.com/problem/494/\" target=\"_blank\" rel=\"noopener\">494-implement-stack-by-two-queues</a></td>\n<td>双队列实现栈</td>\n<td>queue</td>\n<td>Medium</td>\n<td></td>\n<td>2020/6/25</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>45</td>\n<td><a href=\"https://www.lintcode.com/problem/130/\" target=\"_blank\" rel=\"noopener\">130  heapify</a></td>\n<td>堆化</td>\n<td>heap</td>\n<td>Medium</td>\n<td></td>\n<td>2020/6/25</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>46</td>\n<td><a href=\"https://www.lintcode.com/problem/158/\" target=\"_blank\" rel=\"noopener\">158  valid-anagram</a></td>\n<td>两个字符串是变位词</td>\n<td>string,map</td>\n<td>Easy</td>\n<td></td>\n<td>2020/6/26</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>47</td>\n<td><a href=\"https://www.lintcode.com/problem/122/\" target=\"_blank\" rel=\"noopener\">122  largest-rectangle-in-histogram</a></td>\n<td>直方图最大矩形覆盖</td>\n<td>monotonic stack</td>\n<td>Hard</td>\n<td></td>\n<td>2020/6/26</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>48</td>\n<td><a href=\"https://www.lintcode.com/problem/126/\" target=\"_blank\" rel=\"noopener\">126-max-tree</a></td>\n<td>最大树</td>\n<td>monotonic stack</td>\n<td>Hard</td>\n<td></td>\n<td>2020/6/26</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>49</td>\n<td><a href=\"https://www.lintcode.com/problem/134/\" target=\"_blank\" rel=\"noopener\">134-lru  cache</a></td>\n<td>LRU缓存策略</td>\n<td>hash</td>\n<td>Hard</td>\n<td></td>\n<td>2020/6/26</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>50</td>\n<td><a href=\"https://www.lintcode.com/problem/24/\" target=\"_blank\" rel=\"noopener\">24-lfu  cache</a></td>\n<td>LFU缓存</td>\n<td>hash</td>\n<td>Hard</td>\n<td></td>\n<td>2020/6/26</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>51</td>\n<td><a href=\"https://www.lintcode.com/problem/129/\" target=\"_blank\" rel=\"noopener\">129-rehashing</a></td>\n<td>重哈希</td>\n<td>hash</td>\n<td>Medium</td>\n<td></td>\n<td>2020/6/26</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>52</td>\n<td><a href=\"https://www.lintcode.com/problem/171/\" target=\"_blank\" rel=\"noopener\">171-anagrams</a></td>\n<td>变位词</td>\n<td>hash</td>\n<td>Medium</td>\n<td></td>\n<td>2020/6/26</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>53</td>\n<td><a href=\"https://www.lintcode.com/problem/138/\" target=\"_blank\" rel=\"noopener\">138-subarray-sum</a></td>\n<td>子数组之和</td>\n<td>hash，前缀和</td>\n<td>Easy</td>\n<td></td>\n<td>2020/6/26</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>54</td>\n<td><a href=\"https://www.lintcode.com/problem/124/\" target=\"_blank\" rel=\"noopener\">124-longest-consecutive-sequence</a></td>\n<td>最长连续序列</td>\n<td>hash</td>\n<td>Medium</td>\n<td></td>\n<td>2020/6/26</td>\n<td>2021/2/13</td>\n<td></td>\n</tr>\n<tr>\n<td>55</td>\n<td><a href=\"https://www.lintcode.com/problem/81/\" target=\"_blank\" rel=\"noopener\">81-find-median-from-data-stream</a></td>\n<td>数据流中位数</td>\n<td>heap</td>\n<td>Hard</td>\n<td></td>\n<td>2020/6/26</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>56</td>\n<td><a href=\"https://www.lintcode.com/problem/132/\" target=\"_blank\" rel=\"noopener\">132-word-search-ii</a></td>\n<td>单词搜索 II</td>\n<td>trie</td>\n<td>Hard</td>\n<td></td>\n<td>2020/6/26</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>57</td>\n<td><a href=\"https://www.lintcode.com/problem/442/\" target=\"_blank\" rel=\"noopener\">442-implement-trie-prefix-tree</a></td>\n<td>实现 Trie（前缀树）</td>\n<td>trie</td>\n<td></td>\n<td></td>\n<td>2020/6/27</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>58</td>\n<td><a href=\"https://www.lintcode.com/problem/61/\" target=\"_blank\" rel=\"noopener\">61-search-for-a-range</a></td>\n<td>搜索区间(对比<a href=\"https://www.lintcode.com/problem/138/\" target=\"_blank\" rel=\"noopener\">138</a>)</td>\n<td>binarysearch</td>\n<td>Medium</td>\n<td></td>\n<td>2020/6/27</td>\n<td>2021/2/13</td>\n<td></td>\n</tr>\n<tr>\n<td>59</td>\n<td><a href=\"https://www.lintcode.com/problem/60/\" target=\"_blank\" rel=\"noopener\">60-search-insert-position</a></td>\n<td>搜索插入位置</td>\n<td>binarysearch</td>\n<td>Easy</td>\n<td></td>\n<td>2020/6/27</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>60</td>\n<td><a href=\"https://www.lintcode.com/problem/28/\" target=\"_blank\" rel=\"noopener\">28-search-a-2d-matrix</a></td>\n<td>搜索二维矩阵</td>\n<td>binarysearch</td>\n<td>Easy</td>\n<td></td>\n<td>2020/6/27</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>61</td>\n<td><a href=\"https://www.lintcode.com/problem/75/\" target=\"_blank\" rel=\"noopener\">75-find-peak-element</a></td>\n<td>寻找峰值</td>\n<td>binarysearch</td>\n<td>Medium</td>\n<td></td>\n<td>2020/6/27</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>62</td>\n<td><a href=\"https://www.lintcode.com/problem/62/\" target=\"_blank\" rel=\"noopener\">62-search-in-rotated-sorted-array(无重复)</a></td>\n<td>搜索旋转排序数组</td>\n<td>binarysearch</td>\n<td>Medium</td>\n<td></td>\n<td>2020/6/27</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>63</td>\n<td><a href=\"https://www.lintcode.com/problem/63/\" target=\"_blank\" rel=\"noopener\">63-search-in-rotated-sorted-array-ii(有重复)</a></td>\n<td>搜索旋转排序数组</td>\n<td>62 follow up</td>\n<td>Medium</td>\n<td></td>\n<td>2020/6/27</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>64</td>\n<td><a href=\"https://www.lintcode.com/problem/6/\" target=\"_blank\" rel=\"noopener\">6-merge-two-sorted-arrays</a></td>\n<td>合并排序数组 II</td>\n<td>Two Pointers</td>\n<td>Easy</td>\n<td></td>\n<td>2020/6/27</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>65</td>\n<td><a href=\"https://www.lintcode.com/problem/64/\" target=\"_blank\" rel=\"noopener\">64-merge-sorted-array</a></td>\n<td>合并排序数组</td>\n<td>Two Pointers</td>\n<td>Easy</td>\n<td></td>\n<td>2020/6/27</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>66</td>\n<td><a href=\"https://www.lintcode.com/problem/159/\" target=\"_blank\" rel=\"noopener\">159-find-minimum-in-rotated-sorted-array</a></td>\n<td>寻找旋转排序数组中的最小值(无重复)</td>\n<td>binarysearch</td>\n<td>Medium</td>\n<td></td>\n<td>2020/6/27</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>67</td>\n<td><a href=\"https://www.lintcode.com/problem/160/\" target=\"_blank\" rel=\"noopener\">160-find-minimum-in-rotated-sorted-array-ii</a></td>\n<td>寻找旋转排序数组中的最小值(有重复)</td>\n<td>binarysearch</td>\n<td>Medium</td>\n<td></td>\n<td>2020/6/27</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>68</td>\n<td><a href=\"https://www.lintcode.com/problem/65/\" target=\"_blank\" rel=\"noopener\">65-median-of-two-sorted-arrays</a></td>\n<td>两个排序数组的中位数</td>\n<td>binarysearch,FindKMax</td>\n<td>Hard</td>\n<td></td>\n<td>2020/6/27</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>69</td>\n<td><a href=\"https://www.lintcode.com/problem/8/\" target=\"_blank\" rel=\"noopener\">8-rotate-string</a></td>\n<td>旋转字符串</td>\n<td>string，simulation，三步翻转法</td>\n<td>Easy</td>\n<td></td>\n<td>2020/6/27</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>70</td>\n<td><a href=\"https://www.lintcode.com/problem/53/\" target=\"_blank\" rel=\"noopener\">53-reverse-words-in-a-string</a></td>\n<td>翻转字符串中的单词</td>\n<td>string</td>\n<td>Easy</td>\n<td></td>\n<td>2020/6/27</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>71</td>\n<td><a href=\"https://www.lintcode.com/problem/241/\" target=\"_blank\" rel=\"noopener\">241-string-to-integer</a></td>\n<td>转换字符串到整数</td>\n<td>string</td>\n<td>Easy</td>\n<td></td>\n<td>2020/6/28</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>72</td>\n<td><a href=\"https://www.lintcode.com/problem/1510/\" target=\"_blank\" rel=\"noopener\">1510-buddy-strings</a></td>\n<td>亲密字符串</td>\n<td>string</td>\n<td>Easy</td>\n<td></td>\n<td>2020/6/28</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>73</td>\n<td><a href=\"https://www.lintcode.com/problem/415/\" target=\"_blank\" rel=\"noopener\">415-valid-palindrome</a></td>\n<td>有效回文串</td>\n<td>string，双指针</td>\n<td>Medium</td>\n<td></td>\n<td>2020/6/28</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>74</td>\n<td><a href=\"https://www.lintcode.com/problem/767/\" target=\"_blank\" rel=\"noopener\">767-reverse-array</a></td>\n<td>翻转数组</td>\n<td>string，reverse</td>\n<td>Easy</td>\n<td></td>\n<td>2020/6/28</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>75</td>\n<td><a href=\"https://www.lintcode.com/problem/1283/\" target=\"_blank\" rel=\"noopener\">1283-reverse-string</a></td>\n<td>翻转字符串</td>\n<td>string，reverse</td>\n<td>Easy</td>\n<td></td>\n<td>2020/6/28</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>76</td>\n<td><a href=\"https://www.lintcode.com/problem/78/\" target=\"_blank\" rel=\"noopener\">78-longest-common-prefix</a></td>\n<td>最长公共前缀 (LCP)</td>\n<td>string。Simulation</td>\n<td>Medium</td>\n<td></td>\n<td>2020/6/28</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>77</td>\n<td><a href=\"https://www.lintcode.com/problem/1263/\" target=\"_blank\" rel=\"noopener\">1263-is-subsequence</a></td>\n<td>是子序列吗</td>\n<td>string，Simulation</td>\n<td>Medium</td>\n<td></td>\n<td>2020/6/28</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>78</td>\n<td><a href=\"https://www.lintcode.com/problem/384/\" target=\"_blank\" rel=\"noopener\">384-longest-substring-without-repeating-characters</a></td>\n<td>最长无重复字符的子串</td>\n<td>string，two pointer</td>\n<td>Medium</td>\n<td></td>\n<td>2020/6/29</td>\n<td>2021/2/14</td>\n<td></td>\n</tr>\n<tr>\n<td>79</td>\n<td><a href=\"https://www.lintcode.com/problem/213/\" target=\"_blank\" rel=\"noopener\">213-string-compression</a></td>\n<td>字符串压缩</td>\n<td>string</td>\n<td>Easy</td>\n<td></td>\n<td>2020/6/29</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>80</td>\n<td><a href=\"https://www.lintcode.com/problem/1352/\" target=\"_blank\" rel=\"noopener\">1352-compare-version-numbers</a></td>\n<td>比较版本号</td>\n<td>string</td>\n<td>Medium</td>\n<td></td>\n<td>2020/6/29</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>81</td>\n<td><a href=\"https://www.lintcode.com/problem/1542/\" target=\"_blank\" rel=\"noopener\">1542-nexttime-norepeat</a></td>\n<td>下一个不重复的时间</td>\n<td>string</td>\n<td>Medium</td>\n<td></td>\n<td>2020/6/29</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>82</td>\n<td><a href=\"https://www.lintcode.com/problem/192/\" target=\"_blank\" rel=\"noopener\">192-wildcard-matching</a></td>\n<td>通配符匹配</td>\n<td>string，DFS</td>\n<td>Hard</td>\n<td></td>\n<td>2020/6/30</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>83</td>\n<td><a href=\"https://www.lintcode.com/problem/98/\" target=\"_blank\" rel=\"noopener\">98-sort-list（排序链表）</a></td>\n<td>链表排序(归并和快速)</td>\n<td>sort</td>\n<td>Medium</td>\n<td></td>\n<td>2020/6/30</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>84</td>\n<td><a href=\"https://www.lintcode.com/problem/463/\" target=\"_blank\" rel=\"noopener\">463-sort-integers</a></td>\n<td>整数排序</td>\n<td>sort【直接选择(选择)，冒泡排序(交换)，直接插入排序(插入)】</td>\n<td>Native</td>\n<td>简单排序</td>\n<td>2020/6/30</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>85</td>\n<td><a href=\"https://www.lintcode.com/problem/464/\" target=\"_blank\" rel=\"noopener\">464-sort-integers-ii </a></td>\n<td>整数排序2</td>\n<td>sort【堆排序(选择)，快排(交换)，归并排序(归并)】</td>\n<td>Medium</td>\n<td>分治排序</td>\n<td>2020/6/30</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>86</td>\n<td><a href=\"https://www.lintcode.com/problem/136/\" target=\"_blank\" rel=\"noopener\">136-palindrome-partitioning</a></td>\n<td>分割回文串</td>\n<td>组合型DFS+Backtracking</td>\n<td>Medium</td>\n<td></td>\n<td>2020/7/1</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>87</td>\n<td><a href=\"https://www.lintcode.com/problem/77/\" target=\"_blank\" rel=\"noopener\">77-longest-common-subsequence</a></td>\n<td>最长公共子序列(LCS)</td>\n<td>match-dp</td>\n<td>Medium</td>\n<td></td>\n<td>2020/7/2</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>88</td>\n<td><a href=\"https://www.lintcode.com/problem/79/\" target=\"_blank\" rel=\"noopener\">79-longest-common-substring</a></td>\n<td>最长公共子串(LCS)</td>\n<td>Two Sequences DP</td>\n<td>Medium</td>\n<td></td>\n<td>2020/7/2</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>89</td>\n<td><a href=\"https://www.lintcode.com/problem/680/\" target=\"_blank\" rel=\"noopener\">680-spilt-string</a></td>\n<td>分割字符串</td>\n<td>组合型DFS+Backtracking</td>\n<td>Medium</td>\n<td></td>\n<td>2020/7/2</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>90</td>\n<td><a href=\"https://www.lintcode.com/problem/15/\" target=\"_blank\" rel=\"noopener\">15-permutations</a></td>\n<td>全排列</td>\n<td>排列型DFS+Backtracking</td>\n<td>Medium</td>\n<td></td>\n<td>2020/7/2</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>91</td>\n<td><a href=\"https://www.lintcode.com/problem/16/\" target=\"_blank\" rel=\"noopener\">16-permutations-ii</a></td>\n<td>全排列</td>\n<td>排列型DFS+Backtracking</td>\n<td>Medium</td>\n<td></td>\n<td>2020/7/2</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>92</td>\n<td><a href=\"https://www.lintcode.com/problem/669/\" target=\"_blank\" rel=\"noopener\">669-coin-change</a></td>\n<td>换硬币</td>\n<td>无限背包,DFS,DP,不用回溯</td>\n<td></td>\n<td></td>\n<td>2020/7/3</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>93</td>\n<td><a href=\"https://www.lintcode.com/problem/816/\" target=\"_blank\" rel=\"noopener\">816-traveling-salesman-problem</a></td>\n<td>旅行商问题</td>\n<td>排列型DFS，pruning,dp,旅行售货员问题，TSP问题，组合优化</td>\n<td>Hard</td>\n<td></td>\n<td>2020/7/3</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>94</td>\n<td><a href=\"https://www.lintcode.com/problem/1147/\" target=\"_blank\" rel=\"noopener\">1147-work-plan</a></td>\n<td>工作安排</td>\n<td>coordinate-dp</td>\n<td>Medium</td>\n<td></td>\n<td>2020/7/3</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>95</td>\n<td><a href=\"https://www.lintcode.com/problem/76/\" target=\"_blank\" rel=\"noopener\">76-longest-increasing-subsequence</a></td>\n<td>最长上升子序列(LIS)</td>\n<td>match-dp，LIS</td>\n<td>Medium</td>\n<td></td>\n<td>2020/7/3</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>96</td>\n<td><a href=\"https://www.lintcode.com/problem/91/\" target=\"_blank\" rel=\"noopener\">91-minimum-adjustment-cost</a></td>\n<td>最小调整代价</td>\n<td>dp</td>\n<td>Medium</td>\n<td></td>\n<td>2020/7/3</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>97</td>\n<td><a href=\"https://www.lintcode.com/problem/34/\" target=\"_blank\" rel=\"noopener\">34-n-queens-ii</a></td>\n<td>N皇后问题（方案数）</td>\n<td>Backtracking+DFS</td>\n<td>Medium</td>\n<td></td>\n<td>2020/7/4</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>98</td>\n<td><a href=\"https://www.lintcode.com/problem/33/\" target=\"_blank\" rel=\"noopener\">33-n-queens</a></td>\n<td>N皇后问题（具体方案）</td>\n<td>Backtracking+DFS</td>\n<td>Medium</td>\n<td></td>\n<td>2020/7/4</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>99</td>\n<td><a href=\"https://www.lintcode.com/problem/622/\" target=\"_blank\" rel=\"noopener\">622-frog-jump</a></td>\n<td>青蛙跳</td>\n<td>DFS，DP</td>\n<td>Hard</td>\n<td></td>\n<td>2020/7/4</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>100</td>\n<td><a href=\"https://www.lintcode.com/problem/602/\" target=\"_blank\" rel=\"noopener\">602-russian-doll-envelopes</a></td>\n<td>俄罗斯套娃信封</td>\n<td>dfs(指数级),dp(正解)</td>\n<td>Hard</td>\n<td></td>\n<td>2020/7/4</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>101</td>\n<td><a href=\"https://www.lintcode.com/problem/116/\" target=\"_blank\" rel=\"noopener\">116-jump-game</a></td>\n<td>跳跃游戏</td>\n<td>单序列dp(可行性)，贪心</td>\n<td>Medium</td>\n<td></td>\n<td>2020/7/4</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>102</td>\n<td><a href=\"https://www.lintcode.com/problem/117/\" target=\"_blank\" rel=\"noopener\">117-jump-game-ii</a></td>\n<td>跳跃游戏</td>\n<td>单序列dp(最小值)</td>\n<td>Medium</td>\n<td></td>\n<td>2020/7/4</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>103</td>\n<td><a href=\"https://www.lintcode.com/problem/149/\" target=\"_blank\" rel=\"noopener\">149-best-time-to-buy-and-sell-stock</a></td>\n<td>买卖股票的最佳时机（一次交易）</td>\n<td>单序列dp(最大值)</td>\n<td>Medium</td>\n<td></td>\n<td>2020/7/4</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>104</td>\n<td><a href=\"https://www.lintcode.com/problem/115/\" target=\"_blank\" rel=\"noopener\">115-unique-paths-ii</a></td>\n<td>不同的路径 II</td>\n<td>坐标DP</td>\n<td>Easy</td>\n<td></td>\n<td>2020/7/4</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>105</td>\n<td><a href=\"https://www.lintcode.com/problem/111/\" target=\"_blank\" rel=\"noopener\">111-climbing-stairs</a></td>\n<td>爬楼梯</td>\n<td>单序列dp(计数问题)</td>\n<td>Easy</td>\n<td></td>\n<td>2020/7/4</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>106</td>\n<td><a href=\"https://www.lintcode.com/problem/563/\" target=\"_blank\" rel=\"noopener\">563-backpack-v</a></td>\n<td>背包问题 V</td>\n<td>Backpack DP</td>\n<td>Medium</td>\n<td></td>\n<td>2020/7/4</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>107</td>\n<td><a href=\"https://www.lintcode.com/problem/630/\" target=\"_blank\" rel=\"noopener\">630-knight-shortest-path-ii</a></td>\n<td>骑士的最短路径II</td>\n<td>坐标dp, 单向BFS-&gt;双向BFS</td>\n<td>Medium</td>\n<td></td>\n<td>2020/7/6</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>108</td>\n<td><a href=\"https://www.lintcode.com/problem/564/\" target=\"_blank\" rel=\"noopener\">564-combination-sum-iv(backpack-vi)</a></td>\n<td>组合总和 IV</td>\n<td>单序列dp，Backpack DP</td>\n<td>Medium</td>\n<td></td>\n<td>2020/7/6</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>109</td>\n<td><a href=\"https://www.lintcode.com/problem/512/\" target=\"_blank\" rel=\"noopener\">512-decode-ways</a></td>\n<td>解码方法</td>\n<td>dp</td>\n<td>Medium</td>\n<td></td>\n<td>2020/7/7</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>110</td>\n<td><a href=\"https://www.lintcode.com/problem/589/\" target=\"_blank\" rel=\"noopener\">589-connecting-graph</a></td>\n<td>连接图</td>\n<td>union-find</td>\n<td>Medium</td>\n<td></td>\n<td>2020/7/7</td>\n<td>2021/2/14</td>\n<td></td>\n</tr>\n<tr>\n<td>111</td>\n<td><a href=\"https://www.lintcode.com/problem/752/\" target=\"_blank\" rel=\"noopener\">752-rogue-knight-sven</a></td>\n<td>流浪剑客斯温</td>\n<td>dp</td>\n<td>Medium</td>\n<td></td>\n<td>2020/7/7</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>112</td>\n<td><a href=\"https://www.lintcode.com/problem/590/\" target=\"_blank\" rel=\"noopener\">590-connecting-graph-ii</a></td>\n<td>连接图</td>\n<td>union-find</td>\n<td>Medium</td>\n<td></td>\n<td>2020/7/8</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>113</td>\n<td><a href=\"https://www.lintcode.com/problem/360/\" target=\"_blank\" rel=\"noopener\">360-sliding-window-median</a></td>\n<td>滑动窗口的中位数</td>\n<td>heap，Sliding Window</td>\n<td>Hard</td>\n<td></td>\n<td>2020/7/8</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>114</td>\n<td><a href=\"https://www.lintcode.com/problem/401/\" target=\"_blank\" rel=\"noopener\">401-kth-smallest-number-in-sorted-matrix</a></td>\n<td>排序矩阵中的从小到大第k个数</td>\n<td>heap</td>\n<td>Medium</td>\n<td></td>\n<td>2020/7/8</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>115</td>\n<td><a href=\"https://www.lintcode.com/problem/362/\" target=\"_blank\" rel=\"noopener\">362-sliding-window-maximum</a></td>\n<td>滑动窗口的最大值</td>\n<td>monotonic-queue</td>\n<td>Hard</td>\n<td></td>\n<td>2020/7/8</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>116</td>\n<td><a href=\"https://www.lintcode.com/problem/178/\" target=\"_blank\" rel=\"noopener\">178-graph-valid-tree</a></td>\n<td>图是否是树</td>\n<td>union-find</td>\n<td>Medium</td>\n<td></td>\n<td>2020/7/8</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>117</td>\n<td><a href=\"https://www.lintcode.com/problem/434/\" target=\"_blank\" rel=\"noopener\">434-number-of-islands-ii</a></td>\n<td>岛屿的个数II</td>\n<td>union-find</td>\n<td>Medium</td>\n<td></td>\n<td>2020/7/9</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>118</td>\n<td><a href=\"https://www.lintcode.com/problem/430/\" target=\"_blank\" rel=\"noopener\">430-scramble-string</a></td>\n<td>攀爬字符串</td>\n<td>dfs+pruning</td>\n<td>Hard</td>\n<td></td>\n<td>2020/7/9</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>119</td>\n<td><a href=\"https://www.lintcode.com/problem/802/\" target=\"_blank\" rel=\"noopener\">802-sudoku-solver</a></td>\n<td>数独</td>\n<td>dfs+pruning+backtracking</td>\n<td>Hard</td>\n<td></td>\n<td>2020/7/10</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>120</td>\n<td><a href=\"https://www.lintcode.com/problem/121/\" target=\"_blank\" rel=\"noopener\">121-word-ladder-ii</a></td>\n<td>单词接龙 II</td>\n<td>dfs+pruning+backtracking</td>\n<td>Hard</td>\n<td></td>\n<td>2020/7/10</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>121</td>\n<td><a href=\"https://www.lintcode.com/problem/582/\" target=\"_blank\" rel=\"noopener\">582-word-break-ii</a></td>\n<td>单词拆分II</td>\n<td>dfs+pruning+backtracking</td>\n<td>Hard</td>\n<td></td>\n<td>2020/7/11</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>122</td>\n<td><a href=\"https://www.lintcode.com/problem/652/\" target=\"_blank\" rel=\"noopener\">652-factorization</a></td>\n<td>因式分解</td>\n<td>dfs+pruning+backtracking</td>\n<td>Medium</td>\n<td></td>\n<td>2020/7/11</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>123</td>\n<td><a href=\"https://www.lintcode.com/problem/119/\" target=\"_blank\" rel=\"noopener\">119-edit-distance</a></td>\n<td>编辑距离</td>\n<td>匹配性dp</td>\n<td>Medium</td>\n<td></td>\n<td>2020/7/11</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>124</td>\n<td><a href=\"https://www.lintcode.com/problem/787/\" target=\"_blank\" rel=\"noopener\">787-the-maze</a></td>\n<td>迷宫</td>\n<td>bfs</td>\n<td>Medium</td>\n<td></td>\n<td>2020/7/11</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>125</td>\n<td><a href=\"https://www.lintcode.com/problem/788/\" target=\"_blank\" rel=\"noopener\">788-the-maze-ii</a></td>\n<td>迷宫</td>\n<td>bfs</td>\n<td>Medium</td>\n<td></td>\n<td>2020/7/11</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>126</td>\n<td><a href=\"https://www.lintcode.com/problem/789/\" target=\"_blank\" rel=\"noopener\">789-the-maze-iii</a></td>\n<td>迷宫</td>\n<td>bfs</td>\n<td>Hard</td>\n<td></td>\n<td>2020/7/11</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>127</td>\n<td><a href=\"https://www.lintcode.com/problem/691/\" target=\"_blank\" rel=\"noopener\">691-recover-binary-search-tree</a></td>\n<td>恢复二叉搜索树</td>\n<td>bst</td>\n<td>Medium</td>\n<td></td>\n<td>2020/7/12</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>128</td>\n<td><a href=\"https://www.lintcode.com/problem/82/\" target=\"_blank\" rel=\"noopener\">82-single-number</a></td>\n<td>落单的数2n*1,两次</td>\n<td>bit，hash</td>\n<td>Easy</td>\n<td></td>\n<td>2020/7/12</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>129</td>\n<td><a href=\"https://www.lintcode.com/problem/83/\" target=\"_blank\" rel=\"noopener\">83-single-number-ii</a></td>\n<td>落单的数 II 3n*1，三次</td>\n<td>bit，hash</td>\n<td>Medium</td>\n<td></td>\n<td>2020/7/12</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>130</td>\n<td><a href=\"https://www.lintcode.com/problem/84/\" target=\"_blank\" rel=\"noopener\">84-single-number-iii</a></td>\n<td>落单的数2*n + 2</td>\n<td>bit，hash</td>\n<td>Medium</td>\n<td></td>\n<td>2020/7/12</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>131</td>\n<td><a href=\"https://www.lintcode.com/problem/46/\" target=\"_blank\" rel=\"noopener\">46-majority-element</a></td>\n<td>主元素(不是众数) 1/2</td>\n<td>Enumerate</td>\n<td>Easy</td>\n<td></td>\n<td>2020/7/12</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>132</td>\n<td><a href=\"https://www.lintcode.com/problem/1018/\" target=\"_blank\" rel=\"noopener\">1018-champagne-tower(triangle)</a></td>\n<td>香槟塔</td>\n<td>二维坐标dp</td>\n<td>Medium</td>\n<td></td>\n<td>2020/7/12</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>133</td>\n<td><a href=\"https://www.lintcode.com/problem/200/\" target=\"_blank\" rel=\"noopener\">200-longest-palindromic-substring</a></td>\n<td>最长回文子串</td>\n<td>区间dp</td>\n<td>Medium</td>\n<td></td>\n<td>2020/7/14</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>134</td>\n<td><a href=\"https://www.lintcode.com/problem/1565/\" target=\"_blank\" rel=\"noopener\">1565-modern-ludo-i</a></td>\n<td>飞行棋 I</td>\n<td>一维坐标dp</td>\n<td>Medium</td>\n<td></td>\n<td>2020/7/16</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>135</td>\n<td><a href=\"https://www.lintcode.com/problem/1141/\" target=\"_blank\" rel=\"noopener\">1141-the-months-days</a></td>\n<td>月份天数</td>\n<td>闰年</td>\n<td>Easy</td>\n<td></td>\n<td>2020/7/16</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>136</td>\n<td><a href=\"https://www.lintcode.com/problem/254/\" target=\"_blank\" rel=\"noopener\">254-drop-eggs</a></td>\n<td>丢鸡蛋</td>\n<td>归纳法</td>\n<td>Easy</td>\n<td></td>\n<td>2020/7/16</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>137</td>\n<td><a href=\"https://www.lintcode.com/problem/47/\" target=\"_blank\" rel=\"noopener\">47-majority-element-ii</a></td>\n<td>主元素1/3</td>\n<td>Enumerate</td>\n<td>Medium</td>\n<td></td>\n<td>2020/7/19</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>138</td>\n<td><a href=\"https://www.lintcode.com/problem/48/\" target=\"_blank\" rel=\"noopener\">48-majority-element-iii</a></td>\n<td>主元素1/k</td>\n<td>HashTable</td>\n<td>Medium</td>\n<td></td>\n<td>2020/7/20</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>139</td>\n<td><a href=\"https://www.lintcode.com/problem/150/\" target=\"_blank\" rel=\"noopener\">150-best-time-to-buy-and-sell-stock-ii</a></td>\n<td>买卖股票的最佳时机 II(多次交易)</td>\n<td>贪心</td>\n<td>Medium</td>\n<td></td>\n<td>2020/7/20</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>140</td>\n<td><a href=\"https://www.lintcode.com/problem/151/\" target=\"_blank\" rel=\"noopener\">151-best-time-to-buy-and-sell-stock-iii</a></td>\n<td>买卖股票的最佳时机 III(两笔交易)</td>\n<td>Enumerate</td>\n<td>Medium</td>\n<td></td>\n<td>2020/7/20</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>141</td>\n<td><a href=\"https://www.lintcode.com/problem/393/\" target=\"_blank\" rel=\"noopener\">393-best-time-to-buy-and-sell-stock-iv</a></td>\n<td>买卖股票的最佳时机 III(K笔交易)</td>\n<td>dp</td>\n<td>Medium</td>\n<td></td>\n<td>2020/7/20</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>142</td>\n<td><a href=\"https://www.lintcode.com/problem/44/\" target=\"_blank\" rel=\"noopener\">44-minimum-subarray</a></td>\n<td>最小子数组</td>\n<td>贪心</td>\n<td>Easy</td>\n<td></td>\n<td>2020/7/20</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>143</td>\n<td><a href=\"https://www.lintcode.com/problem/45/\" target=\"_blank\" rel=\"noopener\">45-maximum-subarray-difference</a></td>\n<td>最大子数组差</td>\n<td>贪心</td>\n<td>Easy</td>\n<td></td>\n<td>2020/7/20</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>144</td>\n<td><a href=\"https://www.lintcode.com/problem/138/\" target=\"_blank\" rel=\"noopener\">138-subarray-sum</a></td>\n<td>子数组之和</td>\n<td>hashmap</td>\n<td>Easy</td>\n<td></td>\n<td>2020/7/20</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>145</td>\n<td><a href=\"https://www.lintcode.com/problem/139/\" target=\"_blank\" rel=\"noopener\">139-subarray-sum-closest</a></td>\n<td>最接近零的子数组和</td>\n<td>Two Pointers，hashmap</td>\n<td>Medium</td>\n<td></td>\n<td>2020/7/20</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>146</td>\n<td><a href=\"https://www.lintcode.com/problem/56/\" target=\"_blank\" rel=\"noopener\">56-two-sum</a></td>\n<td>两数之和</td>\n<td>Two Pointers</td>\n<td>Easy</td>\n<td></td>\n<td>2020/7/20</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>147</td>\n<td><a href=\"https://www.lintcode.com/problem/608/\" target=\"_blank\" rel=\"noopener\">608-two-sum-ii-input-array-is-sorted</a></td>\n<td>两数和 II-输入已排序的数组</td>\n<td>Two Pointers</td>\n<td>Medium</td>\n<td></td>\n<td>2020/7/20</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>148</td>\n<td><a href=\"https://www.lintcode.com/problem/57/\" target=\"_blank\" rel=\"noopener\">57-3sum</a></td>\n<td>三数之和</td>\n<td>Two Pointers</td>\n<td>Medium</td>\n<td></td>\n<td>2020/7/20</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>149</td>\n<td><a href=\"https://www.lintcode.com/problem/533/\" target=\"_blank\" rel=\"noopener\">533-two-sum-closest-to-target</a></td>\n<td>两数和的最接近值</td>\n<td>Two Pointers</td>\n<td>Medium</td>\n<td></td>\n<td>2020/7/20</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>150</td>\n<td><a href=\"https://www.lintcode.com/problem/89/\" target=\"_blank\" rel=\"noopener\">89-k-sum</a></td>\n<td>K数之和</td>\n<td>dp</td>\n<td>Hard</td>\n<td></td>\n<td>2020/7/20</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>151</td>\n<td><a href=\"https://www.lintcode.com/problem/140/\" target=\"_blank\" rel=\"noopener\">140-fast-power</a></td>\n<td>快速幂</td>\n<td>DC</td>\n<td>Medium</td>\n<td></td>\n<td>2020/7/21</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>152</td>\n<td><a href=\"https://www.lintcode.com/problem/1324/\" target=\"_blank\" rel=\"noopener\">1324-count-primes</a></td>\n<td>质数的个数</td>\n<td>Mathmatics</td>\n<td>Easy</td>\n<td></td>\n<td>2020/7/21</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>153</td>\n<td><a href=\"https://www.lintcode.com/problem/141/\" target=\"_blank\" rel=\"noopener\">141-sqrtx</a></td>\n<td>对x开根</td>\n<td>Mathmatics</td>\n<td>Easy</td>\n<td></td>\n<td>2020/7/21</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>154</td>\n<td><a href=\"https://www.lintcode.com/problem/2/\" target=\"_blank\" rel=\"noopener\">2-trailing-zeros</a></td>\n<td>尾部的零</td>\n<td>Mathmatics</td>\n<td>Easy</td>\n<td></td>\n<td>2020/7/21</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>155</td>\n<td><a href=\"https://www.lintcode.com/problem/142/\" target=\"_blank\" rel=\"noopener\">142.o1-check-power-of-2</a></td>\n<td>O(1)时间检测2的幂次</td>\n<td>Binary</td>\n<td>Easy</td>\n<td></td>\n<td>2020/7/21</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>156</td>\n<td><a href=\"https://www.lintcode.com/problem/49/\" target=\"_blank\" rel=\"noopener\">49-sort-letters-by-case</a></td>\n<td>字符大小写排序</td>\n<td>Two Pointers</td>\n<td>Medium</td>\n<td></td>\n<td>2020/7/21</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>157</td>\n<td><a href=\"https://www.lintcode.com/problem/1563/\" target=\"_blank\" rel=\"noopener\">1563-shortest-path-to-the-destination</a></td>\n<td>目的地的最短路径</td>\n<td>bfs</td>\n<td>Medium</td>\n<td></td>\n<td>2020/7/21</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>158</td>\n<td><a href=\"https://www.lintcode.com/problem/108/\" target=\"_blank\" rel=\"noopener\">108-palindrome-partitioning-ii</a></td>\n<td>分割回文串 II</td>\n<td>dp</td>\n<td>Medium</td>\n<td></td>\n<td>2020/8/2</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>159</td>\n<td><a href=\"https://www.lintcode.com/problem/107/\" target=\"_blank\" rel=\"noopener\">107-word-break</a></td>\n<td>单词拆分 I</td>\n<td>dp</td>\n<td>Medium</td>\n<td></td>\n<td>2020/8/2</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>160</td>\n<td><a href=\"https://www.lintcode.com/problem/41/\" target=\"_blank\" rel=\"noopener\">41-maximum-subarray</a></td>\n<td>最大子数组</td>\n<td>dp</td>\n<td>Easy</td>\n<td></td>\n<td>2020/8/3</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>161</td>\n<td><a href=\"https://www.lintcode.com/problem/29/\" target=\"_blank\" rel=\"noopener\">29-interleaving-string</a></td>\n<td>交叉字符串</td>\n<td>dp</td>\n<td>Medium</td>\n<td></td>\n<td>2020/8/9</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>162</td>\n<td><a href=\"https://www.lintcode.com/problem/513/\" target=\"_blank\" rel=\"noopener\">513-perfect-squares</a></td>\n<td>完美平方</td>\n<td>dp</td>\n<td>Medium</td>\n<td></td>\n<td>2020/8/9</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>163</td>\n<td><a href=\"https://www.lintcode.com/problem/394/\" target=\"_blank\" rel=\"noopener\">394-coins-in-a-line</a></td>\n<td>硬币排成线</td>\n<td>dp</td>\n<td>Medium</td>\n<td></td>\n<td>2020/8/9</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>164</td>\n<td><a href=\"https://www.lintcode.com/problem/92/\" target=\"_blank\" rel=\"noopener\">92-backpack</a></td>\n<td>背包问题</td>\n<td>dp</td>\n<td>Medium</td>\n<td></td>\n<td>2020/8/9</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>165</td>\n<td><a href=\"https://www.lintcode.com/problem/118/\" target=\"_blank\" rel=\"noopener\">118-distinct-subsequences</a></td>\n<td>不同的子序列</td>\n<td>dp</td>\n<td>Medium</td>\n<td></td>\n<td>2020/8/9</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>166</td>\n<td><a href=\"https://www.lintcode.com/problem/604/\" target=\"_blank\" rel=\"noopener\">604-window-sum</a></td>\n<td>滑动窗口内数的和</td>\n<td>two-pointer</td>\n<td>Easy</td>\n<td></td>\n<td>2020/8/9</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>167</td>\n<td><a href=\"https://www.lintcode.com/problem/539/\" target=\"_blank\" rel=\"noopener\">539-move-zeroes</a></td>\n<td>移动0</td>\n<td>two-pointer</td>\n<td>Easy</td>\n<td></td>\n<td>2020/8/10</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>168</td>\n<td><a href=\"https://www.lintcode.com/problem/521/\" target=\"_blank\" rel=\"noopener\">521.remove-duplicate-numbers-in-array</a></td>\n<td>数组去重</td>\n<td>two-pointer</td>\n<td>Easy</td>\n<td></td>\n<td>2020/8/10</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>169</td>\n<td><a href=\"https://www.lintcode.com/problem/638/\" target=\"_blank\" rel=\"noopener\">638. Isomorphic Strings</a></td>\n<td>字符同构</td>\n<td>string</td>\n<td>Easy</td>\n<td></td>\n<td>2021/2/10</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>170</td>\n<td><a href=\"https://www.lintcode.com/problem/626/\" target=\"_blank\" rel=\"noopener\">626. Rectangle Overlap</a></td>\n<td>矩形重叠</td>\n<td>string</td>\n<td>Easy</td>\n<td></td>\n<td>2021/2/10</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>171</td>\n<td><a href=\"https://www.lintcode.com/problem/637/\" target=\"_blank\" rel=\"noopener\">637. Valid Word Abbreviation</a></td>\n<td>检查缩写单词</td>\n<td>string</td>\n<td>Easy</td>\n<td></td>\n<td>2021/2/10</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>172</td>\n<td><a href=\"https://www.lintcode.com/problem/639/\" target=\"_blank\" rel=\"noopener\">639. Word Abbreviation</a></td>\n<td>单词缩写</td>\n<td>string</td>\n<td>Hard</td>\n<td></td>\n<td>2021/2/11</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>173</td>\n<td><a href=\"https://www.lintcode.com/problem/642/\" target=\"_blank\" rel=\"noopener\">642. Moving Average from Data Stream</a></td>\n<td>数据流滑动窗口平均值</td>\n<td>Prefix Sum Array，rolling array</td>\n<td>Easy</td>\n<td></td>\n<td>2021/2/11</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>174</td>\n<td><a href=\"https://www.lintcode.com/problem/644/\" target=\"_blank\" rel=\"noopener\">644. Strobogrammatic Number</a></td>\n<td>镜像数字</td>\n<td>Enumerate</td>\n<td>Easy</td>\n<td></td>\n<td>2021/2/11</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>175</td>\n<td><a href=\"https://www.lintcode.com/problem/640/\" target=\"_blank\" rel=\"noopener\">640. One Edit Distance</a></td>\n<td>一次编辑距离</td>\n<td>Enumerate</td>\n<td>Medium</td>\n<td></td>\n<td>2021/2/11</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>176</td>\n<td><a href=\"https://www.lintcode.com/problem/660/\" target=\"_blank\" rel=\"noopener\">660. Read N Characters Given Read4</a></td>\n<td>用Read4从文件中读取N个字符 II-多次调用</td>\n<td>Enumerate</td>\n<td>Hard</td>\n<td></td>\n<td>2021/2/12</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>177</td>\n<td><a href=\"https://www.lintcode.com/problem/659/\" target=\"_blank\" rel=\"noopener\">659. Encode and Decode Strings</a></td>\n<td>编码和解码字符串</td>\n<td>Enumerate</td>\n<td>Medium</td>\n<td></td>\n<td>2021/2/12</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>178</td>\n<td><a href=\"https://www.lintcode.com/problem/419/\" target=\"_blank\" rel=\"noopener\">419. Roman to Integer</a></td>\n<td>罗马数字转整数</td>\n<td>Enumerate</td>\n<td>Medium</td>\n<td></td>\n<td>2021/2/12</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>179</td>\n<td><a href=\"https://www.lintcode.com/problem/418/\" target=\"_blank\" rel=\"noopener\">418. Integer to Roman</a></td>\n<td>整数转罗马数字</td>\n<td>Enumerate</td>\n<td>Medium</td>\n<td></td>\n<td>2021/2/12</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>180</td>\n<td><a href=\"https://www.lintcode.com/problem/645/\" target=\"_blank\" rel=\"noopener\">645. Find the Celebrity</a></td>\n<td>识别名人</td>\n<td>Enumerate</td>\n<td>Medium</td>\n<td></td>\n<td>2021/2/12</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>181</td>\n<td><a href=\"https://www.lintcode.com/problem/641/\" target=\"_blank\" rel=\"noopener\">641. Missing Ranges</a></td>\n<td>丢失的间隔</td>\n<td>Enumerate</td>\n<td>Medium</td>\n<td></td>\n<td>2021/2/12</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>182</td>\n<td><a href=\"https://www.lintcode.com/problem/156/\" target=\"_blank\" rel=\"noopener\">156. Merge Intervals</a></td>\n<td>合并区间</td>\n<td>Enumerate</td>\n<td>Easy</td>\n<td></td>\n<td>2021/2/12</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>183</td>\n<td><a href=\"https://www.lintcode.com/problem/30/\" target=\"_blank\" rel=\"noopener\">30. Insert Interval</a></td>\n<td>插入区间</td>\n<td>Enumerate</td>\n<td>Medium</td>\n<td></td>\n<td>2021/2/12</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>184</td>\n<td><a href=\"https://www.lintcode.com/problem/646/\" target=\"_blank\" rel=\"noopener\">646. First Position Unique Character</a></td>\n<td>第一个不重复字符位置</td>\n<td>Hash</td>\n<td>Easy</td>\n<td></td>\n<td>2021/2/12</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>185</td>\n<td><a href=\"https://www.lintcode.com/problem/647/\" target=\"_blank\" rel=\"noopener\">647. Find All Anagrams in a String</a></td>\n<td>子串字谜</td>\n<td>Hash+Siding Windows</td>\n<td>Medium</td>\n<td></td>\n<td>2021/2/12</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>186</td>\n<td><a href=\"https://www.lintcode.com/problem/423/\" target=\"_blank\" rel=\"noopener\">423. Valid Parentheses</a></td>\n<td>有效的括号序列</td>\n<td>Stack</td>\n<td>Easy</td>\n<td></td>\n<td>2021/2/13</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>187</td>\n<td><a href=\"https://www.jiuzhang.com/problem/load-balancer/\" target=\"_blank\" rel=\"noopener\">526. Load Balancer</a></td>\n<td>负载均衡</td>\n<td>DS</td>\n<td></td>\n<td></td>\n<td>2021/2/13</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>188</td>\n<td><a href=\"https://www.lintcode.com/problem/662/\" target=\"_blank\" rel=\"noopener\">662. Guess Number Higher or Lower</a></td>\n<td>猜数游戏</td>\n<td>Binary Search</td>\n<td>Easy</td>\n<td></td>\n<td>2021/2/13</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>189</td>\n<td><a href=\"https://www.lintcode.com/problem/661/\" target=\"_blank\" rel=\"noopener\">661. Convert BST to Greater Tree</a></td>\n<td>把二叉搜索树转化成更大的树</td>\n<td>BST</td>\n<td>Easy</td>\n<td></td>\n<td>2021/2/13</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>190</td>\n<td><a href=\"https://www.lintcode.com/problem/649/\" target=\"_blank\" rel=\"noopener\">649. Binary Tree Upside Down</a></td>\n<td>二叉树翻转</td>\n<td>BST</td>\n<td>Medium</td>\n<td></td>\n<td>2021/2/13</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>191</td>\n<td><a href=\"https://www.lintcode.com/problem/650/\" target=\"_blank\" rel=\"noopener\">650. Find Leaves of Binary Tree</a></td>\n<td>二叉树叶子顺序遍历</td>\n<td>BST</td>\n<td>Medium</td>\n<td></td>\n<td>2021/2/13</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>192</td>\n<td><a href=\"https://www.lintcode.com/problem/651/\" target=\"_blank\" rel=\"noopener\">651. Binary Tree Vertical Order Traversal</a></td>\n<td>二叉树垂直遍历</td>\n<td>Hash+BFS</td>\n<td>Medium</td>\n<td></td>\n<td>2021/2/13</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>193</td>\n<td><a href=\"https://www.lintcode.com/problem/448/\" target=\"_blank\" rel=\"noopener\">448. Inorder Successor in BST</a></td>\n<td>二叉查找树的中序后继</td>\n<td>BST</td>\n<td>Medium</td>\n<td></td>\n<td>2021/2/13</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>194</td>\n<td><a href=\"https://www.lintcode.com/problem/477/\" target=\"_blank\" rel=\"noopener\">477. Surrounded Regions</a></td>\n<td>被围绕的区域</td>\n<td>BFS</td>\n<td>Medium</td>\n<td></td>\n<td>2021/2/13</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>195</td>\n<td><a href=\"https://www.lintcode.com/problem/663/\" target=\"_blank\" rel=\"noopener\">663. Walls and Gates</a></td>\n<td>墙和门</td>\n<td>BFS</td>\n<td>Medium</td>\n<td></td>\n<td>2021/2/13</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>196</td>\n<td><a href=\"https://www.lintcode.com/problem/32/\" target=\"_blank\" rel=\"noopener\">32. Minimum Window Substring</a></td>\n<td>最小子串覆盖</td>\n<td>Two pointer</td>\n<td>Medium</td>\n<td></td>\n<td>2021/2/14</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>197</td>\n<td><a href=\"https://www.lintcode.com/problem/543/\" target=\"_blank\" rel=\"noopener\">543. Kth Largest in N Arrays</a></td>\n<td>N数组第K大元素(一个数组第<a href=\"https://www.lintcode.com/problem/5/\" target=\"_blank\" rel=\"noopener\">K大</a>)</td>\n<td>Heap</td>\n<td>Hard</td>\n<td></td>\n<td>2021/2/14</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>198</td>\n<td><a href=\"https://www.lintcode.com/problem/465/\" target=\"_blank\" rel=\"noopener\">465. Kth Smallest Sum In Two Sorted Arrays</a></td>\n<td>两个排序数组和的第K小</td>\n<td>Heap</td>\n<td>Hard</td>\n<td></td>\n<td>2021/2/14</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>199</td>\n<td><a href=\"https://www.lintcode.com/problem/591/\" target=\"_blank\" rel=\"noopener\">591. Connecting Graph III</a></td>\n<td>连接图 III</td>\n<td>UF</td>\n<td>Medium</td>\n<td></td>\n<td>2021/2/14</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>200</td>\n<td><a href=\"https://www.lintcode.com/problem/1179/\" target=\"_blank\" rel=\"noopener\">1179. Friend Circles</a></td>\n<td>朋友圈</td>\n<td>UF</td>\n<td>Medium</td>\n<td></td>\n<td>2021/2/14</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>201</td>\n<td><a href=\"https://www.lintcode.com/problem/152/\" target=\"_blank\" rel=\"noopener\">152. Combinations</a></td>\n<td>组合</td>\n<td>DFS，组合</td>\n<td>Medium</td>\n<td></td>\n<td>2021/2/15</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>202</td>\n<td><a href=\"https://www.lintcode.com/problem/135/\" target=\"_blank\" rel=\"noopener\">135. Combination Sum I</a></td>\n<td>组合数之和</td>\n<td>DFS，组合</td>\n<td>Medium</td>\n<td></td>\n<td>2021/2/15</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>203</td>\n<td><a href=\"https://www.lintcode.com/problem/153/\" target=\"_blank\" rel=\"noopener\">153. Combination Sum II</a></td>\n<td>组合数之和</td>\n<td>DFS，组合</td>\n<td>Medium</td>\n<td></td>\n<td>2021/2/15</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>204</td>\n<td><a href=\"https://www.lintcode.com/problem/1321/\" target=\"_blank\" rel=\"noopener\">1321. Combination Sum III</a></td>\n<td>组合数之和</td>\n<td>DFS，组合</td>\n<td>Medium</td>\n<td></td>\n<td>2021/2/15</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>205</td>\n<td><a href=\"https://www.lintcode.com/problem/457/\" target=\"_blank\" rel=\"noopener\">457. Classical Binary Search</a></td>\n<td>经典二分查找问题</td>\n<td>Binary Search</td>\n<td>Easy</td>\n<td></td>\n<td>2021/2/15</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>206</td>\n<td><a href=\"https://www.lintcode.com/problem/366/\" target=\"_blank\" rel=\"noopener\">366. Fibonacci</a></td>\n<td>斐波那契</td>\n<td>iteration/recursion,多项公式</td>\n<td>Naive</td>\n<td></td>\n<td>2021/2/16</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>207</td>\n<td><a href=\"https://www.lintcode.com/problem/1807/\" target=\"_blank\" rel=\"noopener\">1807. Fibonacci easy</a></td>\n<td>斐波那契</td>\n<td>iteration</td>\n<td>Easy</td>\n<td></td>\n<td>2021/2/16</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>208</td>\n<td><a href=\"https://www.lintcode.com/problem/powx-n/\" target=\"_blank\" rel=\"noopener\">428. Pow(x, n)</a></td>\n<td>x的n次幂</td>\n<td>recursion,decrease-and-conquer</td>\n<td>Medium</td>\n<td></td>\n<td>2021/2/16</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>209</td>\n<td><a href=\"https://www.lintcode.com/problem/451/\" target=\"_blank\" rel=\"noopener\">451. Swap Nodes in Pairs</a></td>\n<td>两两交换链表中的节点</td>\n<td></td>\n<td></td>\n<td></td>\n<td>2021/2/16</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>210</td>\n<td><a href=\"https://www.lintcode.com/problem/450/\" target=\"_blank\" rel=\"noopener\">450. Reverse Nodes in k-Group</a></td>\n<td>K组翻转链表</td>\n<td></td>\n<td></td>\n<td></td>\n<td>2021/2/16</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>211</td>\n<td><a href=\"https://www.lintcode.com/problem/1425/\" target=\"_blank\" rel=\"noopener\">1425. Backspace String Compare</a></td>\n<td>比较含退格的字符串</td>\n<td></td>\n<td></td>\n<td></td>\n<td>2021/2/16</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>212</td>\n<td><a href=\"https://www.lintcode.com/problem/5/\" target=\"_blank\" rel=\"noopener\">5.Kth Largest Element</a></td>\n<td>数组第k大元素</td>\n<td></td>\n<td></td>\n<td></td>\n<td>2021/2/16</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>213</td>\n<td><a href=\"https://www.lintcode.com/problem/471/\" target=\"_blank\" rel=\"noopener\">471. Top K Frequent Words</a></td>\n<td>最高频的K个单词</td>\n<td></td>\n<td></td>\n<td></td>\n<td>2021/2/16</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>214</td>\n<td><a href=\"https://www.lintcode.com/problem/1311/\" target=\"_blank\" rel=\"noopener\">1311. Lowest Common Ancestor of a Binary Search Tree</a></td>\n<td>二叉搜索树的最近公共祖先</td>\n<td></td>\n<td>Easy</td>\n<td></td>\n<td>2021/2/16</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>215</td>\n<td><a href=\"https://www.lintcode.com/problem/1509/\" target=\"_blank\" rel=\"noopener\">1509. Lemonade Change</a></td>\n<td>柠檬水找零</td>\n<td>Greedy</td>\n<td>Easy</td>\n<td></td>\n<td>2021/2/16</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>216</td>\n<td><a href=\"https://www.lintcode.com/problem/1230/\" target=\"_blank\" rel=\"noopener\">1230. Assign Cookies</a></td>\n<td>分饼干</td>\n<td>Greedy</td>\n<td>Easy</td>\n<td></td>\n<td>2021/2/16</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>217</td>\n<td><a href=\"https://www.lintcode.com/problem/1493/\" target=\"_blank\" rel=\"noopener\">1493. Walking Robot Simulation</a></td>\n<td>模拟行走机器人</td>\n<td>Greedy</td>\n<td></td>\n<td></td>\n<td>2021/2/16</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>218</td>\n<td><a href=\"https://www.lintcode.com/problem/155/\" target=\"_blank\" rel=\"noopener\">155. Minimum Depth of Binary Tree</a></td>\n<td>二叉树的最小深度</td>\n<td></td>\n<td></td>\n<td></td>\n<td>2021/2/16</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>219</td>\n<td><a href=\"https://www.lintcode.com/problem/1360/\" target=\"_blank\" rel=\"noopener\">1360. Symmetric Tree</a></td>\n<td>对称树</td>\n<td></td>\n<td></td>\n<td></td>\n<td>2021/2/16</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>220</td>\n<td><a href=\"https://www.lintcode.com/problem/1244/\" target=\"_blank\" rel=\"noopener\">1244. Minimum Genetic Mutation</a></td>\n<td>最小基因变化</td>\n<td></td>\n<td></td>\n<td></td>\n<td>2021/2/16</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>221</td>\n<td><a href=\"https://www.lintcode.com/problem/427/\" target=\"_blank\" rel=\"noopener\">427. Generate Parentheses</a></td>\n<td>生成括号</td>\n<td></td>\n<td></td>\n<td></td>\n<td>2021/2/16</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>222</td>\n<td><a href=\"https://www.lintcode.com/problem/1195/\" target=\"_blank\" rel=\"noopener\">1195. Find Largest Value in Each Tree Row</a></td>\n<td>找出树中每行的最大值</td>\n<td></td>\n<td>Medium</td>\n<td></td>\n<td>2021/2/16</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>223</td>\n<td><a href=\"https://www.lintcode.com/problem/120/\" target=\"_blank\" rel=\"noopener\">120. Word Ladder</a></td>\n<td>单词接龙</td>\n<td></td>\n<td></td>\n<td></td>\n<td>2021/2/16</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>224</td>\n<td><a href=\"https://www.lintcode.com/problem/615/\" target=\"_blank\" rel=\"noopener\">615. Course Schedule</a></td>\n<td>课程表</td>\n<td></td>\n<td></td>\n<td></td>\n<td>2021/2/16</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>225</td>\n<td><a href=\"https://www.lintcode.com/problem/1189/\" target=\"_blank\" rel=\"noopener\">1189. Minesweeper</a></td>\n<td>扫雷游戏</td>\n<td>BFS</td>\n<td>Medium</td>\n<td></td>\n<td>2021/2/16</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>226</td>\n<td><a href=\"https://www.lintcode.com/problem/389/\" target=\"_blank\" rel=\"noopener\">389. Valid Sudoku</a></td>\n<td>判断数独是否合法</td>\n<td>Simulation</td>\n<td>Easy</td>\n<td></td>\n<td>2021/2/16</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>227</td>\n<td><a href=\"https://www.lintcode.com/problem/123/\" target=\"_blank\" rel=\"noopener\">123. Word Search</a></td>\n<td>单词搜索</td>\n<td>DFS</td>\n<td>Medium</td>\n<td></td>\n<td>2021/2/16</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>228</td>\n<td><a href=\"https://www.lintcode.com/problem/664/\" target=\"_blank\" rel=\"noopener\">664. Counting Bits</a></td>\n<td>数 1</td>\n<td>Bit，DP</td>\n<td>Medium</td>\n<td></td>\n<td>2021/2/16</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>229</td>\n<td><a href=\"https://www.lintcode.com/problem/maximum-product-subarray/\" target=\"_blank\" rel=\"noopener\">191. Maximum Product Subarray</a></td>\n<td>乘积最大子序列</td>\n<td>线性dp</td>\n<td>Medium</td>\n<td></td>\n<td>2021/2/16</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>230</td>\n<td><a href=\"https://www.lintcode.com/problem/556/\" target=\"_blank\" rel=\"noopener\">556. Standard Bloom Filter</a></td>\n<td>标准型布隆过滤器</td>\n<td></td>\n<td>Medium</td>\n<td></td>\n<td>2021/2/16</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>231</td>\n<td><a href=\"https://www.lintcode.com/problem/555/\" target=\"_blank\" rel=\"noopener\">555. Counting Bloom Filter</a></td>\n<td>计数型布隆过滤器</td>\n<td></td>\n<td>Medium</td>\n<td></td>\n<td>2021/2/16</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>232</td>\n<td><a href=\"https://www.lintcode.com/problem/1332/\" target=\"_blank\" rel=\"noopener\">1332. Number of 1 Bits</a></td>\n<td>判断一个整数中有多少个1</td>\n<td>Bit</td>\n<td>Easy</td>\n<td></td>\n<td>2021/2/16</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>233</td>\n<td><a href=\"https://www.lintcode.com/problem/204/\" target=\"_blank\" rel=\"noopener\">204. Singleton</a></td>\n<td>单例</td>\n<td>OOD</td>\n<td>Easy</td>\n<td></td>\n<td>2021/2/16</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>234</td>\n<td><a href=\"https://www.lintcode.com/problem/496/\" target=\"_blank\" rel=\"noopener\">496. Toy Factory</a></td>\n<td>工厂</td>\n<td>OOD</td>\n<td>Easy</td>\n<td></td>\n<td>2021/2/16</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>235</td>\n<td><a href=\"https://www.lintcode.com/problem/175/\" target=\"_blank\" rel=\"noopener\">175. Invert Binary Tree</a></td>\n<td>反转二叉树</td>\n<td>Tree</td>\n<td>Easy</td>\n<td></td>\n<td>2021/2/16</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n","site":{"data":{}},"excerpt":"","more":"<p>本文章是一个系列，主要记录自己解算法题的一个记录，每道题会出一篇解题报告，作为自己算法功底的沉淀。每次迭代全部从头开始，并且记录以日期。</p>\n<p>下面记录的必须在ide和lintcode上提交过，并且写过代码的。</p>\n<p>解题七步曲：1 倾听问题，2样本确认， 3 动口不动手的暴力天然解， 4 动口也动手的最优解，5 路演你的思路，6 结构化的编码，7 单元测试     </p>\n<p>我的笔记：<a href=\"https://www.lintcode.com/note/?user__username=xiaozhiliaoo\" target=\"_blank\" rel=\"noopener\">here</a>  (复习时候，刷这个效率更高)</p>\n<p>我AC的题目：<a href=\"https://www.lintcode.com/problem/?user_status=accepted\" target=\"_blank\" rel=\"noopener\">here</a></p>\n<table>\n<thead>\n<tr>\n<th>No</th>\n<th>Problem</th>\n<th>Describe</th>\n<th>Type</th>\n<th>Diffculty</th>\n<th>Note</th>\n<th>Date1</th>\n<th>Date2</th>\n<th>Date3</th>\n</tr>\n</thead>\n<tbody><tr>\n<td>1</td>\n<td><a href=\"https://www.lintcode.com/problem/implement-strstr/description\" target=\"_blank\" rel=\"noopener\">13-implement-strstr</a></td>\n<td>字符串查找</td>\n<td>string</td>\n<td>Easy</td>\n<td></td>\n<td>2020/6/19</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>2</td>\n<td><a href=\"https://www.lintcode.com/problem/594/\" target=\"_blank\" rel=\"noopener\">594-strstr-ii</a></td>\n<td>字符串查找 II</td>\n<td>hash,kmp</td>\n<td>Hard</td>\n<td></td>\n<td>2020/6/19</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>3</td>\n<td><a href=\"https://www.lintcode.com/problem/17/\" target=\"_blank\" rel=\"noopener\">17-subsets</a></td>\n<td>子集(无重复)</td>\n<td>combination,dfs</td>\n<td>Medium</td>\n<td></td>\n<td>2020/6/19</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>4</td>\n<td><a href=\"https://www.lintcode.com/problem/18/\" target=\"_blank\" rel=\"noopener\">18-subsets-ii</a></td>\n<td>子集 II(有重复)</td>\n<td>dfs,backtracking</td>\n<td>Medium</td>\n<td></td>\n<td>2020/6/19</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>5</td>\n<td><a href=\"https://www.lintcode.com/problem/1361/\" target=\"_blank\" rel=\"noopener\">1361-text-justification</a></td>\n<td>文字并排</td>\n<td>simulation</td>\n<td>Hard</td>\n<td></td>\n<td>2020/6/19</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>6</td>\n<td><a href=\"https://www.lintcode.com/problem/38/\" target=\"_blank\" rel=\"noopener\">38-search-a-2d-matrix-ii</a></td>\n<td>搜索二维矩阵 II</td>\n<td>sort-matrix</td>\n<td>Medium</td>\n<td></td>\n<td>2020/6/19</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>7</td>\n<td><a href=\"https://www.lintcode.com/problem/recover-rotated-sorted-array\" target=\"_blank\" rel=\"noopener\">39-recover-rotated-sorted-array</a></td>\n<td>恢复旋转排序数组</td>\n<td>sort-array</td>\n<td>Easy</td>\n<td></td>\n<td>2020/6/19</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>8</td>\n<td><a href=\"https://www.lintcode.com/problem/573/\" target=\"_blank\" rel=\"noopener\">573-build-post-office-ii</a></td>\n<td>邮局的建立 II</td>\n<td>bfs</td>\n<td>Medium</td>\n<td></td>\n<td>2020/6/21</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>9</td>\n<td><a href=\"https://www.lintcode.com/problem/616/\" target=\"_blank\" rel=\"noopener\">616-course-schedule-ii</a></td>\n<td>安排课程</td>\n<td>bfs,topological-sort</td>\n<td>Medium</td>\n<td></td>\n<td>2020/6/21</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>10</td>\n<td><a href=\"https://www.lintcode.com/problem/598/\" target=\"_blank\" rel=\"noopener\">598-zombie-in-matrix</a></td>\n<td>僵尸矩阵</td>\n<td>bfs</td>\n<td>Medium</td>\n<td></td>\n<td>2020/6/21</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>11</td>\n<td><a href=\"https://www.lintcode.com/problem/127/\" target=\"_blank\" rel=\"noopener\">127-topological-sorting</a></td>\n<td>拓扑排序</td>\n<td>bfs or dfs</td>\n<td>Medium</td>\n<td></td>\n<td>2020/6/21</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>12</td>\n<td><a href=\"https://www.lintcode.com/problem/433/\" target=\"_blank\" rel=\"noopener\">433-number-of-islands</a></td>\n<td>岛屿的个数</td>\n<td>bfs or union-find</td>\n<td>Easy</td>\n<td></td>\n<td>2020/6/21</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>13</td>\n<td><a href=\"https://www.lintcode.com/problem/number-of-big-islands/\" target=\"_blank\" rel=\"noopener\">677-number-of-big-islands</a></td>\n<td>大岛的数量</td>\n<td>bfs</td>\n<td>Medium</td>\n<td></td>\n<td>2020/6/22</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>14</td>\n<td><a href=\"https://www.lintcode.com/problem/109/\" target=\"_blank\" rel=\"noopener\">109-triangle</a></td>\n<td>数字三角形</td>\n<td>dp，坐标型</td>\n<td>Medium</td>\n<td></td>\n<td>2020/6/22</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>15</td>\n<td><a href=\"https://www.lintcode.com/problem/110\" target=\"_blank\" rel=\"noopener\">110-minimum-path-sum</a></td>\n<td>最小路径和</td>\n<td>dp</td>\n<td>Easy</td>\n<td></td>\n<td>2020/6/22</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>16</td>\n<td><a href=\"https://www.lintcode.com/problem/114/\" target=\"_blank\" rel=\"noopener\">114-unique-paths</a></td>\n<td>不同的路径</td>\n<td>dp，坐标型号dp</td>\n<td>Easy</td>\n<td></td>\n<td>2020/6/22</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>17</td>\n<td><a href=\"https://www.lintcode.com/problem/99\" target=\"_blank\" rel=\"noopener\">99-reorder-list</a></td>\n<td>重排链表</td>\n<td>LinkedList</td>\n<td>Medium</td>\n<td></td>\n<td>2020/6/22</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>18</td>\n<td><a href=\"https://www.lintcode.com/problem/174/\" target=\"_blank\" rel=\"noopener\">174-remove-nth-node-from-end-of-list</a></td>\n<td>删除链表中倒数第n个节点</td>\n<td>LinkedList</td>\n<td>Easy</td>\n<td></td>\n<td>2020/6/23</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>19</td>\n<td><a href=\"https://www.lintcode.com/problem/102/\" target=\"_blank\" rel=\"noopener\">102-linked-list-cycle</a></td>\n<td>带环链表</td>\n<td>LinkedList</td>\n<td>Medium</td>\n<td></td>\n<td>2020/6/23</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>20</td>\n<td><a href=\"https://www.lintcode.com/problem/103/\" target=\"_blank\" rel=\"noopener\">103-linked-list-cycle-ii</a></td>\n<td>带环链表 返回环起点值</td>\n<td>LinkedList</td>\n<td>Hard</td>\n<td></td>\n<td>2020/6/23</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>21</td>\n<td><a href=\"https://www.lintcode.com/problem/104/\" target=\"_blank\" rel=\"noopener\">104-merge-k-sorted-lists</a></td>\n<td>合并k个排序链表</td>\n<td>LinkedList</td>\n<td>Medium</td>\n<td></td>\n<td>2020/6/23</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>22</td>\n<td><a href=\"https://www.lintcode.com/problem/105/\" target=\"_blank\" rel=\"noopener\">105-copy-list-with-random-pointer</a></td>\n<td>复制带随机指针的链表</td>\n<td>LinkedList</td>\n<td>Medium</td>\n<td></td>\n<td>2020/6/23</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>23</td>\n<td><a href=\"https://www.lintcode.com/problem/106/\" target=\"_blank\" rel=\"noopener\">106-convert-sorted-list-to-binary-search-tree</a></td>\n<td>有序链表转换为二叉搜索树</td>\n<td>LinkedList</td>\n<td>Medium</td>\n<td></td>\n<td>2020/6/23</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>24</td>\n<td><a href=\"https://www.lintcode.com/problem/177/\" target=\"_blank\" rel=\"noopener\">177-convert-sorted-array-to-binary-search-tree-with-minimal-height</a></td>\n<td>把排序数组转换为高度最小的二叉搜索树</td>\n<td>LinkedList</td>\n<td>Easy</td>\n<td></td>\n<td>2020/6/23</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>25</td>\n<td><a href=\"https://www.lintcode.com/problem/74/\" target=\"_blank\" rel=\"noopener\">74 first-bad-version</a></td>\n<td>第一个错误的代码版本</td>\n<td>binarysearch</td>\n<td>Medium</td>\n<td></td>\n<td>2020/6/24</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>26</td>\n<td><a href=\"https://www.lintcode.com/problem/1496/\" target=\"_blank\" rel=\"noopener\">1496  implement-rand10-using-rand7</a></td>\n<td>用Rand7()实现Rand10()</td>\n<td>simulation</td>\n<td>Medium</td>\n<td></td>\n<td>2020/6/24</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>27</td>\n<td><a href=\"https://www.lintcode.com/problem/66/\" target=\"_blank\" rel=\"noopener\">66  binary-tree-preorder-traversal</a></td>\n<td>二叉树的前序遍历</td>\n<td>Tree，recursion and iteration(Stack)</td>\n<td>Easy</td>\n<td></td>\n<td>2020/6/24</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>28</td>\n<td><a href=\"https://www.lintcode.com/problem/67/\" target=\"_blank\" rel=\"noopener\">67  binary-tree-inorder-traversal</a></td>\n<td>二叉树的中序遍历</td>\n<td>Tree，recursion and iteration(Stack)</td>\n<td>Easy</td>\n<td></td>\n<td>2020/6/24</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>29</td>\n<td><a href=\"https://www.lintcode.com/problem/68/\" target=\"_blank\" rel=\"noopener\">68  binary-tree-postorder-traversal</a></td>\n<td>二叉树的后序遍历</td>\n<td>Tree，recursion and iteration(Stack)</td>\n<td>Easy</td>\n<td></td>\n<td>2020/6/24</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>30</td>\n<td><a href=\"https://www.lintcode.com/problem/86/\" target=\"_blank\" rel=\"noopener\">86  binary-search-tree-iterator</a></td>\n<td>二叉查找树迭代器</td>\n<td>Tree</td>\n<td>Hard</td>\n<td></td>\n<td>2020/6/24</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>31</td>\n<td><a href=\"https://www.lintcode.com/problem/97/\" target=\"_blank\" rel=\"noopener\">97  maximum-depth-of-binary-tree</a></td>\n<td>二叉树的最大深度</td>\n<td>DC</td>\n<td>Easy</td>\n<td></td>\n<td>2020/6/24</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>32</td>\n<td><a href=\"https://www.lintcode.com/problem/93/\" target=\"_blank\" rel=\"noopener\">93  balanced-binary-tree</a></td>\n<td>是否是平衡二叉树</td>\n<td>DC，Recursion</td>\n<td>Easy</td>\n<td></td>\n<td>2020/6/24</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>33</td>\n<td><a href=\"https://www.lintcode.com/problem/31/\" target=\"_blank\" rel=\"noopener\">31  partition-array</a></td>\n<td>数组划分</td>\n<td>Array,Quick Sort，Two Pointer</td>\n<td>Medium</td>\n<td></td>\n<td>2020/6/25</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>34</td>\n<td><a href=\"https://www.lintcode.com/problem/94/\" target=\"_blank\" rel=\"noopener\">94  binary-tree-maximum-path-sum</a></td>\n<td>二叉树中的最大路径和</td>\n<td>DC</td>\n<td>Medium</td>\n<td></td>\n<td>2020/6/25</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>35</td>\n<td><a href=\"https://www.lintcode.com/problem/88/\" target=\"_blank\" rel=\"noopener\">88  lowest-common-ancestor-of-a-binary-tree</a></td>\n<td>最近公共祖先(LCA)</td>\n<td>DC,RE，LCA</td>\n<td>Medium</td>\n<td></td>\n<td>2020/6/25</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>36</td>\n<td><a href=\"https://www.lintcode.com/problem/69/\" target=\"_blank\" rel=\"noopener\">69  binary-tree-level-order-traversal</a></td>\n<td>二叉树的层次遍历</td>\n<td>BFS,Queue</td>\n<td>Easy</td>\n<td></td>\n<td>2020/6/25</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>37</td>\n<td><a href=\"https://www.lintcode.com/problem/70/\" target=\"_blank\" rel=\"noopener\">70  binary-tree-level-order-traversal-ii</a></td>\n<td>二叉树的层次遍历 II</td>\n<td>BFS</td>\n<td>Medium</td>\n<td></td>\n<td>2020/6/25</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>38</td>\n<td><a href=\"https://www.lintcode.com/problem/95/\" target=\"_blank\" rel=\"noopener\">95  validate-binary-search-tree</a></td>\n<td>验证二叉查找树</td>\n<td>traversal</td>\n<td>Medium</td>\n<td></td>\n<td>2020/6/25</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>39</td>\n<td><a href=\"https://www.lintcode.com/problem/85/\" target=\"_blank\" rel=\"noopener\">85  insert-node-in-a-binary-search-tree</a></td>\n<td>在二叉查找树中插入节点</td>\n<td>BST，分治</td>\n<td>Medium</td>\n<td></td>\n<td>2020/6/25</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>40</td>\n<td><a href=\"https://www.lintcode.com/problem/86/\" target=\"_blank\" rel=\"noopener\">86  binary-search-tree-iterator</a></td>\n<td>在二叉查找树中插入节点</td>\n<td>BST，分治</td>\n<td>Hard</td>\n<td></td>\n<td>2020/6/25</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>41</td>\n<td><a href=\"https://www.lintcode.com/problem/87/\" target=\"_blank\" rel=\"noopener\">87  remove-node-in-binary-search-tree</a></td>\n<td>删除二叉查找树的节点</td>\n<td>BST，分治</td>\n<td>Hard</td>\n<td></td>\n<td>2020/6/25</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>42</td>\n<td><a href=\"https://www.lintcode.com/problem/11/\" target=\"_blank\" rel=\"noopener\">11  search-range-in-binary-search-tree</a></td>\n<td>二叉查找树中搜索区间</td>\n<td>tree-traversal</td>\n<td>Medium</td>\n<td></td>\n<td>2020/6/25</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>42</td>\n<td><a href=\"https://www.lintcode.com/problem/12/\" target=\"_blank\" rel=\"noopener\">12  min-stack</a></td>\n<td>最小栈</td>\n<td>stack，Simulation</td>\n<td>Medium</td>\n<td></td>\n<td>2020/6/25</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>43</td>\n<td><a href=\"https://www.lintcode.com/problem/40/\" target=\"_blank\" rel=\"noopener\">40  implement-queue-by-two-stacks</a></td>\n<td>双栈实现队列</td>\n<td>stack，Simulation</td>\n<td>Medium</td>\n<td></td>\n<td>2020/6/25</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>44</td>\n<td><a href=\"https://www.lintcode.com/problem/494/\" target=\"_blank\" rel=\"noopener\">494-implement-stack-by-two-queues</a></td>\n<td>双队列实现栈</td>\n<td>queue</td>\n<td>Medium</td>\n<td></td>\n<td>2020/6/25</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>45</td>\n<td><a href=\"https://www.lintcode.com/problem/130/\" target=\"_blank\" rel=\"noopener\">130  heapify</a></td>\n<td>堆化</td>\n<td>heap</td>\n<td>Medium</td>\n<td></td>\n<td>2020/6/25</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>46</td>\n<td><a href=\"https://www.lintcode.com/problem/158/\" target=\"_blank\" rel=\"noopener\">158  valid-anagram</a></td>\n<td>两个字符串是变位词</td>\n<td>string,map</td>\n<td>Easy</td>\n<td></td>\n<td>2020/6/26</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>47</td>\n<td><a href=\"https://www.lintcode.com/problem/122/\" target=\"_blank\" rel=\"noopener\">122  largest-rectangle-in-histogram</a></td>\n<td>直方图最大矩形覆盖</td>\n<td>monotonic stack</td>\n<td>Hard</td>\n<td></td>\n<td>2020/6/26</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>48</td>\n<td><a href=\"https://www.lintcode.com/problem/126/\" target=\"_blank\" rel=\"noopener\">126-max-tree</a></td>\n<td>最大树</td>\n<td>monotonic stack</td>\n<td>Hard</td>\n<td></td>\n<td>2020/6/26</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>49</td>\n<td><a href=\"https://www.lintcode.com/problem/134/\" target=\"_blank\" rel=\"noopener\">134-lru  cache</a></td>\n<td>LRU缓存策略</td>\n<td>hash</td>\n<td>Hard</td>\n<td></td>\n<td>2020/6/26</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>50</td>\n<td><a href=\"https://www.lintcode.com/problem/24/\" target=\"_blank\" rel=\"noopener\">24-lfu  cache</a></td>\n<td>LFU缓存</td>\n<td>hash</td>\n<td>Hard</td>\n<td></td>\n<td>2020/6/26</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>51</td>\n<td><a href=\"https://www.lintcode.com/problem/129/\" target=\"_blank\" rel=\"noopener\">129-rehashing</a></td>\n<td>重哈希</td>\n<td>hash</td>\n<td>Medium</td>\n<td></td>\n<td>2020/6/26</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>52</td>\n<td><a href=\"https://www.lintcode.com/problem/171/\" target=\"_blank\" rel=\"noopener\">171-anagrams</a></td>\n<td>变位词</td>\n<td>hash</td>\n<td>Medium</td>\n<td></td>\n<td>2020/6/26</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>53</td>\n<td><a href=\"https://www.lintcode.com/problem/138/\" target=\"_blank\" rel=\"noopener\">138-subarray-sum</a></td>\n<td>子数组之和</td>\n<td>hash，前缀和</td>\n<td>Easy</td>\n<td></td>\n<td>2020/6/26</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>54</td>\n<td><a href=\"https://www.lintcode.com/problem/124/\" target=\"_blank\" rel=\"noopener\">124-longest-consecutive-sequence</a></td>\n<td>最长连续序列</td>\n<td>hash</td>\n<td>Medium</td>\n<td></td>\n<td>2020/6/26</td>\n<td>2021/2/13</td>\n<td></td>\n</tr>\n<tr>\n<td>55</td>\n<td><a href=\"https://www.lintcode.com/problem/81/\" target=\"_blank\" rel=\"noopener\">81-find-median-from-data-stream</a></td>\n<td>数据流中位数</td>\n<td>heap</td>\n<td>Hard</td>\n<td></td>\n<td>2020/6/26</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>56</td>\n<td><a href=\"https://www.lintcode.com/problem/132/\" target=\"_blank\" rel=\"noopener\">132-word-search-ii</a></td>\n<td>单词搜索 II</td>\n<td>trie</td>\n<td>Hard</td>\n<td></td>\n<td>2020/6/26</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>57</td>\n<td><a href=\"https://www.lintcode.com/problem/442/\" target=\"_blank\" rel=\"noopener\">442-implement-trie-prefix-tree</a></td>\n<td>实现 Trie（前缀树）</td>\n<td>trie</td>\n<td></td>\n<td></td>\n<td>2020/6/27</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>58</td>\n<td><a href=\"https://www.lintcode.com/problem/61/\" target=\"_blank\" rel=\"noopener\">61-search-for-a-range</a></td>\n<td>搜索区间(对比<a href=\"https://www.lintcode.com/problem/138/\" target=\"_blank\" rel=\"noopener\">138</a>)</td>\n<td>binarysearch</td>\n<td>Medium</td>\n<td></td>\n<td>2020/6/27</td>\n<td>2021/2/13</td>\n<td></td>\n</tr>\n<tr>\n<td>59</td>\n<td><a href=\"https://www.lintcode.com/problem/60/\" target=\"_blank\" rel=\"noopener\">60-search-insert-position</a></td>\n<td>搜索插入位置</td>\n<td>binarysearch</td>\n<td>Easy</td>\n<td></td>\n<td>2020/6/27</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>60</td>\n<td><a href=\"https://www.lintcode.com/problem/28/\" target=\"_blank\" rel=\"noopener\">28-search-a-2d-matrix</a></td>\n<td>搜索二维矩阵</td>\n<td>binarysearch</td>\n<td>Easy</td>\n<td></td>\n<td>2020/6/27</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>61</td>\n<td><a href=\"https://www.lintcode.com/problem/75/\" target=\"_blank\" rel=\"noopener\">75-find-peak-element</a></td>\n<td>寻找峰值</td>\n<td>binarysearch</td>\n<td>Medium</td>\n<td></td>\n<td>2020/6/27</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>62</td>\n<td><a href=\"https://www.lintcode.com/problem/62/\" target=\"_blank\" rel=\"noopener\">62-search-in-rotated-sorted-array(无重复)</a></td>\n<td>搜索旋转排序数组</td>\n<td>binarysearch</td>\n<td>Medium</td>\n<td></td>\n<td>2020/6/27</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>63</td>\n<td><a href=\"https://www.lintcode.com/problem/63/\" target=\"_blank\" rel=\"noopener\">63-search-in-rotated-sorted-array-ii(有重复)</a></td>\n<td>搜索旋转排序数组</td>\n<td>62 follow up</td>\n<td>Medium</td>\n<td></td>\n<td>2020/6/27</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>64</td>\n<td><a href=\"https://www.lintcode.com/problem/6/\" target=\"_blank\" rel=\"noopener\">6-merge-two-sorted-arrays</a></td>\n<td>合并排序数组 II</td>\n<td>Two Pointers</td>\n<td>Easy</td>\n<td></td>\n<td>2020/6/27</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>65</td>\n<td><a href=\"https://www.lintcode.com/problem/64/\" target=\"_blank\" rel=\"noopener\">64-merge-sorted-array</a></td>\n<td>合并排序数组</td>\n<td>Two Pointers</td>\n<td>Easy</td>\n<td></td>\n<td>2020/6/27</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>66</td>\n<td><a href=\"https://www.lintcode.com/problem/159/\" target=\"_blank\" rel=\"noopener\">159-find-minimum-in-rotated-sorted-array</a></td>\n<td>寻找旋转排序数组中的最小值(无重复)</td>\n<td>binarysearch</td>\n<td>Medium</td>\n<td></td>\n<td>2020/6/27</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>67</td>\n<td><a href=\"https://www.lintcode.com/problem/160/\" target=\"_blank\" rel=\"noopener\">160-find-minimum-in-rotated-sorted-array-ii</a></td>\n<td>寻找旋转排序数组中的最小值(有重复)</td>\n<td>binarysearch</td>\n<td>Medium</td>\n<td></td>\n<td>2020/6/27</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>68</td>\n<td><a href=\"https://www.lintcode.com/problem/65/\" target=\"_blank\" rel=\"noopener\">65-median-of-two-sorted-arrays</a></td>\n<td>两个排序数组的中位数</td>\n<td>binarysearch,FindKMax</td>\n<td>Hard</td>\n<td></td>\n<td>2020/6/27</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>69</td>\n<td><a href=\"https://www.lintcode.com/problem/8/\" target=\"_blank\" rel=\"noopener\">8-rotate-string</a></td>\n<td>旋转字符串</td>\n<td>string，simulation，三步翻转法</td>\n<td>Easy</td>\n<td></td>\n<td>2020/6/27</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>70</td>\n<td><a href=\"https://www.lintcode.com/problem/53/\" target=\"_blank\" rel=\"noopener\">53-reverse-words-in-a-string</a></td>\n<td>翻转字符串中的单词</td>\n<td>string</td>\n<td>Easy</td>\n<td></td>\n<td>2020/6/27</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>71</td>\n<td><a href=\"https://www.lintcode.com/problem/241/\" target=\"_blank\" rel=\"noopener\">241-string-to-integer</a></td>\n<td>转换字符串到整数</td>\n<td>string</td>\n<td>Easy</td>\n<td></td>\n<td>2020/6/28</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>72</td>\n<td><a href=\"https://www.lintcode.com/problem/1510/\" target=\"_blank\" rel=\"noopener\">1510-buddy-strings</a></td>\n<td>亲密字符串</td>\n<td>string</td>\n<td>Easy</td>\n<td></td>\n<td>2020/6/28</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>73</td>\n<td><a href=\"https://www.lintcode.com/problem/415/\" target=\"_blank\" rel=\"noopener\">415-valid-palindrome</a></td>\n<td>有效回文串</td>\n<td>string，双指针</td>\n<td>Medium</td>\n<td></td>\n<td>2020/6/28</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>74</td>\n<td><a href=\"https://www.lintcode.com/problem/767/\" target=\"_blank\" rel=\"noopener\">767-reverse-array</a></td>\n<td>翻转数组</td>\n<td>string，reverse</td>\n<td>Easy</td>\n<td></td>\n<td>2020/6/28</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>75</td>\n<td><a href=\"https://www.lintcode.com/problem/1283/\" target=\"_blank\" rel=\"noopener\">1283-reverse-string</a></td>\n<td>翻转字符串</td>\n<td>string，reverse</td>\n<td>Easy</td>\n<td></td>\n<td>2020/6/28</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>76</td>\n<td><a href=\"https://www.lintcode.com/problem/78/\" target=\"_blank\" rel=\"noopener\">78-longest-common-prefix</a></td>\n<td>最长公共前缀 (LCP)</td>\n<td>string。Simulation</td>\n<td>Medium</td>\n<td></td>\n<td>2020/6/28</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>77</td>\n<td><a href=\"https://www.lintcode.com/problem/1263/\" target=\"_blank\" rel=\"noopener\">1263-is-subsequence</a></td>\n<td>是子序列吗</td>\n<td>string，Simulation</td>\n<td>Medium</td>\n<td></td>\n<td>2020/6/28</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>78</td>\n<td><a href=\"https://www.lintcode.com/problem/384/\" target=\"_blank\" rel=\"noopener\">384-longest-substring-without-repeating-characters</a></td>\n<td>最长无重复字符的子串</td>\n<td>string，two pointer</td>\n<td>Medium</td>\n<td></td>\n<td>2020/6/29</td>\n<td>2021/2/14</td>\n<td></td>\n</tr>\n<tr>\n<td>79</td>\n<td><a href=\"https://www.lintcode.com/problem/213/\" target=\"_blank\" rel=\"noopener\">213-string-compression</a></td>\n<td>字符串压缩</td>\n<td>string</td>\n<td>Easy</td>\n<td></td>\n<td>2020/6/29</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>80</td>\n<td><a href=\"https://www.lintcode.com/problem/1352/\" target=\"_blank\" rel=\"noopener\">1352-compare-version-numbers</a></td>\n<td>比较版本号</td>\n<td>string</td>\n<td>Medium</td>\n<td></td>\n<td>2020/6/29</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>81</td>\n<td><a href=\"https://www.lintcode.com/problem/1542/\" target=\"_blank\" rel=\"noopener\">1542-nexttime-norepeat</a></td>\n<td>下一个不重复的时间</td>\n<td>string</td>\n<td>Medium</td>\n<td></td>\n<td>2020/6/29</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>82</td>\n<td><a href=\"https://www.lintcode.com/problem/192/\" target=\"_blank\" rel=\"noopener\">192-wildcard-matching</a></td>\n<td>通配符匹配</td>\n<td>string，DFS</td>\n<td>Hard</td>\n<td></td>\n<td>2020/6/30</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>83</td>\n<td><a href=\"https://www.lintcode.com/problem/98/\" target=\"_blank\" rel=\"noopener\">98-sort-list（排序链表）</a></td>\n<td>链表排序(归并和快速)</td>\n<td>sort</td>\n<td>Medium</td>\n<td></td>\n<td>2020/6/30</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>84</td>\n<td><a href=\"https://www.lintcode.com/problem/463/\" target=\"_blank\" rel=\"noopener\">463-sort-integers</a></td>\n<td>整数排序</td>\n<td>sort【直接选择(选择)，冒泡排序(交换)，直接插入排序(插入)】</td>\n<td>Native</td>\n<td>简单排序</td>\n<td>2020/6/30</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>85</td>\n<td><a href=\"https://www.lintcode.com/problem/464/\" target=\"_blank\" rel=\"noopener\">464-sort-integers-ii </a></td>\n<td>整数排序2</td>\n<td>sort【堆排序(选择)，快排(交换)，归并排序(归并)】</td>\n<td>Medium</td>\n<td>分治排序</td>\n<td>2020/6/30</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>86</td>\n<td><a href=\"https://www.lintcode.com/problem/136/\" target=\"_blank\" rel=\"noopener\">136-palindrome-partitioning</a></td>\n<td>分割回文串</td>\n<td>组合型DFS+Backtracking</td>\n<td>Medium</td>\n<td></td>\n<td>2020/7/1</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>87</td>\n<td><a href=\"https://www.lintcode.com/problem/77/\" target=\"_blank\" rel=\"noopener\">77-longest-common-subsequence</a></td>\n<td>最长公共子序列(LCS)</td>\n<td>match-dp</td>\n<td>Medium</td>\n<td></td>\n<td>2020/7/2</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>88</td>\n<td><a href=\"https://www.lintcode.com/problem/79/\" target=\"_blank\" rel=\"noopener\">79-longest-common-substring</a></td>\n<td>最长公共子串(LCS)</td>\n<td>Two Sequences DP</td>\n<td>Medium</td>\n<td></td>\n<td>2020/7/2</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>89</td>\n<td><a href=\"https://www.lintcode.com/problem/680/\" target=\"_blank\" rel=\"noopener\">680-spilt-string</a></td>\n<td>分割字符串</td>\n<td>组合型DFS+Backtracking</td>\n<td>Medium</td>\n<td></td>\n<td>2020/7/2</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>90</td>\n<td><a href=\"https://www.lintcode.com/problem/15/\" target=\"_blank\" rel=\"noopener\">15-permutations</a></td>\n<td>全排列</td>\n<td>排列型DFS+Backtracking</td>\n<td>Medium</td>\n<td></td>\n<td>2020/7/2</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>91</td>\n<td><a href=\"https://www.lintcode.com/problem/16/\" target=\"_blank\" rel=\"noopener\">16-permutations-ii</a></td>\n<td>全排列</td>\n<td>排列型DFS+Backtracking</td>\n<td>Medium</td>\n<td></td>\n<td>2020/7/2</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>92</td>\n<td><a href=\"https://www.lintcode.com/problem/669/\" target=\"_blank\" rel=\"noopener\">669-coin-change</a></td>\n<td>换硬币</td>\n<td>无限背包,DFS,DP,不用回溯</td>\n<td></td>\n<td></td>\n<td>2020/7/3</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>93</td>\n<td><a href=\"https://www.lintcode.com/problem/816/\" target=\"_blank\" rel=\"noopener\">816-traveling-salesman-problem</a></td>\n<td>旅行商问题</td>\n<td>排列型DFS，pruning,dp,旅行售货员问题，TSP问题，组合优化</td>\n<td>Hard</td>\n<td></td>\n<td>2020/7/3</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>94</td>\n<td><a href=\"https://www.lintcode.com/problem/1147/\" target=\"_blank\" rel=\"noopener\">1147-work-plan</a></td>\n<td>工作安排</td>\n<td>coordinate-dp</td>\n<td>Medium</td>\n<td></td>\n<td>2020/7/3</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>95</td>\n<td><a href=\"https://www.lintcode.com/problem/76/\" target=\"_blank\" rel=\"noopener\">76-longest-increasing-subsequence</a></td>\n<td>最长上升子序列(LIS)</td>\n<td>match-dp，LIS</td>\n<td>Medium</td>\n<td></td>\n<td>2020/7/3</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>96</td>\n<td><a href=\"https://www.lintcode.com/problem/91/\" target=\"_blank\" rel=\"noopener\">91-minimum-adjustment-cost</a></td>\n<td>最小调整代价</td>\n<td>dp</td>\n<td>Medium</td>\n<td></td>\n<td>2020/7/3</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>97</td>\n<td><a href=\"https://www.lintcode.com/problem/34/\" target=\"_blank\" rel=\"noopener\">34-n-queens-ii</a></td>\n<td>N皇后问题（方案数）</td>\n<td>Backtracking+DFS</td>\n<td>Medium</td>\n<td></td>\n<td>2020/7/4</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>98</td>\n<td><a href=\"https://www.lintcode.com/problem/33/\" target=\"_blank\" rel=\"noopener\">33-n-queens</a></td>\n<td>N皇后问题（具体方案）</td>\n<td>Backtracking+DFS</td>\n<td>Medium</td>\n<td></td>\n<td>2020/7/4</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>99</td>\n<td><a href=\"https://www.lintcode.com/problem/622/\" target=\"_blank\" rel=\"noopener\">622-frog-jump</a></td>\n<td>青蛙跳</td>\n<td>DFS，DP</td>\n<td>Hard</td>\n<td></td>\n<td>2020/7/4</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>100</td>\n<td><a href=\"https://www.lintcode.com/problem/602/\" target=\"_blank\" rel=\"noopener\">602-russian-doll-envelopes</a></td>\n<td>俄罗斯套娃信封</td>\n<td>dfs(指数级),dp(正解)</td>\n<td>Hard</td>\n<td></td>\n<td>2020/7/4</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>101</td>\n<td><a href=\"https://www.lintcode.com/problem/116/\" target=\"_blank\" rel=\"noopener\">116-jump-game</a></td>\n<td>跳跃游戏</td>\n<td>单序列dp(可行性)，贪心</td>\n<td>Medium</td>\n<td></td>\n<td>2020/7/4</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>102</td>\n<td><a href=\"https://www.lintcode.com/problem/117/\" target=\"_blank\" rel=\"noopener\">117-jump-game-ii</a></td>\n<td>跳跃游戏</td>\n<td>单序列dp(最小值)</td>\n<td>Medium</td>\n<td></td>\n<td>2020/7/4</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>103</td>\n<td><a href=\"https://www.lintcode.com/problem/149/\" target=\"_blank\" rel=\"noopener\">149-best-time-to-buy-and-sell-stock</a></td>\n<td>买卖股票的最佳时机（一次交易）</td>\n<td>单序列dp(最大值)</td>\n<td>Medium</td>\n<td></td>\n<td>2020/7/4</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>104</td>\n<td><a href=\"https://www.lintcode.com/problem/115/\" target=\"_blank\" rel=\"noopener\">115-unique-paths-ii</a></td>\n<td>不同的路径 II</td>\n<td>坐标DP</td>\n<td>Easy</td>\n<td></td>\n<td>2020/7/4</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>105</td>\n<td><a href=\"https://www.lintcode.com/problem/111/\" target=\"_blank\" rel=\"noopener\">111-climbing-stairs</a></td>\n<td>爬楼梯</td>\n<td>单序列dp(计数问题)</td>\n<td>Easy</td>\n<td></td>\n<td>2020/7/4</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>106</td>\n<td><a href=\"https://www.lintcode.com/problem/563/\" target=\"_blank\" rel=\"noopener\">563-backpack-v</a></td>\n<td>背包问题 V</td>\n<td>Backpack DP</td>\n<td>Medium</td>\n<td></td>\n<td>2020/7/4</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>107</td>\n<td><a href=\"https://www.lintcode.com/problem/630/\" target=\"_blank\" rel=\"noopener\">630-knight-shortest-path-ii</a></td>\n<td>骑士的最短路径II</td>\n<td>坐标dp, 单向BFS-&gt;双向BFS</td>\n<td>Medium</td>\n<td></td>\n<td>2020/7/6</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>108</td>\n<td><a href=\"https://www.lintcode.com/problem/564/\" target=\"_blank\" rel=\"noopener\">564-combination-sum-iv(backpack-vi)</a></td>\n<td>组合总和 IV</td>\n<td>单序列dp，Backpack DP</td>\n<td>Medium</td>\n<td></td>\n<td>2020/7/6</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>109</td>\n<td><a href=\"https://www.lintcode.com/problem/512/\" target=\"_blank\" rel=\"noopener\">512-decode-ways</a></td>\n<td>解码方法</td>\n<td>dp</td>\n<td>Medium</td>\n<td></td>\n<td>2020/7/7</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>110</td>\n<td><a href=\"https://www.lintcode.com/problem/589/\" target=\"_blank\" rel=\"noopener\">589-connecting-graph</a></td>\n<td>连接图</td>\n<td>union-find</td>\n<td>Medium</td>\n<td></td>\n<td>2020/7/7</td>\n<td>2021/2/14</td>\n<td></td>\n</tr>\n<tr>\n<td>111</td>\n<td><a href=\"https://www.lintcode.com/problem/752/\" target=\"_blank\" rel=\"noopener\">752-rogue-knight-sven</a></td>\n<td>流浪剑客斯温</td>\n<td>dp</td>\n<td>Medium</td>\n<td></td>\n<td>2020/7/7</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>112</td>\n<td><a href=\"https://www.lintcode.com/problem/590/\" target=\"_blank\" rel=\"noopener\">590-connecting-graph-ii</a></td>\n<td>连接图</td>\n<td>union-find</td>\n<td>Medium</td>\n<td></td>\n<td>2020/7/8</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>113</td>\n<td><a href=\"https://www.lintcode.com/problem/360/\" target=\"_blank\" rel=\"noopener\">360-sliding-window-median</a></td>\n<td>滑动窗口的中位数</td>\n<td>heap，Sliding Window</td>\n<td>Hard</td>\n<td></td>\n<td>2020/7/8</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>114</td>\n<td><a href=\"https://www.lintcode.com/problem/401/\" target=\"_blank\" rel=\"noopener\">401-kth-smallest-number-in-sorted-matrix</a></td>\n<td>排序矩阵中的从小到大第k个数</td>\n<td>heap</td>\n<td>Medium</td>\n<td></td>\n<td>2020/7/8</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>115</td>\n<td><a href=\"https://www.lintcode.com/problem/362/\" target=\"_blank\" rel=\"noopener\">362-sliding-window-maximum</a></td>\n<td>滑动窗口的最大值</td>\n<td>monotonic-queue</td>\n<td>Hard</td>\n<td></td>\n<td>2020/7/8</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>116</td>\n<td><a href=\"https://www.lintcode.com/problem/178/\" target=\"_blank\" rel=\"noopener\">178-graph-valid-tree</a></td>\n<td>图是否是树</td>\n<td>union-find</td>\n<td>Medium</td>\n<td></td>\n<td>2020/7/8</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>117</td>\n<td><a href=\"https://www.lintcode.com/problem/434/\" target=\"_blank\" rel=\"noopener\">434-number-of-islands-ii</a></td>\n<td>岛屿的个数II</td>\n<td>union-find</td>\n<td>Medium</td>\n<td></td>\n<td>2020/7/9</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>118</td>\n<td><a href=\"https://www.lintcode.com/problem/430/\" target=\"_blank\" rel=\"noopener\">430-scramble-string</a></td>\n<td>攀爬字符串</td>\n<td>dfs+pruning</td>\n<td>Hard</td>\n<td></td>\n<td>2020/7/9</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>119</td>\n<td><a href=\"https://www.lintcode.com/problem/802/\" target=\"_blank\" rel=\"noopener\">802-sudoku-solver</a></td>\n<td>数独</td>\n<td>dfs+pruning+backtracking</td>\n<td>Hard</td>\n<td></td>\n<td>2020/7/10</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>120</td>\n<td><a href=\"https://www.lintcode.com/problem/121/\" target=\"_blank\" rel=\"noopener\">121-word-ladder-ii</a></td>\n<td>单词接龙 II</td>\n<td>dfs+pruning+backtracking</td>\n<td>Hard</td>\n<td></td>\n<td>2020/7/10</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>121</td>\n<td><a href=\"https://www.lintcode.com/problem/582/\" target=\"_blank\" rel=\"noopener\">582-word-break-ii</a></td>\n<td>单词拆分II</td>\n<td>dfs+pruning+backtracking</td>\n<td>Hard</td>\n<td></td>\n<td>2020/7/11</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>122</td>\n<td><a href=\"https://www.lintcode.com/problem/652/\" target=\"_blank\" rel=\"noopener\">652-factorization</a></td>\n<td>因式分解</td>\n<td>dfs+pruning+backtracking</td>\n<td>Medium</td>\n<td></td>\n<td>2020/7/11</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>123</td>\n<td><a href=\"https://www.lintcode.com/problem/119/\" target=\"_blank\" rel=\"noopener\">119-edit-distance</a></td>\n<td>编辑距离</td>\n<td>匹配性dp</td>\n<td>Medium</td>\n<td></td>\n<td>2020/7/11</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>124</td>\n<td><a href=\"https://www.lintcode.com/problem/787/\" target=\"_blank\" rel=\"noopener\">787-the-maze</a></td>\n<td>迷宫</td>\n<td>bfs</td>\n<td>Medium</td>\n<td></td>\n<td>2020/7/11</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>125</td>\n<td><a href=\"https://www.lintcode.com/problem/788/\" target=\"_blank\" rel=\"noopener\">788-the-maze-ii</a></td>\n<td>迷宫</td>\n<td>bfs</td>\n<td>Medium</td>\n<td></td>\n<td>2020/7/11</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>126</td>\n<td><a href=\"https://www.lintcode.com/problem/789/\" target=\"_blank\" rel=\"noopener\">789-the-maze-iii</a></td>\n<td>迷宫</td>\n<td>bfs</td>\n<td>Hard</td>\n<td></td>\n<td>2020/7/11</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>127</td>\n<td><a href=\"https://www.lintcode.com/problem/691/\" target=\"_blank\" rel=\"noopener\">691-recover-binary-search-tree</a></td>\n<td>恢复二叉搜索树</td>\n<td>bst</td>\n<td>Medium</td>\n<td></td>\n<td>2020/7/12</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>128</td>\n<td><a href=\"https://www.lintcode.com/problem/82/\" target=\"_blank\" rel=\"noopener\">82-single-number</a></td>\n<td>落单的数2n*1,两次</td>\n<td>bit，hash</td>\n<td>Easy</td>\n<td></td>\n<td>2020/7/12</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>129</td>\n<td><a href=\"https://www.lintcode.com/problem/83/\" target=\"_blank\" rel=\"noopener\">83-single-number-ii</a></td>\n<td>落单的数 II 3n*1，三次</td>\n<td>bit，hash</td>\n<td>Medium</td>\n<td></td>\n<td>2020/7/12</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>130</td>\n<td><a href=\"https://www.lintcode.com/problem/84/\" target=\"_blank\" rel=\"noopener\">84-single-number-iii</a></td>\n<td>落单的数2*n + 2</td>\n<td>bit，hash</td>\n<td>Medium</td>\n<td></td>\n<td>2020/7/12</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>131</td>\n<td><a href=\"https://www.lintcode.com/problem/46/\" target=\"_blank\" rel=\"noopener\">46-majority-element</a></td>\n<td>主元素(不是众数) 1/2</td>\n<td>Enumerate</td>\n<td>Easy</td>\n<td></td>\n<td>2020/7/12</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>132</td>\n<td><a href=\"https://www.lintcode.com/problem/1018/\" target=\"_blank\" rel=\"noopener\">1018-champagne-tower(triangle)</a></td>\n<td>香槟塔</td>\n<td>二维坐标dp</td>\n<td>Medium</td>\n<td></td>\n<td>2020/7/12</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>133</td>\n<td><a href=\"https://www.lintcode.com/problem/200/\" target=\"_blank\" rel=\"noopener\">200-longest-palindromic-substring</a></td>\n<td>最长回文子串</td>\n<td>区间dp</td>\n<td>Medium</td>\n<td></td>\n<td>2020/7/14</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>134</td>\n<td><a href=\"https://www.lintcode.com/problem/1565/\" target=\"_blank\" rel=\"noopener\">1565-modern-ludo-i</a></td>\n<td>飞行棋 I</td>\n<td>一维坐标dp</td>\n<td>Medium</td>\n<td></td>\n<td>2020/7/16</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>135</td>\n<td><a href=\"https://www.lintcode.com/problem/1141/\" target=\"_blank\" rel=\"noopener\">1141-the-months-days</a></td>\n<td>月份天数</td>\n<td>闰年</td>\n<td>Easy</td>\n<td></td>\n<td>2020/7/16</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>136</td>\n<td><a href=\"https://www.lintcode.com/problem/254/\" target=\"_blank\" rel=\"noopener\">254-drop-eggs</a></td>\n<td>丢鸡蛋</td>\n<td>归纳法</td>\n<td>Easy</td>\n<td></td>\n<td>2020/7/16</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>137</td>\n<td><a href=\"https://www.lintcode.com/problem/47/\" target=\"_blank\" rel=\"noopener\">47-majority-element-ii</a></td>\n<td>主元素1/3</td>\n<td>Enumerate</td>\n<td>Medium</td>\n<td></td>\n<td>2020/7/19</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>138</td>\n<td><a href=\"https://www.lintcode.com/problem/48/\" target=\"_blank\" rel=\"noopener\">48-majority-element-iii</a></td>\n<td>主元素1/k</td>\n<td>HashTable</td>\n<td>Medium</td>\n<td></td>\n<td>2020/7/20</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>139</td>\n<td><a href=\"https://www.lintcode.com/problem/150/\" target=\"_blank\" rel=\"noopener\">150-best-time-to-buy-and-sell-stock-ii</a></td>\n<td>买卖股票的最佳时机 II(多次交易)</td>\n<td>贪心</td>\n<td>Medium</td>\n<td></td>\n<td>2020/7/20</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>140</td>\n<td><a href=\"https://www.lintcode.com/problem/151/\" target=\"_blank\" rel=\"noopener\">151-best-time-to-buy-and-sell-stock-iii</a></td>\n<td>买卖股票的最佳时机 III(两笔交易)</td>\n<td>Enumerate</td>\n<td>Medium</td>\n<td></td>\n<td>2020/7/20</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>141</td>\n<td><a href=\"https://www.lintcode.com/problem/393/\" target=\"_blank\" rel=\"noopener\">393-best-time-to-buy-and-sell-stock-iv</a></td>\n<td>买卖股票的最佳时机 III(K笔交易)</td>\n<td>dp</td>\n<td>Medium</td>\n<td></td>\n<td>2020/7/20</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>142</td>\n<td><a href=\"https://www.lintcode.com/problem/44/\" target=\"_blank\" rel=\"noopener\">44-minimum-subarray</a></td>\n<td>最小子数组</td>\n<td>贪心</td>\n<td>Easy</td>\n<td></td>\n<td>2020/7/20</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>143</td>\n<td><a href=\"https://www.lintcode.com/problem/45/\" target=\"_blank\" rel=\"noopener\">45-maximum-subarray-difference</a></td>\n<td>最大子数组差</td>\n<td>贪心</td>\n<td>Easy</td>\n<td></td>\n<td>2020/7/20</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>144</td>\n<td><a href=\"https://www.lintcode.com/problem/138/\" target=\"_blank\" rel=\"noopener\">138-subarray-sum</a></td>\n<td>子数组之和</td>\n<td>hashmap</td>\n<td>Easy</td>\n<td></td>\n<td>2020/7/20</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>145</td>\n<td><a href=\"https://www.lintcode.com/problem/139/\" target=\"_blank\" rel=\"noopener\">139-subarray-sum-closest</a></td>\n<td>最接近零的子数组和</td>\n<td>Two Pointers，hashmap</td>\n<td>Medium</td>\n<td></td>\n<td>2020/7/20</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>146</td>\n<td><a href=\"https://www.lintcode.com/problem/56/\" target=\"_blank\" rel=\"noopener\">56-two-sum</a></td>\n<td>两数之和</td>\n<td>Two Pointers</td>\n<td>Easy</td>\n<td></td>\n<td>2020/7/20</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>147</td>\n<td><a href=\"https://www.lintcode.com/problem/608/\" target=\"_blank\" rel=\"noopener\">608-two-sum-ii-input-array-is-sorted</a></td>\n<td>两数和 II-输入已排序的数组</td>\n<td>Two Pointers</td>\n<td>Medium</td>\n<td></td>\n<td>2020/7/20</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>148</td>\n<td><a href=\"https://www.lintcode.com/problem/57/\" target=\"_blank\" rel=\"noopener\">57-3sum</a></td>\n<td>三数之和</td>\n<td>Two Pointers</td>\n<td>Medium</td>\n<td></td>\n<td>2020/7/20</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>149</td>\n<td><a href=\"https://www.lintcode.com/problem/533/\" target=\"_blank\" rel=\"noopener\">533-two-sum-closest-to-target</a></td>\n<td>两数和的最接近值</td>\n<td>Two Pointers</td>\n<td>Medium</td>\n<td></td>\n<td>2020/7/20</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>150</td>\n<td><a href=\"https://www.lintcode.com/problem/89/\" target=\"_blank\" rel=\"noopener\">89-k-sum</a></td>\n<td>K数之和</td>\n<td>dp</td>\n<td>Hard</td>\n<td></td>\n<td>2020/7/20</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>151</td>\n<td><a href=\"https://www.lintcode.com/problem/140/\" target=\"_blank\" rel=\"noopener\">140-fast-power</a></td>\n<td>快速幂</td>\n<td>DC</td>\n<td>Medium</td>\n<td></td>\n<td>2020/7/21</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>152</td>\n<td><a href=\"https://www.lintcode.com/problem/1324/\" target=\"_blank\" rel=\"noopener\">1324-count-primes</a></td>\n<td>质数的个数</td>\n<td>Mathmatics</td>\n<td>Easy</td>\n<td></td>\n<td>2020/7/21</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>153</td>\n<td><a href=\"https://www.lintcode.com/problem/141/\" target=\"_blank\" rel=\"noopener\">141-sqrtx</a></td>\n<td>对x开根</td>\n<td>Mathmatics</td>\n<td>Easy</td>\n<td></td>\n<td>2020/7/21</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>154</td>\n<td><a href=\"https://www.lintcode.com/problem/2/\" target=\"_blank\" rel=\"noopener\">2-trailing-zeros</a></td>\n<td>尾部的零</td>\n<td>Mathmatics</td>\n<td>Easy</td>\n<td></td>\n<td>2020/7/21</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>155</td>\n<td><a href=\"https://www.lintcode.com/problem/142/\" target=\"_blank\" rel=\"noopener\">142.o1-check-power-of-2</a></td>\n<td>O(1)时间检测2的幂次</td>\n<td>Binary</td>\n<td>Easy</td>\n<td></td>\n<td>2020/7/21</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>156</td>\n<td><a href=\"https://www.lintcode.com/problem/49/\" target=\"_blank\" rel=\"noopener\">49-sort-letters-by-case</a></td>\n<td>字符大小写排序</td>\n<td>Two Pointers</td>\n<td>Medium</td>\n<td></td>\n<td>2020/7/21</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>157</td>\n<td><a href=\"https://www.lintcode.com/problem/1563/\" target=\"_blank\" rel=\"noopener\">1563-shortest-path-to-the-destination</a></td>\n<td>目的地的最短路径</td>\n<td>bfs</td>\n<td>Medium</td>\n<td></td>\n<td>2020/7/21</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>158</td>\n<td><a href=\"https://www.lintcode.com/problem/108/\" target=\"_blank\" rel=\"noopener\">108-palindrome-partitioning-ii</a></td>\n<td>分割回文串 II</td>\n<td>dp</td>\n<td>Medium</td>\n<td></td>\n<td>2020/8/2</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>159</td>\n<td><a href=\"https://www.lintcode.com/problem/107/\" target=\"_blank\" rel=\"noopener\">107-word-break</a></td>\n<td>单词拆分 I</td>\n<td>dp</td>\n<td>Medium</td>\n<td></td>\n<td>2020/8/2</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>160</td>\n<td><a href=\"https://www.lintcode.com/problem/41/\" target=\"_blank\" rel=\"noopener\">41-maximum-subarray</a></td>\n<td>最大子数组</td>\n<td>dp</td>\n<td>Easy</td>\n<td></td>\n<td>2020/8/3</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>161</td>\n<td><a href=\"https://www.lintcode.com/problem/29/\" target=\"_blank\" rel=\"noopener\">29-interleaving-string</a></td>\n<td>交叉字符串</td>\n<td>dp</td>\n<td>Medium</td>\n<td></td>\n<td>2020/8/9</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>162</td>\n<td><a href=\"https://www.lintcode.com/problem/513/\" target=\"_blank\" rel=\"noopener\">513-perfect-squares</a></td>\n<td>完美平方</td>\n<td>dp</td>\n<td>Medium</td>\n<td></td>\n<td>2020/8/9</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>163</td>\n<td><a href=\"https://www.lintcode.com/problem/394/\" target=\"_blank\" rel=\"noopener\">394-coins-in-a-line</a></td>\n<td>硬币排成线</td>\n<td>dp</td>\n<td>Medium</td>\n<td></td>\n<td>2020/8/9</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>164</td>\n<td><a href=\"https://www.lintcode.com/problem/92/\" target=\"_blank\" rel=\"noopener\">92-backpack</a></td>\n<td>背包问题</td>\n<td>dp</td>\n<td>Medium</td>\n<td></td>\n<td>2020/8/9</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>165</td>\n<td><a href=\"https://www.lintcode.com/problem/118/\" target=\"_blank\" rel=\"noopener\">118-distinct-subsequences</a></td>\n<td>不同的子序列</td>\n<td>dp</td>\n<td>Medium</td>\n<td></td>\n<td>2020/8/9</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>166</td>\n<td><a href=\"https://www.lintcode.com/problem/604/\" target=\"_blank\" rel=\"noopener\">604-window-sum</a></td>\n<td>滑动窗口内数的和</td>\n<td>two-pointer</td>\n<td>Easy</td>\n<td></td>\n<td>2020/8/9</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>167</td>\n<td><a href=\"https://www.lintcode.com/problem/539/\" target=\"_blank\" rel=\"noopener\">539-move-zeroes</a></td>\n<td>移动0</td>\n<td>two-pointer</td>\n<td>Easy</td>\n<td></td>\n<td>2020/8/10</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>168</td>\n<td><a href=\"https://www.lintcode.com/problem/521/\" target=\"_blank\" rel=\"noopener\">521.remove-duplicate-numbers-in-array</a></td>\n<td>数组去重</td>\n<td>two-pointer</td>\n<td>Easy</td>\n<td></td>\n<td>2020/8/10</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>169</td>\n<td><a href=\"https://www.lintcode.com/problem/638/\" target=\"_blank\" rel=\"noopener\">638. Isomorphic Strings</a></td>\n<td>字符同构</td>\n<td>string</td>\n<td>Easy</td>\n<td></td>\n<td>2021/2/10</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>170</td>\n<td><a href=\"https://www.lintcode.com/problem/626/\" target=\"_blank\" rel=\"noopener\">626. Rectangle Overlap</a></td>\n<td>矩形重叠</td>\n<td>string</td>\n<td>Easy</td>\n<td></td>\n<td>2021/2/10</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>171</td>\n<td><a href=\"https://www.lintcode.com/problem/637/\" target=\"_blank\" rel=\"noopener\">637. Valid Word Abbreviation</a></td>\n<td>检查缩写单词</td>\n<td>string</td>\n<td>Easy</td>\n<td></td>\n<td>2021/2/10</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>172</td>\n<td><a href=\"https://www.lintcode.com/problem/639/\" target=\"_blank\" rel=\"noopener\">639. Word Abbreviation</a></td>\n<td>单词缩写</td>\n<td>string</td>\n<td>Hard</td>\n<td></td>\n<td>2021/2/11</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>173</td>\n<td><a href=\"https://www.lintcode.com/problem/642/\" target=\"_blank\" rel=\"noopener\">642. Moving Average from Data Stream</a></td>\n<td>数据流滑动窗口平均值</td>\n<td>Prefix Sum Array，rolling array</td>\n<td>Easy</td>\n<td></td>\n<td>2021/2/11</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>174</td>\n<td><a href=\"https://www.lintcode.com/problem/644/\" target=\"_blank\" rel=\"noopener\">644. Strobogrammatic Number</a></td>\n<td>镜像数字</td>\n<td>Enumerate</td>\n<td>Easy</td>\n<td></td>\n<td>2021/2/11</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>175</td>\n<td><a href=\"https://www.lintcode.com/problem/640/\" target=\"_blank\" rel=\"noopener\">640. One Edit Distance</a></td>\n<td>一次编辑距离</td>\n<td>Enumerate</td>\n<td>Medium</td>\n<td></td>\n<td>2021/2/11</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>176</td>\n<td><a href=\"https://www.lintcode.com/problem/660/\" target=\"_blank\" rel=\"noopener\">660. Read N Characters Given Read4</a></td>\n<td>用Read4从文件中读取N个字符 II-多次调用</td>\n<td>Enumerate</td>\n<td>Hard</td>\n<td></td>\n<td>2021/2/12</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>177</td>\n<td><a href=\"https://www.lintcode.com/problem/659/\" target=\"_blank\" rel=\"noopener\">659. Encode and Decode Strings</a></td>\n<td>编码和解码字符串</td>\n<td>Enumerate</td>\n<td>Medium</td>\n<td></td>\n<td>2021/2/12</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>178</td>\n<td><a href=\"https://www.lintcode.com/problem/419/\" target=\"_blank\" rel=\"noopener\">419. Roman to Integer</a></td>\n<td>罗马数字转整数</td>\n<td>Enumerate</td>\n<td>Medium</td>\n<td></td>\n<td>2021/2/12</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>179</td>\n<td><a href=\"https://www.lintcode.com/problem/418/\" target=\"_blank\" rel=\"noopener\">418. Integer to Roman</a></td>\n<td>整数转罗马数字</td>\n<td>Enumerate</td>\n<td>Medium</td>\n<td></td>\n<td>2021/2/12</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>180</td>\n<td><a href=\"https://www.lintcode.com/problem/645/\" target=\"_blank\" rel=\"noopener\">645. Find the Celebrity</a></td>\n<td>识别名人</td>\n<td>Enumerate</td>\n<td>Medium</td>\n<td></td>\n<td>2021/2/12</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>181</td>\n<td><a href=\"https://www.lintcode.com/problem/641/\" target=\"_blank\" rel=\"noopener\">641. Missing Ranges</a></td>\n<td>丢失的间隔</td>\n<td>Enumerate</td>\n<td>Medium</td>\n<td></td>\n<td>2021/2/12</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>182</td>\n<td><a href=\"https://www.lintcode.com/problem/156/\" target=\"_blank\" rel=\"noopener\">156. Merge Intervals</a></td>\n<td>合并区间</td>\n<td>Enumerate</td>\n<td>Easy</td>\n<td></td>\n<td>2021/2/12</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>183</td>\n<td><a href=\"https://www.lintcode.com/problem/30/\" target=\"_blank\" rel=\"noopener\">30. Insert Interval</a></td>\n<td>插入区间</td>\n<td>Enumerate</td>\n<td>Medium</td>\n<td></td>\n<td>2021/2/12</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>184</td>\n<td><a href=\"https://www.lintcode.com/problem/646/\" target=\"_blank\" rel=\"noopener\">646. First Position Unique Character</a></td>\n<td>第一个不重复字符位置</td>\n<td>Hash</td>\n<td>Easy</td>\n<td></td>\n<td>2021/2/12</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>185</td>\n<td><a href=\"https://www.lintcode.com/problem/647/\" target=\"_blank\" rel=\"noopener\">647. Find All Anagrams in a String</a></td>\n<td>子串字谜</td>\n<td>Hash+Siding Windows</td>\n<td>Medium</td>\n<td></td>\n<td>2021/2/12</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>186</td>\n<td><a href=\"https://www.lintcode.com/problem/423/\" target=\"_blank\" rel=\"noopener\">423. Valid Parentheses</a></td>\n<td>有效的括号序列</td>\n<td>Stack</td>\n<td>Easy</td>\n<td></td>\n<td>2021/2/13</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>187</td>\n<td><a href=\"https://www.jiuzhang.com/problem/load-balancer/\" target=\"_blank\" rel=\"noopener\">526. Load Balancer</a></td>\n<td>负载均衡</td>\n<td>DS</td>\n<td></td>\n<td></td>\n<td>2021/2/13</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>188</td>\n<td><a href=\"https://www.lintcode.com/problem/662/\" target=\"_blank\" rel=\"noopener\">662. Guess Number Higher or Lower</a></td>\n<td>猜数游戏</td>\n<td>Binary Search</td>\n<td>Easy</td>\n<td></td>\n<td>2021/2/13</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>189</td>\n<td><a href=\"https://www.lintcode.com/problem/661/\" target=\"_blank\" rel=\"noopener\">661. Convert BST to Greater Tree</a></td>\n<td>把二叉搜索树转化成更大的树</td>\n<td>BST</td>\n<td>Easy</td>\n<td></td>\n<td>2021/2/13</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>190</td>\n<td><a href=\"https://www.lintcode.com/problem/649/\" target=\"_blank\" rel=\"noopener\">649. Binary Tree Upside Down</a></td>\n<td>二叉树翻转</td>\n<td>BST</td>\n<td>Medium</td>\n<td></td>\n<td>2021/2/13</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>191</td>\n<td><a href=\"https://www.lintcode.com/problem/650/\" target=\"_blank\" rel=\"noopener\">650. Find Leaves of Binary Tree</a></td>\n<td>二叉树叶子顺序遍历</td>\n<td>BST</td>\n<td>Medium</td>\n<td></td>\n<td>2021/2/13</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>192</td>\n<td><a href=\"https://www.lintcode.com/problem/651/\" target=\"_blank\" rel=\"noopener\">651. Binary Tree Vertical Order Traversal</a></td>\n<td>二叉树垂直遍历</td>\n<td>Hash+BFS</td>\n<td>Medium</td>\n<td></td>\n<td>2021/2/13</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>193</td>\n<td><a href=\"https://www.lintcode.com/problem/448/\" target=\"_blank\" rel=\"noopener\">448. Inorder Successor in BST</a></td>\n<td>二叉查找树的中序后继</td>\n<td>BST</td>\n<td>Medium</td>\n<td></td>\n<td>2021/2/13</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>194</td>\n<td><a href=\"https://www.lintcode.com/problem/477/\" target=\"_blank\" rel=\"noopener\">477. Surrounded Regions</a></td>\n<td>被围绕的区域</td>\n<td>BFS</td>\n<td>Medium</td>\n<td></td>\n<td>2021/2/13</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>195</td>\n<td><a href=\"https://www.lintcode.com/problem/663/\" target=\"_blank\" rel=\"noopener\">663. Walls and Gates</a></td>\n<td>墙和门</td>\n<td>BFS</td>\n<td>Medium</td>\n<td></td>\n<td>2021/2/13</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>196</td>\n<td><a href=\"https://www.lintcode.com/problem/32/\" target=\"_blank\" rel=\"noopener\">32. Minimum Window Substring</a></td>\n<td>最小子串覆盖</td>\n<td>Two pointer</td>\n<td>Medium</td>\n<td></td>\n<td>2021/2/14</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>197</td>\n<td><a href=\"https://www.lintcode.com/problem/543/\" target=\"_blank\" rel=\"noopener\">543. Kth Largest in N Arrays</a></td>\n<td>N数组第K大元素(一个数组第<a href=\"https://www.lintcode.com/problem/5/\" target=\"_blank\" rel=\"noopener\">K大</a>)</td>\n<td>Heap</td>\n<td>Hard</td>\n<td></td>\n<td>2021/2/14</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>198</td>\n<td><a href=\"https://www.lintcode.com/problem/465/\" target=\"_blank\" rel=\"noopener\">465. Kth Smallest Sum In Two Sorted Arrays</a></td>\n<td>两个排序数组和的第K小</td>\n<td>Heap</td>\n<td>Hard</td>\n<td></td>\n<td>2021/2/14</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>199</td>\n<td><a href=\"https://www.lintcode.com/problem/591/\" target=\"_blank\" rel=\"noopener\">591. Connecting Graph III</a></td>\n<td>连接图 III</td>\n<td>UF</td>\n<td>Medium</td>\n<td></td>\n<td>2021/2/14</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>200</td>\n<td><a href=\"https://www.lintcode.com/problem/1179/\" target=\"_blank\" rel=\"noopener\">1179. Friend Circles</a></td>\n<td>朋友圈</td>\n<td>UF</td>\n<td>Medium</td>\n<td></td>\n<td>2021/2/14</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>201</td>\n<td><a href=\"https://www.lintcode.com/problem/152/\" target=\"_blank\" rel=\"noopener\">152. Combinations</a></td>\n<td>组合</td>\n<td>DFS，组合</td>\n<td>Medium</td>\n<td></td>\n<td>2021/2/15</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>202</td>\n<td><a href=\"https://www.lintcode.com/problem/135/\" target=\"_blank\" rel=\"noopener\">135. Combination Sum I</a></td>\n<td>组合数之和</td>\n<td>DFS，组合</td>\n<td>Medium</td>\n<td></td>\n<td>2021/2/15</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>203</td>\n<td><a href=\"https://www.lintcode.com/problem/153/\" target=\"_blank\" rel=\"noopener\">153. Combination Sum II</a></td>\n<td>组合数之和</td>\n<td>DFS，组合</td>\n<td>Medium</td>\n<td></td>\n<td>2021/2/15</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>204</td>\n<td><a href=\"https://www.lintcode.com/problem/1321/\" target=\"_blank\" rel=\"noopener\">1321. Combination Sum III</a></td>\n<td>组合数之和</td>\n<td>DFS，组合</td>\n<td>Medium</td>\n<td></td>\n<td>2021/2/15</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>205</td>\n<td><a href=\"https://www.lintcode.com/problem/457/\" target=\"_blank\" rel=\"noopener\">457. Classical Binary Search</a></td>\n<td>经典二分查找问题</td>\n<td>Binary Search</td>\n<td>Easy</td>\n<td></td>\n<td>2021/2/15</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>206</td>\n<td><a href=\"https://www.lintcode.com/problem/366/\" target=\"_blank\" rel=\"noopener\">366. Fibonacci</a></td>\n<td>斐波那契</td>\n<td>iteration/recursion,多项公式</td>\n<td>Naive</td>\n<td></td>\n<td>2021/2/16</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>207</td>\n<td><a href=\"https://www.lintcode.com/problem/1807/\" target=\"_blank\" rel=\"noopener\">1807. Fibonacci easy</a></td>\n<td>斐波那契</td>\n<td>iteration</td>\n<td>Easy</td>\n<td></td>\n<td>2021/2/16</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>208</td>\n<td><a href=\"https://www.lintcode.com/problem/powx-n/\" target=\"_blank\" rel=\"noopener\">428. Pow(x, n)</a></td>\n<td>x的n次幂</td>\n<td>recursion,decrease-and-conquer</td>\n<td>Medium</td>\n<td></td>\n<td>2021/2/16</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>209</td>\n<td><a href=\"https://www.lintcode.com/problem/451/\" target=\"_blank\" rel=\"noopener\">451. Swap Nodes in Pairs</a></td>\n<td>两两交换链表中的节点</td>\n<td></td>\n<td></td>\n<td></td>\n<td>2021/2/16</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>210</td>\n<td><a href=\"https://www.lintcode.com/problem/450/\" target=\"_blank\" rel=\"noopener\">450. Reverse Nodes in k-Group</a></td>\n<td>K组翻转链表</td>\n<td></td>\n<td></td>\n<td></td>\n<td>2021/2/16</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>211</td>\n<td><a href=\"https://www.lintcode.com/problem/1425/\" target=\"_blank\" rel=\"noopener\">1425. Backspace String Compare</a></td>\n<td>比较含退格的字符串</td>\n<td></td>\n<td></td>\n<td></td>\n<td>2021/2/16</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>212</td>\n<td><a href=\"https://www.lintcode.com/problem/5/\" target=\"_blank\" rel=\"noopener\">5.Kth Largest Element</a></td>\n<td>数组第k大元素</td>\n<td></td>\n<td></td>\n<td></td>\n<td>2021/2/16</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>213</td>\n<td><a href=\"https://www.lintcode.com/problem/471/\" target=\"_blank\" rel=\"noopener\">471. Top K Frequent Words</a></td>\n<td>最高频的K个单词</td>\n<td></td>\n<td></td>\n<td></td>\n<td>2021/2/16</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>214</td>\n<td><a href=\"https://www.lintcode.com/problem/1311/\" target=\"_blank\" rel=\"noopener\">1311. Lowest Common Ancestor of a Binary Search Tree</a></td>\n<td>二叉搜索树的最近公共祖先</td>\n<td></td>\n<td>Easy</td>\n<td></td>\n<td>2021/2/16</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>215</td>\n<td><a href=\"https://www.lintcode.com/problem/1509/\" target=\"_blank\" rel=\"noopener\">1509. Lemonade Change</a></td>\n<td>柠檬水找零</td>\n<td>Greedy</td>\n<td>Easy</td>\n<td></td>\n<td>2021/2/16</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>216</td>\n<td><a href=\"https://www.lintcode.com/problem/1230/\" target=\"_blank\" rel=\"noopener\">1230. Assign Cookies</a></td>\n<td>分饼干</td>\n<td>Greedy</td>\n<td>Easy</td>\n<td></td>\n<td>2021/2/16</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>217</td>\n<td><a href=\"https://www.lintcode.com/problem/1493/\" target=\"_blank\" rel=\"noopener\">1493. Walking Robot Simulation</a></td>\n<td>模拟行走机器人</td>\n<td>Greedy</td>\n<td></td>\n<td></td>\n<td>2021/2/16</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>218</td>\n<td><a href=\"https://www.lintcode.com/problem/155/\" target=\"_blank\" rel=\"noopener\">155. Minimum Depth of Binary Tree</a></td>\n<td>二叉树的最小深度</td>\n<td></td>\n<td></td>\n<td></td>\n<td>2021/2/16</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>219</td>\n<td><a href=\"https://www.lintcode.com/problem/1360/\" target=\"_blank\" rel=\"noopener\">1360. Symmetric Tree</a></td>\n<td>对称树</td>\n<td></td>\n<td></td>\n<td></td>\n<td>2021/2/16</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>220</td>\n<td><a href=\"https://www.lintcode.com/problem/1244/\" target=\"_blank\" rel=\"noopener\">1244. Minimum Genetic Mutation</a></td>\n<td>最小基因变化</td>\n<td></td>\n<td></td>\n<td></td>\n<td>2021/2/16</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>221</td>\n<td><a href=\"https://www.lintcode.com/problem/427/\" target=\"_blank\" rel=\"noopener\">427. Generate Parentheses</a></td>\n<td>生成括号</td>\n<td></td>\n<td></td>\n<td></td>\n<td>2021/2/16</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>222</td>\n<td><a href=\"https://www.lintcode.com/problem/1195/\" target=\"_blank\" rel=\"noopener\">1195. Find Largest Value in Each Tree Row</a></td>\n<td>找出树中每行的最大值</td>\n<td></td>\n<td>Medium</td>\n<td></td>\n<td>2021/2/16</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>223</td>\n<td><a href=\"https://www.lintcode.com/problem/120/\" target=\"_blank\" rel=\"noopener\">120. Word Ladder</a></td>\n<td>单词接龙</td>\n<td></td>\n<td></td>\n<td></td>\n<td>2021/2/16</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>224</td>\n<td><a href=\"https://www.lintcode.com/problem/615/\" target=\"_blank\" rel=\"noopener\">615. Course Schedule</a></td>\n<td>课程表</td>\n<td></td>\n<td></td>\n<td></td>\n<td>2021/2/16</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>225</td>\n<td><a href=\"https://www.lintcode.com/problem/1189/\" target=\"_blank\" rel=\"noopener\">1189. Minesweeper</a></td>\n<td>扫雷游戏</td>\n<td>BFS</td>\n<td>Medium</td>\n<td></td>\n<td>2021/2/16</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>226</td>\n<td><a href=\"https://www.lintcode.com/problem/389/\" target=\"_blank\" rel=\"noopener\">389. Valid Sudoku</a></td>\n<td>判断数独是否合法</td>\n<td>Simulation</td>\n<td>Easy</td>\n<td></td>\n<td>2021/2/16</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>227</td>\n<td><a href=\"https://www.lintcode.com/problem/123/\" target=\"_blank\" rel=\"noopener\">123. Word Search</a></td>\n<td>单词搜索</td>\n<td>DFS</td>\n<td>Medium</td>\n<td></td>\n<td>2021/2/16</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>228</td>\n<td><a href=\"https://www.lintcode.com/problem/664/\" target=\"_blank\" rel=\"noopener\">664. Counting Bits</a></td>\n<td>数 1</td>\n<td>Bit，DP</td>\n<td>Medium</td>\n<td></td>\n<td>2021/2/16</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>229</td>\n<td><a href=\"https://www.lintcode.com/problem/maximum-product-subarray/\" target=\"_blank\" rel=\"noopener\">191. Maximum Product Subarray</a></td>\n<td>乘积最大子序列</td>\n<td>线性dp</td>\n<td>Medium</td>\n<td></td>\n<td>2021/2/16</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>230</td>\n<td><a href=\"https://www.lintcode.com/problem/556/\" target=\"_blank\" rel=\"noopener\">556. Standard Bloom Filter</a></td>\n<td>标准型布隆过滤器</td>\n<td></td>\n<td>Medium</td>\n<td></td>\n<td>2021/2/16</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>231</td>\n<td><a href=\"https://www.lintcode.com/problem/555/\" target=\"_blank\" rel=\"noopener\">555. Counting Bloom Filter</a></td>\n<td>计数型布隆过滤器</td>\n<td></td>\n<td>Medium</td>\n<td></td>\n<td>2021/2/16</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>232</td>\n<td><a href=\"https://www.lintcode.com/problem/1332/\" target=\"_blank\" rel=\"noopener\">1332. Number of 1 Bits</a></td>\n<td>判断一个整数中有多少个1</td>\n<td>Bit</td>\n<td>Easy</td>\n<td></td>\n<td>2021/2/16</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>233</td>\n<td><a href=\"https://www.lintcode.com/problem/204/\" target=\"_blank\" rel=\"noopener\">204. Singleton</a></td>\n<td>单例</td>\n<td>OOD</td>\n<td>Easy</td>\n<td></td>\n<td>2021/2/16</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>234</td>\n<td><a href=\"https://www.lintcode.com/problem/496/\" target=\"_blank\" rel=\"noopener\">496. Toy Factory</a></td>\n<td>工厂</td>\n<td>OOD</td>\n<td>Easy</td>\n<td></td>\n<td>2021/2/16</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td>235</td>\n<td><a href=\"https://www.lintcode.com/problem/175/\" target=\"_blank\" rel=\"noopener\">175. Invert Binary Tree</a></td>\n<td>反转二叉树</td>\n<td>Tree</td>\n<td>Easy</td>\n<td></td>\n<td>2021/2/16</td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n<tr>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n<td></td>\n</tr>\n</tbody></table>\n"},{"title":"持续集成之实践单元测试","date":"2020-12-01T17:13:05.000Z","_content":"\n\n\n# 绪论\n\n**单元测试**是保证质量，降低风险的一种重要工具。但是独立的单元测试本身意义不大，但是整合在CI使之成为**自动化测试**中就会体现其价值，这是一个价值流的传递过程，每一个过程传递软件质量和风险的信息。高质量的代码是**CLEAN**的并且**易测试**的，C(Cohesive内聚)，L(Loosely Couped松散耦合) E(Encapsulated 封装) Assertive(自主) Nonredundant(无冗余)，但是单元测试又是怎么影响这些特性的呢？\n\n**Design**：如果我的代码很难测试，那么对客户端来说设计不佳。\n\n**Cohesive**：如果需要为一个类编写很多测试，就会意识到内聚性不足。\n\n**Loosely Couped**：如果我的测试有很多无关的依赖，那么一定是耦合过多了。 \n\n**Encapsulated**：如果我的测试依赖于实现细节，那么肯定是封装出现了问题。\n\n**Assertive**：如果测试结果在被测对象以外对象中体现，我的对象可能不够自主。\n\n**Nonredundant**：如果我一遍一遍编写同样的测试，那肯定出现了冗余。\n\n\n\n一个常规的CI流程如下：\n\n<img src=\"/images/CI.png\" style=\"zoom:80%;\" />\n\n从编译源码-》持续集成数据库-》持续测试-》持续审查-》持续部署-》持续反馈，我们在编译源码和持续部署做的很好，但是在改进质量并降低风险的**持续测试**和**持续审查**做的不好，导致软件质量差，代码烂，重复率高。本文主要对持续测试中的单元测试作为实战基础来讲解一个例子，因为这是一个起点，虽然单独通过**持续审查**也能提高质量，但是由于业务压力和人员变更使得代码变乱，光靠审查无法为迭代的业务提供持续的重构保证，也无法自动化基础设施。\n\n\n\n# 实战案例\n\n## 基础框架\n\n单元测试框架[junit5](https://junit.org/junit5/)，mock框架[mockito](https://site.mockito.org/)，断言框架[assertj](https://joel-costigliola.github.io/assertj/ ) \n\n\n\n## 案例一:使用Mock取代依赖\n\n以下这段代码即调用了Redis，也调用了第三方接口，还调用了数据库，是一个比较综合的案例，我们来一起看看如何将他变成方便测试的代码，并且保证如何通过单元测试达到覆盖率。\n\n```java\npublic class TaskCenterWithdrawServiceImpl implements TaskCenterWithdrawService {\n    @Autowired\n    private HttpEncryptDecryptEngine remote;//调用第三方\n    @Autowired\n    private WithdrawService withdrawService;//关联DB\n   \n    public void startWithdraw(String coinSymbol, String walletSymbol, String appId,\n                              TransactionWithdrawCrypto twc) {\n        \n        TransactionWithdrawCrypto withdrawCrypto = withdrawService.selectByIdAndLock(twc.getId());//查询数据库\n        String payload = generateWithdrawRequest(coinSymbol, walletSymbol, withdrawCrypto);//构造请求参数，里面查询静态方法\n        String result = remote.startWithdraw(appId, payload);//调用第三方接口返回结果\n        WalletResponseCode responseCode = WalletResponseCode.ofCode(result);\n        switch (responseCode) {\n            case SUCCESS:\n                break;\n            case WITHDRAW_ADDR_ERROR:\n            case WITHDRAW_CANNOT_TO_SELF: {\n                try {\n                    withdrawService.cancelWithdraw();\n                } catch (Exception e) {\n                    log.error(\"startWithdrawRequest cancel withdrawCrypto id : {} error \",\n                              withdrawCrypto.getId(), e);\n                }\n                break;\n            }   \n            default:                \n                cancelWithdrawIfAdminConfiged(withdrawCrypto.getId(), responseCode);\n                break;\n          \n    }\n```\n\n\n\n```java\nprivate String generateWithdrawRequest(String coinSymbol, String walletSymbol,\n                                       TransactionWithdrawCrypto c) {\n   \n    //......里面查询了redis\n    ConfigCoinSymbol c = CoinSymbolUtils.getSaaSInfo(coinSymbol);\n    //......\n    return ....;\n}\n```\n\n\n\n我们看到这个代码，需要思考测试什么才能证明代码没有错呢？既当什么情况下，你期望发生什么。来看看我们得期望：\n\n1   当第三方接口返回成功时候，该方法结束。\n\n2   当第三方接口返回WITHDRAW_ADDR_ERROR或者WITHDRAW_CANNOT_TO_SELF，我们需要调用cancelWithdraw，\n\n3   当第三方接口返回其他情况时候，调用cancelWithdrawIfAdminConfiged方法。\n\n4   当传入不同币种的时候，generateWithdrawRequest产生不同的请求。\n\n我们仅仅需要验证这些就够了，因为TaskCenterWithdrawServiceImpl得协作者的产生的行为仅仅如此，至于协作者行为的可靠性，需要协作者自身去验证，而不是在该测试中验证。\n\n### 第一步 依赖注入解耦\n\nspring字段注入导致单元测试困难，因为你无法实例化类中的对象，所以在TaskCenterWithdrawServiceImpl中将字段注入改成构造器注入或者属性注入。\n\n```java\npublic class TaskCenterWithdrawServiceImpl {\n\n    private HttpEncryptDecryptEngine httpEncryptDecryptEngine;\n\n    private WithdrawService withdrawService;\n\n    @Autowired\n    public void setHttpEncryptDecryptEngine(HttpEncryptDecryptEngine httpEncryptDecryptEngine) {\n        this.httpEncryptDecryptEngine = httpEncryptDecryptEngine;\n    }\n\n    @Autowired\n    public void setWithdrawService(WithdrawService withdrawService) {\n        this.withdrawService = withdrawService;\n    }\n\n```\n\n\n### 第二步 静态方法抽离接口\n\n不是所有静态方法都需要抽离成接口，由于项目中CoinSymbolUtils.getSaaSInfo调用了数据库和redis，所以此时你无法真实调用数据库和redis，因为在脱离spring环境你无法创建这两个对象，所以抽离成接口可以mock改接口。如果是普通的工具类，让他执行即可。\n\n```java\npublic interface CoinSymbolOperator {\n    ConfigCoinSymbol getSaaSInfoAll(String coinSymbol);\n}\n```\n\n之前工具类实现该接口，并且调用之前静态方法。\n\n```java\n@Component\npublic class CoinSymbolUtils implements  CoinSymbolOperator {\n\n   public ConfigCoinSymbol getSaaSInfoAll(String coinSymbol) {\n        return getSaaSInfo(coinSymbol);\n   }\n}\n```\n\n\n\n### 第三步 测试mock对象\n\nmock对象我们使用的是**mockito**框架。\n\n```java\npublic class TaskCenterWithdrawServiceMockTest {\n    //待测试的类\n    private TaskCenterWithdrawServiceImpl taskCenterWithdrawService;\n\n    private HttpEncryptDecryptEngine httpEncryptDecryptEngine;\n\n    private WithdrawService withdrawService;\n\n    private CoinSymbolOperator coinSymbolOperator;\n\n@Before\npublic void setup() {\n    //创建TaskCenterWithdrawService对象\n    httpEncryptDecryptEngine = mock(HttpEncryptDecryptEngine.class);\n    withdrawService = mock(WithdrawService.class);\n    //mock静态方法拆离的接口在这里需要注入到TaskCenterWithdrawService中\n    coinSymbolOperator = mock(CoinSymbolOperator.class);\n    taskCenterWithdrawService = new new TaskCenterWithdrawServiceImpl();\n    taskCenterWithdrawService.setHttpEncryptDecryptEngine(httpEncryptDecryptEngine);\n    taskCenterWithdrawService.setWithdrawService(withdrawService);\n    taskCenterWithdrawService.setCoinSymbolOperator(coinSymbolOperator);\n}\n    \n```\n\n   \n\n### 第四步 编写测试方法\n\n测试方法必须要写assertions和你要验证的东西，否则这个单元测试没有意义。这个测试没有用到**assertj**  ，而是使用了**mockito**自带的verify方法验证。\n\n```java\n@Test\npublic void startWithdraw() { \n    //given willReturn 短语帮助我们构造期望的输入和输出，含义是当满足xxx条件时候，发生什么，期望什么结果。\n    //当给getWalletUid传入任意int和string时候，调用cryptoAddressService.getWalletUid，期望返回123\n    given(cryptoAddressService.getWalletUid(anyInt(), anyString())).willReturn(123);\n\n    //构造期望的返回值\n    TransactionWithdrawCrypto transactionWithdrawCrypto = new TransactionWithdrawCrypto();\n    transactionWithdrawCrypto.setAddressFrom(\"alibaba\");\n    transactionWithdrawCrypto.setFee(new BigDecimal(\"456.777\"));\n    transactionWithdrawCrypto.setSymbol(\"USDT\");\n    transactionWithdrawCrypto.setAddressTo(\"baidu\");\n    transactionWithdrawCrypto.setUid(111111111);\n\n    transactionWithdrawCrypto.setAmount(new BigDecimal(\"123.444\"));\n    //构造期望输入和输出\n    given(withdrawService.selectByIdAndLock(anyInt())).willReturn(transactionWithdrawCrypto);\n\n    ConfigCoinSymbol ccs = new ConfigCoinSymbol();\n    ccs.setTokenBase(\"BTC\");\n    ccs.setContractAddress(\"BTC_ContractAddress\");\n    //构造期望输入和输出\n    given(coinSymbolOperator.from(\"USDT\")).willReturn(ccs);\n\n    Map<String,String> result = new HashMap<>();\n    result.put(\"code\", WalletResponseCode.SUCCESS.getCode());\n    result.put(\"message\", WalletResponseCode.SUCCESS.getMessage());\n    //构造期望输入和输出\n    given(httpEncryptDecryptEngine.startWithdraw(anyString(), anyString())).willReturn(JSON.toJSONString(result));\n\n    //和given，willReturn一样的效果\n    //when(httpEncryptDecryptEngine.startWithdraw(anyString(), anyString())).thenReturn(\"111111111\");\n\n    //这一步是将之前mock的对象和数据以及构造期望输入和输出串联起来执行。\n    taskCenterWithdrawService.startWithdraw(\"USDT\", \"BTC\", \"aaaa\", new TransactionWithdrawCrypto());\n\n    //由于该方法是void所以需要验证方法是否被调用.比如断言getWalletUid是否被调用，比如第三方接口返回值不同调用不同的方法\n    //来使得代码覆盖率比较高\n    verify(this.cryptoAddressService).getWalletUid(111111111, \"BTC\");\n}\n```\n\n\n\n## 案例二：关联数据库的单元测试\n\n有些测试必须关联数据库或者第三方接口，此时不得不接受使用外部资源这一现实。这时候测试关联数据库的必须保证测试前数据库状态和测试后状态一致。我们来建立一个test fixture来验证一个CRUD的正确性。在每个方法执行前用@BeforeEach中建立Account对象，在integrateTestDataBaseCRUD中测试CRUD方法，在每个方法结束后用@AfterEach清除数据库对象，使得测试前后数据库状态幂等。我曾经遇到一个必须使用第三方资源场景是 本地代码必须调用第三方接口来验证程序，以及在集成测试时候，也主要验证第三方接口，程序本身逻辑很少。这时候就必须使用外部依赖来完成单元测试。\n\n```java\npublic class AccountServiceTest {\n    @Autowired\n    private AccountService accountService;\n    private Account account;\n\n    @BeforeEach\n    void setUp() {\n        account = Account.builder().\n                balance(new BigDecimal(\"67.88\")).\n                type(111).\n                uid(445).\n                tag(\"33\").\n                build();\n    }\n\n    @Test\n    public void integrateTestDataBaseCRUD() {\n        accountService.insert(account);\n        long id = account.getId();\n        Account accountFind = accountService.get(id);\n        accountFind.setBalance(new BigDecimal(\"366334\"));\n        accountService.update(accountFind);\n        Account accountUpdate = accountService.get(id);\n        accountService.delete(id);\n        Account accountDelete = accountService.get(id);\n\n        assertAll(\"test\", () -> {\n            assertEquals(accountFind.getBalance().stripTrailingZeros().toPlainString(),\n                    accountUpdate.getBalance().stripTrailingZeros().toPlainString());\n        });\n        assertNull(accountDelete);\n    }\n\n    @AfterEach\n    void tearDown() {\n        accountService.delete(id);\n    }\n}\n```\n\n\n\n我们可以看到上述两个案例都是先写代码后写单元测试，这样可能导致单元测试很难测试代码，给遗留系统添加单元测试也很繁琐，所以需要从设计层面改进代码，使之更加容易测试和验证。更优秀的做法是实践TDD，这样代码天然可测试。\n\n\n\n# 常见问题\n\n**1 单元测试的价值在哪里？** 1  保证代码质量，当然质量保证不仅仅靠单元测试。当你看到队友提交了一些代码，确发现单元测试覆盖率降低了，就知道他的提交可能带来代码质量下降。 2  代码可测试性往往带来灵活的设计。  3  你不仅仅在写单元测试，而是实践自动化测试，实践着CI \n\n**2  遗留系统很多没有单元测试，我需要补吗？**1  当你修改老代码的时候，加一个单元测试。 2 依赖最多的，访问最多的需要补充。 3 试图在遗留系统上加单元测试很困难，并且使之成为自动化测试，但是需要尝试，新的代码尝试TDD。\n\n**3  我觉得有些情况需要读取数据库，看到数据落库心里才踏实，这时候写单元测试需要连数据库吗？**单元测试不连库，连库的叫集成测试，单元测试验证是逻辑，数据库只是细节实现，你的代码可以脱离SSM，MySQL..... 在实践中你会真正理解解耦的。你的踏实和自信应该建立在独立性和不依赖外界细节上，而不是数据归属地到底是哪里。如果一些测试必须要用数据库，请使用test fixture。保证单元测试前和单元测试后数据库状态一致。\n\n**4  什么时候用Mock或者Stub？** 能不用就不用，最简单的方式验证你的代码是否正确。\n\n**5  DAO层的实体对象需要手动new吗？** 取决于你验证的是什么。随着积累会建立实体对象的测试仓库。\n\n**6  单元测试能检测什么类型bug？** 测不出与数据库交互和第三方接口的BUG，这不是单元测试职责，但是你可以在单元测试中调用第三方，然后发布时候@Disable该测试即可。\n\n**7 为什么不用junit自带的断言，而是第三方断言？** junit断言可读性不好，而且需要自己写断言逻辑，assertXXX，而assertj里面assertThat可以方便断言和真正验证的东西相匹配。\n\n**8 先写测试还是先写代码？** 先写测试的系统天然适合自动化测试，先写代码在写测试，极大可能不写测试了。\n\n\n\n\n\n这些只是个人观点，实践过程有更好的方法或者理解，可以推翻。单元测试价值不应该被夸大，但也不该被忽视。它是能提高设计和质量的重要工具，因为相信，所以看见。\n\n\n\n# 参考书籍\n\n- 《测试驱动开发》\n- 《持续集成-软件质量改进和风险降低之道》\n\n","source":"_posts/unit-test.md","raw":"---\ntitle: 持续集成之实践单元测试\ndate: 2020-12-02 01:13:05\ntags:\n  - 单元测试\ncategories:\n  - 持续集成\n  - 单元测试\n---\n\n\n\n# 绪论\n\n**单元测试**是保证质量，降低风险的一种重要工具。但是独立的单元测试本身意义不大，但是整合在CI使之成为**自动化测试**中就会体现其价值，这是一个价值流的传递过程，每一个过程传递软件质量和风险的信息。高质量的代码是**CLEAN**的并且**易测试**的，C(Cohesive内聚)，L(Loosely Couped松散耦合) E(Encapsulated 封装) Assertive(自主) Nonredundant(无冗余)，但是单元测试又是怎么影响这些特性的呢？\n\n**Design**：如果我的代码很难测试，那么对客户端来说设计不佳。\n\n**Cohesive**：如果需要为一个类编写很多测试，就会意识到内聚性不足。\n\n**Loosely Couped**：如果我的测试有很多无关的依赖，那么一定是耦合过多了。 \n\n**Encapsulated**：如果我的测试依赖于实现细节，那么肯定是封装出现了问题。\n\n**Assertive**：如果测试结果在被测对象以外对象中体现，我的对象可能不够自主。\n\n**Nonredundant**：如果我一遍一遍编写同样的测试，那肯定出现了冗余。\n\n\n\n一个常规的CI流程如下：\n\n<img src=\"/images/CI.png\" style=\"zoom:80%;\" />\n\n从编译源码-》持续集成数据库-》持续测试-》持续审查-》持续部署-》持续反馈，我们在编译源码和持续部署做的很好，但是在改进质量并降低风险的**持续测试**和**持续审查**做的不好，导致软件质量差，代码烂，重复率高。本文主要对持续测试中的单元测试作为实战基础来讲解一个例子，因为这是一个起点，虽然单独通过**持续审查**也能提高质量，但是由于业务压力和人员变更使得代码变乱，光靠审查无法为迭代的业务提供持续的重构保证，也无法自动化基础设施。\n\n\n\n# 实战案例\n\n## 基础框架\n\n单元测试框架[junit5](https://junit.org/junit5/)，mock框架[mockito](https://site.mockito.org/)，断言框架[assertj](https://joel-costigliola.github.io/assertj/ ) \n\n\n\n## 案例一:使用Mock取代依赖\n\n以下这段代码即调用了Redis，也调用了第三方接口，还调用了数据库，是一个比较综合的案例，我们来一起看看如何将他变成方便测试的代码，并且保证如何通过单元测试达到覆盖率。\n\n```java\npublic class TaskCenterWithdrawServiceImpl implements TaskCenterWithdrawService {\n    @Autowired\n    private HttpEncryptDecryptEngine remote;//调用第三方\n    @Autowired\n    private WithdrawService withdrawService;//关联DB\n   \n    public void startWithdraw(String coinSymbol, String walletSymbol, String appId,\n                              TransactionWithdrawCrypto twc) {\n        \n        TransactionWithdrawCrypto withdrawCrypto = withdrawService.selectByIdAndLock(twc.getId());//查询数据库\n        String payload = generateWithdrawRequest(coinSymbol, walletSymbol, withdrawCrypto);//构造请求参数，里面查询静态方法\n        String result = remote.startWithdraw(appId, payload);//调用第三方接口返回结果\n        WalletResponseCode responseCode = WalletResponseCode.ofCode(result);\n        switch (responseCode) {\n            case SUCCESS:\n                break;\n            case WITHDRAW_ADDR_ERROR:\n            case WITHDRAW_CANNOT_TO_SELF: {\n                try {\n                    withdrawService.cancelWithdraw();\n                } catch (Exception e) {\n                    log.error(\"startWithdrawRequest cancel withdrawCrypto id : {} error \",\n                              withdrawCrypto.getId(), e);\n                }\n                break;\n            }   \n            default:                \n                cancelWithdrawIfAdminConfiged(withdrawCrypto.getId(), responseCode);\n                break;\n          \n    }\n```\n\n\n\n```java\nprivate String generateWithdrawRequest(String coinSymbol, String walletSymbol,\n                                       TransactionWithdrawCrypto c) {\n   \n    //......里面查询了redis\n    ConfigCoinSymbol c = CoinSymbolUtils.getSaaSInfo(coinSymbol);\n    //......\n    return ....;\n}\n```\n\n\n\n我们看到这个代码，需要思考测试什么才能证明代码没有错呢？既当什么情况下，你期望发生什么。来看看我们得期望：\n\n1   当第三方接口返回成功时候，该方法结束。\n\n2   当第三方接口返回WITHDRAW_ADDR_ERROR或者WITHDRAW_CANNOT_TO_SELF，我们需要调用cancelWithdraw，\n\n3   当第三方接口返回其他情况时候，调用cancelWithdrawIfAdminConfiged方法。\n\n4   当传入不同币种的时候，generateWithdrawRequest产生不同的请求。\n\n我们仅仅需要验证这些就够了，因为TaskCenterWithdrawServiceImpl得协作者的产生的行为仅仅如此，至于协作者行为的可靠性，需要协作者自身去验证，而不是在该测试中验证。\n\n### 第一步 依赖注入解耦\n\nspring字段注入导致单元测试困难，因为你无法实例化类中的对象，所以在TaskCenterWithdrawServiceImpl中将字段注入改成构造器注入或者属性注入。\n\n```java\npublic class TaskCenterWithdrawServiceImpl {\n\n    private HttpEncryptDecryptEngine httpEncryptDecryptEngine;\n\n    private WithdrawService withdrawService;\n\n    @Autowired\n    public void setHttpEncryptDecryptEngine(HttpEncryptDecryptEngine httpEncryptDecryptEngine) {\n        this.httpEncryptDecryptEngine = httpEncryptDecryptEngine;\n    }\n\n    @Autowired\n    public void setWithdrawService(WithdrawService withdrawService) {\n        this.withdrawService = withdrawService;\n    }\n\n```\n\n\n### 第二步 静态方法抽离接口\n\n不是所有静态方法都需要抽离成接口，由于项目中CoinSymbolUtils.getSaaSInfo调用了数据库和redis，所以此时你无法真实调用数据库和redis，因为在脱离spring环境你无法创建这两个对象，所以抽离成接口可以mock改接口。如果是普通的工具类，让他执行即可。\n\n```java\npublic interface CoinSymbolOperator {\n    ConfigCoinSymbol getSaaSInfoAll(String coinSymbol);\n}\n```\n\n之前工具类实现该接口，并且调用之前静态方法。\n\n```java\n@Component\npublic class CoinSymbolUtils implements  CoinSymbolOperator {\n\n   public ConfigCoinSymbol getSaaSInfoAll(String coinSymbol) {\n        return getSaaSInfo(coinSymbol);\n   }\n}\n```\n\n\n\n### 第三步 测试mock对象\n\nmock对象我们使用的是**mockito**框架。\n\n```java\npublic class TaskCenterWithdrawServiceMockTest {\n    //待测试的类\n    private TaskCenterWithdrawServiceImpl taskCenterWithdrawService;\n\n    private HttpEncryptDecryptEngine httpEncryptDecryptEngine;\n\n    private WithdrawService withdrawService;\n\n    private CoinSymbolOperator coinSymbolOperator;\n\n@Before\npublic void setup() {\n    //创建TaskCenterWithdrawService对象\n    httpEncryptDecryptEngine = mock(HttpEncryptDecryptEngine.class);\n    withdrawService = mock(WithdrawService.class);\n    //mock静态方法拆离的接口在这里需要注入到TaskCenterWithdrawService中\n    coinSymbolOperator = mock(CoinSymbolOperator.class);\n    taskCenterWithdrawService = new new TaskCenterWithdrawServiceImpl();\n    taskCenterWithdrawService.setHttpEncryptDecryptEngine(httpEncryptDecryptEngine);\n    taskCenterWithdrawService.setWithdrawService(withdrawService);\n    taskCenterWithdrawService.setCoinSymbolOperator(coinSymbolOperator);\n}\n    \n```\n\n   \n\n### 第四步 编写测试方法\n\n测试方法必须要写assertions和你要验证的东西，否则这个单元测试没有意义。这个测试没有用到**assertj**  ，而是使用了**mockito**自带的verify方法验证。\n\n```java\n@Test\npublic void startWithdraw() { \n    //given willReturn 短语帮助我们构造期望的输入和输出，含义是当满足xxx条件时候，发生什么，期望什么结果。\n    //当给getWalletUid传入任意int和string时候，调用cryptoAddressService.getWalletUid，期望返回123\n    given(cryptoAddressService.getWalletUid(anyInt(), anyString())).willReturn(123);\n\n    //构造期望的返回值\n    TransactionWithdrawCrypto transactionWithdrawCrypto = new TransactionWithdrawCrypto();\n    transactionWithdrawCrypto.setAddressFrom(\"alibaba\");\n    transactionWithdrawCrypto.setFee(new BigDecimal(\"456.777\"));\n    transactionWithdrawCrypto.setSymbol(\"USDT\");\n    transactionWithdrawCrypto.setAddressTo(\"baidu\");\n    transactionWithdrawCrypto.setUid(111111111);\n\n    transactionWithdrawCrypto.setAmount(new BigDecimal(\"123.444\"));\n    //构造期望输入和输出\n    given(withdrawService.selectByIdAndLock(anyInt())).willReturn(transactionWithdrawCrypto);\n\n    ConfigCoinSymbol ccs = new ConfigCoinSymbol();\n    ccs.setTokenBase(\"BTC\");\n    ccs.setContractAddress(\"BTC_ContractAddress\");\n    //构造期望输入和输出\n    given(coinSymbolOperator.from(\"USDT\")).willReturn(ccs);\n\n    Map<String,String> result = new HashMap<>();\n    result.put(\"code\", WalletResponseCode.SUCCESS.getCode());\n    result.put(\"message\", WalletResponseCode.SUCCESS.getMessage());\n    //构造期望输入和输出\n    given(httpEncryptDecryptEngine.startWithdraw(anyString(), anyString())).willReturn(JSON.toJSONString(result));\n\n    //和given，willReturn一样的效果\n    //when(httpEncryptDecryptEngine.startWithdraw(anyString(), anyString())).thenReturn(\"111111111\");\n\n    //这一步是将之前mock的对象和数据以及构造期望输入和输出串联起来执行。\n    taskCenterWithdrawService.startWithdraw(\"USDT\", \"BTC\", \"aaaa\", new TransactionWithdrawCrypto());\n\n    //由于该方法是void所以需要验证方法是否被调用.比如断言getWalletUid是否被调用，比如第三方接口返回值不同调用不同的方法\n    //来使得代码覆盖率比较高\n    verify(this.cryptoAddressService).getWalletUid(111111111, \"BTC\");\n}\n```\n\n\n\n## 案例二：关联数据库的单元测试\n\n有些测试必须关联数据库或者第三方接口，此时不得不接受使用外部资源这一现实。这时候测试关联数据库的必须保证测试前数据库状态和测试后状态一致。我们来建立一个test fixture来验证一个CRUD的正确性。在每个方法执行前用@BeforeEach中建立Account对象，在integrateTestDataBaseCRUD中测试CRUD方法，在每个方法结束后用@AfterEach清除数据库对象，使得测试前后数据库状态幂等。我曾经遇到一个必须使用第三方资源场景是 本地代码必须调用第三方接口来验证程序，以及在集成测试时候，也主要验证第三方接口，程序本身逻辑很少。这时候就必须使用外部依赖来完成单元测试。\n\n```java\npublic class AccountServiceTest {\n    @Autowired\n    private AccountService accountService;\n    private Account account;\n\n    @BeforeEach\n    void setUp() {\n        account = Account.builder().\n                balance(new BigDecimal(\"67.88\")).\n                type(111).\n                uid(445).\n                tag(\"33\").\n                build();\n    }\n\n    @Test\n    public void integrateTestDataBaseCRUD() {\n        accountService.insert(account);\n        long id = account.getId();\n        Account accountFind = accountService.get(id);\n        accountFind.setBalance(new BigDecimal(\"366334\"));\n        accountService.update(accountFind);\n        Account accountUpdate = accountService.get(id);\n        accountService.delete(id);\n        Account accountDelete = accountService.get(id);\n\n        assertAll(\"test\", () -> {\n            assertEquals(accountFind.getBalance().stripTrailingZeros().toPlainString(),\n                    accountUpdate.getBalance().stripTrailingZeros().toPlainString());\n        });\n        assertNull(accountDelete);\n    }\n\n    @AfterEach\n    void tearDown() {\n        accountService.delete(id);\n    }\n}\n```\n\n\n\n我们可以看到上述两个案例都是先写代码后写单元测试，这样可能导致单元测试很难测试代码，给遗留系统添加单元测试也很繁琐，所以需要从设计层面改进代码，使之更加容易测试和验证。更优秀的做法是实践TDD，这样代码天然可测试。\n\n\n\n# 常见问题\n\n**1 单元测试的价值在哪里？** 1  保证代码质量，当然质量保证不仅仅靠单元测试。当你看到队友提交了一些代码，确发现单元测试覆盖率降低了，就知道他的提交可能带来代码质量下降。 2  代码可测试性往往带来灵活的设计。  3  你不仅仅在写单元测试，而是实践自动化测试，实践着CI \n\n**2  遗留系统很多没有单元测试，我需要补吗？**1  当你修改老代码的时候，加一个单元测试。 2 依赖最多的，访问最多的需要补充。 3 试图在遗留系统上加单元测试很困难，并且使之成为自动化测试，但是需要尝试，新的代码尝试TDD。\n\n**3  我觉得有些情况需要读取数据库，看到数据落库心里才踏实，这时候写单元测试需要连数据库吗？**单元测试不连库，连库的叫集成测试，单元测试验证是逻辑，数据库只是细节实现，你的代码可以脱离SSM，MySQL..... 在实践中你会真正理解解耦的。你的踏实和自信应该建立在独立性和不依赖外界细节上，而不是数据归属地到底是哪里。如果一些测试必须要用数据库，请使用test fixture。保证单元测试前和单元测试后数据库状态一致。\n\n**4  什么时候用Mock或者Stub？** 能不用就不用，最简单的方式验证你的代码是否正确。\n\n**5  DAO层的实体对象需要手动new吗？** 取决于你验证的是什么。随着积累会建立实体对象的测试仓库。\n\n**6  单元测试能检测什么类型bug？** 测不出与数据库交互和第三方接口的BUG，这不是单元测试职责，但是你可以在单元测试中调用第三方，然后发布时候@Disable该测试即可。\n\n**7 为什么不用junit自带的断言，而是第三方断言？** junit断言可读性不好，而且需要自己写断言逻辑，assertXXX，而assertj里面assertThat可以方便断言和真正验证的东西相匹配。\n\n**8 先写测试还是先写代码？** 先写测试的系统天然适合自动化测试，先写代码在写测试，极大可能不写测试了。\n\n\n\n\n\n这些只是个人观点，实践过程有更好的方法或者理解，可以推翻。单元测试价值不应该被夸大，但也不该被忽视。它是能提高设计和质量的重要工具，因为相信，所以看见。\n\n\n\n# 参考书籍\n\n- 《测试驱动开发》\n- 《持续集成-软件质量改进和风险降低之道》\n\n","slug":"unit-test","published":1,"updated":"2022-06-28T17:28:50.000Z","comments":1,"layout":"post","photos":[],"link":"","_id":"clh7s5cub002nxt8j5zot848w","content":"<h1 id=\"绪论\"><a href=\"#绪论\" class=\"headerlink\" title=\"绪论\"></a>绪论</h1><p><strong>单元测试</strong>是保证质量，降低风险的一种重要工具。但是独立的单元测试本身意义不大，但是整合在CI使之成为<strong>自动化测试</strong>中就会体现其价值，这是一个价值流的传递过程，每一个过程传递软件质量和风险的信息。高质量的代码是<strong>CLEAN</strong>的并且<strong>易测试</strong>的，C(Cohesive内聚)，L(Loosely Couped松散耦合) E(Encapsulated 封装) Assertive(自主) Nonredundant(无冗余)，但是单元测试又是怎么影响这些特性的呢？</p>\n<p><strong>Design</strong>：如果我的代码很难测试，那么对客户端来说设计不佳。</p>\n<p><strong>Cohesive</strong>：如果需要为一个类编写很多测试，就会意识到内聚性不足。</p>\n<p><strong>Loosely Couped</strong>：如果我的测试有很多无关的依赖，那么一定是耦合过多了。 </p>\n<p><strong>Encapsulated</strong>：如果我的测试依赖于实现细节，那么肯定是封装出现了问题。</p>\n<p><strong>Assertive</strong>：如果测试结果在被测对象以外对象中体现，我的对象可能不够自主。</p>\n<p><strong>Nonredundant</strong>：如果我一遍一遍编写同样的测试，那肯定出现了冗余。</p>\n<p>一个常规的CI流程如下：</p>\n<img src=\"/images/CI.png\" style=\"zoom:80%;\" />\n\n<p>从编译源码-》持续集成数据库-》持续测试-》持续审查-》持续部署-》持续反馈，我们在编译源码和持续部署做的很好，但是在改进质量并降低风险的<strong>持续测试</strong>和<strong>持续审查</strong>做的不好，导致软件质量差，代码烂，重复率高。本文主要对持续测试中的单元测试作为实战基础来讲解一个例子，因为这是一个起点，虽然单独通过<strong>持续审查</strong>也能提高质量，但是由于业务压力和人员变更使得代码变乱，光靠审查无法为迭代的业务提供持续的重构保证，也无法自动化基础设施。</p>\n<h1 id=\"实战案例\"><a href=\"#实战案例\" class=\"headerlink\" title=\"实战案例\"></a>实战案例</h1><h2 id=\"基础框架\"><a href=\"#基础框架\" class=\"headerlink\" title=\"基础框架\"></a>基础框架</h2><p>单元测试框架<a href=\"https://junit.org/junit5/\" target=\"_blank\" rel=\"noopener\">junit5</a>，mock框架<a href=\"https://site.mockito.org/\" target=\"_blank\" rel=\"noopener\">mockito</a>，断言框架<a href=\"https://joel-costigliola.github.io/assertj/\" target=\"_blank\" rel=\"noopener\">assertj</a> </p>\n<h2 id=\"案例一-使用Mock取代依赖\"><a href=\"#案例一-使用Mock取代依赖\" class=\"headerlink\" title=\"案例一:使用Mock取代依赖\"></a>案例一:使用Mock取代依赖</h2><p>以下这段代码即调用了Redis，也调用了第三方接口，还调用了数据库，是一个比较综合的案例，我们来一起看看如何将他变成方便测试的代码，并且保证如何通过单元测试达到覆盖率。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TaskCenterWithdrawServiceImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">TaskCenterWithdrawService</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> HttpEncryptDecryptEngine remote;<span class=\"comment\">//调用第三方</span></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> WithdrawService withdrawService;<span class=\"comment\">//关联DB</span></span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">startWithdraw</span><span class=\"params\">(String coinSymbol, String walletSymbol, String appId,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                              TransactionWithdrawCrypto twc)</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        TransactionWithdrawCrypto withdrawCrypto = withdrawService.selectByIdAndLock(twc.getId());<span class=\"comment\">//查询数据库</span></span><br><span class=\"line\">        String payload = generateWithdrawRequest(coinSymbol, walletSymbol, withdrawCrypto);<span class=\"comment\">//构造请求参数，里面查询静态方法</span></span><br><span class=\"line\">        String result = remote.startWithdraw(appId, payload);<span class=\"comment\">//调用第三方接口返回结果</span></span><br><span class=\"line\">        WalletResponseCode responseCode = WalletResponseCode.ofCode(result);</span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (responseCode) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> SUCCESS:</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> WITHDRAW_ADDR_ERROR:</span><br><span class=\"line\">            <span class=\"keyword\">case</span> WITHDRAW_CANNOT_TO_SELF: &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    withdrawService.cancelWithdraw();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                    log.error(<span class=\"string\">\"startWithdrawRequest cancel withdrawCrypto id : &#123;&#125; error \"</span>,</span><br><span class=\"line\">                              withdrawCrypto.getId(), e);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;   </span><br><span class=\"line\">            <span class=\"keyword\">default</span>:                </span><br><span class=\"line\">                cancelWithdrawIfAdminConfiged(withdrawCrypto.getId(), responseCode);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">          </span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> String <span class=\"title\">generateWithdrawRequest</span><span class=\"params\">(String coinSymbol, String walletSymbol,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                       TransactionWithdrawCrypto c)</span> </span>&#123;</span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"comment\">//......里面查询了redis</span></span><br><span class=\"line\">    ConfigCoinSymbol c = CoinSymbolUtils.getSaaSInfo(coinSymbol);</span><br><span class=\"line\">    <span class=\"comment\">//......</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ....;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>我们看到这个代码，需要思考测试什么才能证明代码没有错呢？既当什么情况下，你期望发生什么。来看看我们得期望：</p>\n<p>1   当第三方接口返回成功时候，该方法结束。</p>\n<p>2   当第三方接口返回WITHDRAW_ADDR_ERROR或者WITHDRAW_CANNOT_TO_SELF，我们需要调用cancelWithdraw，</p>\n<p>3   当第三方接口返回其他情况时候，调用cancelWithdrawIfAdminConfiged方法。</p>\n<p>4   当传入不同币种的时候，generateWithdrawRequest产生不同的请求。</p>\n<p>我们仅仅需要验证这些就够了，因为TaskCenterWithdrawServiceImpl得协作者的产生的行为仅仅如此，至于协作者行为的可靠性，需要协作者自身去验证，而不是在该测试中验证。</p>\n<h3 id=\"第一步-依赖注入解耦\"><a href=\"#第一步-依赖注入解耦\" class=\"headerlink\" title=\"第一步 依赖注入解耦\"></a>第一步 依赖注入解耦</h3><p>spring字段注入导致单元测试困难，因为你无法实例化类中的对象，所以在TaskCenterWithdrawServiceImpl中将字段注入改成构造器注入或者属性注入。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TaskCenterWithdrawServiceImpl</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> HttpEncryptDecryptEngine httpEncryptDecryptEngine;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> WithdrawService withdrawService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setHttpEncryptDecryptEngine</span><span class=\"params\">(HttpEncryptDecryptEngine httpEncryptDecryptEngine)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.httpEncryptDecryptEngine = httpEncryptDecryptEngine;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setWithdrawService</span><span class=\"params\">(WithdrawService withdrawService)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.withdrawService = withdrawService;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"第二步-静态方法抽离接口\"><a href=\"#第二步-静态方法抽离接口\" class=\"headerlink\" title=\"第二步 静态方法抽离接口\"></a>第二步 静态方法抽离接口</h3><p>不是所有静态方法都需要抽离成接口，由于项目中CoinSymbolUtils.getSaaSInfo调用了数据库和redis，所以此时你无法真实调用数据库和redis，因为在脱离spring环境你无法创建这两个对象，所以抽离成接口可以mock改接口。如果是普通的工具类，让他执行即可。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">CoinSymbolOperator</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">ConfigCoinSymbol <span class=\"title\">getSaaSInfoAll</span><span class=\"params\">(String coinSymbol)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>之前工具类实现该接口，并且调用之前静态方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CoinSymbolUtils</span> <span class=\"keyword\">implements</span>  <span class=\"title\">CoinSymbolOperator</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> ConfigCoinSymbol <span class=\"title\">getSaaSInfoAll</span><span class=\"params\">(String coinSymbol)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> getSaaSInfo(coinSymbol);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"第三步-测试mock对象\"><a href=\"#第三步-测试mock对象\" class=\"headerlink\" title=\"第三步 测试mock对象\"></a>第三步 测试mock对象</h3><p>mock对象我们使用的是<strong>mockito</strong>框架。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TaskCenterWithdrawServiceMockTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//待测试的类</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> TaskCenterWithdrawServiceImpl taskCenterWithdrawService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> HttpEncryptDecryptEngine httpEncryptDecryptEngine;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> WithdrawService withdrawService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> CoinSymbolOperator coinSymbolOperator;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Before</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setup</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//创建TaskCenterWithdrawService对象</span></span><br><span class=\"line\">    httpEncryptDecryptEngine = mock(HttpEncryptDecryptEngine<span class=\"class\">.<span class=\"keyword\">class</span>)</span>;</span><br><span class=\"line\">    withdrawService = mock(WithdrawService<span class=\"class\">.<span class=\"keyword\">class</span>)</span>;</span><br><span class=\"line\">    <span class=\"comment\">//mock静态方法拆离的接口在这里需要注入到TaskCenterWithdrawService中</span></span><br><span class=\"line\">    coinSymbolOperator = mock(CoinSymbolOperator<span class=\"class\">.<span class=\"keyword\">class</span>)</span>;</span><br><span class=\"line\">    taskCenterWithdrawService = <span class=\"keyword\">new</span> <span class=\"keyword\">new</span> TaskCenterWithdrawServiceImpl();</span><br><span class=\"line\">    taskCenterWithdrawService.setHttpEncryptDecryptEngine(httpEncryptDecryptEngine);</span><br><span class=\"line\">    taskCenterWithdrawService.setWithdrawService(withdrawService);</span><br><span class=\"line\">    taskCenterWithdrawService.setCoinSymbolOperator(coinSymbolOperator);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"第四步-编写测试方法\"><a href=\"#第四步-编写测试方法\" class=\"headerlink\" title=\"第四步 编写测试方法\"></a>第四步 编写测试方法</h3><p>测试方法必须要写assertions和你要验证的东西，否则这个单元测试没有意义。这个测试没有用到<strong>assertj</strong>  ，而是使用了<strong>mockito</strong>自带的verify方法验证。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">startWithdraw</span><span class=\"params\">()</span> </span>&#123; </span><br><span class=\"line\">    <span class=\"comment\">//given willReturn 短语帮助我们构造期望的输入和输出，含义是当满足xxx条件时候，发生什么，期望什么结果。</span></span><br><span class=\"line\">    <span class=\"comment\">//当给getWalletUid传入任意int和string时候，调用cryptoAddressService.getWalletUid，期望返回123</span></span><br><span class=\"line\">    given(cryptoAddressService.getWalletUid(anyInt(), anyString())).willReturn(<span class=\"number\">123</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//构造期望的返回值</span></span><br><span class=\"line\">    TransactionWithdrawCrypto transactionWithdrawCrypto = <span class=\"keyword\">new</span> TransactionWithdrawCrypto();</span><br><span class=\"line\">    transactionWithdrawCrypto.setAddressFrom(<span class=\"string\">\"alibaba\"</span>);</span><br><span class=\"line\">    transactionWithdrawCrypto.setFee(<span class=\"keyword\">new</span> BigDecimal(<span class=\"string\">\"456.777\"</span>));</span><br><span class=\"line\">    transactionWithdrawCrypto.setSymbol(<span class=\"string\">\"USDT\"</span>);</span><br><span class=\"line\">    transactionWithdrawCrypto.setAddressTo(<span class=\"string\">\"baidu\"</span>);</span><br><span class=\"line\">    transactionWithdrawCrypto.setUid(<span class=\"number\">111111111</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    transactionWithdrawCrypto.setAmount(<span class=\"keyword\">new</span> BigDecimal(<span class=\"string\">\"123.444\"</span>));</span><br><span class=\"line\">    <span class=\"comment\">//构造期望输入和输出</span></span><br><span class=\"line\">    given(withdrawService.selectByIdAndLock(anyInt())).willReturn(transactionWithdrawCrypto);</span><br><span class=\"line\"></span><br><span class=\"line\">    ConfigCoinSymbol ccs = <span class=\"keyword\">new</span> ConfigCoinSymbol();</span><br><span class=\"line\">    ccs.setTokenBase(<span class=\"string\">\"BTC\"</span>);</span><br><span class=\"line\">    ccs.setContractAddress(<span class=\"string\">\"BTC_ContractAddress\"</span>);</span><br><span class=\"line\">    <span class=\"comment\">//构造期望输入和输出</span></span><br><span class=\"line\">    given(coinSymbolOperator.from(<span class=\"string\">\"USDT\"</span>)).willReturn(ccs);</span><br><span class=\"line\"></span><br><span class=\"line\">    Map&lt;String,String&gt; result = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">    result.put(<span class=\"string\">\"code\"</span>, WalletResponseCode.SUCCESS.getCode());</span><br><span class=\"line\">    result.put(<span class=\"string\">\"message\"</span>, WalletResponseCode.SUCCESS.getMessage());</span><br><span class=\"line\">    <span class=\"comment\">//构造期望输入和输出</span></span><br><span class=\"line\">    given(httpEncryptDecryptEngine.startWithdraw(anyString(), anyString())).willReturn(JSON.toJSONString(result));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//和given，willReturn一样的效果</span></span><br><span class=\"line\">    <span class=\"comment\">//when(httpEncryptDecryptEngine.startWithdraw(anyString(), anyString())).thenReturn(\"111111111\");</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//这一步是将之前mock的对象和数据以及构造期望输入和输出串联起来执行。</span></span><br><span class=\"line\">    taskCenterWithdrawService.startWithdraw(<span class=\"string\">\"USDT\"</span>, <span class=\"string\">\"BTC\"</span>, <span class=\"string\">\"aaaa\"</span>, <span class=\"keyword\">new</span> TransactionWithdrawCrypto());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//由于该方法是void所以需要验证方法是否被调用.比如断言getWalletUid是否被调用，比如第三方接口返回值不同调用不同的方法</span></span><br><span class=\"line\">    <span class=\"comment\">//来使得代码覆盖率比较高</span></span><br><span class=\"line\">    verify(<span class=\"keyword\">this</span>.cryptoAddressService).getWalletUid(<span class=\"number\">111111111</span>, <span class=\"string\">\"BTC\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"案例二：关联数据库的单元测试\"><a href=\"#案例二：关联数据库的单元测试\" class=\"headerlink\" title=\"案例二：关联数据库的单元测试\"></a>案例二：关联数据库的单元测试</h2><p>有些测试必须关联数据库或者第三方接口，此时不得不接受使用外部资源这一现实。这时候测试关联数据库的必须保证测试前数据库状态和测试后状态一致。我们来建立一个test fixture来验证一个CRUD的正确性。在每个方法执行前用@BeforeEach中建立Account对象，在integrateTestDataBaseCRUD中测试CRUD方法，在每个方法结束后用@AfterEach清除数据库对象，使得测试前后数据库状态幂等。我曾经遇到一个必须使用第三方资源场景是 本地代码必须调用第三方接口来验证程序，以及在集成测试时候，也主要验证第三方接口，程序本身逻辑很少。这时候就必须使用外部依赖来完成单元测试。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AccountServiceTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> AccountService accountService;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Account account;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@BeforeEach</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setUp</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        account = Account.builder().</span><br><span class=\"line\">                balance(<span class=\"keyword\">new</span> BigDecimal(<span class=\"string\">\"67.88\"</span>)).</span><br><span class=\"line\">                type(<span class=\"number\">111</span>).</span><br><span class=\"line\">                uid(<span class=\"number\">445</span>).</span><br><span class=\"line\">                tag(<span class=\"string\">\"33\"</span>).</span><br><span class=\"line\">                build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">integrateTestDataBaseCRUD</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        accountService.insert(account);</span><br><span class=\"line\">        <span class=\"keyword\">long</span> id = account.getId();</span><br><span class=\"line\">        Account accountFind = accountService.get(id);</span><br><span class=\"line\">        accountFind.setBalance(<span class=\"keyword\">new</span> BigDecimal(<span class=\"string\">\"366334\"</span>));</span><br><span class=\"line\">        accountService.update(accountFind);</span><br><span class=\"line\">        Account accountUpdate = accountService.get(id);</span><br><span class=\"line\">        accountService.delete(id);</span><br><span class=\"line\">        Account accountDelete = accountService.get(id);</span><br><span class=\"line\"></span><br><span class=\"line\">        assertAll(<span class=\"string\">\"test\"</span>, () -&gt; &#123;</span><br><span class=\"line\">            assertEquals(accountFind.getBalance().stripTrailingZeros().toPlainString(),</span><br><span class=\"line\">                    accountUpdate.getBalance().stripTrailingZeros().toPlainString());</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        assertNull(accountDelete);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@AfterEach</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">tearDown</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        accountService.delete(id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>我们可以看到上述两个案例都是先写代码后写单元测试，这样可能导致单元测试很难测试代码，给遗留系统添加单元测试也很繁琐，所以需要从设计层面改进代码，使之更加容易测试和验证。更优秀的做法是实践TDD，这样代码天然可测试。</p>\n<h1 id=\"常见问题\"><a href=\"#常见问题\" class=\"headerlink\" title=\"常见问题\"></a>常见问题</h1><p><strong>1 单元测试的价值在哪里？</strong> 1  保证代码质量，当然质量保证不仅仅靠单元测试。当你看到队友提交了一些代码，确发现单元测试覆盖率降低了，就知道他的提交可能带来代码质量下降。 2  代码可测试性往往带来灵活的设计。  3  你不仅仅在写单元测试，而是实践自动化测试，实践着CI </p>\n<p><strong>2  遗留系统很多没有单元测试，我需要补吗？</strong>1  当你修改老代码的时候，加一个单元测试。 2 依赖最多的，访问最多的需要补充。 3 试图在遗留系统上加单元测试很困难，并且使之成为自动化测试，但是需要尝试，新的代码尝试TDD。</p>\n<p><strong>3  我觉得有些情况需要读取数据库，看到数据落库心里才踏实，这时候写单元测试需要连数据库吗？</strong>单元测试不连库，连库的叫集成测试，单元测试验证是逻辑，数据库只是细节实现，你的代码可以脱离SSM，MySQL….. 在实践中你会真正理解解耦的。你的踏实和自信应该建立在独立性和不依赖外界细节上，而不是数据归属地到底是哪里。如果一些测试必须要用数据库，请使用test fixture。保证单元测试前和单元测试后数据库状态一致。</p>\n<p><strong>4  什么时候用Mock或者Stub？</strong> 能不用就不用，最简单的方式验证你的代码是否正确。</p>\n<p><strong>5  DAO层的实体对象需要手动new吗？</strong> 取决于你验证的是什么。随着积累会建立实体对象的测试仓库。</p>\n<p><strong>6  单元测试能检测什么类型bug？</strong> 测不出与数据库交互和第三方接口的BUG，这不是单元测试职责，但是你可以在单元测试中调用第三方，然后发布时候@Disable该测试即可。</p>\n<p><strong>7 为什么不用junit自带的断言，而是第三方断言？</strong> junit断言可读性不好，而且需要自己写断言逻辑，assertXXX，而assertj里面assertThat可以方便断言和真正验证的东西相匹配。</p>\n<p><strong>8 先写测试还是先写代码？</strong> 先写测试的系统天然适合自动化测试，先写代码在写测试，极大可能不写测试了。</p>\n<p>这些只是个人观点，实践过程有更好的方法或者理解，可以推翻。单元测试价值不应该被夸大，但也不该被忽视。它是能提高设计和质量的重要工具，因为相信，所以看见。</p>\n<h1 id=\"参考书籍\"><a href=\"#参考书籍\" class=\"headerlink\" title=\"参考书籍\"></a>参考书籍</h1><ul>\n<li>《测试驱动开发》</li>\n<li>《持续集成-软件质量改进和风险降低之道》</li>\n</ul>\n","site":{"data":{}},"excerpt":"","more":"<h1 id=\"绪论\"><a href=\"#绪论\" class=\"headerlink\" title=\"绪论\"></a>绪论</h1><p><strong>单元测试</strong>是保证质量，降低风险的一种重要工具。但是独立的单元测试本身意义不大，但是整合在CI使之成为<strong>自动化测试</strong>中就会体现其价值，这是一个价值流的传递过程，每一个过程传递软件质量和风险的信息。高质量的代码是<strong>CLEAN</strong>的并且<strong>易测试</strong>的，C(Cohesive内聚)，L(Loosely Couped松散耦合) E(Encapsulated 封装) Assertive(自主) Nonredundant(无冗余)，但是单元测试又是怎么影响这些特性的呢？</p>\n<p><strong>Design</strong>：如果我的代码很难测试，那么对客户端来说设计不佳。</p>\n<p><strong>Cohesive</strong>：如果需要为一个类编写很多测试，就会意识到内聚性不足。</p>\n<p><strong>Loosely Couped</strong>：如果我的测试有很多无关的依赖，那么一定是耦合过多了。 </p>\n<p><strong>Encapsulated</strong>：如果我的测试依赖于实现细节，那么肯定是封装出现了问题。</p>\n<p><strong>Assertive</strong>：如果测试结果在被测对象以外对象中体现，我的对象可能不够自主。</p>\n<p><strong>Nonredundant</strong>：如果我一遍一遍编写同样的测试，那肯定出现了冗余。</p>\n<p>一个常规的CI流程如下：</p>\n<img src=\"/images/CI.png\" style=\"zoom:80%;\" />\n\n<p>从编译源码-》持续集成数据库-》持续测试-》持续审查-》持续部署-》持续反馈，我们在编译源码和持续部署做的很好，但是在改进质量并降低风险的<strong>持续测试</strong>和<strong>持续审查</strong>做的不好，导致软件质量差，代码烂，重复率高。本文主要对持续测试中的单元测试作为实战基础来讲解一个例子，因为这是一个起点，虽然单独通过<strong>持续审查</strong>也能提高质量，但是由于业务压力和人员变更使得代码变乱，光靠审查无法为迭代的业务提供持续的重构保证，也无法自动化基础设施。</p>\n<h1 id=\"实战案例\"><a href=\"#实战案例\" class=\"headerlink\" title=\"实战案例\"></a>实战案例</h1><h2 id=\"基础框架\"><a href=\"#基础框架\" class=\"headerlink\" title=\"基础框架\"></a>基础框架</h2><p>单元测试框架<a href=\"https://junit.org/junit5/\" target=\"_blank\" rel=\"noopener\">junit5</a>，mock框架<a href=\"https://site.mockito.org/\" target=\"_blank\" rel=\"noopener\">mockito</a>，断言框架<a href=\"https://joel-costigliola.github.io/assertj/\" target=\"_blank\" rel=\"noopener\">assertj</a> </p>\n<h2 id=\"案例一-使用Mock取代依赖\"><a href=\"#案例一-使用Mock取代依赖\" class=\"headerlink\" title=\"案例一:使用Mock取代依赖\"></a>案例一:使用Mock取代依赖</h2><p>以下这段代码即调用了Redis，也调用了第三方接口，还调用了数据库，是一个比较综合的案例，我们来一起看看如何将他变成方便测试的代码，并且保证如何通过单元测试达到覆盖率。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TaskCenterWithdrawServiceImpl</span> <span class=\"keyword\">implements</span> <span class=\"title\">TaskCenterWithdrawService</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> HttpEncryptDecryptEngine remote;<span class=\"comment\">//调用第三方</span></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> WithdrawService withdrawService;<span class=\"comment\">//关联DB</span></span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">startWithdraw</span><span class=\"params\">(String coinSymbol, String walletSymbol, String appId,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                              TransactionWithdrawCrypto twc)</span> </span>&#123;</span><br><span class=\"line\">        </span><br><span class=\"line\">        TransactionWithdrawCrypto withdrawCrypto = withdrawService.selectByIdAndLock(twc.getId());<span class=\"comment\">//查询数据库</span></span><br><span class=\"line\">        String payload = generateWithdrawRequest(coinSymbol, walletSymbol, withdrawCrypto);<span class=\"comment\">//构造请求参数，里面查询静态方法</span></span><br><span class=\"line\">        String result = remote.startWithdraw(appId, payload);<span class=\"comment\">//调用第三方接口返回结果</span></span><br><span class=\"line\">        WalletResponseCode responseCode = WalletResponseCode.ofCode(result);</span><br><span class=\"line\">        <span class=\"keyword\">switch</span> (responseCode) &#123;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> SUCCESS:</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            <span class=\"keyword\">case</span> WITHDRAW_ADDR_ERROR:</span><br><span class=\"line\">            <span class=\"keyword\">case</span> WITHDRAW_CANNOT_TO_SELF: &#123;</span><br><span class=\"line\">                <span class=\"keyword\">try</span> &#123;</span><br><span class=\"line\">                    withdrawService.cancelWithdraw();</span><br><span class=\"line\">                &#125; <span class=\"keyword\">catch</span> (Exception e) &#123;</span><br><span class=\"line\">                    log.error(<span class=\"string\">\"startWithdrawRequest cancel withdrawCrypto id : &#123;&#125; error \"</span>,</span><br><span class=\"line\">                              withdrawCrypto.getId(), e);</span><br><span class=\"line\">                &#125;</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">            &#125;   </span><br><span class=\"line\">            <span class=\"keyword\">default</span>:                </span><br><span class=\"line\">                cancelWithdrawIfAdminConfiged(withdrawCrypto.getId(), responseCode);</span><br><span class=\"line\">                <span class=\"keyword\">break</span>;</span><br><span class=\"line\">          </span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"function\"><span class=\"keyword\">private</span> String <span class=\"title\">generateWithdrawRequest</span><span class=\"params\">(String coinSymbol, String walletSymbol,</span></span></span><br><span class=\"line\"><span class=\"function\"><span class=\"params\">                                       TransactionWithdrawCrypto c)</span> </span>&#123;</span><br><span class=\"line\">   </span><br><span class=\"line\">    <span class=\"comment\">//......里面查询了redis</span></span><br><span class=\"line\">    ConfigCoinSymbol c = CoinSymbolUtils.getSaaSInfo(coinSymbol);</span><br><span class=\"line\">    <span class=\"comment\">//......</span></span><br><span class=\"line\">    <span class=\"keyword\">return</span> ....;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>我们看到这个代码，需要思考测试什么才能证明代码没有错呢？既当什么情况下，你期望发生什么。来看看我们得期望：</p>\n<p>1   当第三方接口返回成功时候，该方法结束。</p>\n<p>2   当第三方接口返回WITHDRAW_ADDR_ERROR或者WITHDRAW_CANNOT_TO_SELF，我们需要调用cancelWithdraw，</p>\n<p>3   当第三方接口返回其他情况时候，调用cancelWithdrawIfAdminConfiged方法。</p>\n<p>4   当传入不同币种的时候，generateWithdrawRequest产生不同的请求。</p>\n<p>我们仅仅需要验证这些就够了，因为TaskCenterWithdrawServiceImpl得协作者的产生的行为仅仅如此，至于协作者行为的可靠性，需要协作者自身去验证，而不是在该测试中验证。</p>\n<h3 id=\"第一步-依赖注入解耦\"><a href=\"#第一步-依赖注入解耦\" class=\"headerlink\" title=\"第一步 依赖注入解耦\"></a>第一步 依赖注入解耦</h3><p>spring字段注入导致单元测试困难，因为你无法实例化类中的对象，所以在TaskCenterWithdrawServiceImpl中将字段注入改成构造器注入或者属性注入。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TaskCenterWithdrawServiceImpl</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> HttpEncryptDecryptEngine httpEncryptDecryptEngine;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> WithdrawService withdrawService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setHttpEncryptDecryptEngine</span><span class=\"params\">(HttpEncryptDecryptEngine httpEncryptDecryptEngine)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.httpEncryptDecryptEngine = httpEncryptDecryptEngine;</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setWithdrawService</span><span class=\"params\">(WithdrawService withdrawService)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">this</span>.withdrawService = withdrawService;</span><br><span class=\"line\">    &#125;</span><br></pre></td></tr></table></figure>\n\n\n<h3 id=\"第二步-静态方法抽离接口\"><a href=\"#第二步-静态方法抽离接口\" class=\"headerlink\" title=\"第二步 静态方法抽离接口\"></a>第二步 静态方法抽离接口</h3><p>不是所有静态方法都需要抽离成接口，由于项目中CoinSymbolUtils.getSaaSInfo调用了数据库和redis，所以此时你无法真实调用数据库和redis，因为在脱离spring环境你无法创建这两个对象，所以抽离成接口可以mock改接口。如果是普通的工具类，让他执行即可。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">interface</span> <span class=\"title\">CoinSymbolOperator</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"function\">ConfigCoinSymbol <span class=\"title\">getSaaSInfoAll</span><span class=\"params\">(String coinSymbol)</span></span>;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n<p>之前工具类实现该接口，并且调用之前静态方法。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Component</span></span><br><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">CoinSymbolUtils</span> <span class=\"keyword\">implements</span>  <span class=\"title\">CoinSymbolOperator</span> </span>&#123;</span><br><span class=\"line\"></span><br><span class=\"line\">   <span class=\"function\"><span class=\"keyword\">public</span> ConfigCoinSymbol <span class=\"title\">getSaaSInfoAll</span><span class=\"params\">(String coinSymbol)</span> </span>&#123;</span><br><span class=\"line\">        <span class=\"keyword\">return</span> getSaaSInfo(coinSymbol);</span><br><span class=\"line\">   &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"第三步-测试mock对象\"><a href=\"#第三步-测试mock对象\" class=\"headerlink\" title=\"第三步 测试mock对象\"></a>第三步 测试mock对象</h3><p>mock对象我们使用的是<strong>mockito</strong>框架。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">TaskCenterWithdrawServiceMockTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//待测试的类</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> TaskCenterWithdrawServiceImpl taskCenterWithdrawService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> HttpEncryptDecryptEngine httpEncryptDecryptEngine;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> WithdrawService withdrawService;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"keyword\">private</span> CoinSymbolOperator coinSymbolOperator;</span><br><span class=\"line\"></span><br><span class=\"line\"><span class=\"meta\">@Before</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">setup</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"comment\">//创建TaskCenterWithdrawService对象</span></span><br><span class=\"line\">    httpEncryptDecryptEngine = mock(HttpEncryptDecryptEngine<span class=\"class\">.<span class=\"keyword\">class</span>)</span>;</span><br><span class=\"line\">    withdrawService = mock(WithdrawService<span class=\"class\">.<span class=\"keyword\">class</span>)</span>;</span><br><span class=\"line\">    <span class=\"comment\">//mock静态方法拆离的接口在这里需要注入到TaskCenterWithdrawService中</span></span><br><span class=\"line\">    coinSymbolOperator = mock(CoinSymbolOperator<span class=\"class\">.<span class=\"keyword\">class</span>)</span>;</span><br><span class=\"line\">    taskCenterWithdrawService = <span class=\"keyword\">new</span> <span class=\"keyword\">new</span> TaskCenterWithdrawServiceImpl();</span><br><span class=\"line\">    taskCenterWithdrawService.setHttpEncryptDecryptEngine(httpEncryptDecryptEngine);</span><br><span class=\"line\">    taskCenterWithdrawService.setWithdrawService(withdrawService);</span><br><span class=\"line\">    taskCenterWithdrawService.setCoinSymbolOperator(coinSymbolOperator);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h3 id=\"第四步-编写测试方法\"><a href=\"#第四步-编写测试方法\" class=\"headerlink\" title=\"第四步 编写测试方法\"></a>第四步 编写测试方法</h3><p>测试方法必须要写assertions和你要验证的东西，否则这个单元测试没有意义。这个测试没有用到<strong>assertj</strong>  ，而是使用了<strong>mockito</strong>自带的verify方法验证。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br><span class=\"line\">39</span><br><span class=\"line\">40</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"meta\">@Test</span></span><br><span class=\"line\"><span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">startWithdraw</span><span class=\"params\">()</span> </span>&#123; </span><br><span class=\"line\">    <span class=\"comment\">//given willReturn 短语帮助我们构造期望的输入和输出，含义是当满足xxx条件时候，发生什么，期望什么结果。</span></span><br><span class=\"line\">    <span class=\"comment\">//当给getWalletUid传入任意int和string时候，调用cryptoAddressService.getWalletUid，期望返回123</span></span><br><span class=\"line\">    given(cryptoAddressService.getWalletUid(anyInt(), anyString())).willReturn(<span class=\"number\">123</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//构造期望的返回值</span></span><br><span class=\"line\">    TransactionWithdrawCrypto transactionWithdrawCrypto = <span class=\"keyword\">new</span> TransactionWithdrawCrypto();</span><br><span class=\"line\">    transactionWithdrawCrypto.setAddressFrom(<span class=\"string\">\"alibaba\"</span>);</span><br><span class=\"line\">    transactionWithdrawCrypto.setFee(<span class=\"keyword\">new</span> BigDecimal(<span class=\"string\">\"456.777\"</span>));</span><br><span class=\"line\">    transactionWithdrawCrypto.setSymbol(<span class=\"string\">\"USDT\"</span>);</span><br><span class=\"line\">    transactionWithdrawCrypto.setAddressTo(<span class=\"string\">\"baidu\"</span>);</span><br><span class=\"line\">    transactionWithdrawCrypto.setUid(<span class=\"number\">111111111</span>);</span><br><span class=\"line\"></span><br><span class=\"line\">    transactionWithdrawCrypto.setAmount(<span class=\"keyword\">new</span> BigDecimal(<span class=\"string\">\"123.444\"</span>));</span><br><span class=\"line\">    <span class=\"comment\">//构造期望输入和输出</span></span><br><span class=\"line\">    given(withdrawService.selectByIdAndLock(anyInt())).willReturn(transactionWithdrawCrypto);</span><br><span class=\"line\"></span><br><span class=\"line\">    ConfigCoinSymbol ccs = <span class=\"keyword\">new</span> ConfigCoinSymbol();</span><br><span class=\"line\">    ccs.setTokenBase(<span class=\"string\">\"BTC\"</span>);</span><br><span class=\"line\">    ccs.setContractAddress(<span class=\"string\">\"BTC_ContractAddress\"</span>);</span><br><span class=\"line\">    <span class=\"comment\">//构造期望输入和输出</span></span><br><span class=\"line\">    given(coinSymbolOperator.from(<span class=\"string\">\"USDT\"</span>)).willReturn(ccs);</span><br><span class=\"line\"></span><br><span class=\"line\">    Map&lt;String,String&gt; result = <span class=\"keyword\">new</span> HashMap&lt;&gt;();</span><br><span class=\"line\">    result.put(<span class=\"string\">\"code\"</span>, WalletResponseCode.SUCCESS.getCode());</span><br><span class=\"line\">    result.put(<span class=\"string\">\"message\"</span>, WalletResponseCode.SUCCESS.getMessage());</span><br><span class=\"line\">    <span class=\"comment\">//构造期望输入和输出</span></span><br><span class=\"line\">    given(httpEncryptDecryptEngine.startWithdraw(anyString(), anyString())).willReturn(JSON.toJSONString(result));</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//和given，willReturn一样的效果</span></span><br><span class=\"line\">    <span class=\"comment\">//when(httpEncryptDecryptEngine.startWithdraw(anyString(), anyString())).thenReturn(\"111111111\");</span></span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//这一步是将之前mock的对象和数据以及构造期望输入和输出串联起来执行。</span></span><br><span class=\"line\">    taskCenterWithdrawService.startWithdraw(<span class=\"string\">\"USDT\"</span>, <span class=\"string\">\"BTC\"</span>, <span class=\"string\">\"aaaa\"</span>, <span class=\"keyword\">new</span> TransactionWithdrawCrypto());</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"comment\">//由于该方法是void所以需要验证方法是否被调用.比如断言getWalletUid是否被调用，比如第三方接口返回值不同调用不同的方法</span></span><br><span class=\"line\">    <span class=\"comment\">//来使得代码覆盖率比较高</span></span><br><span class=\"line\">    verify(<span class=\"keyword\">this</span>.cryptoAddressService).getWalletUid(<span class=\"number\">111111111</span>, <span class=\"string\">\"BTC\"</span>);</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<h2 id=\"案例二：关联数据库的单元测试\"><a href=\"#案例二：关联数据库的单元测试\" class=\"headerlink\" title=\"案例二：关联数据库的单元测试\"></a>案例二：关联数据库的单元测试</h2><p>有些测试必须关联数据库或者第三方接口，此时不得不接受使用外部资源这一现实。这时候测试关联数据库的必须保证测试前数据库状态和测试后状态一致。我们来建立一个test fixture来验证一个CRUD的正确性。在每个方法执行前用@BeforeEach中建立Account对象，在integrateTestDataBaseCRUD中测试CRUD方法，在每个方法结束后用@AfterEach清除数据库对象，使得测试前后数据库状态幂等。我曾经遇到一个必须使用第三方资源场景是 本地代码必须调用第三方接口来验证程序，以及在集成测试时候，也主要验证第三方接口，程序本身逻辑很少。这时候就必须使用外部依赖来完成单元测试。</p>\n<figure class=\"highlight java\"><table><tr><td class=\"gutter\"><pre><span class=\"line\">1</span><br><span class=\"line\">2</span><br><span class=\"line\">3</span><br><span class=\"line\">4</span><br><span class=\"line\">5</span><br><span class=\"line\">6</span><br><span class=\"line\">7</span><br><span class=\"line\">8</span><br><span class=\"line\">9</span><br><span class=\"line\">10</span><br><span class=\"line\">11</span><br><span class=\"line\">12</span><br><span class=\"line\">13</span><br><span class=\"line\">14</span><br><span class=\"line\">15</span><br><span class=\"line\">16</span><br><span class=\"line\">17</span><br><span class=\"line\">18</span><br><span class=\"line\">19</span><br><span class=\"line\">20</span><br><span class=\"line\">21</span><br><span class=\"line\">22</span><br><span class=\"line\">23</span><br><span class=\"line\">24</span><br><span class=\"line\">25</span><br><span class=\"line\">26</span><br><span class=\"line\">27</span><br><span class=\"line\">28</span><br><span class=\"line\">29</span><br><span class=\"line\">30</span><br><span class=\"line\">31</span><br><span class=\"line\">32</span><br><span class=\"line\">33</span><br><span class=\"line\">34</span><br><span class=\"line\">35</span><br><span class=\"line\">36</span><br><span class=\"line\">37</span><br><span class=\"line\">38</span><br></pre></td><td class=\"code\"><pre><span class=\"line\"><span class=\"keyword\">public</span> <span class=\"class\"><span class=\"keyword\">class</span> <span class=\"title\">AccountServiceTest</span> </span>&#123;</span><br><span class=\"line\">    <span class=\"meta\">@Autowired</span></span><br><span class=\"line\">    <span class=\"keyword\">private</span> AccountService accountService;</span><br><span class=\"line\">    <span class=\"keyword\">private</span> Account account;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@BeforeEach</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">setUp</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        account = Account.builder().</span><br><span class=\"line\">                balance(<span class=\"keyword\">new</span> BigDecimal(<span class=\"string\">\"67.88\"</span>)).</span><br><span class=\"line\">                type(<span class=\"number\">111</span>).</span><br><span class=\"line\">                uid(<span class=\"number\">445</span>).</span><br><span class=\"line\">                tag(<span class=\"string\">\"33\"</span>).</span><br><span class=\"line\">                build();</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@Test</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">public</span> <span class=\"keyword\">void</span> <span class=\"title\">integrateTestDataBaseCRUD</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        accountService.insert(account);</span><br><span class=\"line\">        <span class=\"keyword\">long</span> id = account.getId();</span><br><span class=\"line\">        Account accountFind = accountService.get(id);</span><br><span class=\"line\">        accountFind.setBalance(<span class=\"keyword\">new</span> BigDecimal(<span class=\"string\">\"366334\"</span>));</span><br><span class=\"line\">        accountService.update(accountFind);</span><br><span class=\"line\">        Account accountUpdate = accountService.get(id);</span><br><span class=\"line\">        accountService.delete(id);</span><br><span class=\"line\">        Account accountDelete = accountService.get(id);</span><br><span class=\"line\"></span><br><span class=\"line\">        assertAll(<span class=\"string\">\"test\"</span>, () -&gt; &#123;</span><br><span class=\"line\">            assertEquals(accountFind.getBalance().stripTrailingZeros().toPlainString(),</span><br><span class=\"line\">                    accountUpdate.getBalance().stripTrailingZeros().toPlainString());</span><br><span class=\"line\">        &#125;);</span><br><span class=\"line\">        assertNull(accountDelete);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\"></span><br><span class=\"line\">    <span class=\"meta\">@AfterEach</span></span><br><span class=\"line\">    <span class=\"function\"><span class=\"keyword\">void</span> <span class=\"title\">tearDown</span><span class=\"params\">()</span> </span>&#123;</span><br><span class=\"line\">        accountService.delete(id);</span><br><span class=\"line\">    &#125;</span><br><span class=\"line\">&#125;</span><br></pre></td></tr></table></figure>\n\n\n\n<p>我们可以看到上述两个案例都是先写代码后写单元测试，这样可能导致单元测试很难测试代码，给遗留系统添加单元测试也很繁琐，所以需要从设计层面改进代码，使之更加容易测试和验证。更优秀的做法是实践TDD，这样代码天然可测试。</p>\n<h1 id=\"常见问题\"><a href=\"#常见问题\" class=\"headerlink\" title=\"常见问题\"></a>常见问题</h1><p><strong>1 单元测试的价值在哪里？</strong> 1  保证代码质量，当然质量保证不仅仅靠单元测试。当你看到队友提交了一些代码，确发现单元测试覆盖率降低了，就知道他的提交可能带来代码质量下降。 2  代码可测试性往往带来灵活的设计。  3  你不仅仅在写单元测试，而是实践自动化测试，实践着CI </p>\n<p><strong>2  遗留系统很多没有单元测试，我需要补吗？</strong>1  当你修改老代码的时候，加一个单元测试。 2 依赖最多的，访问最多的需要补充。 3 试图在遗留系统上加单元测试很困难，并且使之成为自动化测试，但是需要尝试，新的代码尝试TDD。</p>\n<p><strong>3  我觉得有些情况需要读取数据库，看到数据落库心里才踏实，这时候写单元测试需要连数据库吗？</strong>单元测试不连库，连库的叫集成测试，单元测试验证是逻辑，数据库只是细节实现，你的代码可以脱离SSM，MySQL….. 在实践中你会真正理解解耦的。你的踏实和自信应该建立在独立性和不依赖外界细节上，而不是数据归属地到底是哪里。如果一些测试必须要用数据库，请使用test fixture。保证单元测试前和单元测试后数据库状态一致。</p>\n<p><strong>4  什么时候用Mock或者Stub？</strong> 能不用就不用，最简单的方式验证你的代码是否正确。</p>\n<p><strong>5  DAO层的实体对象需要手动new吗？</strong> 取决于你验证的是什么。随着积累会建立实体对象的测试仓库。</p>\n<p><strong>6  单元测试能检测什么类型bug？</strong> 测不出与数据库交互和第三方接口的BUG，这不是单元测试职责，但是你可以在单元测试中调用第三方，然后发布时候@Disable该测试即可。</p>\n<p><strong>7 为什么不用junit自带的断言，而是第三方断言？</strong> junit断言可读性不好，而且需要自己写断言逻辑，assertXXX，而assertj里面assertThat可以方便断言和真正验证的东西相匹配。</p>\n<p><strong>8 先写测试还是先写代码？</strong> 先写测试的系统天然适合自动化测试，先写代码在写测试，极大可能不写测试了。</p>\n<p>这些只是个人观点，实践过程有更好的方法或者理解，可以推翻。单元测试价值不应该被夸大，但也不该被忽视。它是能提高设计和质量的重要工具，因为相信，所以看见。</p>\n<h1 id=\"参考书籍\"><a href=\"#参考书籍\" class=\"headerlink\" title=\"参考书籍\"></a>参考书籍</h1><ul>\n<li>《测试驱动开发》</li>\n<li>《持续集成-软件质量改进和风险降低之道》</li>\n</ul>\n"}],"PostAsset":[],"PostCategory":[{"post_id":"clh7s5cti0007xt8j3dg7d9ao","category_id":"clh7s5ctf0004xt8jfu9wbegj","_id":"clh7s5ctu000uxt8j4dr9g6fn"},{"post_id":"clh7s5cti0007xt8j3dg7d9ao","category_id":"clh7s5ctp000kxt8j30libp8v","_id":"clh7s5ctu000xxt8jgvtxdeam"},{"post_id":"clh7s5ct80000xt8jb5dkdqe1","category_id":"clh7s5ctf0004xt8jfu9wbegj","_id":"clh7s5ctv0010xt8j43fkgtd2"},{"post_id":"clh7s5ct80000xt8jb5dkdqe1","category_id":"clh7s5ctp000kxt8j30libp8v","_id":"clh7s5ctw0015xt8j9wix7fa6"},{"post_id":"clh7s5ctt000sxt8j0fn4eyva","category_id":"clh7s5ctf0004xt8jfu9wbegj","_id":"clh7s5ctx0018xt8j2krx91d7"},{"post_id":"clh7s5ctt000sxt8j0fn4eyva","category_id":"clh7s5ctp000kxt8j30libp8v","_id":"clh7s5cty001dxt8j2vq0f9kz"},{"post_id":"clh7s5cti0008xt8j6m2lc7gq","category_id":"clh7s5ctf0004xt8jfu9wbegj","_id":"clh7s5ctz001fxt8j7bhv519x"},{"post_id":"clh7s5cti0008xt8j6m2lc7gq","category_id":"clh7s5ctt000txt8j9w7zacve","_id":"clh7s5cu0001jxt8jg14742qe"},{"post_id":"clh7s5ctk000cxt8j6ntw9dew","category_id":"clh7s5ctv0012xt8jhsehamt7","_id":"clh7s5cu1001mxt8jfg73afop"},{"post_id":"clh7s5cte0002xt8jac0p7s9t","category_id":"clh7s5ctj0009xt8j0tox5dqc","_id":"clh7s5cu2001rxt8j3dva3sbn"},{"post_id":"clh7s5cte0002xt8jac0p7s9t","category_id":"clh7s5cty001bxt8jgj4u5bbk","_id":"clh7s5cu3001txt8j1vcv0a8n"},{"post_id":"clh7s5ctl000ext8jalt276aa","category_id":"clh7s5ctf0004xt8jfu9wbegj","_id":"clh7s5cu4001xxt8j6huh0hw1"},{"post_id":"clh7s5ctl000ext8jalt276aa","category_id":"clh7s5ctt000txt8j9w7zacve","_id":"clh7s5cu50020xt8jep6d9k0y"},{"post_id":"clh7s5ctn000hxt8jbeqzg5dn","category_id":"clh7s5ctf0004xt8jfu9wbegj","_id":"clh7s5cu60025xt8jgey33bgi"},{"post_id":"clh7s5ctn000hxt8jbeqzg5dn","category_id":"clh7s5ctt000txt8j9w7zacve","_id":"clh7s5cu60028xt8j5d2wetk6"},{"post_id":"clh7s5cth0006xt8jgodo3cze","category_id":"clh7s5ctf0004xt8jfu9wbegj","_id":"clh7s5cu7002bxt8j7tpl7jn6"},{"post_id":"clh7s5cth0006xt8jgodo3cze","category_id":"clh7s5ctp000kxt8j30libp8v","_id":"clh7s5cu8002fxt8j0u4b73ab"},{"post_id":"clh7s5cto000jxt8j7z3e2joi","category_id":"clh7s5cu50023xt8j2bsn6aqp","_id":"clh7s5cu9002hxt8j7skk4h2u"},{"post_id":"clh7s5ctq000mxt8j9xk488ks","category_id":"clh7s5ctf0004xt8jfu9wbegj","_id":"clh7s5cub002mxt8j9h7b1g6f"},{"post_id":"clh7s5ctq000mxt8j9xk488ks","category_id":"clh7s5cu7002axt8jhp8l374n","_id":"clh7s5cuc002qxt8j3xd7ddca"},{"post_id":"clh7s5ctq000oxt8jhrcc19ff","category_id":"clh7s5cu9002ixt8jft0v8lhz","_id":"clh7s5cuc002txt8jdzxda52o"},{"post_id":"clh7s5ctu000wxt8jbj1mcu9b","category_id":"clh7s5cuc002uxt8j162ya1rr","_id":"clh7s5cud002zxt8j5mmgfssz"},{"post_id":"clh7s5ctw0013xt8j2r8cfnv3","category_id":"clh7s5cud0030xt8j9zs7g58m","_id":"clh7s5cuf0037xt8j6lji2wav"},{"post_id":"clh7s5ctx0017xt8jc7kza6x7","category_id":"clh7s5cue0034xt8je3jffvo0","_id":"clh7s5cuf003cxt8jhi77d8rn"},{"post_id":"clh7s5ctx001axt8jhx4ic87y","category_id":"clh7s5ctf0004xt8jfu9wbegj","_id":"clh7s5cug003gxt8jdwgyd89r"},{"post_id":"clh7s5ctx001axt8jhx4ic87y","category_id":"clh7s5cu7002axt8jhp8l374n","_id":"clh7s5cug003ixt8jbqx9bphq"},{"post_id":"clh7s5ctz001gxt8jcvt49bcb","category_id":"clh7s5cud0030xt8j9zs7g58m","_id":"clh7s5cuh003nxt8j0z9e3mce"},{"post_id":"clh7s5cu4001zxt8ja4m03ej6","category_id":"clh7s5cud002xxt8j8e3ncpnu","_id":"clh7s5cuk0040xt8j089t0njd"},{"post_id":"clh7s5cu60029xt8j7bm25rky","category_id":"clh7s5cuk0043xt8j1idx6tvi","_id":"clh7s5cul004bxt8jh4e139ad"},{"post_id":"clh7s5cua002lxt8j5quuagbk","category_id":"clh7s5ctj0009xt8j0tox5dqc","_id":"clh7s5cun004mxt8jbz2ggwcn"},{"post_id":"clh7s5cua002lxt8j5quuagbk","category_id":"clh7s5cum004fxt8j16z28ws1","_id":"clh7s5cun004pxt8j4vjd77d4"},{"post_id":"clh7s5cts000rxt8jeb53ajzh","category_id":"clh7s5cub002oxt8jc8mlbl1f","_id":"clh7s5cuo004uxt8je7i77c2b"},{"post_id":"clh7s5cts000rxt8jeb53ajzh","category_id":"clh7s5cun004oxt8j0sai266m","_id":"clh7s5cuo004xxt8j99898spr"},{"post_id":"clh7s5ctv000zxt8j28pf5tx2","category_id":"clh7s5cud002xxt8j8e3ncpnu","_id":"clh7s5cup004zxt8j4umq3s7w"},{"post_id":"clh7s5ctv000zxt8j28pf5tx2","category_id":"clh7s5cun004sxt8j98wf0r9o","_id":"clh7s5cup0052xt8j03st3z5o"},{"post_id":"clh7s5cu1001oxt8jfl9s5wua","category_id":"clh7s5cuh003mxt8j970xbong","_id":"clh7s5cuq0058xt8j4vrr9fwc"},{"post_id":"clh7s5cu1001oxt8jfl9s5wua","category_id":"clh7s5cup0054xt8j5lwl9u8f","_id":"clh7s5cuq005bxt8jgvut06bz"},{"post_id":"clh7s5cu2001sxt8j4d3ub029","category_id":"clh7s5cud0030xt8j9zs7g58m","_id":"clh7s5cur005fxt8jb3f4gbgj"},{"post_id":"clh7s5cu2001sxt8j4d3ub029","category_id":"clh7s5cuq0056xt8j749x2oah","_id":"clh7s5cur005hxt8j1eoo9xdx"},{"post_id":"clh7s5cu50022xt8jgru837ac","category_id":"clh7s5cuh003mxt8j970xbong","_id":"clh7s5cur005jxt8j3im91m7p"},{"post_id":"clh7s5cu50022xt8jgru837ac","category_id":"clh7s5cup0054xt8j5lwl9u8f","_id":"clh7s5cus005mxt8j3478dddp"},{"post_id":"clh7s5cu60026xt8j8ez5053g","category_id":"clh7s5cuj003zxt8jfeu4fe28","_id":"clh7s5cus005pxt8j37lagyov"},{"post_id":"clh7s5cu60026xt8j8ez5053g","category_id":"clh7s5cur005ext8j0nhz2o6j","_id":"clh7s5cus005rxt8j98pc29ez"},{"post_id":"clh7s5cu8002dxt8j3pyudln2","category_id":"clh7s5cuj003zxt8jfeu4fe28","_id":"clh7s5cut005txt8j6uczcp1p"},{"post_id":"clh7s5cu8002dxt8j3pyudln2","category_id":"clh7s5cur005ext8j0nhz2o6j","_id":"clh7s5cut005uxt8jdbbfet0d"},{"post_id":"clh7s5cu8002gxt8jbrsdc09j","category_id":"clh7s5cuj003zxt8jfeu4fe28","_id":"clh7s5cut005vxt8javlre4pq"},{"post_id":"clh7s5cu8002gxt8jbrsdc09j","category_id":"clh7s5cur005ext8j0nhz2o6j","_id":"clh7s5cut005xxt8j2qlydhw0"},{"post_id":"clh7s5cu9002kxt8j9gv409ar","category_id":"clh7s5cul004dxt8jgg8851ow","_id":"clh7s5cut005yxt8jdlur5thc"},{"post_id":"clh7s5cu9002kxt8j9gv409ar","category_id":"clh7s5cus005sxt8j9ckhd1ia","_id":"clh7s5cut0060xt8je8p1hspm"},{"post_id":"clh7s5cub002nxt8j5zot848w","category_id":"clh7s5cun004kxt8j2b4vflto","_id":"clh7s5cuu0061xt8jbne7f26f"},{"post_id":"clh7s5cub002nxt8j5zot848w","category_id":"clh7s5cut005wxt8jap6vfc27","_id":"clh7s5cuu0063xt8jgpyg5eyx"},{"post_id":"clh7s5cty001ext8jglv0he17","category_id":"clh7s5cud0030xt8j9zs7g58m","_id":"clh7s5cuu0064xt8jgaref1m6"},{"post_id":"clh7s5cty001ext8jglv0he17","category_id":"clh7s5cuo004wxt8j1df77lxk","_id":"clh7s5cuu0065xt8j1509d63a"},{"post_id":"clh7s5cty001ext8jglv0he17","category_id":"clh7s5cut005zxt8j2zdceti1","_id":"clh7s5cuu0066xt8j2pm85trv"},{"post_id":"clh7s5cu0001lxt8j7sy104pt","category_id":"clh7s5cud0030xt8j9zs7g58m","_id":"clh7s5cuu0067xt8jgyexbkct"},{"post_id":"clh7s5cu0001lxt8j7sy104pt","category_id":"clh7s5cuo004wxt8j1df77lxk","_id":"clh7s5cuu0068xt8j1x6j598g"},{"post_id":"clh7s5cu0001lxt8j7sy104pt","category_id":"clh7s5cut005zxt8j2zdceti1","_id":"clh7s5cuu0069xt8jds8phvj0"}],"PostTag":[{"post_id":"clh7s5cti0007xt8j3dg7d9ao","tag_id":"clh7s5ctg0005xt8j3nn3gj6p","_id":"clh7s5ctk000bxt8jenzgcyjp"},{"post_id":"clh7s5ct80000xt8jb5dkdqe1","tag_id":"clh7s5ctg0005xt8j3nn3gj6p","_id":"clh7s5ctl000dxt8jesmud88h"},{"post_id":"clh7s5cte0002xt8jac0p7s9t","tag_id":"clh7s5ctj000axt8jg9tqecss","_id":"clh7s5cto000ixt8jftqbakmi"},{"post_id":"clh7s5cth0006xt8jgodo3cze","tag_id":"clh7s5ctg0005xt8j3nn3gj6p","_id":"clh7s5ctq000nxt8j0opx9yva"},{"post_id":"clh7s5cti0008xt8j6m2lc7gq","tag_id":"clh7s5ctp000lxt8jaztv3cvf","_id":"clh7s5ctu000yxt8j6p6rf2nk"},{"post_id":"clh7s5cti0008xt8j6m2lc7gq","tag_id":"clh7s5ctr000qxt8jg1whapc3","_id":"clh7s5ctv0011xt8jgm51hpcw"},{"post_id":"clh7s5ctt000sxt8j0fn4eyva","tag_id":"clh7s5ctg0005xt8j3nn3gj6p","_id":"clh7s5ctx0016xt8j519w6x2w"},{"post_id":"clh7s5ctk000cxt8j6ntw9dew","tag_id":"clh7s5ctu000vxt8jgz6f1hro","_id":"clh7s5ctx0019xt8jal7m1ns2"},{"post_id":"clh7s5ctl000ext8jalt276aa","tag_id":"clh7s5ctp000lxt8jaztv3cvf","_id":"clh7s5cu0001kxt8j5xwd9gck"},{"post_id":"clh7s5ctl000ext8jalt276aa","tag_id":"clh7s5ctr000qxt8jg1whapc3","_id":"clh7s5cu1001nxt8j2w2zconw"},{"post_id":"clh7s5ctn000hxt8jbeqzg5dn","tag_id":"clh7s5ctp000lxt8jaztv3cvf","_id":"clh7s5cu4001yxt8j2wx5el61"},{"post_id":"clh7s5ctn000hxt8jbeqzg5dn","tag_id":"clh7s5ctr000qxt8jg1whapc3","_id":"clh7s5cu50021xt8j18dgftca"},{"post_id":"clh7s5cto000jxt8j7z3e2joi","tag_id":"clh7s5cu3001vxt8jewg58x3p","_id":"clh7s5cu60027xt8jcqn87owy"},{"post_id":"clh7s5ctq000mxt8j9xk488ks","tag_id":"clh7s5cu50024xt8j2preblvl","_id":"clh7s5cu8002ext8jf2j5b0bu"},{"post_id":"clh7s5ctq000oxt8jhrcc19ff","tag_id":"clh7s5cu7002cxt8javm71gfl","_id":"clh7s5cuc002rxt8jek2i853f"},{"post_id":"clh7s5ctq000oxt8jhrcc19ff","tag_id":"clh7s5cu9002jxt8jcwq6hnfg","_id":"clh7s5cuc002sxt8j94859oap"},{"post_id":"clh7s5cts000rxt8jeb53ajzh","tag_id":"clh7s5cub002pxt8jcex5bd4s","_id":"clh7s5cud002wxt8j84yw8k3u"},{"post_id":"clh7s5ctu000wxt8jbj1mcu9b","tag_id":"clh7s5cuc002vxt8j3wgv9dj7","_id":"clh7s5cue0032xt8j7yel58bu"},{"post_id":"clh7s5ctu000wxt8jbj1mcu9b","tag_id":"clh7s5cud002yxt8j54l405nv","_id":"clh7s5cue0033xt8jgjk67j6s"},{"post_id":"clh7s5ctv000zxt8j28pf5tx2","tag_id":"clh7s5cue0031xt8jfrjjeq5j","_id":"clh7s5cue0036xt8jghfvgcib"},{"post_id":"clh7s5ctw0013xt8j2r8cfnv3","tag_id":"clh7s5cue0035xt8j40wz9pgk","_id":"clh7s5cuf003axt8j4w4zflvq"},{"post_id":"clh7s5ctx0017xt8jc7kza6x7","tag_id":"clh7s5cuf0039xt8jf851b1eg","_id":"clh7s5cug003ext8j0jmx0wyl"},{"post_id":"clh7s5ctx001axt8jhx4ic87y","tag_id":"clh7s5cuf003dxt8j2kp4crwk","_id":"clh7s5cuh003lxt8jfving3pr"},{"post_id":"clh7s5ctx001axt8jhx4ic87y","tag_id":"clh7s5cug003hxt8j9mih3u2s","_id":"clh7s5cuh003oxt8j1luzflji"},{"post_id":"clh7s5cty001ext8jglv0he17","tag_id":"clh7s5cue0035xt8j40wz9pgk","_id":"clh7s5cui003sxt8j78myhbjm"},{"post_id":"clh7s5cty001ext8jglv0he17","tag_id":"clh7s5cuh003pxt8jhae8hmsk","_id":"clh7s5cui003uxt8je5c5bubm"},{"post_id":"clh7s5ctz001gxt8jcvt49bcb","tag_id":"clh7s5cui003rxt8jeguphucl","_id":"clh7s5cuj003wxt8j8wxgdgow"},{"post_id":"clh7s5cu0001lxt8j7sy104pt","tag_id":"clh7s5cue0035xt8j40wz9pgk","_id":"clh7s5cuk0042xt8jbi0k0dgv"},{"post_id":"clh7s5cu0001lxt8j7sy104pt","tag_id":"clh7s5cuh003pxt8jhae8hmsk","_id":"clh7s5cuk0044xt8jefmueihj"},{"post_id":"clh7s5cu1001oxt8jfl9s5wua","tag_id":"clh7s5cuk0041xt8j109a4d32","_id":"clh7s5cuk0046xt8jfhwk514f"},{"post_id":"clh7s5cu2001sxt8j4d3ub029","tag_id":"clh7s5cuk0045xt8jdvnt9wmp","_id":"clh7s5cul0049xt8j2juk98pq"},{"post_id":"clh7s5cu4001zxt8ja4m03ej6","tag_id":"clh7s5cul0048xt8j4mou9b5g","_id":"clh7s5cum004gxt8j63lf88bt"},{"post_id":"clh7s5cu4001zxt8ja4m03ej6","tag_id":"clh7s5cul004cxt8jhzry6ud0","_id":"clh7s5cum004hxt8j5jf91us9"},{"post_id":"clh7s5cu50022xt8jgru837ac","tag_id":"clh7s5cuk0041xt8j109a4d32","_id":"clh7s5cum004jxt8jga3k0u8k"},{"post_id":"clh7s5cu60026xt8j8ez5053g","tag_id":"clh7s5cum004ixt8j5xywcw4p","_id":"clh7s5cun004nxt8j0k8ffhy5"},{"post_id":"clh7s5cu60029xt8j7bm25rky","tag_id":"clh7s5cun004lxt8j4udmc4t4","_id":"clh7s5cun004rxt8j0j3cddd4"},{"post_id":"clh7s5cu8002dxt8j3pyudln2","tag_id":"clh7s5cun004qxt8j3musagd3","_id":"clh7s5cuo004vxt8j7nhyf8bv"},{"post_id":"clh7s5cu8002gxt8jbrsdc09j","tag_id":"clh7s5cuo004txt8jfxyjcvum","_id":"clh7s5cup0050xt8j9ezd748y"},{"post_id":"clh7s5cu9002kxt8j9gv409ar","tag_id":"clh7s5cuo004yxt8j09zr79w6","_id":"clh7s5cuq005axt8jeoxq2l5m"},{"post_id":"clh7s5cu9002kxt8j9gv409ar","tag_id":"clh7s5cup0053xt8jhrin5kab","_id":"clh7s5cur005cxt8jc8ze88kc"},{"post_id":"clh7s5cu9002kxt8j9gv409ar","tag_id":"clh7s5cup0055xt8j1jwcdv3b","_id":"clh7s5cur005gxt8j2gpmcg6u"},{"post_id":"clh7s5cua002lxt8j5quuagbk","tag_id":"clh7s5cuq0057xt8j132qcd2t","_id":"clh7s5cus005lxt8jcqsthpdt"},{"post_id":"clh7s5cua002lxt8j5quuagbk","tag_id":"clh7s5cur005dxt8j0y59fbro","_id":"clh7s5cus005nxt8j8vjw02z3"},{"post_id":"clh7s5cub002nxt8j5zot848w","tag_id":"clh7s5cur005ixt8j959yggad","_id":"clh7s5cus005qxt8j69cf6gc7"}],"Tag":[{"name":"java.util.concurrent","_id":"clh7s5ctg0005xt8j3nn3gj6p"},{"name":"algorithm","_id":"clh7s5ctj000axt8jg9tqecss"},{"name":"java.util.*","_id":"clh7s5ctp000lxt8jaztv3cvf"},{"name":"java collection framework","_id":"clh7s5ctr000qxt8jg1whapc3"},{"name":"2020尾声规划","_id":"clh7s5ctu000vxt8jgz6f1hro"},{"name":"代码设计杂谈","_id":"clh7s5cu3001vxt8jewg58x3p"},{"name":"java.lang","_id":"clh7s5cu50024xt8j2preblvl"},{"name":"内存溢出","_id":"clh7s5cu7002cxt8javm71gfl"},{"name":"内存泄露","_id":"clh7s5cu9002jxt8jcwq6hnfg"},{"name":"house","_id":"clh7s5cub002pxt8jcex5bd4s"},{"name":"数据同步","_id":"clh7s5cuc002vxt8j3wgv9dj7"},{"name":"MySQL和Redis","_id":"clh7s5cud002yxt8j54l405nv"},{"name":"SQL","_id":"clh7s5cue0031xt8jfrjjeq5j"},{"name":"分布式系统泛型","_id":"clh7s5cue0035xt8j40wz9pgk"},{"name":"guava-retry","_id":"clh7s5cuf0039xt8jf851b1eg"},{"name":"java.lang.reflect","_id":"clh7s5cuf003dxt8j2kp4crwk"},{"name":"Java-Core","_id":"clh7s5cug003hxt8j9mih3u2s"},{"name":"elasticsearch","_id":"clh7s5cuh003pxt8jhae8hmsk"},{"name":"分布式事务","_id":"clh7s5cui003rxt8jeguphucl"},{"name":"kafka","_id":"clh7s5cuk0041xt8j109a4d32"},{"name":"distributed system","_id":"clh7s5cuk0045xt8jdvnt9wmp"},{"name":"读写分离","_id":"clh7s5cul0048xt8j4mou9b5g"},{"name":"应用设计","_id":"clh7s5cul004cxt8jhzry6ud0"},{"name":"软考","_id":"clh7s5cum004ixt8j5xywcw4p"},{"name":"OOD","_id":"clh7s5cun004lxt8j4udmc4t4"},{"name":"高级架构师案例分析","_id":"clh7s5cun004qxt8j3musagd3"},{"name":"高级架构师论文","_id":"clh7s5cuo004txt8jfxyjcvum"},{"name":"软件系统模型","_id":"clh7s5cuo004yxt8j09zr79w6"},{"name":"COSEA策略","_id":"clh7s5cup0053xt8jhrin5kab"},{"name":"创造","_id":"clh7s5cup0055xt8j1jwcdv3b"},{"name":"lintcode","_id":"clh7s5cuq0057xt8j132qcd2t"},{"name":"interview","_id":"clh7s5cur005dxt8j0y59fbro"},{"name":"单元测试","_id":"clh7s5cur005ixt8j959yggad"}]}}